import React, { useState, useEffect, useCallback } from 'react';
import BrowserChrome from './components/BrowserChrome';
import BrowserView, { type BrowserControls } from './components/BrowserView';
import WindowFrame from './components/WindowFrame';
import SidebarFrame from './components/SidebarFrame';
import ToastContainer from './components/ToastContainer';
import ErrorBoundary from './components/ErrorBoundary';
import CommandPalette, { CommandAction } from './components/CommandPalette';
import OnboardingGate from './components/OnboardingGate';

const loadChatInterface = () => import('./components/ChatInterface');
const loadNotesInterface = () => import('./components/NotesInterface');
const loadMT5Interface = () => import('./components/MT5Interface');
const loadTradeLockerInterface = () => import('./components/TradeLockerInterface');
const loadNativeChartInterface = () => import('./components/NativeChartInterface');
const loadBacktesterInterface = () => import('./components/BacktesterInterface');
const loadSetupsInterface = () => import('./components/SetupsInterface');
const loadAgentCreatorInterface = () => import('./components/AgentCreatorInterface');
const loadSignalInterface = () => import('./components/SignalInterface');
const loadSnapshotInterface = () => import('./components/SnapshotInterface');
const loadPatternsInterface = () => import('./components/PatternsInterface');
const loadShadowInterface = () => import('./components/ShadowInterface');
const loadCalendarInterface = () => import('./components/CalendarInterface');
const loadAgentMemoryInterface = () => import('./components/AgentMemoryInterface');
const loadAgentLabInterface = () => import('./components/AgentLabInterface');
const loadAutoPilotInterface = () => import('./components/AutoPilotInterface');
const loadLeaderboardInterface = () => import('./components/LeaderboardInterface');
const loadAcademyInterface = () => import('./components/AcademyInterface');
const loadAuditTrailInterface = () => import('./components/AuditTrailInterface');
const loadChangesInterface = () => import('./components/ChangesInterface');
const loadPerformanceDashboardInterface = () => import('./components/PerformanceDashboard');
const loadMonitorInterface = () => import('./components/MonitorInterface');
const loadSettingsModal = () => import('./components/SettingsModal');

const ChatInterface = React.lazy(loadChatInterface);
const NotesInterface = React.lazy(loadNotesInterface);
const MT5Interface = React.lazy(loadMT5Interface);
const TradeLockerInterface = React.lazy(loadTradeLockerInterface);
const NativeChartInterface = React.lazy(loadNativeChartInterface);
const BacktesterInterface = React.lazy(loadBacktesterInterface);
const SetupsInterface = React.lazy(loadSetupsInterface);
const AgentCreatorInterface = React.lazy(loadAgentCreatorInterface);
const SignalInterface = React.lazy(loadSignalInterface);
const SnapshotInterface = React.lazy(loadSnapshotInterface);
const PatternsInterface = React.lazy(loadPatternsInterface);
const ShadowInterface = React.lazy(loadShadowInterface);
const CalendarInterface = React.lazy(loadCalendarInterface);
const AgentMemoryInterface = React.lazy(loadAgentMemoryInterface);
const AgentLabInterface = React.lazy(loadAgentLabInterface);
const AutoPilotInterface = React.lazy(loadAutoPilotInterface);
const LeaderboardInterface = React.lazy(loadLeaderboardInterface);
const AcademyInterface = React.lazy(loadAcademyInterface);
const AuditTrailInterface = React.lazy(loadAuditTrailInterface);
const ChangesInterface = React.lazy(loadChangesInterface);
const PerformanceDashboard = React.lazy(loadPerformanceDashboardInterface);
const MonitorInterface = React.lazy(loadMonitorInterface);
const SettingsModal = React.lazy(loadSettingsModal);

type OpenAiServiceModule = typeof import('./services/openaiService');
type BacktestResearchServiceModule = typeof import('./services/backtestResearchService');
type BacktestWorkerModule = typeof import('./services/backtestComputeWorkerClient');
type OptimizerLoopServiceModule = typeof import('./services/optimizerLoopService');
type ResearchAutopilotServiceModule = typeof import('./services/researchAutopilotService');
type ExecutionPlaybookRuntimeModule = typeof import('./services/executionPlaybookRuntime');
type SetupPerformanceRuntimeModule = typeof import('./services/setupPerformanceRuntime');
type TelegramCommandRuntimeModule = typeof import('./services/telegramCommandRuntime');
type TelegramCallbackRuntimeModule = typeof import('./services/telegramCallbackRuntime');
type TelegramMessageRuntimeModule = typeof import('./services/telegramMessageRuntime');
type BacktesterActionRuntimeModule = typeof import('./services/backtesterActionRuntime');
type BacktestCatalogRuntimeModule = typeof import('./services/backtestCatalogRuntime');
type ActionCatalogModule = typeof import('./services/actionCatalog');
type NotesActionRuntimeModule = typeof import('./services/notesActionRuntime');
type AuditActionRuntimeModule = typeof import('./services/auditActionRuntime');
type ChangesShadowActionRuntimeModule = typeof import('./services/changesShadowActionRuntime');
type FeatureControllersModule = typeof import('./controllers/featureControllers');
type SignalControllerModule = typeof import('./controllers/signalController');
type CalendarControllerModule = typeof import('./controllers/calendarController');
type AcademyControllerModule = typeof import('./controllers/academyController');
type ShadowControllerModule = typeof import('./controllers/shadowController');
type OutcomeFeedRefreshControllerModule = typeof import('./controllers/outcomeFeedRefreshController');
type SetupWatcherBackgroundControllerModule = typeof import('./controllers/setupWatcherBackgroundController');
type TradingViewPriceControllerModule = typeof import('./controllers/tradingViewPriceController');
type Mt5AccountSpecControllerModule = typeof import('./controllers/mt5AccountSpecController');
type Mt5TelemetryControllerModule = typeof import('./controllers/mt5TelemetryController');
type LiveCaptureControllerModule = typeof import('./controllers/liveCaptureController');
type CatalogOpsRuntimeModule = typeof import('./services/catalogOpsRuntime');
type CatalogAgentRuntimeModule = typeof import('./services/catalogAgentRuntime');

let openAiServicePromise: Promise<OpenAiServiceModule> | null = null;
const loadOpenAiService = () => {
  if (!openAiServicePromise) openAiServicePromise = import('./services/openaiService');
  return openAiServicePromise;
};

let backtestResearchServicePromise: Promise<BacktestResearchServiceModule> | null = null;
const loadBacktestResearchServiceModule = () => {
  if (!backtestResearchServicePromise) {
    backtestResearchServicePromise = import('./services/backtestResearchService');
  }
  return backtestResearchServicePromise;
};

let backtestWorkerPromise: Promise<BacktestWorkerModule> | null = null;
const loadBacktestWorkerModule = () => {
  if (!backtestWorkerPromise) backtestWorkerPromise = import('./services/backtestComputeWorkerClient');
  return backtestWorkerPromise;
};

let optimizerLoopServicePromise: Promise<OptimizerLoopServiceModule> | null = null;
const loadOptimizerLoopServiceModule = () => {
  if (!optimizerLoopServicePromise) optimizerLoopServicePromise = import('./services/optimizerLoopService');
  return optimizerLoopServicePromise;
};

let researchAutopilotServicePromise: Promise<ResearchAutopilotServiceModule> | null = null;
const loadResearchAutopilotServiceModule = () => {
  if (!researchAutopilotServicePromise) {
    researchAutopilotServicePromise = import('./services/researchAutopilotService');
  }
  return researchAutopilotServicePromise;
};

let executionPlaybookRuntimePromise: Promise<ExecutionPlaybookRuntimeModule> | null = null;
const loadExecutionPlaybookRuntimeModule = () => {
  if (!executionPlaybookRuntimePromise) {
    executionPlaybookRuntimePromise = import('./services/executionPlaybookRuntime');
  }
  return executionPlaybookRuntimePromise;
};

let setupPerformanceRuntimePromise: Promise<SetupPerformanceRuntimeModule> | null = null;
const loadSetupPerformanceRuntimeModule = () => {
  if (!setupPerformanceRuntimePromise) {
    setupPerformanceRuntimePromise = import('./services/setupPerformanceRuntime');
  }
  return setupPerformanceRuntimePromise;
};

let telegramCommandRuntimePromise: Promise<TelegramCommandRuntimeModule> | null = null;
const loadTelegramCommandRuntimeModule = () => {
  if (!telegramCommandRuntimePromise) {
    telegramCommandRuntimePromise = import('./services/telegramCommandRuntime');
  }
  return telegramCommandRuntimePromise;
};

let backtesterActionRuntimePromise: Promise<BacktesterActionRuntimeModule> | null = null;
const loadBacktesterActionRuntimeModule = () => {
  if (!backtesterActionRuntimePromise) {
    backtesterActionRuntimePromise = import('./services/backtesterActionRuntime');
  }
  return backtesterActionRuntimePromise;
};

let backtestCatalogRuntimePromise: Promise<BacktestCatalogRuntimeModule> | null = null;
const loadBacktestCatalogRuntimeModule = () => {
  if (!backtestCatalogRuntimePromise) {
    backtestCatalogRuntimePromise = import('./services/backtestCatalogRuntime');
  }
  return backtestCatalogRuntimePromise;
};

let actionCatalogPromise: Promise<ActionCatalogModule> | null = null;
let actionCatalogModule: ActionCatalogModule | null = null;
const loadActionCatalogModule = () => {
  if (!actionCatalogPromise) {
    actionCatalogPromise = import('./services/actionCatalog').then((mod) => {
      actionCatalogModule = mod;
      return mod;
    });
  }
  return actionCatalogPromise;
};
const getActionDefinitionCached = (actionId: string) => actionCatalogModule?.getActionDefinition(actionId);
const getToolTypeForActionIdCached = (actionId: string) => actionCatalogModule?.getToolTypeForActionId(actionId);
const getBrokerActionTypeForActionIdCached = (actionId: string) => actionCatalogModule?.getBrokerActionTypeForActionId(actionId);

let telegramCallbackRuntimePromise: Promise<TelegramCallbackRuntimeModule> | null = null;
const loadTelegramCallbackRuntimeModule = () => {
  if (!telegramCallbackRuntimePromise) {
    telegramCallbackRuntimePromise = import('./services/telegramCallbackRuntime');
  }
  return telegramCallbackRuntimePromise;
};

let telegramMessageRuntimePromise: Promise<TelegramMessageRuntimeModule> | null = null;
const loadTelegramMessageRuntimeModule = () => {
  if (!telegramMessageRuntimePromise) {
    telegramMessageRuntimePromise = import('./services/telegramMessageRuntime');
  }
  return telegramMessageRuntimePromise;
};

let notesActionRuntimePromise: Promise<NotesActionRuntimeModule> | null = null;
const loadNotesActionRuntimeModule = () => {
  if (!notesActionRuntimePromise) {
    notesActionRuntimePromise = import('./services/notesActionRuntime');
  }
  return notesActionRuntimePromise;
};

let auditActionRuntimePromise: Promise<AuditActionRuntimeModule> | null = null;
const loadAuditActionRuntimeModule = () => {
  if (!auditActionRuntimePromise) {
    auditActionRuntimePromise = import('./services/auditActionRuntime');
  }
  return auditActionRuntimePromise;
};

let changesShadowActionRuntimePromise: Promise<ChangesShadowActionRuntimeModule> | null = null;
const loadChangesShadowActionRuntimeModule = () => {
  if (!changesShadowActionRuntimePromise) {
    changesShadowActionRuntimePromise = import('./services/changesShadowActionRuntime');
  }
  return changesShadowActionRuntimePromise;
};

let featureControllersPromise: Promise<FeatureControllersModule> | null = null;
let signalControllerPromise: Promise<SignalControllerModule> | null = null;
let calendarControllerPromise: Promise<CalendarControllerModule> | null = null;
let academyControllerPromise: Promise<AcademyControllerModule> | null = null;
let shadowControllerPromise: Promise<ShadowControllerModule> | null = null;
let outcomeFeedRefreshControllerPromise: Promise<OutcomeFeedRefreshControllerModule> | null = null;
let setupWatcherBackgroundControllerPromise: Promise<SetupWatcherBackgroundControllerModule> | null = null;
let tradingViewPriceControllerPromise: Promise<TradingViewPriceControllerModule> | null = null;
let mt5AccountSpecControllerPromise: Promise<Mt5AccountSpecControllerModule> | null = null;
let mt5TelemetryControllerPromise: Promise<Mt5TelemetryControllerModule> | null = null;
let liveCaptureControllerPromise: Promise<LiveCaptureControllerModule> | null = null;
let catalogOpsRuntimePromise: Promise<CatalogOpsRuntimeModule> | null = null;
const loadCatalogOpsRuntimeModule = () => {
  if (!catalogOpsRuntimePromise) catalogOpsRuntimePromise = import('./services/catalogOpsRuntime');
  return catalogOpsRuntimePromise;
};

let catalogAgentRuntimePromise: Promise<CatalogAgentRuntimeModule> | null = null;
const loadCatalogAgentRuntimeModule = () => {
  if (!catalogAgentRuntimePromise) catalogAgentRuntimePromise = import('./services/catalogAgentRuntime');
  return catalogAgentRuntimePromise;
};

const loadFeatureControllers = () => {
  if (!featureControllersPromise) featureControllersPromise = import('./controllers/featureControllers');
  return featureControllersPromise;
};

const loadSignalControllerModule = () => {
  if (!signalControllerPromise) signalControllerPromise = import('./controllers/signalController');
  return signalControllerPromise;
};

const loadCalendarControllerModule = () => {
  if (!calendarControllerPromise) calendarControllerPromise = import('./controllers/calendarController');
  return calendarControllerPromise;
};

const loadAcademyControllerModule = () => {
  if (!academyControllerPromise) academyControllerPromise = import('./controllers/academyController');
  return academyControllerPromise;
};

const loadShadowControllerModule = () => {
  if (!shadowControllerPromise) shadowControllerPromise = import('./controllers/shadowController');
  return shadowControllerPromise;
};

const loadOutcomeFeedRefreshControllerModule = () => {
  if (!outcomeFeedRefreshControllerPromise) {
    outcomeFeedRefreshControllerPromise = import('./controllers/outcomeFeedRefreshController');
  }
  return outcomeFeedRefreshControllerPromise;
};

const loadSetupWatcherBackgroundControllerModule = () => {
  if (!setupWatcherBackgroundControllerPromise) {
    setupWatcherBackgroundControllerPromise = import('./controllers/setupWatcherBackgroundController');
  }
  return setupWatcherBackgroundControllerPromise;
};

const loadTradingViewPriceControllerModule = () => {
  if (!tradingViewPriceControllerPromise) {
    tradingViewPriceControllerPromise = import('./controllers/tradingViewPriceController');
  }
  return tradingViewPriceControllerPromise;
};

const loadMt5AccountSpecControllerModule = () => {
  if (!mt5AccountSpecControllerPromise) {
    mt5AccountSpecControllerPromise = import('./controllers/mt5AccountSpecController');
  }
  return mt5AccountSpecControllerPromise;
};

const loadMt5TelemetryControllerModule = () => {
  if (!mt5TelemetryControllerPromise) {
    mt5TelemetryControllerPromise = import('./controllers/mt5TelemetryController');
  }
  return mt5TelemetryControllerPromise;
};

const loadLiveCaptureControllerModule = () => {
  if (!liveCaptureControllerPromise) {
    liveCaptureControllerPromise = import('./controllers/liveCaptureController');
  }
  return liveCaptureControllerPromise;
};

const sendMessageToOpenAI = async (...args: Parameters<OpenAiServiceModule['sendMessageToOpenAI']>) => {
  const mod = await loadOpenAiService();
  return mod.sendMessageToOpenAI(...args);
};

const sendPlainTextToOpenAI = async (...args: Parameters<OpenAiServiceModule['sendPlainTextToOpenAI']>) => {
  const mod = await loadOpenAiService();
  return mod.sendPlainTextToOpenAI(...args);
};

const loadBacktestOptimizationHistory = async (...args: Parameters<BacktestResearchServiceModule['loadBacktestOptimizationHistory']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.history', channel: 'backtest', intervalMs: 15_000 });
  monitor.noteAttempt('backtest.optimizer.history', Date.now());
  const mod = await loadBacktestResearchServiceModule();
  const res = await mod.loadBacktestOptimizationHistory(...args);
  monitor.noteRun('backtest.optimizer.history', Date.now());
  return res;
};

const runBacktestOptimization = async (...args: Parameters<BacktestResearchServiceModule['runBacktestOptimization']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.run', channel: 'backtest', intervalMs: 30_000 });
  monitor.noteAttempt('backtest.optimizer.run', Date.now());
  const mod = await loadBacktestResearchServiceModule();
  const res = await mod.runBacktestOptimization(...args);
  monitor.noteRun('backtest.optimizer.run', Date.now());
  return res;
};

const runBacktestOptimizationWorker = async (...args: Parameters<BacktestWorkerModule['runBacktestOptimizationWorker']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.worker', channel: 'backtest', intervalMs: 30_000 });
  monitor.noteAttempt('backtest.optimizer.worker', Date.now());
  const mod = await loadBacktestWorkerModule();
  const res = await mod.runBacktestOptimizationWorker(...args);
  monitor.noteRun('backtest.optimizer.worker', Date.now());
  return res;
};

const getLatestOptimizerSession = async (...args: Parameters<OptimizerLoopServiceModule['getLatestOptimizerSession']>) => {
  const mod = await loadOptimizerLoopServiceModule();
  return mod.getLatestOptimizerSession(...args);
};

const getOptimizerResults = async (...args: Parameters<OptimizerLoopServiceModule['getOptimizerResults']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.results', channel: 'backtest', intervalMs: 10_000 });
  monitor.noteAttempt('backtest.optimizer.results', Date.now());
  const mod = await loadOptimizerLoopServiceModule();
  const res = await mod.getOptimizerResults(...args);
  monitor.noteRun('backtest.optimizer.results', Date.now());
  return res;
};

const getOptimizerStatus = async (...args: Parameters<OptimizerLoopServiceModule['getOptimizerStatus']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.status', channel: 'backtest', intervalMs: 8_000 });
  monitor.noteAttempt('backtest.optimizer.status', Date.now());
  const mod = await loadOptimizerLoopServiceModule();
  const res = await mod.getOptimizerStatus(...args);
  monitor.noteRun('backtest.optimizer.status', Date.now());
  return res;
};

const proposeOptimizationRefinement = async (...args: Parameters<OptimizerLoopServiceModule['proposeOptimizationRefinement']>) => {
  const mod = await loadOptimizerLoopServiceModule();
  return mod.proposeOptimizationRefinement(...args);
};

const startOptimizationSession = async (...args: Parameters<OptimizerLoopServiceModule['startOptimizationSession']>) => {
  const monitor = getRefreshSlaMonitor();
  monitor.ensureTask({ id: 'backtest.optimizer.session', channel: 'backtest', intervalMs: 30_000 });
  monitor.noteAttempt('backtest.optimizer.session', Date.now());
  const mod = await loadOptimizerLoopServiceModule();
  const res = await mod.startOptimizationSession(...args);
  monitor.noteRun('backtest.optimizer.session', Date.now());
  return res;
};

const getResearchResults = async (...args: Parameters<ResearchAutopilotServiceModule['getResearchResults']>) => {
  const mod = await loadResearchAutopilotServiceModule();
  return mod.getResearchResults(...args);
};

const getResearchStatus = async (...args: Parameters<ResearchAutopilotServiceModule['getResearchStatus']>) => {
  const mod = await loadResearchAutopilotServiceModule();
  return mod.getResearchStatus(...args);
};

const startResearchSession = async (...args: Parameters<ResearchAutopilotServiceModule['startResearchSession']>) => {
  const mod = await loadResearchAutopilotServiceModule();
  return mod.startResearchSession(...args);
};

const stopResearchSession = async (...args: Parameters<ResearchAutopilotServiceModule['stopResearchSession']>) => {
  const mod = await loadResearchAutopilotServiceModule();
  return mod.stopResearchSession(...args);
};

// Hooks
import { useTabs } from './hooks/useTabs';
import { useChat } from './hooks/useChat';
import { useSidebar } from './hooks/useSidebar';
import { usePortfolio } from './hooks/usePortfolio';
import { useTradeLocker } from './hooks/useTradeLocker';
import { useStartupReadiness } from './hooks/useStartupReadiness';
import { useChartSessions } from './hooks/useChartSessions';
import { useBrokerLinkEngine } from './hooks/useBrokerLinkEngine';
import { playSound } from './services/audioService';
import { formatTradingViewIntervalLabel, getTradingViewLine, getTradingViewParams, isTradingViewUrl } from './services/tradingView';
import { hashStringSampled } from './services/stringHash';
import { validateTradeProposalBasic } from './services/tradeValidation';
import { computeBrokerActionIdempotencyKey, computeClientStrategyIdFromDedupeKey, computeTradeDedupeKey, extractBrokerOrderId } from './services/tradeIdentity';
import { createExecutionApi, type ExecutionCommand } from './services/executionApi';
import { createMarketDataService } from './services/marketDataService';
import { createQueueMetrics } from './services/queueMetrics';
import { getBrokerRequestCoordinator } from './services/brokerRequestCoordinator';
import { getRuntimeScheduler } from './services/runtimeScheduler';
import { getDiagnosticsRateLimiter } from './services/diagnosticsRateLimiter';
import { registerBrokerRequestExecutor } from './services/brokerRequestBridge';
import { instrumentTradeLedger, recordLedgerHealth, getPersistenceHealthSnapshot } from './services/persistenceHealth';
import { createAgentRunner } from './services/agentRunnerService';
import { createMt5Adapter, createTradeLockerAdapter } from './services/brokerAdapters';
import { applyPriceAdjustment, loadBrokerLinkConfig, saveBrokerLinkConfig, DEFAULT_BROKER_LINK_CONFIG, type BrokerAccountSpec, type BrokerId } from './services/brokerLink';
import { resolveBrokerSymbol } from './services/brokerRouter';
import { fetchMt5, fetchMt5AccountSpec, fetchMt5Quote } from './services/mt5Client';
import {
  buildSymbolKeyVariants as buildSymbolKeyVariantsShared,
  normalizeSymbolKey as normalizeSymbolKeyShared,
  normalizeSymbolLoose as normalizeSymbolLooseShared,
  normalizeTimeframeKey as normalizeTimeframeKeyShared
} from './services/symbols';
import { reserveLedgerEntry } from './services/omsService';
import { evaluateRiskGate } from './services/riskGateService';
import {
  buildStrategyConfig,
  resolutionToMs,
  DEFAULT_BREAK_RETEST_CONFIG,
  DEFAULT_FVG_RETRACE_CONFIG,
  DEFAULT_MEAN_REVERSION_CONFIG,
  DEFAULT_RANGE_BREAKOUT_CONFIG,
  DEFAULT_TREND_PULLBACK_CONFIG
} from './services/backtestEngine';
import { createActionTaskTree } from './services/actionTaskTree';
import { appendTechAgentLog } from './services/techAgentLog';
import { ChartEngine, type ChartPersistence, type ChartWatchConfig, type PatternEvent } from './services/chartEngine';
import { getRegimeSnapshot } from './services/setupWatcherService';
import { evaluateWatchersWorker } from './services/setupWatcherWorkerClient';
import { classifyRegime, getCachedRegimeState } from './services/regimeClassifier';
import { buildSetupLibraryEntry, buildSetupLibraryTierKey, shouldReplaceLibraryEntry } from './services/setupLibraryService';
import { buildEvidenceCardFromLibraryEntry, buildEvidenceCardFromSignal } from './services/evidenceCard';
import {
  DEFAULT_CHART_CHAT_TIMEFRAMES,
  DEFAULT_MAX_CANDLES as CHART_CHAT_DEFAULT_MAX_CANDLES,
  DEFAULT_MAX_PAYLOAD_CHARS as CHART_CHAT_DEFAULT_MAX_PAYLOAD_CHARS,
  buildChartSnapshotContext,
  buildChartSnapshotPayload,
  resolveModelType
} from './services/chartChatSnapshotBuilder';
import {
  buildAgentTestRun,
  buildAgentTestRunKey,
  buildAgentTestRunMemoryEntry,
  buildAgentTestScenarioKey,
  buildAgentTestScenarioMemoryEntry,
  evaluateAgentTestRun,
  normalizeAgentTestScenario,
  resolveScenarioPlaybook
} from './services/agentTestHarnessService';
import {
  buildSetupSignalBucketId,
  buildSetupSignalDedupeId,
  getSetupSignalBucketTime,
  getSetupSignalResolutionMs,
  toSignalEpochMs
} from './services/setupSignalLifecycle';
import { planWarmup } from './services/warmupPlanner';
import { createSnapshotHistoryFetcher } from './services/snapshotHistoryFetcher';
import { createPatternRefreshCoalescer } from './services/patternRefreshCoalescer';
import { computeFrameGapWorker } from './services/signalAnalysisWorkerClient';
import { getWorkerFallbackStats } from './services/workerFallbackPolicy';
import { getRefreshSlaMonitor } from './services/refreshSlaMonitor';
import { getBrokerCircuitBreaker } from './services/brokerCircuitBreaker';
import { evaluatePreTradeHealthGate } from './services/preTradeHealthGate';
import { getDomainReadiness } from './services/bridgeGuard';
import { getExecutionAuditService } from './services/executionAuditService';
import { buildResolvedOutcomeEnvelope, buildSignalAttributionRecord } from './services/signalLifecycleService';
import { buildRankFreshnessState, computeAgentDriftReports, type DriftObservation } from './services/agentDriftService';
import { scoreEnsemble } from './services/ensembleScoring';
import { evaluateMetaLabel } from './services/metaLabeler';
import { evaluatePortfolioRisk } from './services/portfolioRiskEngine';
import { buildExperimentRegistryEntry, evaluateAutoDemotionPolicy, evaluatePromotionPolicy } from './services/promotionPolicyService';
import { getLivePolicyService } from './services/livePolicyService';
import { getPanelConnectivityEngine } from './services/panelConnectivityEngine';
import { getCrossPanelContextEngine } from './services/crossPanelContextEngine';
import { getOutcomeConsistencyEngine } from './services/outcomeConsistencyEngine';
import { GLASS_EVENT, dispatchGlassEvent } from './services/glassEvents';
import { submitTradeLockerOrderBatch } from './services/executionSubmissionService';
import { cancelTimer, deferMs, sleepMs, type TimerHandle } from './services/timerPrimitives';
import { buildCalendarPnlSnapshot } from './services/calendarPnlEngine';
import { buildMirrorExecutions } from './orchestrators/executionOrchestrator';
import { normalizePanelConnectivitySnapshot } from './orchestrators/panelOrchestrator';
import { buildSystemInitializedMessage } from './orchestrators/startupOrchestrator';
import { TaskTreeOrchestrator, type TaskTreeRunSummary, type TaskTreeStateSnapshot } from './services/taskTreeService';
import { resolveAutoPilotPolicy } from './services/autoPilotPolicy';
import { evaluateAutoPilotState, mergeAutoPilotState } from './services/autopilotStateMachine';
import { normalizeAgentCapabilities } from './services/agentCapabilities';
import { getTechAgentLogs } from './services/techAgentLog';
import { getCacheBudgetManager } from './services/cacheBudgetManager';
import { ActionFlowRecommendation, AcademyCase, AcademyCaseEvent, AcademyCaseSnapshot, AcademyLesson, AcademySymbolLearning, Agent, AgentTestRun, AgentTestScenario, AgentToolAction, AgentToolResult, AutoPilotStateSnapshot, BrokerAction, BrokerActionType, CalendarPnlSnapshot, CalendarRule, ChartChatSnapshotStatus, ChartSnapshotReasonCode, CrossPanelContext, ExecutionPlaybook, HealthSnapshot, Notification, OutcomeFeedConsistencyState, OutcomeFeedCursor, PanelFreshnessState, RegimeBlockState, RegimeSnapshot, ReviewAnnotation, ShadowAccountSnapshot, ShadowProfile, ShadowTradeCompareSummary, ShadowTradeStats, ShadowTradeView, TaskPlaybook, TaskPlaybookMode, TaskPlaybookRun, TaskPlaybookRunStep, TaskPlaybookStep, TaskTreeResumeEntry, TaskTreeRunEntry, TradeLockerQuote, TradeProposal, TradeBlockInfo, SidebarMode, SetupLibraryEntry, SetupPerformance, SetupSignal, SetupSignalTransition, SetupWatcher, SignalHistoryEntry, SystemStateSnapshot, TruthEventRecord, TruthProjection, TruthReplay, WatchProfile, SymbolScope, ChartTimeframe, NewsSnapshot } from './types';
import type { NativeChartHandle, NativeChartMeta } from './components/NativeChartInterface';
import type { BacktesterHandle, BacktesterOptimizationApply } from './components/BacktesterInterface';
import type { SignalEntry, SignalEntryStatus, SignalExecutionTarget, SignalSessionWindow, SignalSnapshotStatus, SignalStrategyMode } from './components/SignalInterface';

type PerfStats = {
  windowStartMs: number;
  auditEvents: number;
  brokerRequests: number;
  brokerResponses: number;
  brokerTimeouts: number;
  brokerRateLimits: number;
  quoteUpdates: number;
  quoteIngests: number;
  backgroundWatcherTicks: number;
  backgroundWatcherLastDurationMs: number | null;
  signalScans: number;
  signalScanLastDurationMs: number | null;
  chartRefreshRequests: number;
  chartRefreshCoalesced: number;
  patternWatchSyncCoalesced: number;
  chartRefreshRuns: number;
  chartRefreshLastDurationMs: number | null;
  signalSnapshotWarmups: number;
  signalSnapshotWarmupTimeouts: number;
  signalSnapshotWarmupLastDurationMs: number | null;
};

const DAILY_BASELINE_PREFIX = 'glass_daily_baseline_v1';
const LOSS_STREAK_PREFIX = 'glass_loss_streak_v1';
const SETUP_WATCHER_STORAGE_KEY = 'glass_setup_watchers_v1';
const MAX_SETUP_SIGNALS = 200;
const SETUP_SIGNAL_COOLDOWN_KEY = 'glass_setup_signal_cooldown_ms';
const DEFAULT_SETUP_SIGNAL_COOLDOWN_MS = 120_000;
const SETUP_SIGNAL_RETENTION_DAYS_KEY = 'glass_setup_signal_retention_days';
const SETUP_SIGNAL_RETENTION_LIMIT_KEY = 'glass_setup_signal_retention_limit';
const DEFAULT_SETUP_SIGNAL_RETENTION_DAYS = 14;
const DEFAULT_SETUP_SIGNAL_RETENTION_LIMIT = 100;
const DEFAULT_SIGNAL_ENTRY_RETENTION_DAYS = 30;
const SIGNAL_ENTRY_RETENTION_MS = DEFAULT_SIGNAL_ENTRY_RETENTION_DAYS * 24 * 60 * 60 * 1000;
const PERF_WINDOW_MS = 60_000;
const AUDIT_THROTTLE_WINDOW_MS = 1500;
const AUDIT_THROTTLE_TYPES = new Set([
  'broker_request',
  'broker_response',
  'broker_error',
  'broker_quotes',
  'broker_stream_status',
  'chart_update'
]);
const TRADELOCKER_SNAPSHOT_METHODS = new Set([
  'getHistorySeries',
  'getQuote',
  'getQuotes',
  'getInstrumentConstraints',
  'searchInstruments'
]);
const SETUP_SIGNAL_EXPIRY_BARS_KEY = 'glass_setup_signal_expiry_bars';
const SETUP_SIGNAL_EXPIRY_HOURS_KEY = 'glass_setup_signal_expiry_hours';
const DEFAULT_SETUP_SIGNAL_EXPIRY_BARS = 8;
const DEFAULT_SETUP_SIGNAL_EXPIRY_HOURS = 12;
const SIGNAL_OUTCOME_GATE_KEY = 'glass_signal_outcome_gate_enabled';
const SIGNAL_OUTCOME_GATE_MAX_OPEN_KEY = 'glass_signal_outcome_gate_max_open';
const SIGNAL_PERFORMANCE_WEIGHT_KEY = 'glass_signal_performance_weighting';
const AGENT_ACADEMY_UPDATE_KEY = 'glass_agent_academy_updates';
const QUANT_MODE_STORAGE_KEY = 'glass_quant_mode_defaults_v1';
const CHART_CHAT_CAPTURE_TIMEOUT_MS = 3500;
const CHART_CHAT_MAX_CANDLES = CHART_CHAT_DEFAULT_MAX_CANDLES;
const CHART_CHAT_MAX_PAYLOAD_CHARS = CHART_CHAT_DEFAULT_MAX_PAYLOAD_CHARS;
const CHART_HISTORY_FETCH_CONCURRENCY = 2;
const CHART_HISTORY_FETCH_TIMEOUT_MS = 25_000;
const CHART_REFRESH_MIN_GAP_MS = 3_000;
const SIGNAL_SNAPSHOT_PARALLELISM = 2;
const BROKER_REQUEST_CONCURRENCY = 6;
const BROKER_REQUEST_TIMEOUT_MS = 25_000;
const BROKER_DEDUPE_TTL_MS = BROKER_REQUEST_TIMEOUT_MS + 1500;
const ACTIVE_BROKER_CACHE_TTL_MS = 4_000;
const EXECUTION_QUEUE_KIND = 'execution_queue';
const EXECUTION_QUEUE_CONCURRENCY = 1;
const EXECUTION_QUEUE_DEDUPE_WINDOW_MS = 90_000;
const EXECUTION_QUEUE_MAX_AGE_MS = 6 * 60 * 60 * 1000;
const EXECUTION_QUEUE_RECOVERY_LIMIT = 800;
const BROKER_DEDUPE_METHODS = new Set([
  'getHistorySeries',
  'getHistory',
  'getQuote',
  'getQuotes',
  'getSnapshot',
  'getOrders',
  'getOrdersHistory',
  'getAccountMetrics',
  'getInstrumentConstraints',
  'getInstrumentDetails',
  'getSessionDetails',
  'getSessionStatus',
  'searchInstruments',
  'getDailyBar'
]);
const SIGNAL_SNAPSHOT_WARMUP_TIMEOUT_MS = 90_000;
const SIGNAL_SNAPSHOT_WARMUP_POLL_MS = 750;
const SIGNAL_SNAPSHOT_WARMUP_BARS_DEFAULT = 320;
const SIGNAL_SNAPSHOT_WARMUP_BARS_1D = 120;
const SIGNAL_SNAPSHOT_WARMUP_BARS_1W = 52;
const SETUP_SIGNAL_DEBUG_KEY = 'glass_setup_signal_debug';
const TL_SNAPSHOT_SOURCE_KEY = 'glass_tl_snapshot_source';
const TL_SNAPSHOT_AUTO_KEY = 'glass_tl_snapshot_auto';
const TL_SNAPSHOT_FALLBACK_KEY = 'glass_tl_snapshot_fallback';
const TL_EXECUTION_TARGETS_KEY = 'glass_tl_execution_targets';
const TL_NORMALIZE_ENABLED_KEY = 'glass_tl_normalize_enabled';
const TL_NORMALIZE_REF_KEY = 'glass_tl_normalize_ref';
const LEGACY_TL_SUBMISSION_FLAG_KEY = 'execution.useLegacyTradeLockerSubmission';
const TL_NORMALIZE_WINDOW = 120;
const TL_NORMALIZE_MIN_SAMPLES = 30;
const TL_NORMALIZE_ALPHA = 0.12;
const TL_NORMALIZE_OUTLIER_MAD = 3;
const ACTION_TRACE_RETENTION_DAYS_KEY = 'glass_action_trace_retention_days';
const ACTION_TRACE_RETENTION_LIMIT_KEY = 'glass_action_trace_retention_limit';
const LEADERBOARD_FILTER_KEY = 'glass_leaderboard_filter_v1';
const DEFAULT_ACTION_TRACE_RETENTION_DAYS = 14;
const DEFAULT_ACTION_TRACE_RETENTION_LIMIT = 2000;
const DEDUPE_FALLBACK_WINDOW_MS = 45_000;
const SHUTDOWN_STATE_KEY = 'glass_shutdown_state_v1';
const TASK_TREE_STATE_KIND = 'task_tree_state';
const MAX_LIVE_ERRORS = 500;
const ACADEMY_AGENT_UPDATE_MARKER = '\n\n[ACADEMY UPDATES]\n';
const SNAPSHOT_SLA_TASK_ID = 'snapshot.panel.refresh';
const SCHEDULER_CIRCUIT_GUARD_TASK_ID = 'scheduler.guard.circuit';
const PRE_TRADE_QUANT_LATENCY_BUDGET_MS = 150;

const readLegacyTradeLockerSubmissionFlag = () => {
  try {
    const raw = String(localStorage.getItem(LEGACY_TL_SUBMISSION_FLAG_KEY) || '').trim().toLowerCase();
    return raw === '1' || raw === 'true' || raw === 'yes' || raw === 'on';
  } catch {
    return false;
  }
};

type LiveErrorEntry = {
  id: string;
  ts: number;
  level: 'error' | 'warn' | 'info';
  source: string;
  message: string;
  stack?: string | null;
  detail?: any;
  count?: number;
};
const TASK_TREE_STATE_KEYS = {
  signal: 'task_tree_state:signal',
  action: 'task_tree_state:action'
};
const DEFAULT_HEADLESS_EXECUTION = {
  spreadModel: 'percent',
  spreadPct: 0.02,
  slippageModel: 'percent',
  slippagePct: 0.01,
  commissionModel: 'percent',
  commissionPct: 0.01,
  sessionCostOverrides: {
    asia: { spreadMult: 1.1, slippageMult: 1.1, commissionMult: 1 },
    london: { spreadMult: 1, slippageMult: 1, commissionMult: 1 },
    ny: { spreadMult: 1.05, slippageMult: 1.05, commissionMult: 1 }
  },
  volatilitySlippageEnabled: true,
  volatilitySlippageLookback: 50,
  volatilitySlippageLowThresh: 0.8,
  volatilitySlippageHighThresh: 1.2,
  volatilitySlippageLowMult: 0.8,
  volatilitySlippageMidMult: 1,
  volatilitySlippageHighMult: 1.5,
  partialFillMode: 'range',
  partialFillAtrMult: 2,
  partialFillMinRatio: 0.5,
  partialFillOnExit: true,
  newsSpikeAtrMult: 3,
  newsSpikeSlippageMult: 2,
  newsSpikeSpreadMult: 1.5
};
const EXECUTION_REALISM_PRESETS: Record<'lite' | 'standard' | 'strict', { label: string; config: Record<string, any> }> =
  {
    lite: {
      label: 'Lite',
      config: {
        spreadModel: 'percent',
        spreadPct: 0.01,
        slippageModel: 'none',
        slippagePct: 0,
        commissionModel: 'none',
        commissionPct: 0,
        sessionCostOverrides: {
          asia: { spreadMult: 1, slippageMult: 1, commissionMult: 1 },
          london: { spreadMult: 1, slippageMult: 1, commissionMult: 1 },
          ny: { spreadMult: 1, slippageMult: 1, commissionMult: 1 }
        },
        volatilitySlippageEnabled: false,
        partialFillMode: 'none',
        newsSpikeAtrMult: 0,
        newsSpikeSlippageMult: 1,
        newsSpikeSpreadMult: 1
      }
    },
    standard: {
      label: 'Standard',
      config: DEFAULT_HEADLESS_EXECUTION
    },
    strict: {
      label: 'Strict',
      config: {
        spreadModel: 'percent',
        spreadPct: 0.04,
        slippageModel: 'percent',
        slippagePct: 0.03,
        commissionModel: 'percent',
        commissionPct: 0.02,
        sessionCostOverrides: {
          asia: { spreadMult: 1.25, slippageMult: 1.25, commissionMult: 1.1 },
          london: { spreadMult: 1.1, slippageMult: 1.1, commissionMult: 1.05 },
          ny: { spreadMult: 1.15, slippageMult: 1.15, commissionMult: 1.05 }
        },
        volatilitySlippageEnabled: true,
        volatilitySlippageLookback: 50,
        volatilitySlippageLowThresh: 0.8,
        volatilitySlippageHighThresh: 1.2,
        volatilitySlippageLowMult: 0.7,
        volatilitySlippageMidMult: 1,
        volatilitySlippageHighMult: 2,
        partialFillMode: 'range',
        partialFillAtrMult: 1.5,
        partialFillMinRatio: 0.35,
        partialFillOnExit: true,
        newsSpikeAtrMult: 2.5,
        newsSpikeSlippageMult: 2.5,
        newsSpikeSpreadMult: 2
      }
    }
  };
const DEFAULT_HEADLESS_VALIDATION = {
  mode: 'walk_forward',
  trainDays: 90,
  testDays: 30,
  stepDays: 30,
  minTrades: 10
};

const BROKER_RESOLUTION_MS: Record<string, number> = {
  '1m': 60_000,
  '5m': 5 * 60_000,
  '15m': 15 * 60_000,
  '30m': 30 * 60_000,
  '1H': 60 * 60_000,
  '4H': 4 * 60 * 60_000,
  '1D': 24 * 60 * 60_000
};

function getLocalDateKey(d: Date = new Date()) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

function getDailyBaselineStorageKey(accountKey: string, dateKey: string) {
  const h = hashStringSampled(`${accountKey}::${dateKey}`, 2048);
  return `${DAILY_BASELINE_PREFIX}:${dateKey}:${h}`;
}

function getLossStreakStorageKey(accountKey: string) {
  const h = hashStringSampled(accountKey, 512);
  return `${LOSS_STREAK_PREFIX}:${h}`;
}

function isTextInputElement(target: EventTarget | null) {
  const el = target as HTMLElement | null;
  if (!el) return false;
  const tag = el.tagName ? el.tagName.toUpperCase() : '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
  return !!(el as HTMLElement).isContentEditable;
}

function readLocalJson(key: string): any | null {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function writeLocalJson(key: string, value: any) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch {
    return false;
  }
}

function readSetupSignalCooldownMs() {
  try {
    const raw = localStorage.getItem(SETUP_SIGNAL_COOLDOWN_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return DEFAULT_SETUP_SIGNAL_COOLDOWN_MS;
    return Math.max(60_000, Math.min(180_000, Math.floor(num)));
  } catch {
    return DEFAULT_SETUP_SIGNAL_COOLDOWN_MS;
  }
}

function readSetupSignalRetentionMs() {
  try {
    const raw = localStorage.getItem(SETUP_SIGNAL_RETENTION_DAYS_KEY);
    const num = Number(raw);
    const days = Number.isFinite(num) ? Math.max(3, Math.min(60, Math.floor(num))) : DEFAULT_SETUP_SIGNAL_RETENTION_DAYS;
    return days * 24 * 60 * 60_000;
  } catch {
    return DEFAULT_SETUP_SIGNAL_RETENTION_DAYS * 24 * 60 * 60_000;
  }
}

function readSetupSignalRetentionLimit() {
  try {
    const raw = localStorage.getItem(SETUP_SIGNAL_RETENTION_LIMIT_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return DEFAULT_SETUP_SIGNAL_RETENTION_LIMIT;
    return Math.max(20, Math.min(500, Math.floor(num)));
  } catch {
    return DEFAULT_SETUP_SIGNAL_RETENTION_LIMIT;
  }
}

function readActionTraceRetentionMs() {
  try {
    const raw = localStorage.getItem(ACTION_TRACE_RETENTION_DAYS_KEY);
    const num = Number(raw);
    const days = Number.isFinite(num) ? Math.max(1, Math.min(90, Math.floor(num))) : DEFAULT_ACTION_TRACE_RETENTION_DAYS;
    return days * 24 * 60 * 60_000;
  } catch {
    return DEFAULT_ACTION_TRACE_RETENTION_DAYS * 24 * 60 * 60_000;
  }
}

function readActionTraceRetentionLimit() {
  try {
    const raw = localStorage.getItem(ACTION_TRACE_RETENTION_LIMIT_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return DEFAULT_ACTION_TRACE_RETENTION_LIMIT;
    return Math.max(200, Math.min(10_000, Math.floor(num)));
  } catch {
    return DEFAULT_ACTION_TRACE_RETENTION_LIMIT;
  }
}

function loadLeaderboardFilter() {
  try {
    const raw = localStorage.getItem(LEADERBOARD_FILTER_KEY);
    const value = String(raw || '').trim().toLowerCase();
    return value || 'all';
  } catch {
    return 'all';
  }
}

function persistLeaderboardFilter(value: string) {
  try {
    localStorage.setItem(LEADERBOARD_FILTER_KEY, String(value || 'all'));
  } catch {
    // ignore
  }
}

function readSetupSignalExpiryBars() {
  try {
    const raw = localStorage.getItem(SETUP_SIGNAL_EXPIRY_BARS_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return DEFAULT_SETUP_SIGNAL_EXPIRY_BARS;
    return Math.max(0, Math.min(200, Math.floor(num)));
  } catch {
    return DEFAULT_SETUP_SIGNAL_EXPIRY_BARS;
  }
}

function readSetupSignalExpiryHours() {
  try {
    const raw = localStorage.getItem(SETUP_SIGNAL_EXPIRY_HOURS_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return DEFAULT_SETUP_SIGNAL_EXPIRY_HOURS;
    return Math.max(0, Math.min(168, Math.floor(num)));
  } catch {
    return DEFAULT_SETUP_SIGNAL_EXPIRY_HOURS;
  }
}

function readSignalOutcomeGateEnabled() {
  try {
    const raw = localStorage.getItem(SIGNAL_OUTCOME_GATE_KEY);
    if (raw == null) return true;
    return raw === '1' || raw.toLowerCase() === 'true';
  } catch {
    return true;
  }
}

function readSignalOutcomeGateMaxOpen() {
  try {
    const raw = localStorage.getItem(SIGNAL_OUTCOME_GATE_MAX_OPEN_KEY);
    const num = Number(raw);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(5, Math.floor(num)));
  } catch {
    return 0;
  }
}

function readSignalPerformanceWeighting() {
  try {
    const raw = localStorage.getItem(SIGNAL_PERFORMANCE_WEIGHT_KEY);
    if (raw == null) return true;
    return raw === '1' || raw.toLowerCase() === 'true';
  } catch {
    return true;
  }
}

function readAgentAcademyUpdatesEnabled() {
  try {
    const raw = localStorage.getItem(AGENT_ACADEMY_UPDATE_KEY);
    if (raw == null) return true;
    return raw === '1' || raw.toLowerCase() === 'true';
  } catch {
    return true;
  }
}

type QuantGateMode = 'observe' | 'warn' | 'soft_block' | 'hard_block';

function normalizeQuantGateMode(value: any): QuantGateMode {
  const raw = String(value || '').trim().toLowerCase();
  if (raw === 'warn') return 'warn';
  if (raw === 'soft_block') return 'soft_block';
  if (raw === 'hard_block') return 'hard_block';
  return 'observe';
}

function resolveQuantGateMode(config: Record<string, any> | null | undefined, key: 'regime' | 'ensemble' | 'metaLabel' | 'portfolioRisk' | 'promotion'): QuantGateMode {
  const mode = normalizeQuantGateMode(config?.quantModes?.[key]);
  if (mode !== 'observe') return mode;
  try {
    const raw = localStorage.getItem(QUANT_MODE_STORAGE_KEY);
    if (!raw) return mode;
    const parsed = JSON.parse(raw);
    return normalizeQuantGateMode(parsed?.[key]);
  } catch {
    return mode;
  }
}

function isSetupSignalDebugEnabled() {
  try {
    return localStorage.getItem(SETUP_SIGNAL_DEBUG_KEY) === '1';
  } catch {
    return false;
  }
}

function wrapBrokerResult(method: string, res: any, brokerId: string) {
  if (res && typeof res === 'object' && !Array.isArray(res)) {
    const ok = typeof res.ok === 'boolean' ? res.ok : true;
    return { ...res, ok, brokerId, sourceBroker: brokerId, brokerMethod: method };
  }
  return { ok: true, brokerId, sourceBroker: brokerId, brokerMethod: method, result: res };
}

type BrokerQueueItem = {
  method: string;
  args?: any;
  priority: number;
  enqueuedAt: number;
  resolve: (value: any) => void;
  brokerId?: string | null;
};

type ExecutionQueuePayload = {
  kind: 'execution_queue';
  executor: 'trade' | 'mt5';
  proposal: TradeProposal;
  source: 'manual' | 'autopilot';
  brokerHint?: 'mt5' | 'tradelocker' | 'sim' | 'auto' | null;
  opts?: {
    forceBroker?: 'sim' | 'tradelocker' | 'mt5';
    executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
    runId?: string;
    autoConfigOverride?: Record<string, any> | null;
  } | null;
  queuedAtMs: number;
  attempts?: number;
  lastAttemptAtMs?: number | null;
  signalId?: string | null;
  dedupeKey?: string | null;
  submittedAtMs?: number | null;
  ackAtMs?: number | null;
  brokerOrderId?: string | null;
  retryCount?: number | null;
};

type ExecutionQueueItem = {
  ledgerId: string | null;
  dedupeKey: string;
  payload: ExecutionQueuePayload;
  resolve?: (value: any) => void;
  reject?: (error: any) => void;
};

const brokerQueue: BrokerQueueItem[] = [];
const brokerQueueMetrics = createQueueMetrics();
let brokerInFlight = 0;
let brokerDrainScheduled = false;
const brokerRequestCoordinator = getBrokerRequestCoordinator();
const runtimeScheduler = getRuntimeScheduler();
const diagnosticsRateLimiter = getDiagnosticsRateLimiter();
const cacheBudgetManager = getCacheBudgetManager();
const refreshSlaMonitor = getRefreshSlaMonitor();
const brokerCircuitBreaker = getBrokerCircuitBreaker();
const executionAuditService = getExecutionAuditService();
const livePolicyService = getLivePolicyService();
const panelConnectivityEngine = getPanelConnectivityEngine();
const crossPanelContextEngine = getCrossPanelContextEngine();
const outcomeConsistencyEngine = getOutcomeConsistencyEngine();

const stableStringify = (value: any): string => {
  const seen = new WeakSet();
  const normalize = (input: any): any => {
    if (input == null || typeof input !== 'object') return input;
    if (seen.has(input)) return null;
    seen.add(input);
    if (Array.isArray(input)) return input.map((item) => normalize(item));
    const keys = Object.keys(input).sort();
    const out: Record<string, any> = {};
    for (const key of keys) {
      out[key] = normalize((input as any)[key]);
    }
    return out;
  };
  try {
    return JSON.stringify(normalize(value));
  } catch {
    return '';
  }
};

const buildExecutionQueueKey = (payload: ExecutionQueuePayload) => {
  const proposal = payload?.proposal;
  const setup = proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
  const base = {
    v: 1,
    executor: payload?.executor || null,
    source: payload?.source || null,
    brokerHint: payload?.brokerHint ?? null,
    forceBroker: payload?.opts?.forceBroker ?? null,
    executionMode: payload?.opts?.executionMode ?? null,
    symbol: proposal?.symbol ?? null,
    action: proposal?.action ?? null,
    entryPrice: proposal?.entryPrice ?? null,
    stopLoss: proposal?.stopLoss ?? null,
    takeProfit: proposal?.takeProfit ?? null,
    messageId: proposal?.messageId ?? null,
    setupSignalId: setup?.signalId ?? null,
    setupWatcherId: setup?.watcherId ?? null,
    setupParamsHash: setup?.paramsHash ?? null
  };
  const raw = stableStringify(base);
  const h = hashStringSampled(raw || JSON.stringify(base), 4096);
  return `execq_${h}`;
};

const buildBrokerDedupeKey = (method: string, args?: any, brokerId?: string | null) => {
  const key = String(method || '').trim();
  if (!BROKER_DEDUPE_METHODS.has(key)) return '';
  const payload = args && typeof args === 'object' ? args : null;
  const encoded = stableStringify({
    brokerId: brokerId || null,
    payload
  });
  return encoded ? `${key}:${encoded}` : `${key}:na`;
};

const resolveBrokerPriority = (method: string) => {
  const key = String(method || '').toLowerCase();
  if (key.includes('quote')) return 3;
  if (key.includes('history')) return 2;
  if (key.includes('snapshot')) return 2;
  if (key.includes('search')) return 1;
  return 0;
};

const scheduleBrokerDrain = () => {
  if (brokerDrainScheduled) return;
  brokerDrainScheduled = true;
  deferMs(() => {
    brokerDrainScheduled = false;
    drainBrokerQueue();
  }, 0);
};

const drainBrokerQueue = () => {
  while (brokerInFlight < BROKER_REQUEST_CONCURRENCY && brokerQueue.length > 0) {
    const next = brokerQueue.shift();
    if (!next) return;
    const waitMs = Math.max(0, Date.now() - next.enqueuedAt);
    brokerQueueMetrics.noteWait(waitMs);
    brokerInFlight += 1;
    const { method, args, resolve, brokerId } = next;
    const timeoutMs = BROKER_REQUEST_TIMEOUT_MS;
    let timeoutHandle: TimerHandle | null = null;
    let timedOut = false;
    const timeoutPromise = new Promise((timeoutResolve) => {
      timeoutHandle = deferMs(() => {
        timedOut = true;
        timeoutResolve({ ok: false, timeout: true, error: `${method} timeout (${timeoutMs}ms).` });
      }, timeoutMs);
    });
    const work = requestBrokerRaw(method, args, brokerId).catch((err: any) => ({
      ok: false,
      error: err?.message ? String(err.message) : `${method} request failed.`
    }));
    Promise.race([work, timeoutPromise])
      .then((res) => {
        if (timeoutHandle) {
          cancelTimer(timeoutHandle);
          timeoutHandle = null;
        }
        if (timedOut && res && typeof res === 'object' && !Array.isArray(res)) {
          res.timeout = true;
        }
        resolve(res);
      })
      .finally(() => {
        brokerInFlight = Math.max(0, brokerInFlight - 1);
        drainBrokerQueue();
      });
  }
};

async function requestBroker(method: string, args?: any, opts?: { brokerId?: string | null; source?: string | null }) {
  const methodKey = String(method || '').trim();
  const dedupeEnabled = BROKER_DEDUPE_METHODS.has(methodKey);
  const payload = args && typeof args === 'object' ? args : null;
  const symbol = String((payload as any)?.symbol || (payload as any)?.instrument || (payload as any)?.instrumentSymbol || '').trim() || null;
  const timeframe = String((payload as any)?.timeframe || (payload as any)?.resolution || '').trim() || null;
  const maxAgeMs = Number((payload as any)?.maxAgeMs || 0);
  const argsHash = dedupeEnabled
    ? stableStringify({ brokerId: opts?.brokerId || null, payload })
    : `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  const priority = resolveBrokerPriority(method);

  const coordinated = await brokerRequestCoordinator.run(
    {
      method: methodKey,
      symbol,
      timeframe,
      maxAgeMs: Number.isFinite(maxAgeMs) && maxAgeMs > 0 ? maxAgeMs : dedupeEnabled ? BROKER_DEDUPE_TTL_MS : 0,
      argsHash,
      source: String(opts?.source || 'other'),
      priority: priority >= 3 ? 'critical' : priority >= 2 ? 'interactive' : 'background'
    },
    async () => {
      return await new Promise((resolve) => {
        const entry: BrokerQueueItem = {
          method,
          args,
          priority,
          enqueuedAt: Date.now(),
          resolve,
          brokerId: opts?.brokerId ?? null
        };
        brokerQueue.push(entry);
        brokerQueue.sort((a, b) => {
          if (b.priority !== a.priority) return b.priority - a.priority;
          return a.enqueuedAt - b.enqueuedAt;
        });
        brokerQueueMetrics.noteDepth(brokerQueue.length);
        scheduleBrokerDrain();
      });
    }
  );

  return coordinated.value;
}

registerBrokerRequestExecutor((method, args, opts) =>
  requestBroker(method, args, {
    brokerId: opts?.brokerId ?? null,
    source: opts?.source ?? null
  })
);

async function requestBrokerRaw(method: string, args?: any, brokerId?: string | null) {
  const broker = (window as any)?.glass?.broker;
  const brokerRequest = broker && typeof (broker as any)['request'] === 'function'
    ? (broker as any)['request'].bind(broker)
    : null;
  const requestedBroker = brokerId ? String(brokerId) : null;
  if (brokerRequest) {
    try {
      const res = await brokerRequest({ method, args, brokerId: requestedBroker });
      if (res && res.ok === false) {
        const errMsg = String(res.error || '');
        const unsupported =
          errMsg.includes('does not support') ||
          errMsg.includes('Unknown broker') ||
          errMsg.includes('No active broker');
        if (unsupported && (!requestedBroker || requestedBroker === 'tradelocker')) {
          const tl = (window as any)?.glass?.tradelocker;
          const fn = tl && (tl as any)[method];
          if (typeof fn === 'function') {
            try {
              const fallback = await fn(args);
              return wrapBrokerResult(method, fallback, 'tradelocker');
            } catch (err: any) {
              return {
                ok: false,
                error: err?.message ? String(err.message) : `${method} request failed.`,
                brokerId: 'tradelocker',
                sourceBroker: 'tradelocker',
                brokerMethod: method
              };
            }
          }
        }
      }
      return res;
    } catch (err: any) {
      return { ok: false, error: err?.message ? String(err.message) : `${method} request failed.` };
    }
  }

  if (!requestedBroker || requestedBroker === 'tradelocker') {
    const tl = (window as any)?.glass?.tradelocker;
    const fn = tl && (tl as any)[method];
    if (typeof fn === 'function') {
      try {
        const res = await fn(args);
        return wrapBrokerResult(method, res, 'tradelocker');
      } catch (err: any) {
        return {
          ok: false,
          error: err?.message ? String(err.message) : `${method} request failed.`,
          brokerId: 'tradelocker',
          sourceBroker: 'tradelocker',
          brokerMethod: method
        };
      }
    }
  }
  return { ok: false, error: `${method} unavailable.` };
}

const parseJsonArray = (key: string): string[] => {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed.map((entry) => String(entry)).filter(Boolean) : [];
  } catch {
    return [];
  }
};

const buildTradeLockerAccountKey = (input?: {
  env?: string | null;
  server?: string | null;
  accountId?: number | null;
  accNum?: number | null;
} | null) => {
  if (!input) return '';
  const env = input.env ? String(input.env).trim() : '';
  const server = input.server ? String(input.server).trim() : '';
  const accountId = Number(input.accountId);
  const accNum = Number(input.accNum);
  if (!env || !server || !Number.isFinite(accountId) || accountId <= 0 || !Number.isFinite(accNum) || accNum <= 0) {
    return '';
  }
  return [env, server, String(Math.trunc(accountId)), String(Math.trunc(accNum))].join(':');
};

const parseTradeLockerAccountKey = (key: string) => {
  const parts = String(key || '').split(':').map((p) => p.trim());
  if (parts.length < 4) return null;
  const [env, server, accountIdRaw, accNumRaw] = parts;
  const accountId = Number(accountIdRaw);
  const accNum = Number(accNumRaw);
  if (!env || !server || !Number.isFinite(accountId) || accountId <= 0 || !Number.isFinite(accNum) || accNum <= 0) return null;
  return { env, server, accountId: Math.trunc(accountId), accNum: Math.trunc(accNum) };
};

const parseTradeLockerAccountNumber = (value: any): number | null => {
  if (value == null) return null;
  const raw = Number(value);
  if (!Number.isFinite(raw) || raw <= 0) return null;
  return Math.trunc(raw);
};

const computeMedian = (values: number[]) => {
  if (!Array.isArray(values) || values.length === 0) return null;
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }
  return sorted[mid];
};

const computeMad = (values: number[], median: number | null) => {
  if (median == null || !Number.isFinite(median)) return null;
  const deviations = values.map((v) => Math.abs(v - median));
  return computeMedian(deviations);
};

function normalizePlaybookStep(raw: any, index: number) {
  if (!raw || typeof raw !== 'object') return null;
  const rrRaw = Number(raw.rr ?? raw.r ?? raw.targetR);
  if (!Number.isFinite(rrRaw) || rrRaw <= 0) return null;
  const qtyRaw = Number(raw.qtyPct ?? raw.qty ?? raw.percent ?? raw.sizePct);
  if (!Number.isFinite(qtyRaw) || qtyRaw <= 0) return null;
  let qtyPct = qtyRaw;
  if (qtyPct > 0 && qtyPct <= 1) qtyPct = qtyPct * 100;
  qtyPct = Math.min(100, Math.max(0, qtyPct));
  if (!Number.isFinite(qtyPct) || qtyPct <= 0) return null;
  const id = raw.id ? String(raw.id).trim() : `step_${index + 1}`;
  const moveRaw = raw.moveStopTo != null ? String(raw.moveStopTo).trim().toLowerCase() : '';
  const moveStopTo =
    moveRaw === 'breakeven' || moveRaw === 'entry' || moveRaw === 'none'
      ? (moveRaw as 'breakeven' | 'entry' | 'none')
      : undefined;
  return { id, rr: rrRaw, qtyPct, moveStopTo };
}

function normalizeExecutionPlaybook(raw: any): ExecutionPlaybook | null {
  if (!raw || typeof raw !== 'object') return null;
  const enabled = raw.enabled !== false;
  const stepsRaw = Array.isArray(raw.steps) ? raw.steps : Array.isArray(raw.tps) ? raw.tps : [];
  const steps = stepsRaw.map(normalizePlaybookStep).filter(Boolean) as ExecutionPlaybook['steps'];
  const breakevenRaw = raw.breakevenAtR ?? raw.breakevenR ?? raw.beAtR;
  const breakevenAtR =
    breakevenRaw != null && Number.isFinite(Number(breakevenRaw)) && Number(breakevenRaw) > 0
      ? Number(breakevenRaw)
      : undefined;
  const trailRaw = raw.trail || raw.trailing || null;
  let trail: ExecutionPlaybook['trail'] = null;
  if (trailRaw && typeof trailRaw === 'object') {
    const activationRaw = trailRaw.activationR ?? trailRaw.activateR ?? trailRaw.startR;
    const offsetRaw = trailRaw.offsetR ?? trailRaw.trailR ?? trailRaw.offset;
    const activationR =
      activationRaw != null && Number.isFinite(Number(activationRaw)) && Number(activationRaw) > 0
        ? Number(activationRaw)
        : undefined;
    const offsetR =
      offsetRaw != null && Number.isFinite(Number(offsetRaw)) && Number(offsetRaw) > 0
        ? Number(offsetRaw)
        : undefined;
    if (activationR != null || offsetR != null) {
      trail = { activationR, offsetR };
    }
  }
  const minIntervalRaw = raw.minIntervalMs;
  const minIntervalMs =
    minIntervalRaw != null && Number.isFinite(Number(minIntervalRaw)) && Number(minIntervalRaw) > 0
      ? Number(minIntervalRaw)
      : undefined;
  if ((!steps || steps.length === 0) && breakevenAtR == null && !trail) return null;
  return {
    enabled,
    version: Number.isFinite(Number(raw.version)) ? Number(raw.version) : 1,
    steps,
    breakevenAtR,
    trail,
    minIntervalMs
  };
}

function extractPlaybookFromParams(params: Record<string, any> | null | undefined) {
  if (!params || typeof params !== 'object') return { params: {}, playbook: null as ExecutionPlaybook | null };
  const playbook = normalizeExecutionPlaybook((params as any).playbook);
  if (!playbook) return { params, playbook: null };
  const next = { ...params };
  delete (next as any).playbook;
  return { params: next, playbook };
}

function buildPlaybookState(playbook: ExecutionPlaybook | null, previous?: any) {
  if (!playbook) return null;
  const prev = previous && typeof previous === 'object' ? { ...previous } : {};
  const prevSteps = Array.isArray(prev.steps) ? prev.steps : [];
  const prevById = new Map(prevSteps.map((step: any) => [String(step?.id || ''), step]));
  const steps = (playbook.steps || []).map((step, index) => {
    const id = String(step?.id || `step_${index + 1}`);
    const prior = prevById.get(id);
    const done = prior?.status === 'done';
    return {
      id,
      rr: Number(step?.rr),
      qtyPct: Number(step?.qtyPct),
      status: done ? 'done' : 'pending',
      filledQty: prior?.filledQty ?? null,
      filledAtMs: prior?.filledAtMs ?? null
    };
  });
  const trail = playbook.trail
    ? {
        activationR: playbook.trail.activationR,
        offsetR: playbook.trail.offsetR,
        active: !!prev?.trail?.active,
        lastStop: prev?.trail?.lastStop ?? null
      }
    : null;
  return {
    version: playbook.version ?? 1,
    steps,
    breakevenAtR: playbook.breakevenAtR ?? prev?.breakevenAtR ?? null,
    breakevenDone: !!prev?.breakevenDone,
    trail,
    initialQty: prev?.initialQty ?? null,
    lastActionAtMs: prev?.lastActionAtMs ?? null
  };
}

function normalizeTaskPlaybookMode(value: any): TaskPlaybookMode {
  const raw = String(value || '').trim().toLowerCase();
  if (raw === 'autopilot') return 'autopilot';
  if (raw === 'team') return 'team';
  return 'coordinate';
}

function normalizeTaskPlaybookStep(raw: any, index: number): TaskPlaybookStep | null {
  if (!raw || typeof raw !== 'object') return null;
  const actionId = String(raw.actionId || '').trim();
  if (!actionId) return null;
  const id = String(raw.id || `step_${index + 1}`).trim() || `step_${index + 1}`;
  const label = raw.label != null ? String(raw.label) : null;
  const stageRaw = raw.stage != null ? String(raw.stage).trim().toLowerCase() : '';
  const stage =
    stageRaw === 'observe' || stageRaw === 'evaluate' || stageRaw === 'decide' || stageRaw === 'verify' ||
    stageRaw === 'execute' || stageRaw === 'monitor' || stageRaw === 'review'
      ? (stageRaw as TaskPlaybookStep['stage'])
      : null;
  const payload = raw.payload && typeof raw.payload === 'object' ? raw.payload : null;
  return {
    id,
    actionId,
    label: label || null,
    stage,
    payload,
    storeAs: raw.storeAs != null ? String(raw.storeAs) : null,
    optional: raw.optional === true,
    requiresConfirmation: raw.requiresConfirmation === true,
    requiresUser: raw.requiresUser === true,
    skipIfMissing: raw.skipIfMissing != null ? String(raw.skipIfMissing) : null,
    timeoutMs: Number.isFinite(Number(raw.timeoutMs)) ? Number(raw.timeoutMs) : null,
    maxRetries: Number.isFinite(Number(raw.maxRetries)) ? Math.max(0, Math.floor(Number(raw.maxRetries))) : null,
    retryDelayMs: Number.isFinite(Number(raw.retryDelayMs)) ? Math.max(0, Math.floor(Number(raw.retryDelayMs))) : null
  };
}

function normalizeTaskPlaybook(raw: any): TaskPlaybook | null {
  if (!raw || typeof raw !== 'object') return null;
  const id = String(raw.id || '').trim();
  const name = String(raw.name || '').trim();
  if (!id || !name) return null;
  const stepsRaw = Array.isArray(raw.steps) ? raw.steps : [];
  const steps = stepsRaw.map((step, index) => normalizeTaskPlaybookStep(step, index)).filter(Boolean) as TaskPlaybookStep[];
  if (steps.length === 0) return null;
  const symbol = raw.symbol != null ? String(raw.symbol).trim() : null;
  const timeframes = Array.isArray(raw.timeframes)
    ? raw.timeframes.map((tf: any) => String(tf || '').trim()).filter(Boolean)
    : null;
  const strategy = raw.strategy ? normalizeSetupStrategyName(String(raw.strategy)) : null;
  return {
    id,
    name,
    description: raw.description != null ? String(raw.description) : null,
    version: Number.isFinite(Number(raw.version)) ? Number(raw.version) : 1,
    owner: raw.owner ? String(raw.owner) as TaskPlaybook['owner'] : null,
    symbol: symbol || null,
    timeframes: timeframes && timeframes.length > 0 ? timeframes : null,
    strategy: strategy as TaskPlaybook['strategy'],
    defaultMode: normalizeTaskPlaybookMode(raw.defaultMode),
    steps,
    tags: Array.isArray(raw.tags) ? raw.tags.map((tag: any) => String(tag || '').trim()).filter(Boolean) : null,
    createdAtMs: Number.isFinite(Number(raw.createdAtMs)) ? Number(raw.createdAtMs) : null,
    updatedAtMs: Number.isFinite(Number(raw.updatedAtMs)) ? Number(raw.updatedAtMs) : null
  };
}

function normalizeActionSequenceSteps(raw: any): TaskPlaybookStep[] {
  const entries = Array.isArray(raw) ? raw : [];
  const steps: TaskPlaybookStep[] = [];
  for (let idx = 0; idx < entries.length; idx += 1) {
    const entry = entries[idx];
    const payload =
      entry && typeof entry === 'object' && !Array.isArray(entry)
        ? entry
        : typeof entry === 'string'
          ? { actionId: entry }
          : null;
    const step = normalizeTaskPlaybookStep(payload, idx);
    if (step) steps.push(step);
  }
  return steps;
}

function buildActionSequencePlaybook(input: {
  steps: TaskPlaybookStep[];
  intentLabel?: string | null;
}): TaskPlaybook | null {
  if (!Array.isArray(input.steps) || input.steps.length === 0) return null;
  const labelRaw = input.intentLabel != null ? String(input.intentLabel).trim() : '';
  const label = labelRaw.length > 80 ? `${labelRaw.slice(0, 76)}...` : labelRaw;
  const stepSignature = JSON.stringify(
    input.steps.map((step) => ({
      actionId: step.actionId,
      label: step.label || null,
      payload: step.payload || null,
      storeAs: step.storeAs || null,
      optional: !!step.optional,
      requiresConfirmation: !!step.requiresConfirmation,
      requiresUser: !!step.requiresUser,
      skipIfMissing: step.skipIfMissing || null,
      timeoutMs: step.timeoutMs || null,
      maxRetries: step.maxRetries || null,
      retryDelayMs: step.retryDelayMs || null
    }))
  );
  const idHash = hashStringSampled(stepSignature, 512);
  return {
    id: `playbook.action_sequence.${idHash}`,
    name: label ? `Action Flow: ${label}` : 'Action Flow',
    description: label ? `Auto-generated flow: ${label}` : 'Auto-generated action sequence.',
    owner: 'agent',
    version: 1,
    steps: input.steps
  };
}

function buildDefaultTradeSessionPlaybook(): TaskPlaybook {
  return {
    id: 'playbook.trade_session_mtf.v1',
    name: 'MTF Trade Session (MTF + Backtest + Optimize)',
    description: 'Watch multi-timeframe chart context, run optimizer chain, and create a live watcher from the best params.',
    owner: 'system',
    version: 1,
    symbol: 'BTCUSD',
    timeframes: ['4h', '1h', '15m', '5m'],
    strategy: 'MEAN_REVERSION',
    defaultMode: 'coordinate',
    steps: [
      {
        id: 'snapshot',
        label: 'System snapshot',
        stage: 'observe',
        actionId: 'system.snapshot',
        storeAs: 'snapshot'
      },
      {
        id: 'chart_watch',
        label: 'Start chart watch (MTF)',
        stage: 'observe',
        actionId: 'chart.watch.start',
        payload: {
          symbol: '{{symbol}}',
          timeframes: ['4h', '1h', '15m', '5m']
        },
        storeAs: 'chartWatch'
      },
      {
        id: 'chart_state',
        label: 'Chart engine snapshot',
        stage: 'evaluate',
        actionId: 'chart.engine.snapshot',
        payload: {
          symbol: '{{symbol}}',
          timeframes: ['4h', '1h', '15m', '5m'],
          barsLimit: 80,
          eventsLimit: 20
        },
        storeAs: 'chartState'
      },
      {
        id: 'optimizer_chain',
        label: 'Optimizer chain (round 1 + 2)',
        stage: 'evaluate',
        actionId: 'backtest.optimizer.chain',
        payload: {
          symbol: '{{symbol}}',
          timeframe: '5m',
          strategy: '{{strategy}}',
          rangeDays: 90,
          maxCombos: 200,
          objectivePreset: 'winrate_dd',
          rounds: 2
        },
        storeAs: 'optimizer'
      },
      {
        id: 'save_preset',
        label: 'Save round-2 winner preset',
        stage: 'decide',
        actionId: 'backtest.optimizer.save_preset',
        payload: {
          winnerId: '{{optimizer.round2WinnerId}}',
          presetName: '{{symbol}} {{strategy}} 5m R2',
          tags: ['optimizer', 'round2', '{{symbol}}', '{{strategy}}', '5m']
        },
        optional: true,
        storeAs: 'savedPreset'
      },
      {
        id: 'watcher_create',
        label: 'Create watcher from round-2 winner',
        stage: 'execute',
        actionId: 'watcher.create',
        payload: {
          winnerId: '{{optimizer.round2WinnerId}}',
          mode: '{{watcherMode}}',
          enabled: true
        },
        storeAs: 'watcher'
      },
      {
        id: 'signals',
        label: 'Fetch setup signals',
        stage: 'monitor',
        actionId: 'watcher.signals',
        payload: {
          watcherId: '{{watcher.id}}',
          limit: 10
        },
        optional: true,
        storeAs: 'signals'
      },
      {
        id: 'trade_propose',
        label: 'Propose trade from latest signal',
        stage: 'execute',
        actionId: 'trade.propose',
        payload: {
          symbol: '{{signals.0.symbol}}',
          action: '{{signals.0.payload.side}}',
          entryPrice: '{{signals.0.payload.details.entryPrice}}',
          stopLoss: '{{signals.0.payload.details.stopLoss}}',
          takeProfit: '{{signals.0.payload.details.takeProfit}}',
          reason: 'Playbook signal {{signals.0.payload.status}}'
        },
        optional: true,
        skipIfMissing: 'signals.0.payload.details.entryPrice'
      }
    ]
  };
}

function normalizeSetupWatcher(raw: any): SetupWatcher | null {
  if (!raw || typeof raw !== 'object') return null;
  const id = String(raw.id || '').trim();
  const symbol = String(raw.symbol || '').trim();
  const timeframe = String(raw.timeframe || '').trim();
  const strategyRaw = String(raw.strategy || '').trim().toUpperCase();
  const allowed = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
  if (!id || !symbol || !timeframe || !allowed.has(strategyRaw)) return null;
  const paramsRaw = raw.params && typeof raw.params === 'object' ? raw.params : {};
  const explicitPlaybook = normalizeExecutionPlaybook(raw.playbook);
  const extracted = extractPlaybookFromParams(paramsRaw);
  const playbook = explicitPlaybook || extracted.playbook;
  const params = extracted.params;
  const modeRaw = String(raw.mode || '').trim().toLowerCase();
  const mode = modeRaw === 'live' ? 'live' : modeRaw === 'paper' ? 'paper' : 'suggest';
  const enabled = raw.enabled !== false;
  const createdAtMs = Number.isFinite(Number(raw.createdAtMs)) ? Number(raw.createdAtMs) : Date.now();
  const updatedAtMs = Number.isFinite(Number(raw.updatedAtMs)) ? Number(raw.updatedAtMs) : createdAtMs;
  const lastSignalType = raw.lastSignalType ? String(raw.lastSignalType) : null;
  const lastSignalAtMs = Number.isFinite(Number(raw.lastSignalAtMs)) ? Number(raw.lastSignalAtMs) : null;
  const profileId = raw.profileId ? String(raw.profileId).trim() : null;
  const profileLabel = raw.profileLabel ? String(raw.profileLabel).trim() : null;
  const profileObjectivePreset = raw.profileObjectivePreset ? String(raw.profileObjectivePreset).trim() : null;
  const profileSessionId = raw.profileSessionId ? String(raw.profileSessionId).trim() : null;
  const profileBaselineRunId = raw.profileBaselineRunId ? String(raw.profileBaselineRunId).trim() : null;
  const profileParamsHash = raw.profileParamsHash
    ? String(raw.profileParamsHash).trim()
    : raw.paramsHash
      ? String(raw.paramsHash).trim()
      : null;
  const optimizerSessionId = raw.optimizerSessionId ? String(raw.optimizerSessionId).trim() : null;
  const optimizerRound = Number.isFinite(Number(raw.optimizerRound)) ? Math.max(1, Math.floor(Number(raw.optimizerRound))) : null;
  const optimizerWinnerId = raw.optimizerWinnerId ? String(raw.optimizerWinnerId).trim() : null;
  const libraryKey = raw.libraryKey ? String(raw.libraryKey).trim() : null;
  const tierRaw = raw.libraryTier ? String(raw.libraryTier).trim().toUpperCase() : '';
  const allowedTiers = new Set(['S', 'A', 'B', 'C', 'D']);
  const libraryTier = tierRaw && allowedTiers.has(tierRaw) ? (tierRaw as SetupWatcher['libraryTier']) : null;
  const scoreRaw = Number(raw.libraryScore);
  const libraryScore = Number.isFinite(scoreRaw) ? scoreRaw : null;
  const winRateTierRaw = raw.libraryWinRateTier ? String(raw.libraryWinRateTier).trim().toUpperCase() : '';
  const allowedWinRate = new Set(['WR70', 'WR60', 'WR50', 'WR40', 'WR30']);
  const libraryWinRateTier = winRateTierRaw && allowedWinRate.has(winRateTierRaw)
    ? (winRateTierRaw as SetupWatcher['libraryWinRateTier'])
    : null;
  const libraryStats = raw.libraryStats && typeof raw.libraryStats === 'object' ? raw.libraryStats : null;
  const regimeRaw = raw.regime ? String(raw.regime).trim().toLowerCase() : '';
  const allowedRegimes = new Set(['any', 'trend', 'range', 'breakout']);
  const regime = regimeRaw && allowedRegimes.has(regimeRaw) ? (regimeRaw as SetupWatcher['regime']) : 'any';

  return {
    id,
    symbol,
    timeframe,
    strategy: strategyRaw as SetupWatcher['strategy'],
    params,
    playbook,
    mode,
    enabled,
    regime,
    createdAtMs,
    updatedAtMs,
    lastSignalType: lastSignalType as SetupWatcher['lastSignalType'],
    lastSignalAtMs,
    profileId,
    profileLabel,
    profileObjectivePreset,
    profileSessionId,
    profileBaselineRunId,
    profileParamsHash,
    optimizerSessionId,
    optimizerRound,
    optimizerWinnerId,
    libraryKey,
    libraryTier,
    libraryScore,
    libraryWinRateTier,
    libraryStats
  };
}

function normalizeWatchProfile(raw: any): WatchProfile | null {
  if (!raw || typeof raw !== 'object') return null;
  const payload = raw.payload && typeof raw.payload === 'object' ? raw.payload : raw;
  const rawKey = String(payload.profileId || raw.profileId || payload.key || raw.key || raw.id || '').trim();
  const profileId = rawKey.replace(/^watch_profile:/, '');
  const symbol = String(payload.symbol || raw.symbol || '').trim();
  const timeframe = String(payload.timeframe || raw.timeframe || '').trim();
  const strategy = normalizeSetupStrategyName(payload.strategy || raw.strategy || '');
  if (!profileId || !symbol || !timeframe || !strategy) return null;
  const params = payload.params && typeof payload.params === 'object' ? payload.params : {};
  const createdAtMs = Number(payload.createdAtMs || raw.createdAtMs) || Date.now();
  const updatedAtMs = Number(payload.updatedAtMs || raw.updatedAtMs) || createdAtMs;
  const regimeConstraint =
    payload.regimeConstraint && typeof payload.regimeConstraint === 'object' ? payload.regimeConstraint : null;
  return {
    profileId,
    symbol,
    timeframe,
    strategy: strategy as WatchProfile['strategy'],
    params,
    regimeConstraint,
    paramsHash: payload.paramsHash ? String(payload.paramsHash) : null,
    objectivePresetId: payload.objectivePresetId ? String(payload.objectivePresetId) : null,
    objectivePresetName: payload.objectivePresetName ? String(payload.objectivePresetName) : null,
    baselineRunId: payload.baselineRunId ? String(payload.baselineRunId) : null,
    optimizerSessionId: payload.optimizerSessionId ? String(payload.optimizerSessionId) : null,
    createdAtMs,
    updatedAtMs,
    source: payload.source || raw.source || null
  };
}

const SETUP_SIGNAL_STATUS_RANK: Record<SetupSignal['payload']['status'], number> = {
  setup_detected: 1,
  setup_ready: 2,
  entry_confirmed: 3,
  triggered: 4,
  invalidated: 5
};

function normalizeSetupSignalStatus(value: any, fallback?: string): SetupSignal['payload']['status'] {
  const raw = String(value || '').trim();
  if (raw && raw in SETUP_SIGNAL_STATUS_RANK) return raw as SetupSignal['payload']['status'];
  const fallbackRaw = String(fallback || '').trim();
  if (fallbackRaw && fallbackRaw in SETUP_SIGNAL_STATUS_RANK) return fallbackRaw as SetupSignal['payload']['status'];
  return 'setup_ready';
}

function mergeSetupSignals(prev: SetupSignal, next: SetupSignal): SetupSignal {
  const prevStatus = normalizeSetupSignalStatus(prev?.payload?.status, prev?.payload?.signalType);
  const nextStatus = normalizeSetupSignalStatus(next?.payload?.status, next?.payload?.signalType);
  const prevRank = SETUP_SIGNAL_STATUS_RANK[prevStatus] || 0;
  const nextRank = SETUP_SIGNAL_STATUS_RANK[nextStatus] || 0;
  let chosenStatus = prevStatus;
  let regression = false;
  if (prevStatus !== nextStatus) {
    if (prevStatus === 'triggered' || nextStatus === 'triggered') {
      chosenStatus = 'triggered';
    } else if (prevStatus === 'invalidated' || nextStatus === 'invalidated') {
      chosenStatus = 'invalidated';
    } else if (nextRank >= prevRank) {
      chosenStatus = nextStatus;
    } else {
      chosenStatus = prevStatus;
      regression = true;
    }
  }
  if (regression && isSetupSignalDebugEnabled()) {
    console.info('[setup_signal] status regression ignored', {
      id: prev.id || next.id,
      symbol: prev.symbol || next.symbol,
      timeframe: prev.timeframe || next.timeframe,
      prevStatus,
      nextStatus
    });
  }

  const prevDetails = prev?.payload?.details && typeof prev.payload.details === 'object' ? prev.payload.details : null;
  const nextDetails = next?.payload?.details && typeof next.payload.details === 'object' ? next.payload.details : null;
  const mergedDetails =
    prevDetails && nextDetails ? { ...prevDetails, ...nextDetails } : nextDetails || prevDetails || null;

  const prevInvalid = Array.isArray(prev?.payload?.invalidReasonCodes)
    ? prev.payload.invalidReasonCodes
    : [];
  const nextInvalid = Array.isArray(next?.payload?.invalidReasonCodes)
    ? next.payload.invalidReasonCodes
    : [];
  const invalidReasonCodes = Array.from(new Set([...prevInvalid, ...nextInvalid]));

  const reasonCodes = Array.from(
    new Set([...(prev.reasonCodes || []), ...(next.reasonCodes || [])].map((code) => String(code || '').trim()).filter(Boolean))
  );

  const confirmation =
    next?.payload?.confirmation && typeof next.payload.confirmation === 'object'
      ? next.payload.confirmation
      : prev?.payload?.confirmation;
  const evidence =
    next?.payload?.evidence && typeof next.payload.evidence === 'object'
      ? next.payload.evidence
      : prev?.payload?.evidence;

  return {
    ...prev,
    ...next,
    id: prev.id || next.id,
    ts: Math.max(prev.ts || 0, next.ts || 0),
    strength: Math.max(prev.strength || 0, next.strength || 0),
    reasonCodes,
    payload: {
      ...prev.payload,
      ...next.payload,
      status: chosenStatus,
      details: mergedDetails,
      invalidReasonCodes: invalidReasonCodes.length > 0 ? invalidReasonCodes : undefined,
      confirmation: confirmation || undefined,
      evidence: evidence || undefined
    }
  };
}

function normalizeSetupSignal(raw: any): SetupSignal | null {
  if (!raw || typeof raw !== 'object') return null;
  const payload = raw.payload && typeof raw.payload === 'object' ? raw.payload : raw;
  if (payload?.type !== 'setup_signal') return null;
  const symbol = String(payload.symbol || raw.symbol || '').trim();
  const timeframe = String(payload.timeframe || raw.timeframe || '').trim();
  const tsRaw = Number(payload.ts);
  const ts = Number.isFinite(tsRaw) ? (tsRaw > 1e11 ? Math.floor(tsRaw) : Math.floor(tsRaw * 1000)) : NaN;
  if (!symbol || !timeframe || !Number.isFinite(ts)) return null;
  const payloadBlock = payload.payload && typeof payload.payload === 'object' ? payload.payload : {};
  const signalTypeRaw = String(payloadBlock.signalType || payload.signalType || '').trim();
  const allowedTypes = new Set(['setup_ready', 'entry_confirmed', 'invalidated']);
  const signalType = allowedTypes.has(signalTypeRaw) ? signalTypeRaw : 'setup_ready';
  const status = normalizeSetupSignalStatus(payloadBlock.status || payload.status, signalType);
  const profileId = payload.profileId ? String(payload.profileId) : '';
  const watcherId = String(payloadBlock.watcherId || payload.watcherId || '').trim();
  const strategy = normalizeSetupStrategyName(payloadBlock.strategy || payload.strategy || '');
  const profileKey = profileId || watcherId || [symbol, timeframe, strategy].filter(Boolean).join(':') || 'na';
  const details =
    payloadBlock.details && typeof payloadBlock.details === 'object'
      ? payloadBlock.details
      : (payload.details && typeof payload.details === 'object' ? payload.details : null);
  const barTime = toSignalEpochMs(payloadBlock.barTime || payload.barTime || ts, ts);
  const signalBarTime = toSignalEpochMs((details as any)?.signalBarTime || (details as any)?.signalTime || barTime, barTime);
  const bucketIdRaw = details && typeof (details as any).signalBucketId === 'string'
    ? String((details as any).signalBucketId).trim()
    : '';
  const stableKey =
    bucketIdRaw && bucketIdRaw.startsWith(`${profileKey}:`)
      ? bucketIdRaw
      : buildSetupSignalBucketId(profileKey, timeframe, signalBarTime);
  const rawKey = String(raw.key || '').trim();
  const keyId = rawKey.startsWith('setup_signal:') ? `setup_signal_${rawKey.slice('setup_signal:'.length)}` : rawKey;
  const id =
    String(payload.id || raw.id || keyId || '').trim() ||
    `setup_signal_${hashStringSampled(stableKey)}`;
  const strengthRaw = Number(payload.strength);
  const strength = Number.isFinite(strengthRaw) ? Math.max(0, Math.min(1, strengthRaw)) : 0.5;
  const reasonCodes = Array.isArray(payload.reasonCodes) ? payload.reasonCodes.map((code: any) => String(code)) : [];
  const invalidReasonCodes = Array.isArray(payloadBlock.invalidReasonCodes || payload.invalidReasonCodes)
    ? (payloadBlock.invalidReasonCodes || payload.invalidReasonCodes).map((code: any) => String(code))
    : [];
  const confirmationRaw = payloadBlock.confirmation || payload.confirmation;
  const confirmation =
    confirmationRaw && typeof confirmationRaw === 'object'
      ? {
          type: confirmationRaw.type ? String(confirmationRaw.type) : undefined,
          ts: confirmationRaw.ts ? toSignalEpochMs(confirmationRaw.ts, ts) : undefined,
          details:
            confirmationRaw.details && typeof confirmationRaw.details === 'object' ? confirmationRaw.details : null
        }
      : undefined;
  const evidenceRaw = payloadBlock.evidence || payload.evidence || null;
  const evidence = evidenceRaw && typeof evidenceRaw === 'object' ? evidenceRaw : undefined;
  return {
    id,
    type: 'setup_signal',
    profileId: profileId || null,
    symbol,
    timeframe,
    ts,
    strength,
    reasonCodes,
    payload: {
      signalType,
      status,
      strategy: normalizeSetupStrategyName(payloadBlock.strategy || payload.strategy || '') as SetupSignal['payload']['strategy'],
      side: payloadBlock.side || payload.side || undefined,
      barTime: (() => {
        return toSignalEpochMs(payloadBlock.barTime || payload.barTime || ts, ts);
      })(),
      watcherId: payloadBlock.watcherId || payload.watcherId || null,
      details,
      evidence,
      invalidReasonCodes: invalidReasonCodes.length ? invalidReasonCodes : undefined,
      confirmation
    }
  };
}

function normalizeSetupStrategyName(value: any) {
  const raw = String(value || '').trim().toUpperCase();
  if (!raw) return '';
  const normalized = raw.replace(/[^A-Z0-9]+/g, '_');
  if (normalized === 'BREAK_RETEST' || normalized === 'BREAKRETEST') return 'BREAK_RETEST';
  if (normalized === 'BREAK_AND_RETEST' || normalized === 'BREAKANDRETEST') return 'BREAK_RETEST';
  if (normalized === 'RANGEBREAKOUT') return 'RANGE_BREAKOUT';
  if (normalized === 'FVGRETRACE') return 'FVG_RETRACE';
  if (normalized === 'TRENDPULLBACK') return 'TREND_PULLBACK';
  if (normalized === 'MEANREVERSION') return 'MEAN_REVERSION';
  const allowed = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
  return allowed.has(normalized) ? normalized : '';
}

function inferStrategyFromText(value: any) {
  const raw = String(value || '').toLowerCase();
  if (!raw) return '';
  if (raw.includes('break') && raw.includes('retest')) return 'BREAK_RETEST';
  if (raw.includes('fvg') || raw.includes('fair value') || raw.includes('imbalance')) return 'FVG_RETRACE';
  if (raw.includes('pullback') || raw.includes('trend') || raw.includes('ema') || raw.includes('moving average')) {
    return 'TREND_PULLBACK';
  }
  if (
    raw.includes('mean reversion') ||
    raw.includes('reversion') ||
    raw.includes('bollinger') ||
    raw.includes('rsi') ||
    raw.includes('oversold') ||
    raw.includes('overbought')
  ) {
    return 'MEAN_REVERSION';
  }
  if (raw.includes('breakout') || raw.includes('range') || raw.includes('break of structure')) return 'RANGE_BREAKOUT';
  return '';
}

function resolveToolStrategy(action: AgentToolAction) {
  const direct = normalizeSetupStrategyName(action.strategy || '');
  if (direct) return direct;
  const description = String(action.strategyDescription || '').trim();
  if (description) {
    const inferred = inferStrategyFromText(description);
    if (inferred) return inferred;
  }
  const inferred = inferStrategyFromText(action.strategy || '');
  return inferred;
}

function resolveStrategyParams(action: AgentToolAction) {
  if (action.params && typeof action.params === 'object') return action.params;
  const payload = action.payload && typeof action.payload === 'object' ? action.payload : null;
  if (payload && typeof (payload as any).strategyParams === 'object') return (payload as any).strategyParams;
  if (payload && typeof (payload as any).params === 'object') return (payload as any).params;
  return null;
}

function normalizeSetupRegimeGate(value: any): SetupWatcher['regime'] {
  const raw = String(value || '').trim().toLowerCase();
  if (!raw) return 'any';
  if (raw === 'trend' || raw === 'range' || raw === 'breakout') return raw;
  if (raw.includes('any') || raw.includes('all') || raw.includes('none')) return 'any';
  return 'any';
}

function getDefaultRegimeGate(strategy: string): SetupWatcher['regime'] {
  const key = String(strategy || '').trim().toUpperCase();
  if (key === 'RANGE_BREAKOUT') return 'breakout';
  if (key === 'BREAK_RETEST') return 'breakout';
  if (key === 'MEAN_REVERSION') return 'range';
  if (key === 'TREND_PULLBACK') return 'trend';
  if (key === 'FVG_RETRACE') return 'trend';
  return 'any';
}

function loadSetupWatchers(): SetupWatcher[] {
  try {
    const raw = localStorage.getItem(SETUP_WATCHER_STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.map(normalizeSetupWatcher).filter(Boolean) as SetupWatcher[];
  } catch {
    return [];
  }
}

type SymbolCap = { maxLot?: number | null; maxPositions?: number | null };
type GroupCap = { maxLot?: number | null; maxPositions?: number | null };

function normalizeSymbolKey(value: string) {
  return normalizeSymbolKeyShared(value);
}

function normalizeGroupKey(value: string) {
  const raw = String(value || '').trim().toUpperCase();
  if (!raw) return '';
  return raw.replace(/\s+/g, '_');
}

function normalizeTimeframeKey(value: string) {
  return normalizeTimeframeKeyShared(value);
}

function normalizeDriftAction(value: any): 'none' | 'paper' | 'suggest' | 'disable' {
  const raw = String(value || '').trim().toLowerCase();
  if (!raw) return 'none';
  if (raw.includes('paper')) return 'paper';
  if (raw.includes('suggest')) return 'suggest';
  if (raw.includes('disable') || raw.includes('off')) return 'disable';
  if (raw.includes('none') || raw.includes('no')) return 'none';
  return 'none';
}

function buildParamsKey(params: Record<string, any>) {
  if (!params || typeof params !== 'object') return '';
  const entries = Object.entries(params)
    .filter(([key, value]) => value != null && key !== 'playbook')
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, value]) => [key, value]);
  try {
    return JSON.stringify(entries);
  } catch {
    return '';
  }
}

function buildParamGridFromParams(params: Record<string, any> | null | undefined) {
  const grid: Record<string, any> = {};
  if (!params || typeof params !== 'object') return grid;
  for (const [key, value] of Object.entries(params)) {
    if (value == null || key === 'playbook') continue;
    grid[key] = Array.isArray(value) ? value : [value];
  }
  return grid;
}

const uniqueNumbers = (values: number[]) => {
  const filtered = values.filter((value) => Number.isFinite(value));
  return Array.from(new Set(filtered));
};

const round2 = (value: number) => Math.round(value * 100) / 100;

function buildDefaultOptimizationGrid(strategy: string) {
  const key = String(strategy || '').trim().toUpperCase();
  if (key === 'BREAK_RETEST') {
    const base = DEFAULT_BREAK_RETEST_CONFIG;
    return {
      lookbackBars: uniqueNumbers([
        Math.max(5, Math.round(base.lookbackBars * 0.5)),
        base.lookbackBars,
        Math.round(base.lookbackBars * 1.5)
      ]),
      atrPeriod: uniqueNumbers([
        Math.max(5, Math.round(base.atrPeriod * 0.7)),
        base.atrPeriod,
        Math.round(base.atrPeriod * 1.5)
      ]),
      atrMult: uniqueNumbers([
        round2(base.atrMult * 0.7),
        base.atrMult,
        round2(base.atrMult * 1.2),
        round2(base.atrMult * 1.6)
      ]),
      rr: uniqueNumbers([
        round2(base.rr * 0.75),
        base.rr,
        round2(base.rr * 1.2),
        round2(base.rr * 1.5)
      ]),
      cooldownBars: uniqueNumbers([0, Math.round(base.cooldownBars * 0.5), base.cooldownBars]),
      breakoutMode: ['close', 'wick'],
      bufferAtrMult: uniqueNumbers([0, round2(base.bufferAtrMult || 0), 0.5, 1.0]),
      retestBars: uniqueNumbers([
        Math.max(4, Math.round(base.retestBars * 0.5)),
        base.retestBars,
        Math.round(base.retestBars * 1.5)
      ]),
      retestBufferAtrMult: uniqueNumbers([
        round2(base.retestBufferAtrMult * 0.7),
        base.retestBufferAtrMult,
        round2(base.retestBufferAtrMult * 1.4)
      ]),
      retestConfirm: ['touch', 'close']
    };
  }
  if (key === 'FVG_RETRACE') {
    const base = DEFAULT_FVG_RETRACE_CONFIG;
    return {
      atrPeriod: uniqueNumbers([
        Math.max(5, Math.round(base.atrPeriod * 0.7)),
        base.atrPeriod,
        Math.round(base.atrPeriod * 1.5)
      ]),
      atrMult: uniqueNumbers([
        round2(base.atrMult * 0.7),
        base.atrMult,
        round2(base.atrMult * 1.2),
        round2(base.atrMult * 1.5)
      ]),
      rr: uniqueNumbers([
        round2(base.rr * 0.7),
        base.rr,
        round2(base.rr * 1.15),
        round2(base.rr * 1.4)
      ]),
      maxWaitBars: uniqueNumbers([
        Math.max(20, Math.round(base.maxWaitBars * 0.5)),
        base.maxWaitBars,
        Math.round(base.maxWaitBars * 1.2),
        Math.round(base.maxWaitBars * 1.6)
      ]),
      entryMode: ['mid', 'edge'],
      minGapAtrMult: uniqueNumbers([0, round2(base.minGapAtrMult || 0), 0.25, 0.5, 0.75, 1.0])
    };
  }
  if (key === 'TREND_PULLBACK') {
    const base = DEFAULT_TREND_PULLBACK_CONFIG;
    return {
      fastEma: uniqueNumbers([
        Math.max(2, Math.round(base.fastEma * 0.5)),
        Math.round(base.fastEma * 0.75),
        base.fastEma,
        Math.round(base.fastEma * 1.25)
      ]),
      slowEma: uniqueNumbers([
        Math.max(5, Math.round(base.slowEma * 0.6)),
        Math.round(base.slowEma * 0.85),
        base.slowEma,
        Math.round(base.slowEma * 1.4)
      ]),
      pullbackEma: ['fast', 'slow'],
      confirmMode: ['touch', 'close'],
      minTrendBars: uniqueNumbers([
        Math.max(2, Math.round(base.minTrendBars * 0.5)),
        base.minTrendBars,
        Math.round(base.minTrendBars * 1.5)
      ]),
      atrPeriod: uniqueNumbers([
        Math.max(5, Math.round(base.atrPeriod * 0.7)),
        base.atrPeriod,
        Math.round(base.atrPeriod * 1.5)
      ]),
      atrMult: uniqueNumbers([
        round2(base.atrMult * 0.7),
        base.atrMult,
        round2(base.atrMult * 1.25),
        round2(base.atrMult * 1.6)
      ]),
      rr: uniqueNumbers([
        round2(base.rr * 0.75),
        base.rr,
        round2(base.rr * 1.2),
        round2(base.rr * 1.5)
      ]),
      cooldownBars: uniqueNumbers([0, Math.round(base.cooldownBars * 0.5), base.cooldownBars])
    };
  }
  if (key === 'MEAN_REVERSION') {
    const base = DEFAULT_MEAN_REVERSION_CONFIG;
    return {
      smaPeriod: uniqueNumbers([
        Math.max(5, Math.round(base.smaPeriod * 0.5)),
        base.smaPeriod,
        Math.round(base.smaPeriod * 1.5)
      ]),
      atrPeriod: uniqueNumbers([
        Math.max(5, Math.round(base.atrPeriod * 0.7)),
        base.atrPeriod,
        Math.round(base.atrPeriod * 1.5)
      ]),
      bandAtrMult: uniqueNumbers([
        round2(base.bandAtrMult * 0.75),
        base.bandAtrMult,
        round2(base.bandAtrMult * 1.2),
        round2(base.bandAtrMult * 1.5)
      ]),
      stopAtrMult: uniqueNumbers([
        round2(base.stopAtrMult * 0.7),
        base.stopAtrMult,
        round2(base.stopAtrMult * 1.2),
        round2(base.stopAtrMult * 1.5)
      ]),
      rr: uniqueNumbers([
        round2(base.rr * 0.7),
        base.rr,
        round2(base.rr * 1.2),
        round2(base.rr * 1.5)
      ]),
      cooldownBars: uniqueNumbers([0, Math.round(base.cooldownBars * 0.5), base.cooldownBars]),
      useRsiFilter: [false, true],
      rsiPeriod: uniqueNumbers([base.rsiPeriod]),
      rsiOversold: uniqueNumbers([
        Math.max(5, Math.round(base.rsiOversold - 5)),
        base.rsiOversold,
        Math.round(base.rsiOversold + 5)
      ]),
      rsiOverbought: uniqueNumbers([
        Math.max(55, Math.round(base.rsiOverbought - 5)),
        base.rsiOverbought,
        Math.round(base.rsiOverbought + 5)
      ])
    };
  }
  const base = DEFAULT_RANGE_BREAKOUT_CONFIG;
  return {
    lookbackBars: uniqueNumbers([
      Math.max(5, Math.round(base.lookbackBars * 0.5)),
      base.lookbackBars,
      Math.round(base.lookbackBars * 1.5),
      Math.round(base.lookbackBars * 2)
    ]),
    atrPeriod: uniqueNumbers([
      Math.max(5, Math.round(base.atrPeriod * 0.7)),
      base.atrPeriod,
      Math.round(base.atrPeriod * 1.5)
    ]),
    atrMult: uniqueNumbers([
      round2(base.atrMult * 0.7),
      base.atrMult,
      round2(base.atrMult * 1.2),
      round2(base.atrMult * 1.6)
    ]),
    rr: uniqueNumbers([
      round2(base.rr * 0.75),
      base.rr,
      round2(base.rr * 1.2),
      round2(base.rr * 1.5)
    ]),
    cooldownBars: uniqueNumbers([0, Math.round(base.cooldownBars * 0.5), base.cooldownBars]),
    breakoutMode: ['close', 'wick'],
    bufferAtrMult: uniqueNumbers([0, 0.5, 1.0])
  };
}

function normalizeExecutionPresetKey(value: any): 'lite' | 'standard' | 'strict' | null {
  const raw = String(value || '').trim().toLowerCase();
  if (raw === 'lite' || raw === 'standard' || raw === 'strict') return raw;
  return null;
}

function resolveExecutionConfig(raw: any, fallback?: any, presetKey?: string | null) {
  if (raw && typeof raw === 'object') return raw;
  const preset = normalizeExecutionPresetKey(presetKey);
  if (preset) {
    const config = EXECUTION_REALISM_PRESETS[preset]?.config;
    if (config && typeof config === 'object') {
      return { ...DEFAULT_HEADLESS_EXECUTION, ...config };
    }
  }
  if (fallback && typeof fallback === 'object') return fallback;
  return DEFAULT_HEADLESS_EXECUTION;
}

function formatExecutionSummary(execution: any, presetKey?: string | null) {
  if (!execution || typeof execution !== 'object') return 'Execution: --';
  const preset = normalizeExecutionPresetKey(presetKey);
  const label = preset ? `Execution (${EXECUTION_REALISM_PRESETS[preset].label})` : 'Execution';
  const fmtNum = (value: any, digits = 2) => {
    const num = Number(value);
    return Number.isFinite(num) ? num.toFixed(digits) : '--';
  };
  const fmtPct = (value: any) => {
    const num = Number(value);
    return Number.isFinite(num) ? `${num.toFixed(2)}%` : '--';
  };
  const formatCost = (model: any, fixed: any, pct: any, atr: any) => {
    const mode = String(model || 'none');
    if (mode === 'fixed') return `fixed ${fmtNum(fixed)}`;
    if (mode === 'percent') return `percent ${fmtPct(pct)}`;
    if (mode === 'atr') return `atr x${fmtNum(atr)}`;
    return 'none';
  };
  const spread = formatCost(execution.spreadModel, execution.spreadValue, execution.spreadPct, execution.spreadAtrMult);
  const slippage = formatCost(
    execution.slippageModel,
    execution.slippageValue,
    execution.slippagePct,
    execution.slippageAtrMult
  );
  const commission = formatCost(execution.commissionModel, execution.commissionValue, execution.commissionPct, 0);
  const vol = execution.volatilitySlippageEnabled ? 'vol slip on' : 'vol slip off';
  const partial =
    execution.partialFillMode === 'range'
      ? `partial fills range x${fmtNum(execution.partialFillAtrMult)}`
      : 'partial fills off';
  const news =
    Number.isFinite(Number(execution.newsSpikeAtrMult)) && Number(execution.newsSpikeAtrMult) > 0
      ? `news spike x${fmtNum(execution.newsSpikeAtrMult)}`
      : 'news spike off';
  return `${label}: spread ${spread} | slippage ${slippage} | commission ${commission} | ${vol} | ${partial} | ${news}`;
}

function formatValidationSummary(validation: any) {
  if (!validation || typeof validation !== 'object') return 'Validation: --';
  const mode = String(validation.mode || '').trim().toLowerCase();
  if (mode === 'walk_forward') {
    const trainDays = Number.isFinite(Number(validation.trainDays)) ? Number(validation.trainDays) : '--';
    const testDays = Number.isFinite(Number(validation.testDays)) ? Number(validation.testDays) : '--';
    const stepDays = Number.isFinite(Number(validation.stepDays)) ? Number(validation.stepDays) : '--';
    const minTrades = Number.isFinite(Number(validation.minTrades)) ? Number(validation.minTrades) : null;
    const minTradesText = minTrades != null ? ` | min trades ${minTrades}` : '';
    return `Validation: walk_forward ${trainDays}/${testDays}/${stepDays}d${minTradesText}`;
  }
  if (mode === 'last_days') {
    const lastDays = Number.isFinite(Number(validation.lastDays)) ? Number(validation.lastDays) : '--';
    return `Validation: last_days ${lastDays}d`;
  }
  if (mode === 'percent') {
    const split = Number.isFinite(Number(validation.splitPercent)) ? Number(validation.splitPercent) : '--';
    return `Validation: percent ${split}%`;
  }
  return `Validation: ${mode || '--'}`;
}

function resolveOptimizationValidation(raw: any, summary?: any) {
  if (raw && typeof raw === 'object') return raw;
  const wf = summary?.walkForwardConfig;
  if (wf?.enabled) {
    return {
      mode: 'walk_forward',
      trainDays: wf.trainDays,
      testDays: wf.testDays,
      stepDays: wf.stepDays,
      minTrades: wf.minTrades
    };
  }
  const validation = summary?.validationConfig;
  if (validation?.enabled) {
    return {
      mode: validation.mode === 'last_days' ? 'last_days' : 'percent',
      splitPercent: validation.splitPercent,
      lastDays: validation.lastDays
    };
  }
  return DEFAULT_HEADLESS_VALIDATION;
}

function normalizeSymbolLoose(value: string) {
  return normalizeSymbolLooseShared(value);
}

function buildSymbolKeyVariants(value: string) {
  return buildSymbolKeyVariantsShared(value);
}

function parseSymbolCapsRaw(raw: string | undefined | null) {
  const map = new Map<string, SymbolCap>();
  const text = String(raw || '').trim();
  if (!text) return map;

  const parseField = (value: string | undefined) => {
    if (value == null) return null;
    const trimmed = String(value).trim();
    if (!trimmed) return null;
    const num = Number(trimmed);
    return Number.isFinite(num) ? num : null;
  };

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const stripped = line.split('#')[0].trim();
    if (!stripped) continue;

    let parts = stripped.split(',').map((p) => p.trim());
    if (parts.length <= 1) {
      parts = stripped.split(/\s+/).map((p) => p.trim()).filter((p) => p.length > 0 || p === '0');
    }

    const symbol = parts[0];
    if (!symbol) continue;

    const maxLot = parseField(parts[1]);
    const maxPositions = parseField(parts[2]);
    const cap: SymbolCap = {};
    if (maxLot != null) cap.maxLot = maxLot;
    if (maxPositions != null) cap.maxPositions = maxPositions;
    if (cap.maxLot == null && cap.maxPositions == null) continue;

    for (const key of buildSymbolKeyVariants(symbol)) {
      map.set(key, cap);
    }
  }

  return map;
}

function parseSymbolAllowlistRaw(raw: string | undefined | null) {
  const set = new Set<string>();
  const text = String(raw || '').trim();
  if (!text) return set;

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const stripped = line.split('#')[0].trim();
    if (!stripped) continue;

    let parts = stripped.split(',').map((p) => p.trim()).filter(Boolean);
    if (parts.length <= 1) {
      parts = stripped.split(/\s+/).map((p) => p.trim()).filter(Boolean);
    }
    for (const symbol of parts) {
      for (const key of buildSymbolKeyVariants(symbol)) {
        set.add(key);
      }
    }
  }

  return set;
}

function parseSymbolGroupMapRaw(raw: string | undefined | null) {
  const map = new Map<string, string>();
  const text = String(raw || '').trim();
  if (!text) return map;

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const stripped = line.split('#')[0].trim();
    if (!stripped) continue;

    let group = '';
    let symbols: string[] = [];

    if (stripped.includes(':')) {
      const [left, right] = stripped.split(':');
      group = String(left || '').trim();
      symbols = String(right || '')
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean);
    } else {
      let parts = stripped.split(',').map((p) => p.trim()).filter(Boolean);
      if (parts.length <= 1) {
        parts = stripped.split(/\s+/).map((p) => p.trim()).filter(Boolean);
      }
      if (parts.length >= 2) {
        symbols = [parts[0]];
        group = parts.slice(1).join(' ');
      }
    }

    if (!group || symbols.length === 0) continue;
    const groupKey = normalizeGroupKey(group);
    if (!groupKey) continue;

    for (const symbol of symbols) {
      for (const key of buildSymbolKeyVariants(symbol)) {
        map.set(key, groupKey);
      }
    }
  }

  return map;
}

function parseGroupCapsRaw(raw: string | undefined | null) {
  const map = new Map<string, GroupCap>();
  const text = String(raw || '').trim();
  if (!text) return map;

  const parseField = (value: string | undefined) => {
    if (value == null) return null;
    const trimmed = String(value).trim();
    if (!trimmed) return null;
    const num = Number(trimmed);
    return Number.isFinite(num) ? num : null;
  };

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const stripped = line.split('#')[0].trim();
    if (!stripped) continue;

    let parts = stripped.split(',').map((p) => p.trim());
    if (parts.length <= 1) {
      parts = stripped.split(/\s+/).map((p) => p.trim()).filter((p) => p.length > 0 || p === '0');
    }

    const groupRaw = parts[0];
    if (!groupRaw) continue;
    const groupKey = normalizeGroupKey(groupRaw);
    if (!groupKey) continue;

    const maxLot = parseField(parts[1]);
    const maxPositions = parseField(parts[2]);
    const cap: GroupCap = {};
    if (maxLot != null) cap.maxLot = maxLot;
    if (maxPositions != null) cap.maxPositions = maxPositions;
    if (cap.maxLot == null && cap.maxPositions == null) continue;

    map.set(groupKey, cap);
  }

  return map;
}


function mapTradingViewIntervalToBrokerResolution(interval: string) {
  const label = formatTradingViewIntervalLabel(interval);
  const raw = String(label || '').trim();
  if (!raw) return '';
  const match = raw.match(/^(\d+)\s*([a-zA-Z]+)$/);
  if (!match) return '';
  const count = Number(match[1]);
  const unit = String(match[2] || '').trim().toUpperCase();
  if (!Number.isFinite(count) || count <= 0) return '';
  let res = '';
  if (unit.startsWith('M')) res = `${count}m`;
  else if (unit.startsWith('H')) res = `${count}H`;
  else if (unit.startsWith('D')) res = `${count}D`;
  return BROKER_RESOLUTION_MS[res] ? res : '';
}

function formatBrokerPrice(value: any) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '';
  const abs = Math.abs(num);
  const decimals = abs >= 1000 ? 2 : abs >= 1 ? 4 : 6;
  return num.toFixed(decimals).replace(/\.?0+$/, '');
}

function formatConstraintError(message: string) {
  const raw = String(message || '').trim();
  if (!raw) return 'Constraints unavailable.';
  const lower = raw.toLowerCase();
  if (lower.includes('accnum') || lower.includes('accountid') || lower.includes('account id')) {
    return 'Select a TradeLocker account to load constraints.';
  }
  if (lower.includes('developer') || lower.includes('api key')) {
    return 'Add a TradeLocker developer API key to load constraints.';
  }
  if (lower.includes('400') || lower.includes('bad request')) {
    return 'Constraints unavailable for this symbol.';
  }
  return raw;
}

function parsePriceText(raw: string) {
  const text = String(raw || '').trim();
  if (!text) return null;
  const match = text.match(/[-+]?[\d.,\s]+/);
  if (!match) return null;
  let value = match[0].replace(/\s+/g, '');
  const hasDot = value.includes('.');
  const hasComma = value.includes(',');
  if (hasDot && hasComma) {
    const lastDot = value.lastIndexOf('.');
    const lastComma = value.lastIndexOf(',');
    const decimalSep = lastDot > lastComma ? '.' : ',';
    const thousandsSep = decimalSep === '.' ? ',' : '.';
    value = value.replace(new RegExp(`\\${thousandsSep}`, 'g'), '');
    if (decimalSep === ',') value = value.replace(/,/g, '.');
  } else if (hasComma) {
    const parts = value.split(',');
    const tail = parts[parts.length - 1] || '';
    if (parts.length > 1 && tail.length === 3) {
      value = value.replace(/,/g, '');
    } else {
      value = value.replace(/,/g, '.');
    }
  }
  const num = Number(value);
  return Number.isFinite(num) ? num : null;
}

type HistoryCoverage = {
  expectedBars?: number;
  missingBars?: number;
  gapCount?: number;
  maxGapMs?: number | null;
  coveragePct?: number | null;
  firstTs?: number | null;
  lastTs?: number | null;
};

function computeHistorySummaryLine(bars: any[], resolution: string, coverage?: HistoryCoverage) {
  const list = Array.isArray(bars) ? bars.filter((b) => b && Number.isFinite(Number(b?.t))) : [];
  if (list.length === 0) return '';

  const readNum = (value: any) => {
    const n = Number(value);
    return Number.isFinite(n) ? n : null;
  };

  const closes = list
    .map((b) => readNum(b?.c ?? b?.close ?? b?.o ?? b?.open ?? b?.h ?? b?.high ?? b?.l ?? b?.low))
    .filter((n) => n != null) as number[];
  if (closes.length === 0) return '';

  const lastClose = closes[closes.length - 1];

  const sma = (window: number) => {
    if (closes.length < window) return null;
    const slice = closes.slice(-window);
    const sum = slice.reduce((acc, v) => acc + v, 0);
    return sum / slice.length;
  };

  const atr = (period: number) => {
    let prevClose: number | null = null;
    const trs: number[] = [];
    for (const bar of list) {
      const high = readNum(bar?.h ?? bar?.high ?? bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
      const low = readNum(bar?.l ?? bar?.low ?? bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
      const close = readNum(bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
      if (high == null || low == null) continue;
      const tr = prevClose == null ? (high - low) : Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
      if (Number.isFinite(tr)) trs.push(tr);
      prevClose = close != null ? close : prevClose;
    }
    if (trs.length < period) return null;
    const slice = trs.slice(-period);
    const sum = slice.reduce((acc, v) => acc + v, 0);
    return sum / slice.length;
  };

  const rsi = (period: number) => {
    if (closes.length < period + 1) return null;
    let gains = 0;
    let losses = 0;
    for (let i = closes.length - period; i < closes.length; i += 1) {
      const prev = closes[i - 1];
      const current = closes[i];
      const delta = current - prev;
      if (delta >= 0) gains += delta;
      else losses -= delta;
    }
    if (gains === 0 && losses === 0) return 50;
    if (losses === 0) return 100;
    const rs = gains / losses;
    return 100 - (100 / (1 + rs));
  };

  const rangeWindow = Math.min(50, list.length);
  const rangeBars = list.slice(-rangeWindow);
  const highs = rangeBars.map((b) => readNum(b?.h ?? b?.high ?? b?.c ?? b?.close ?? b?.o ?? b?.open)).filter((n) => n != null) as number[];
  const lows = rangeBars.map((b) => readNum(b?.l ?? b?.low ?? b?.c ?? b?.close ?? b?.o ?? b?.open)).filter((n) => n != null) as number[];
  const rangeHigh = highs.length ? Math.max(...highs) : null;
  const rangeLow = lows.length ? Math.min(...lows) : null;

  const sma20 = sma(20);
  const sma50 = sma(50);
  const atr14 = atr(14);
  const rsi14 = rsi(14);
  const atrPct =
    atr14 != null && lastClose != null && Number.isFinite(lastClose) && lastClose !== 0
      ? (atr14 / lastClose) * 100
      : null;
  let trend = '';
  if (sma20 != null && sma50 != null) {
    if (sma20 > sma50) trend = 'UP';
    else if (sma20 < sma50) trend = 'DOWN';
    else trend = 'FLAT';
  }

  const coveragePct = Number.isFinite(Number(coverage?.coveragePct)) ? Number(coverage?.coveragePct) : null;
  const gapCount = Number.isFinite(Number(coverage?.gapCount)) ? Number(coverage?.gapCount) : null;
  const missingBars = Number.isFinite(Number(coverage?.missingBars)) ? Number(coverage?.missingBars) : null;
  const coverageLabel = coveragePct != null && coveragePct < 0.98 ? `cov ${(coveragePct * 100).toFixed(0)}%` : '';
  const gapLabel = gapCount != null && gapCount > 0 ? `gaps ${gapCount}` : '';
  const missingLabel = !gapLabel && missingBars != null && missingBars > 0 ? `missing ${missingBars}` : '';

  const parts = [
    `${resolution}: close ${formatBrokerPrice(lastClose)}`,
    trend ? `Trend ${trend}` : '',
    sma20 != null ? `SMA20 ${formatBrokerPrice(sma20)}` : '',
    sma50 != null ? `SMA50 ${formatBrokerPrice(sma50)}` : '',
    atr14 != null ? `ATR14 ${formatBrokerPrice(atr14)}` : '',
    atrPct != null ? `Vol ${atrPct.toFixed(2)}%` : '',
    rsi14 != null ? `RSI14 ${rsi14.toFixed(1)}` : '',
    rangeHigh != null && rangeLow != null
      ? `range${rangeWindow} ${formatBrokerPrice(rangeLow)}-${formatBrokerPrice(rangeHigh)}`
      : '',
    coverageLabel,
    gapLabel,
    missingLabel
  ].filter(Boolean);

  return parts.length > 0 ? `- ${parts.join(' | ')}` : '';
}

function computeAtr14FromBars(bars: any[]) {
  const list = Array.isArray(bars) ? bars : [];
  if (list.length === 0) return null;

  const readNum = (value: any) => {
    const n = Number(value);
    return Number.isFinite(n) ? n : null;
  };

  let prevClose: number | null = null;
  const trs: number[] = [];
  for (const bar of list) {
    const high = readNum(bar?.h ?? bar?.high ?? bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
    const low = readNum(bar?.l ?? bar?.low ?? bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
    const close = readNum(bar?.c ?? bar?.close ?? bar?.o ?? bar?.open);
    if (high == null || low == null) continue;
    const tr = prevClose == null ? (high - low) : Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
    if (Number.isFinite(tr)) trs.push(tr);
    prevClose = close != null ? close : prevClose;
  }
  if (trs.length < 14) return null;
  const slice = trs.slice(-14);
  const sum = slice.reduce((acc, v) => acc + v, 0);
  const atr = sum / slice.length;
  return Number.isFinite(atr) ? atr : null;
}

const TRADINGVIEW_PRICE_SCRIPT = `
(() => {
  const selectors = [
    '[data-test="instrument-price"]',
    '[data-name="instrument-price"]',
    '[data-field="last"]',
    '.tv-symbol-price-quote__value',
    '.js-symbol-last',
    '.last-price-value'
  ];
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    if (!el) continue;
    const text = (el.textContent || '').trim();
    if (text) return { text, source: sel };
  }
  const alt = document.querySelector('[data-test="quote-header"] [data-test="price"]');
  if (alt) {
    const text = (alt.textContent || '').trim();
    if (text) return { text, source: '[data-test="quote-header"] [data-test="price"]' };
  }
  return null;
})()
`;

const SIDEBAR_LAZY_FALLBACK = (
  <div className="flex-1 flex items-center justify-center text-gray-400 text-sm">
    Loading
  </div>
);

const SETTINGS_LAZY_FALLBACK = (
  <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
    <div className="bg-[#111]/80 border border-white/10 rounded-xl px-4 py-3 text-gray-200 text-sm shadow-xl">
      Loading settings
    </div>
  </div>
);

const SYMBOL_SCOPE_STORAGE_KEY = 'glass_symbol_scope_v1';
const SYMBOL_SCOPE_HISTORY_KEY = 'glass_symbol_scope_history_v1';
const SYMBOL_SCOPE_LEDGER_KEY = 'symbol_scope:current';
const DEFAULT_SYMBOL_SCOPE_TIMEFRAMES: ChartTimeframe[] = ['5m', '15m', '1h', '4h'];
const SIGNAL_SETTINGS_STORAGE_KEY = 'glass_signal_panel_v1';
const DEFAULT_SIGNAL_TIMEFRAMES: ChartTimeframe[] = ['5m', '15m', '30m', '1h', '4h', '1d'];
const DEFAULT_SIGNAL_REFRESH_MS = 60_000;
const DEFAULT_SIGNAL_THRESHOLD = 60;
const DEFAULT_SIGNAL_PROBABILITY_MAX = 100;
const DEFAULT_SIGNAL_EXPIRY_MINUTES = 180;
const DEFAULT_SIGNAL_MEMORY_MODE: 'inject' | 'tool' | 'both' = 'both';
const DEFAULT_SIGNAL_MEMORY_LIMIT = 8;
const DEFAULT_SIGNAL_SHADOW_FOLLOW = false;
const SIGNAL_TELEGRAM_STATUS_OPTIONS: SignalEntryStatus[] = [
  'PROPOSED',
  'SUBMITTING',
  'PENDING',
  'EXECUTED',
  'REJECTED',
  'EXPIRED',
  'WIN',
  'LOSS',
  'FAILED'
];
const PATTERN_SETTINGS_STORAGE_KEY = 'glass_patterns_panel_v1';
const DEFAULT_PATTERN_TIMEFRAMES = ['1m', '5m', '15m', '30m', '1h', '4h', '1d'];
const DEFAULT_PATTERN_DETECTORS = [
  'swing_high',
  'swing_low',
  'ema_cross',
  'rsi_extreme',
  'atr_spike',
  'structure_break',
  'range_breakout',
  'support_resistance',
  'trend_pullback',
  'engulfing',
  'inside_bar',
  'pin_bar',
  'fvg'
];
const DEFAULT_PATTERN_REFRESH_MS = 60_000;
const DEFAULT_PATTERN_REFRESH_MODE = 'both';
const PATTERN_WATCH_LIMIT = 80;
const ACADEMY_SETTINGS_STORAGE_KEY = 'glass_academy_panel_v1';
const SNAPSHOT_PANEL_STORAGE_KEY = 'glass_snapshot_panel_v1';
const CALENDAR_BACKFILL_STORAGE_KEY = 'glass_calendar_backfill_v1';
const AGENT_SCAN_ENABLED_STORAGE_KEY = 'glass_agent_scan_enabled_v1';
const DEFAULT_ACADEMY_AUTO_APPLY = true;
const DEFAULT_ACADEMY_AUTO_EXPORT = true;
const DEFAULT_ACADEMY_LESSON_LIMIT = 8;
const SHADOW_PROFILE_KIND = 'shadow_profile';
const DEFAULT_SHADOW_START_BALANCE = 100_000;
const DEFAULT_SHADOW_RISK_PCT = 1;
const DEFAULT_SHADOW_LIVE_BROKER: 'mt5' | 'tradelocker' = 'mt5';
const DEFAULT_SHADOW_LIVE_MODE: 'fixed' | 'risk' = 'fixed';
const DEFAULT_SHADOW_LIVE_LOT_SIZE = 0.1;
const DEFAULT_SHADOW_LIVE_RISK_PCT = 1;
const DEFAULT_SHADOW_LIVE_MAX_DAILY_LOSS = 0;
const DEFAULT_SHADOW_LIVE_MAX_OPEN_POSITIONS = 0;
const DEFAULT_SHADOW_LIVE_MAX_ORDERS_PER_MIN = 0;
const DEFAULT_SHADOW_LIVE_MAX_CONSECUTIVE_LOSSES = 0;
const DEFAULT_SHADOW_LIVE_SYMBOL_ALLOWLIST = '';
const DEFAULT_SHADOW_LIVE_ENTRY_TOLERANCE_PCT = 0.15;
const LIVE_PENDING_EXECUTE_LIMIT = 6;
const LIVE_PENDING_EXECUTE_THROTTLE_MS = 8_000;
const LIVE_STOP_SYNC_MIN_SHIFT_PCT = 0.02;
const SIGNAL_PANEL_PRIMARY = true;
const CHART_DATA_ACTIONS = new Set(['chart.snapshot', 'chart.capture_snapshot', 'chart.capture_all']);
const BROKER_WRITE_ACTIONS = new Set([
  'trade.execute',
  'broker.action.execute',
  'tradelocker.place_order',
  'tradelocker.cancel_all_orders',
  'tradelocker.close_all_positions'
]);

const normalizeScopeTimeframes = (raw?: string[] | null) => {
  const list = Array.isArray(raw) ? raw : [];
  const out: ChartTimeframe[] = [];
  const seen = new Set<string>();
  for (const entry of list) {
    const key = String(entry || '').trim().toLowerCase();
    if (!key) continue;
    const normalized =
      key === '1w'
        ? '1w'
        : key === '1d'
          ? '1d'
          : key === '4h'
            ? '4h'
            : key === '1h'
              ? '1h'
              : key === '30m'
                ? '30m'
                : key === '15m'
                  ? '15m'
                  : key === '5m'
                    ? '5m'
                    : key === '1m'
                      ? '1m'
                      : '';
    if (!normalized || seen.has(normalized)) continue;
    seen.add(normalized);
    out.push(normalized as ChartTimeframe);
  }
  return out.length > 0 ? out : [...DEFAULT_SYMBOL_SCOPE_TIMEFRAMES];
};

const normalizePatternTimeframes = (raw?: string[] | null) => {
  const list = Array.isArray(raw) ? raw : [];
  const out: string[] = [];
  const seen = new Set<string>();
  const allowed = new Set(DEFAULT_PATTERN_TIMEFRAMES.map((tf) => tf.toLowerCase()));
  for (const entry of list) {
    const key = String(entry || '').trim().toLowerCase();
    if (!key || !allowed.has(key) || seen.has(key)) continue;
    seen.add(key);
    out.push(key);
  }
  return out.length > 0 ? out : [...DEFAULT_PATTERN_TIMEFRAMES];
};

const DEFAULT_SIGNAL_SESSIONS: SignalSessionWindow[] = [
  { id: 'asia', label: 'Asia', startHour: 0, endHour: 7, enabled: true },
  { id: 'london', label: 'London', startHour: 7, endHour: 13, enabled: true },
  { id: 'ny', label: 'NY', startHour: 13, endHour: 21, enabled: true },
  { id: 'custom', label: 'Custom', startHour: 0, endHour: 0, enabled: false }
];

const normalizeSignalSessions = (raw?: SignalSessionWindow[] | null) => {
  const defaults = DEFAULT_SIGNAL_SESSIONS.map((s) => ({ ...s }));
  const input = Array.isArray(raw) ? raw : [];
  const byId = new Map(input.map((s) => [s?.id, s]));
  return defaults.map((session) => {
    const override = byId.get(session.id);
    if (!override) return session;
    const startHour = Number.isFinite(Number(override.startHour))
      ? Math.max(0, Math.min(23, Math.floor(Number(override.startHour))))
      : session.startHour;
    const endHour = Number.isFinite(Number(override.endHour))
      ? Math.max(0, Math.min(23, Math.floor(Number(override.endHour))))
      : session.endHour;
    return {
      ...session,
      enabled: typeof override.enabled === 'boolean' ? override.enabled : session.enabled,
      startHour,
      endHour
    };
  });
};

const parseSymbolScope = (input: any): SymbolScope | null => {
  if (!input || typeof input !== 'object') return null;
  const symbol = String(input.symbol || '').trim();
  if (!symbol) return null;
  const timeframes = normalizeScopeTimeframes(input.timeframes);
  const updatedAtMs = Number(input.updatedAtMs) || Date.now();
  const source = input.source != null ? String(input.source) : null;
  return { symbol, timeframes, updatedAtMs, source };
};

const loadSymbolScope = (): SymbolScope | null => {
  try {
    const raw = localStorage.getItem(SYMBOL_SCOPE_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return parseSymbolScope(parsed);
  } catch {
    return null;
  }
};

type SignalSettings = {
  symbol?: string | null;
  symbols?: string[];
  timeframes: ChartTimeframe[];
  sessions: SignalSessionWindow[];
  strategyModes: SignalStrategyMode[];
  autoRefreshEnabled: boolean;
  refreshIntervalMs: number;
  probabilityThreshold: number;
  probabilityMax: number;
  expiryMinutes: number;
  autoExecuteEnabled: boolean;
  executionTarget?: SignalExecutionTarget;
  shadowFollowEnabled?: boolean;
  memoryMode?: 'inject' | 'tool' | 'both';
  memoryLimit?: number;
  includePatterns?: boolean;
  telegram?: SignalTelegramConfig;
  snapshotWarmupBarsDefault?: number;
  snapshotWarmupBars1d?: number;
  snapshotWarmupBars1w?: number;
  snapshotWarmupTimeoutMs?: number;
};

const normalizeSignalSymbolEntry = (value: any) => {
  const raw = String(value ?? '').trim();
  if (!raw) return '';
  return raw.toUpperCase();
};

const normalizeSignalSymbols = (input: any) => {
  const list = Array.isArray(input) ? input : [];
  const seen = new Set<string>();
  const out: string[] = [];
  for (const entry of list) {
    const cleaned = normalizeSignalSymbolEntry(entry);
    if (!cleaned) continue;
    if (seen.has(cleaned)) continue;
    seen.add(cleaned);
    out.push(cleaned);
  }
  return out;
};

type SignalTelegramConfig = {
  enabled: boolean;
  botToken: string;
  chatId: string;
  sendOn: SignalEntryStatus[];
  commandsEnabled?: boolean;
  commandMode?: 'read' | 'manage';
  commandPassphrase?: string;
  allowChart?: boolean;
  allowStatus?: boolean;
  allowManage?: boolean;
  alertsEnabled?: boolean;
  alertTrades?: boolean;
  alertTpSl?: boolean;
  alertDrawdown?: boolean;
  alertAgentConfidence?: boolean;
  alertConfidenceDrop?: number;
  alertDrawdownPct?: number;
  inlineActionsEnabled?: boolean;
  confirmationsEnabled?: boolean;
  confirmationTimeoutSec?: number;
  digestDailyEnabled?: boolean;
  digestWeeklyEnabled?: boolean;
  digestHourLocal?: number;
  digestWeeklyDay?: number;
};

type TelegramQtySpec = { mode: 'fraction' | 'absolute'; value: number };

type TelegramPendingAction = {
  id: string;
  kind: 'signal_execute' | 'signal_reject' | 'signal_cancel' | 'manage_positions';
  createdAtMs: number;
  expiresAtMs: number;
  chatId: string;
  summary: string;
  payload: {
    entryId?: string;
    forceBroker?: BrokerId | null;
    broker?: 'mt5' | 'tradelocker';
    requestedSymbol?: string | null;
    isBreakeven?: boolean;
    qtySpec?: TelegramQtySpec | null;
    accountHint?: string | null;
  };
};

type PatternSymbolMode = 'auto' | 'scope' | 'active' | 'custom';
type PatternRefreshMode = 'interval' | 'bar' | 'both';

type PatternSettings = {
  symbols: string[];
  symbolMode: PatternSymbolMode;
  timeframes: string[];
  detectors: string[];
  autoRefreshEnabled: boolean;
  refreshIntervalMs: number;
  refreshMode: PatternRefreshMode;
};

const DEFAULT_SIGNAL_TELEGRAM_CONFIG: SignalTelegramConfig = {
  enabled: false,
  botToken: '',
  chatId: '-1003398000423',
  sendOn: ['PROPOSED'],
  commandsEnabled: false,
  commandMode: 'read',
  commandPassphrase: '',
  allowChart: true,
  allowStatus: true,
  allowManage: false,
  alertsEnabled: true,
  alertTrades: true,
  alertTpSl: true,
  alertDrawdown: true,
  alertAgentConfidence: true,
  alertConfidenceDrop: 15,
  alertDrawdownPct: 80,
  inlineActionsEnabled: true,
  confirmationsEnabled: true,
  confirmationTimeoutSec: 45,
  digestDailyEnabled: false,
  digestWeeklyEnabled: false,
  digestHourLocal: 9,
  digestWeeklyDay: 1
};
const SIGNAL_TELEGRAM_STATUS_SET = new Set(SIGNAL_TELEGRAM_STATUS_OPTIONS);

const normalizeSignalSettings = (raw: any): SignalSettings => {
  const timeframes = normalizeScopeTimeframes(raw?.timeframes || DEFAULT_SIGNAL_TIMEFRAMES);
  const sessions = normalizeSignalSessions(raw?.sessions || null);
  const strategyModesRaw = Array.isArray(raw?.strategyModes) ? raw.strategyModes : [];
  const strategyModes: SignalStrategyMode[] = strategyModesRaw
    .map((mode: any) => String(mode || '').trim().toLowerCase())
    .filter((mode: string) => mode === 'scalp' || mode === 'day' || mode === 'swing') as SignalStrategyMode[];
  const symbols = normalizeSignalSymbols(raw?.symbols);
  const legacySymbol = raw?.symbol != null ? String(raw.symbol || '').trim() : '';
  const legacyNormalized = normalizeSignalSymbolEntry(legacySymbol);
  if (symbols.length === 0 && legacyNormalized) symbols.push(legacyNormalized);
  const symbol = symbols[0] || legacyNormalized || '';
  const refreshIntervalMs = Number.isFinite(Number(raw?.refreshIntervalMs))
    ? Math.max(5_000, Math.min(600_000, Math.floor(Number(raw.refreshIntervalMs))))
    : DEFAULT_SIGNAL_REFRESH_MS;
  const probabilityThreshold = Number.isFinite(Number(raw?.probabilityThreshold))
    ? Math.max(1, Math.min(100, Math.floor(Number(raw.probabilityThreshold))))
    : DEFAULT_SIGNAL_THRESHOLD;
  const probabilityMaxRaw = Number.isFinite(Number(raw?.probabilityMax))
    ? Math.max(1, Math.min(100, Math.floor(Number(raw.probabilityMax))))
    : DEFAULT_SIGNAL_PROBABILITY_MAX;
  const probabilityMax = Math.max(probabilityThreshold, probabilityMaxRaw);
  const expiryMinutes = Number.isFinite(Number(raw?.expiryMinutes))
    ? Math.max(5, Math.min(1440, Math.floor(Number(raw.expiryMinutes))))
    : DEFAULT_SIGNAL_EXPIRY_MINUTES;
  const autoRefreshEnabled = raw?.autoRefreshEnabled == null ? true : !!raw.autoRefreshEnabled;
  const autoExecuteEnabled = raw?.autoExecuteEnabled == null ? true : !!raw.autoExecuteEnabled;
  const shadowFollowEnabled = raw?.shadowFollowEnabled == null ? DEFAULT_SIGNAL_SHADOW_FOLLOW : !!raw.shadowFollowEnabled;
  const executionTargetRaw = String(raw?.executionTarget || '').trim().toLowerCase();
  const executionTarget: SignalExecutionTarget =
    executionTargetRaw === 'mt5' || executionTargetRaw === 'tradelocker' || executionTargetRaw === 'auto'
      ? (executionTargetRaw as SignalExecutionTarget)
      : 'auto';
  const memoryModeRaw = String(raw?.memoryMode || '').trim().toLowerCase();
  const memoryMode =
    memoryModeRaw === 'inject' || memoryModeRaw === 'tool' || memoryModeRaw === 'both'
      ? (memoryModeRaw as SignalSettings['memoryMode'])
      : DEFAULT_SIGNAL_MEMORY_MODE;
  const memoryLimit = Number.isFinite(Number(raw?.memoryLimit))
    ? Math.max(2, Math.min(50, Math.floor(Number(raw.memoryLimit))))
    : DEFAULT_SIGNAL_MEMORY_LIMIT;
  const includePatterns = raw?.includePatterns == null ? true : !!raw.includePatterns;
  const snapshotWarmupBarsDefault = Number.isFinite(Number(raw?.snapshotWarmupBarsDefault))
    ? Math.max(1, Math.min(1000, Math.floor(Number(raw.snapshotWarmupBarsDefault))))
    : SIGNAL_SNAPSHOT_WARMUP_BARS_DEFAULT;
  const snapshotWarmupBars1d = Number.isFinite(Number(raw?.snapshotWarmupBars1d))
    ? Math.max(1, Math.min(400, Math.floor(Number(raw.snapshotWarmupBars1d))))
    : SIGNAL_SNAPSHOT_WARMUP_BARS_1D;
  const snapshotWarmupBars1w = Number.isFinite(Number(raw?.snapshotWarmupBars1w))
    ? Math.max(1, Math.min(100, Math.floor(Number(raw.snapshotWarmupBars1w))))
    : SIGNAL_SNAPSHOT_WARMUP_BARS_1W;
  const snapshotWarmupTimeoutMs = Number.isFinite(Number(raw?.snapshotWarmupTimeoutMs))
    ? Math.max(10_000, Math.min(180_000, Math.floor(Number(raw.snapshotWarmupTimeoutMs))))
    : SIGNAL_SNAPSHOT_WARMUP_TIMEOUT_MS;
  const telegramRaw = raw?.telegram && typeof raw.telegram === 'object' ? raw.telegram : {};
  const sendOnRaw = Array.isArray(telegramRaw?.sendOn) ? telegramRaw.sendOn : null;
  const sendOnNormalized = sendOnRaw
    ? sendOnRaw
        .map((entry: any) => String(entry || '').trim().toUpperCase())
        .filter((entry: string) => SIGNAL_TELEGRAM_STATUS_SET.has(entry)) as SignalEntryStatus[]
    : [];
  const commandsEnabledRaw = telegramRaw?.commandsEnabled ?? telegramRaw?.commandEnabled;
  const commandModeRaw = String(telegramRaw?.commandMode || '').trim().toLowerCase();
  const commandMode = commandModeRaw === 'manage' ? 'manage' : 'read';
  const commandPassphrase =
    telegramRaw?.commandPassphrase != null ? String(telegramRaw.commandPassphrase).trim() : '';
  const allowChart = telegramRaw?.allowChart == null ? true : !!telegramRaw.allowChart;
  const allowStatus = telegramRaw?.allowStatus == null ? true : !!telegramRaw.allowStatus;
  const allowManage = telegramRaw?.allowManage === true;
  const alertsEnabled = telegramRaw?.alertsEnabled === true;
  const alertTrades = telegramRaw?.alertTrades == null ? true : !!telegramRaw.alertTrades;
  const alertTpSl = telegramRaw?.alertTpSl == null ? true : !!telegramRaw.alertTpSl;
  const alertDrawdown = telegramRaw?.alertDrawdown == null ? true : !!telegramRaw.alertDrawdown;
  const alertAgentConfidence = telegramRaw?.alertAgentConfidence == null ? true : !!telegramRaw.alertAgentConfidence;
  const alertConfidenceDropRaw = Number(telegramRaw?.alertConfidenceDrop);
  const alertConfidenceDrop = Number.isFinite(alertConfidenceDropRaw)
    ? Math.max(1, Math.min(100, Math.round(alertConfidenceDropRaw)))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.alertConfidenceDrop ?? 15;
  const alertDrawdownPctRaw = Number(telegramRaw?.alertDrawdownPct);
  const alertDrawdownPct = Number.isFinite(alertDrawdownPctRaw)
    ? Math.max(1, Math.min(100, Math.round(alertDrawdownPctRaw)))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.alertDrawdownPct ?? 80;
  const inlineActionsEnabled = telegramRaw?.inlineActionsEnabled == null ? true : !!telegramRaw.inlineActionsEnabled;
  const confirmationsEnabled = telegramRaw?.confirmationsEnabled == null ? true : !!telegramRaw.confirmationsEnabled;
  const confirmationTimeoutRaw = Number(telegramRaw?.confirmationTimeoutSec);
  const confirmationTimeoutSec = Number.isFinite(confirmationTimeoutRaw)
    ? Math.max(10, Math.min(600, Math.floor(confirmationTimeoutRaw)))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.confirmationTimeoutSec ?? 45;
  const digestDailyEnabled = telegramRaw?.digestDailyEnabled === true;
  const digestWeeklyEnabled = telegramRaw?.digestWeeklyEnabled === true;
  const digestHourRaw = Number(telegramRaw?.digestHourLocal);
  const digestHourLocal = Number.isFinite(digestHourRaw)
    ? Math.max(0, Math.min(23, Math.floor(digestHourRaw)))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.digestHourLocal ?? 9;
  const digestWeeklyDayRaw = Number(telegramRaw?.digestWeeklyDay);
  const digestWeeklyDay = Number.isFinite(digestWeeklyDayRaw)
    ? Math.max(0, Math.min(6, Math.floor(digestWeeklyDayRaw)))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.digestWeeklyDay ?? 1;
  const hasTelegram = raw?.telegram && typeof raw.telegram === 'object';
  const hasTelegramBotToken = hasTelegram && Object.prototype.hasOwnProperty.call(telegramRaw, 'botToken');
  const hasTelegramChatId = hasTelegram && Object.prototype.hasOwnProperty.call(telegramRaw, 'chatId');
  const telegram: SignalTelegramConfig = {
    enabled: telegramRaw?.enabled === true,
    botToken: hasTelegramBotToken
      ? String(telegramRaw.botToken ?? '').trim()
      : DEFAULT_SIGNAL_TELEGRAM_CONFIG.botToken,
    chatId: hasTelegramChatId
      ? String(telegramRaw.chatId ?? '').trim()
      : DEFAULT_SIGNAL_TELEGRAM_CONFIG.chatId,
    sendOn: sendOnRaw ? sendOnNormalized : DEFAULT_SIGNAL_TELEGRAM_CONFIG.sendOn,
    commandsEnabled: commandsEnabledRaw === true,
    commandMode,
    commandPassphrase,
    allowChart,
    allowStatus,
    allowManage,
    alertsEnabled,
    alertTrades,
    alertTpSl,
    alertDrawdown,
    alertAgentConfidence,
    alertConfidenceDrop,
    alertDrawdownPct,
    inlineActionsEnabled,
    confirmationsEnabled,
    confirmationTimeoutSec,
    digestDailyEnabled,
    digestWeeklyEnabled,
    digestHourLocal,
    digestWeeklyDay
  };
  return {
    symbol: symbol || null,
    symbols,
    timeframes,
    sessions,
    strategyModes: strategyModes.length > 0 ? strategyModes : ['scalp', 'day', 'swing'],
    autoRefreshEnabled,
    refreshIntervalMs,
    probabilityThreshold,
    probabilityMax,
    expiryMinutes,
    autoExecuteEnabled,
    executionTarget,
    shadowFollowEnabled,
    memoryMode,
    memoryLimit,
    includePatterns,
    snapshotWarmupBarsDefault,
    snapshotWarmupBars1d,
    snapshotWarmupBars1w,
    snapshotWarmupTimeoutMs,
    telegram
  };
};

const normalizePatternSettings = (raw: any): PatternSettings => {
  const symbolsRaw = Array.isArray(raw?.symbols) ? raw.symbols : [];
  const symbols: string[] = [];
  const seenSymbols = new Set<string>();
  for (const entry of symbolsRaw) {
    const cleaned = String(entry || '').trim().toUpperCase();
    if (!cleaned || seenSymbols.has(cleaned)) continue;
    seenSymbols.add(cleaned);
    symbols.push(cleaned);
  }
  const modeRaw = String(raw?.symbolMode || '').trim().toLowerCase();
  const symbolMode: PatternSymbolMode =
    modeRaw === 'scope' || modeRaw === 'active' || modeRaw === 'custom' || modeRaw === 'auto'
      ? (modeRaw as PatternSymbolMode)
      : 'auto';
  const timeframes = normalizePatternTimeframes(raw?.timeframes || DEFAULT_PATTERN_TIMEFRAMES);
  const detectorsRaw = Array.isArray(raw?.detectors) ? raw.detectors : DEFAULT_PATTERN_DETECTORS;
  const detectors: string[] = [];
  const seenDetectors = new Set<string>();
  for (const entry of detectorsRaw) {
    const cleaned = String(entry || '').trim();
    if (!cleaned || seenDetectors.has(cleaned)) continue;
    seenDetectors.add(cleaned);
    detectors.push(cleaned);
  }
  const autoRefreshEnabled = raw?.autoRefreshEnabled == null ? true : !!raw.autoRefreshEnabled;
  const refreshIntervalMs = Number.isFinite(Number(raw?.refreshIntervalMs))
    ? Math.max(10_000, Math.min(600_000, Math.floor(Number(raw.refreshIntervalMs))))
    : DEFAULT_PATTERN_REFRESH_MS;
  const refreshModeRaw = String(raw?.refreshMode || '').trim().toLowerCase();
  const refreshMode: PatternRefreshMode =
    refreshModeRaw === 'interval' || refreshModeRaw === 'bar' || refreshModeRaw === 'both'
      ? (refreshModeRaw as PatternRefreshMode)
      : (DEFAULT_PATTERN_REFRESH_MODE as PatternRefreshMode);
  return {
    symbols,
    symbolMode,
    timeframes,
    detectors: detectors.length > 0 ? detectors : [...DEFAULT_PATTERN_DETECTORS],
    autoRefreshEnabled,
    refreshIntervalMs,
    refreshMode
  };
};

const loadSignalSettings = (): SignalSettings => {
  try {
    const raw = localStorage.getItem(SIGNAL_SETTINGS_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : null;
    return normalizeSignalSettings(parsed);
  } catch {
    return normalizeSignalSettings(null);
  }
};

const loadPatternSettings = (): PatternSettings => {
  try {
    const raw = localStorage.getItem(PATTERN_SETTINGS_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : null;
    return normalizePatternSettings(parsed);
  } catch {
    return normalizePatternSettings(null);
  }
};

type AcademySettings = {
  autoApplyEnabled: boolean;
  autoExportEnabled: boolean;
  lessonLimit: number;
};

type SnapshotPanelState = {
  symbol: string;
  applyToSignals: boolean;
};

type AgentScorecardSnapshot = {
  agentId: string | null;
  agentName: string | null;
  trades: number;
  wins: number;
  losses: number;
  winRate: number;
  totalScore: number;
  avgScore: number;
  avgHoldMs: number | null;
  avgBars: number | null;
  updatedAtMs: number | null;
};

const normalizeAcademySettings = (raw: any): AcademySettings => {
  const input = raw && typeof raw === 'object' ? raw : {};
  const autoApplyEnabled = input.autoApplyEnabled == null ? DEFAULT_ACADEMY_AUTO_APPLY : !!input.autoApplyEnabled;
  const autoExportEnabled = input.autoExportEnabled == null ? DEFAULT_ACADEMY_AUTO_EXPORT : !!input.autoExportEnabled;
  const lessonLimit = Number.isFinite(Number(input.lessonLimit))
    ? Math.max(3, Math.min(30, Math.floor(Number(input.lessonLimit))))
    : DEFAULT_ACADEMY_LESSON_LIMIT;
  return { autoApplyEnabled, autoExportEnabled, lessonLimit };
};

const loadAcademySettings = (): AcademySettings => {
  try {
    const raw = localStorage.getItem(ACADEMY_SETTINGS_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : null;
    return normalizeAcademySettings(parsed);
  } catch {
    return normalizeAcademySettings(null);
  }
};

const normalizeSnapshotPanelState = (raw: any): SnapshotPanelState => {
  const input = raw && typeof raw === 'object' ? raw : {};
  const symbol = input.symbol != null ? String(input.symbol || '').trim() : '';
  const applyToSignals = input.applyToSignals == null ? true : !!input.applyToSignals;
  return { symbol, applyToSignals };
};

const loadSnapshotPanelState = (): SnapshotPanelState => {
  try {
    const raw = localStorage.getItem(SNAPSHOT_PANEL_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : null;
    return normalizeSnapshotPanelState(parsed);
  } catch {
    return normalizeSnapshotPanelState(null);
  }
};

const App: React.FC = () => {
  const { activeTab, activeTabId, navigate, refresh, tabs, setActiveTabId, toggleTabWatch, addTab, closeTab, updateTab } = useTabs('https://en.wikipedia.org/wiki/Artificial_intelligence');
  const chartSessions = useChartSessions();
  const [nativeChartSymbol, setNativeChartSymbol] = useState('');
  const [nativeChartMounted, setNativeChartMounted] = useState(false);
  const [backtestSymbol, setBacktestSymbol] = useState('');
  const [backtesterMounted, setBacktesterMounted] = useState(false);
  const [setupsMounted, setSetupsMounted] = useState(false);
  const [agentCreatorMounted, setAgentCreatorMounted] = useState(false);
  const [agentMemoryMounted, setAgentMemoryMounted] = useState(false);
  const [agentLabMounted, setAgentLabMounted] = useState(false);
  const [academyMounted, setAcademyMounted] = useState(false);
  const [auditMounted, setAuditMounted] = useState(false);
  const [changesMounted, setChangesMounted] = useState(false);
  const [agentScanEnabledById, setAgentScanEnabledById] = useState<Record<string, boolean>>(() => {
    try {
      const parsed = JSON.parse(localStorage.getItem(AGENT_SCAN_ENABLED_STORAGE_KEY) || '{}');
      if (!parsed || typeof parsed !== 'object') return {};
      const next: Record<string, boolean> = {};
      for (const [key, value] of Object.entries(parsed)) {
        const id = String(key || '').trim();
        if (!id) continue;
        next[id] = value !== false;
      }
      return next;
    } catch {
      return {};
    }
  });
  useEffect(() => {
    try {
      localStorage.setItem(AGENT_SCAN_ENABLED_STORAGE_KEY, JSON.stringify(agentScanEnabledById || {}));
    } catch {
      // ignore storage failures
    }
  }, [agentScanEnabledById]);
  const [actionTaskQueueDepth, setActionTaskQueueDepth] = useState(0);
  const [chartChatSnapshotStatus, setChartChatSnapshotStatus] = useState<ChartChatSnapshotStatus | null>(null);
  const actionTaskActiveStepRef = React.useRef<{
    runId?: string | null;
    actionId?: string | null;
    maxRetries?: number | null;
    retryDelayMs?: number | null;
    timeoutMs?: number | null;
  } | null>(null);
  const [symbolScope, setSymbolScope] = useState<SymbolScope | null>(() => loadSymbolScope());
  const symbolScopeSymbol = String(symbolScope?.symbol || '').trim();
  const symbolScopeTimeframes = symbolScope?.timeframes && symbolScope.timeframes.length > 0
    ? symbolScope.timeframes
    : DEFAULT_SYMBOL_SCOPE_TIMEFRAMES;
  const [signalSettings, setSignalSettings] = useState<SignalSettings>(() => loadSignalSettings());
  const [patternSettings, setPatternSettings] = useState<PatternSettings>(() => loadPatternSettings());
  const [academySettings, setAcademySettings] = useState<AcademySettings>(() => loadAcademySettings());
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [signalSnapshotStatus, setSignalSnapshotStatus] = useState<SignalSnapshotStatus | null>(null);
  const [snapshotPanelSymbol, setSnapshotPanelSymbol] = useState(() => loadSnapshotPanelState().symbol);
  const [snapshotPanelApplyToSignals, setSnapshotPanelApplyToSignals] = useState(() => loadSnapshotPanelState().applyToSignals);
  const [snapshotPanelStatus, setSnapshotPanelStatus] = useState<SignalSnapshotStatus | null>(null);
  const snapshotPanelApplyRef = React.useRef(snapshotPanelApplyToSignals);
  const snapshotPanelLastSymbolRef = React.useRef(snapshotPanelSymbol);
  const snapshotStartupPrewarmRef = React.useRef<{ key: string; atMs: number } | null>(null);
  const [signalWarmupInFlight, setSignalWarmupInFlight] = useState(false);
  const signalWarmupHoldRef = React.useRef(0);
  const beginSignalWarmup = useCallback(() => {
    signalWarmupHoldRef.current += 1;
    if (signalWarmupHoldRef.current === 1) {
      setSignalWarmupInFlight(true);
    }
  }, [normalizeTimeframeKey, resolutionToMs]);
  const endSignalWarmup = useCallback(() => {
    signalWarmupHoldRef.current = Math.max(0, signalWarmupHoldRef.current - 1);
    if (signalWarmupHoldRef.current === 0) {
      setSignalWarmupInFlight(false);
    }
  }, [resolutionToMs]);
  const [signalEntries, setSignalEntries] = useState<SignalEntry[]>([]);
  const [patternEvents, setPatternEvents] = useState<PatternEvent[]>([]);
  const [patternWatchSummary, setPatternWatchSummary] = useState<{ watchCount: number; truncated: number }>({
    watchCount: 0,
    truncated: 0
  });
  const [signalHistory, setSignalHistory] = useState<SignalHistoryEntry[]>([]);
  const [crossPanelContext, setCrossPanelContext] = useState<CrossPanelContext | null>(() =>
    crossPanelContextEngine.getContext()
  );
  const [outcomeFeedCursor, setOutcomeFeedCursor] = useState<OutcomeFeedCursor>(() =>
    outcomeConsistencyEngine.getCursor()
  );
  const [outcomeFeedConsistency, setOutcomeFeedConsistency] = useState<OutcomeFeedConsistencyState>(() =>
    outcomeConsistencyEngine.getConsistencyState()
  );
  const [panelFreshness, setPanelFreshness] = useState<PanelFreshnessState[]>(() =>
    outcomeConsistencyEngine.getPanelFreshness()
  );
  const [agentScorecards, setAgentScorecards] = useState<AgentScorecardSnapshot[]>([]);
  const [leaderboardFilter, setLeaderboardFilter] = useState(() => loadLeaderboardFilter());
  const [signalSimulatedOutcomes, setSignalSimulatedOutcomes] = useState<Record<string, {
    outcome: 'WIN' | 'LOSS' | 'EXPIRED';
    resolvedAtMs: number;
    exitPrice?: number | null;
    timeframe?: string;
    barsToOutcome?: number | null;
    durationMs?: number | null;
  }>>({});
  const [shadowProfiles, setShadowProfiles] = useState<ShadowProfile[]>([]);
  const [shadowAccounts, setShadowAccounts] = useState<ShadowAccountSnapshot[]>([]);
  const [shadowTradeViews, setShadowTradeViews] = useState<ShadowTradeView[]>([]);
  const [mt5AccountSpec, setMt5AccountSpec] = useState<BrokerAccountSpec | null>(null);
  const [mt5PositionsCount, setMt5PositionsCount] = useState<number | null>(null);
  const [mt5OrdersCount, setMt5OrdersCount] = useState<number | null>(null);
  const [mt5PositionsUpdatedAtMs, setMt5PositionsUpdatedAtMs] = useState<number | null>(null);
  const [mt5OrdersUpdatedAtMs, setMt5OrdersUpdatedAtMs] = useState<number | null>(null);
  const [mt5SnapshotError, setMt5SnapshotError] = useState<string | null>(null);
  const [academyCases, setAcademyCases] = useState<AcademyCase[]>([]);
  const [academyLessons, setAcademyLessons] = useState<AcademyLesson[]>([]);
  const [academyLessonsUpdatedAtMs, setAcademyLessonsUpdatedAtMs] = useState<number | null>(null);
  const [academySymbolLearnings, setAcademySymbolLearnings] = useState<AcademySymbolLearning[]>([]);
  const [academySymbolLearningsUpdatedAtMs, setAcademySymbolLearningsUpdatedAtMs] = useState<number | null>(null);
  const [academySelectedCaseId, setAcademySelectedCaseId] = useState<string | null>(null);
  const [calendarRules, setCalendarRules] = useState<CalendarRule[]>([]);
  const [calendarRulesUpdatedAtMs, setCalendarRulesUpdatedAtMs] = useState<number | null>(null);
  const [signalRunning, setSignalRunning] = useState(false);
  const [signalLastRunAtMs, setSignalLastRunAtMs] = useState<number | null>(null);
  const [signalLastAttemptAtMs, setSignalLastAttemptAtMs] = useState<number | null>(null);
  const [signalLastError, setSignalLastError] = useState<string | null>(null);
  const [signalLastParseError, setSignalLastParseError] = useState<string | null>(null);
  const [signalLastParseAtMs, setSignalLastParseAtMs] = useState<number | null>(null);
  useEffect(() => {
    persistLeaderboardFilter(leaderboardFilter);
  }, [leaderboardFilter]);

  useEffect(() => {
    const unsubscribe = crossPanelContextEngine.subscribe((next) => {
      setCrossPanelContext(next);
    });
    setCrossPanelContext(crossPanelContextEngine.getContext());
    return () => {
      unsubscribe();
    };
  }, []);

  useEffect(() => {
    const snapshot = outcomeConsistencyEngine.ingestSignalHistory(signalHistory);
    setOutcomeFeedCursor(snapshot.cursor);
    setOutcomeFeedConsistency(snapshot.consistency);
    setPanelFreshness(snapshot.panelFreshness);
  }, [signalHistory]);

  useEffect(() => {
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadOutcomeFeedRefreshControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createOutcomeFeedRefreshController({
        intervalMs: 15_000,
        tick: () => {
          setOutcomeFeedConsistency(outcomeConsistencyEngine.getConsistencyState());
          setPanelFreshness(outcomeConsistencyEngine.getPanelFreshness());
        }
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, []);

  const leaderboardHistory = React.useMemo(() => {
    const list = Array.isArray(signalHistory) ? signalHistory : [];
    const resolvedOnly = list.filter((entry) => {
      if (entry?.resolvedOutcomeEnvelope) return true;
      const outcome = String(entry?.outcome || '').toUpperCase();
      return outcome === 'WIN' || outcome === 'LOSS' || outcome === 'EXPIRED' || outcome === 'REJECTED' || outcome === 'FAILED';
    });
    const filter = String(leaderboardFilter || 'all').toLowerCase();
    if (!filter || filter === 'all') return resolvedOnly;
    return resolvedOnly.filter((entry) => {
      const broker = String(entry.executionBroker || '').toLowerCase();
      const mode = String(entry.executionMode || '').toLowerCase();
      if (filter === 'shadow') return broker === 'shadow' || mode === 'shadow';
      if (filter === 'live') return mode === 'live';
      if (filter === 'paper') return mode === 'paper';
      if (filter === 'sim') return broker === 'sim' || mode === 'simulated';
      if (filter === 'suggest') return mode === 'suggest';
      return true;
    });
  }, [leaderboardFilter, signalHistory]);

  const agentsRef = React.useRef<Agent[]>([]);
  const agentPerformanceById = React.useMemo(() => {
    const stats = new Map<string, {
      agentId: string;
      agentName: string;
      trades: number;
      wins: number;
      losses: number;
      winRate: number;
      totalScore: number;
      avgScore: number;
      avgHoldMs: number | null;
      avgBars: number | null;
      durationTotal: number;
      durationCount: number;
      barsTotal: number;
      barsCount: number;
    }>();
    const list = Array.isArray(signalHistory) ? signalHistory : [];
    const completed = list.filter((entry) => entry.outcome === 'WIN' || entry.outcome === 'LOSS');
    for (const entry of completed) {
      const agentId = String(entry.agentId || '').trim();
      const agentName = String(entry.agentName || '').trim();
      if (!agentId && !agentName) continue;
      const key = agentId || `name:${agentName}`;
      const existing = stats.get(key) || {
        agentId: agentId || key,
        agentName: agentName || agentId || key,
        trades: 0,
        wins: 0,
        losses: 0,
        winRate: 0,
        totalScore: 0,
        avgScore: 0,
        avgHoldMs: null,
        avgBars: null,
        durationTotal: 0,
        durationCount: 0,
        barsTotal: 0,
        barsCount: 0
      };
      existing.trades += 1;
      if (entry.outcome === 'WIN') existing.wins += 1;
      if (entry.outcome === 'LOSS') existing.losses += 1;
      if (Number.isFinite(Number(entry.score))) {
        existing.totalScore += Number(entry.score);
      }
      const duration = Number(entry.durationMs);
      if (Number.isFinite(duration) && duration > 0) {
        existing.durationTotal += duration;
        existing.durationCount += 1;
      }
      const bars = Number(entry.barsToOutcome);
      if (Number.isFinite(bars) && bars > 0) {
        existing.barsTotal += bars;
        existing.barsCount += 1;
      }
      stats.set(key, existing);
    }

    for (const item of stats.values()) {
      const total = item.wins + item.losses;
      item.winRate = total > 0 ? item.wins / total : 0;
      item.avgScore = item.trades > 0 ? item.totalScore / item.trades : 0;
      item.avgHoldMs = item.durationCount > 0 ? item.durationTotal / item.durationCount : null;
      item.avgBars = item.barsCount > 0 ? item.barsTotal / item.barsCount : null;
    }

    const normalized = new Map<string, typeof stats extends Map<string, infer T> ? T : never>();
    const agentsNow = agentsRef.current || [];
    for (const agent of agentsNow) {
      if (!agent) continue;
      const byId = stats.get(agent.id || '');
      const byName = agent.name ? stats.get(`name:${agent.name}`) : null;
      const entry = byId || byName;
      if (entry) {
        normalized.set(agent.id, { ...entry, agentId: agent.id, agentName: agent.name || entry.agentName });
      }
    }
    if (normalized.size === 0) {
      for (const entry of stats.values()) {
        normalized.set(entry.agentId, entry);
      }
    }
    return normalized;
  }, [signalHistory]);

  useEffect(() => {
    const list = Array.isArray(signalHistory) ? signalHistory : [];
    const observations: DriftObservation[] = [];
    const resolveSession = (ts: number) => {
      const hour = new Date(ts).getUTCHours();
      if (hour < 6) return 'asia';
      if (hour < 12) return 'london';
      if (hour < 21) return 'ny';
      return 'overnight';
    };
    for (const entry of list) {
      const agentId = String(entry?.agentId || '').trim();
      if (!agentId) continue;
      const resolvedAtMs = Number(entry?.resolvedAtMs || entry?.executedAtMs || 0);
      if (!Number.isFinite(resolvedAtMs) || resolvedAtMs <= 0) continue;
      observations.push({
        agentId,
        symbol: entry.symbol || null,
        timeframe: entry.timeframe || null,
        session: resolveSession(resolvedAtMs),
        regime: entry.resolvedOutcomeEnvelope?.lifecycleState || entry.executionMode || null,
        resolvedAtMs,
        outcome: entry.decisionOutcome || entry.outcome || 'UNKNOWN',
        score: entry.score ?? entry.attribution?.alphaBps ?? null
      });
    }
    agentDriftReportsRef.current = computeAgentDriftReports({
      observations,
      baselineSamples: 80,
      liveSamples: 30,
      minSamples: 20
    });
  }, [signalHistory]);

  const agentFocusById = React.useMemo(() => {
    const focus = new Map<string, { symbol?: string; timeframe?: string; strategyMode?: string }>();
    const list = Array.isArray(signalHistory) ? signalHistory : [];
    const recent = list.slice(0, 300);
    const bucket = new Map<string, {
      symbolCounts: Map<string, number>;
      timeframeCounts: Map<string, number>;
      strategyCounts: Map<string, number>;
    }>();
    for (const entry of recent) {
      const agentId = String(entry.agentId || '').trim();
      const agentName = String(entry.agentName || '').trim();
      if (!agentId && !agentName) continue;
      const key = agentId || `name:${agentName}`;
      const group = bucket.get(key) || {
        symbolCounts: new Map<string, number>(),
        timeframeCounts: new Map<string, number>(),
        strategyCounts: new Map<string, number>()
      };
      const symbol = String(entry.symbol || '').trim();
      if (symbol) group.symbolCounts.set(symbol, (group.symbolCounts.get(symbol) || 0) + 1);
      const timeframe = String(entry.timeframe || '').trim();
      if (timeframe) group.timeframeCounts.set(timeframe, (group.timeframeCounts.get(timeframe) || 0) + 1);
      const strategy = String(entry.strategyMode || '').trim();
      if (strategy) group.strategyCounts.set(strategy, (group.strategyCounts.get(strategy) || 0) + 1);
      bucket.set(key, group);
    }

    const pickTop = (map: Map<string, number>) => {
      let best: string | undefined;
      let bestCount = 0;
      for (const [key, count] of map.entries()) {
        if (count > bestCount) {
          best = key;
          bestCount = count;
        }
      }
      return best;
    };

    const agentsNow = agentsRef.current || [];
    for (const agent of agentsNow) {
      if (!agent) continue;
      const byId = bucket.get(agent.id || '');
      const byName = agent.name ? bucket.get(`name:${agent.name}`) : null;
      const group = byId || byName;
      if (!group) continue;
      focus.set(agent.id, {
        symbol: pickTop(group.symbolCounts),
        timeframe: pickTop(group.timeframeCounts),
        strategyMode: pickTop(group.strategyCounts)
      });
    }
    if (focus.size === 0) {
      for (const [key, group] of bucket.entries()) {
        focus.set(key, {
          symbol: pickTop(group.symbolCounts),
          timeframe: pickTop(group.timeframeCounts),
          strategyMode: pickTop(group.strategyCounts)
        });
      }
    }
    return focus;
  }, [signalHistory]);
  const signalSymbols = Array.isArray(signalSettings.symbols) ? signalSettings.symbols : [];
  const signalPrimarySymbol = signalSymbols[0] || String(signalSettings.symbol || '').trim();
  const signalTimeframes = signalSettings.timeframes || [];
  const signalSessions = signalSettings.sessions || [];
  const signalStrategyModes = signalSettings.strategyModes || [];
  const signalAutoRefreshEnabled = !!signalSettings.autoRefreshEnabled;
  const signalRefreshIntervalMs = signalSettings.refreshIntervalMs || DEFAULT_SIGNAL_REFRESH_MS;
  const signalProbabilityThreshold = signalSettings.probabilityThreshold || DEFAULT_SIGNAL_THRESHOLD;
  const signalProbabilityMax = signalSettings.probabilityMax || DEFAULT_SIGNAL_PROBABILITY_MAX;
  const signalExpiryMinutes = signalSettings.expiryMinutes || DEFAULT_SIGNAL_EXPIRY_MINUTES;
  const signalAutoExecuteEnabled = !!signalSettings.autoExecuteEnabled;
  const signalExecutionTarget = (signalSettings.executionTarget || 'auto') as SignalExecutionTarget;
  const signalShadowFollowEnabled = signalSettings.shadowFollowEnabled === true;
  const signalMemoryMode = signalSettings.memoryMode || DEFAULT_SIGNAL_MEMORY_MODE;
  const signalMemoryLimit = signalSettings.memoryLimit || DEFAULT_SIGNAL_MEMORY_LIMIT;
  const signalIncludePatterns = signalSettings.includePatterns !== false;
  const signalTelegramConfig = signalSettings.telegram || DEFAULT_SIGNAL_TELEGRAM_CONFIG;
  const signalSnapshotWarmupBarsDefault = signalSettings.snapshotWarmupBarsDefault ?? SIGNAL_SNAPSHOT_WARMUP_BARS_DEFAULT;
  const signalSnapshotWarmupBars1d = signalSettings.snapshotWarmupBars1d ?? SIGNAL_SNAPSHOT_WARMUP_BARS_1D;
  const signalSnapshotWarmupBars1w = signalSettings.snapshotWarmupBars1w ?? SIGNAL_SNAPSHOT_WARMUP_BARS_1W;
  const signalSnapshotWarmupTimeoutMs = signalSettings.snapshotWarmupTimeoutMs ?? SIGNAL_SNAPSHOT_WARMUP_TIMEOUT_MS;
  const signalTelegramEnabled = !!signalTelegramConfig.enabled;
  const signalTelegramBotToken = String(signalTelegramConfig.botToken || '').trim();
  const signalTelegramChatId = String(signalTelegramConfig.chatId || '').trim();
  const signalTelegramSendOn = Array.isArray(signalTelegramConfig.sendOn)
    ? signalTelegramConfig.sendOn
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.sendOn;
  const signalTelegramSendOnKey = signalTelegramSendOn.join('|');
  const signalTelegramCommandsEnabled = !!signalTelegramConfig.commandsEnabled;
  const signalTelegramCommandMode = signalTelegramConfig.commandMode === 'manage' ? 'manage' : 'read';
  const signalTelegramCommandPassphrase = String(signalTelegramConfig.commandPassphrase || '').trim();
  const signalTelegramAllowChart = signalTelegramConfig.allowChart !== false;
  const signalTelegramAllowStatus = signalTelegramConfig.allowStatus !== false;
  const signalTelegramAllowManage = signalTelegramConfig.allowManage === true;
  const signalTelegramAlertsEnabled = signalTelegramConfig.alertsEnabled === true;
  const signalTelegramAlertTrades = signalTelegramConfig.alertTrades !== false;
  const signalTelegramAlertTpSl = signalTelegramConfig.alertTpSl !== false;
  const signalTelegramAlertDrawdown = signalTelegramConfig.alertDrawdown === true;
  const signalTelegramAlertAgentConfidence = signalTelegramConfig.alertAgentConfidence === true;
  const signalTelegramAlertConfidenceDrop = Number.isFinite(Number(signalTelegramConfig.alertConfidenceDrop))
    ? Math.max(1, Math.min(100, Math.round(Number(signalTelegramConfig.alertConfidenceDrop))))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.alertConfidenceDrop ?? 15;
  const signalTelegramAlertDrawdownPct = Number.isFinite(Number(signalTelegramConfig.alertDrawdownPct))
    ? Math.max(1, Math.min(100, Math.round(Number(signalTelegramConfig.alertDrawdownPct))))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.alertDrawdownPct ?? 80;
  const signalTelegramInlineActionsEnabled = signalTelegramConfig.inlineActionsEnabled !== false;
  const signalTelegramConfirmationsEnabled = signalTelegramConfig.confirmationsEnabled !== false;
  const signalTelegramConfirmationTimeoutSec = Number.isFinite(Number(signalTelegramConfig.confirmationTimeoutSec))
    ? Math.max(10, Math.min(600, Math.floor(Number(signalTelegramConfig.confirmationTimeoutSec))))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.confirmationTimeoutSec ?? 45;
  const signalTelegramDigestDailyEnabled = signalTelegramConfig.digestDailyEnabled === true;
  const signalTelegramDigestWeeklyEnabled = signalTelegramConfig.digestWeeklyEnabled === true;
  const signalTelegramDigestHourLocal = Number.isFinite(Number(signalTelegramConfig.digestHourLocal))
    ? Math.max(0, Math.min(23, Math.floor(Number(signalTelegramConfig.digestHourLocal))))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.digestHourLocal ?? 9;
  const signalTelegramDigestWeeklyDay = Number.isFinite(Number(signalTelegramConfig.digestWeeklyDay))
    ? Math.max(0, Math.min(6, Math.floor(Number(signalTelegramConfig.digestWeeklyDay))))
    : DEFAULT_SIGNAL_TELEGRAM_CONFIG.digestWeeklyDay ?? 1;
  const telegramAlertsActive = signalTelegramEnabled && signalTelegramAlertsEnabled && !!signalTelegramBotToken && !!signalTelegramChatId;
  const signalAutoRefreshStateRef = React.useRef<{
    enabled: boolean;
    symbols: string[];
    running: boolean;
    lastRunAtMs: number | null;
    sessions: SignalSessionWindow[];
  }>({
    enabled: signalAutoRefreshEnabled,
    symbols: signalSymbols,
    running: signalRunning,
    lastRunAtMs: signalLastRunAtMs,
    sessions: signalSessions
  });
  const runSignalScanAutoRef = React.useRef<(source: 'manual' | 'auto') => Promise<void> | void>(async () => {});
  const signalAutoRefreshAttemptAtRef = React.useRef(0);
  const SIGNAL_AUTO_REFRESH_TASK_ID = 'signal.auto_refresh.scan';
  const SHADOW_CONTROLLER_TASK_ID = 'controller.shadow.tick';
  const patternSymbols = Array.isArray(patternSettings.symbols) ? patternSettings.symbols : [];
  const patternSymbolMode = (patternSettings.symbolMode || 'auto') as PatternSymbolMode;
  const patternTimeframes = Array.isArray(patternSettings.timeframes) ? patternSettings.timeframes : [...DEFAULT_PATTERN_TIMEFRAMES];
  const patternDetectors = Array.isArray(patternSettings.detectors) ? patternSettings.detectors : [...DEFAULT_PATTERN_DETECTORS];
  const patternAutoRefreshEnabled = patternSettings.autoRefreshEnabled !== false;
  const patternRefreshIntervalMs = patternSettings.refreshIntervalMs || DEFAULT_PATTERN_REFRESH_MS;
  const patternRefreshMode = (patternSettings.refreshMode || DEFAULT_PATTERN_REFRESH_MODE) as PatternRefreshMode;
  const academyAutoApplyEnabled = academySettings.autoApplyEnabled;
  const academyAutoExportEnabled = academySettings.autoExportEnabled;
  const academyLessonLimit = academySettings.lessonLimit;
  const brokerWatchSymbols = React.useMemo(() => {
    const list: string[] = [];
    const seen = new Set<string>();
    const push = (raw: any) => {
      const sym = String(raw || '').trim();
      if (!sym) return;
      const key = normalizeSymbolKey(sym);
      if (!key || seen.has(key)) return;
      seen.add(key);
      list.push(sym);
    };

    for (const tab of tabs) {
      if (!tab) continue;
      const isRelevant = tab.id === activeTabId || tab.isWatched || tab.aiPinned;
      if (!isRelevant) continue;
      const { symbol } = getTradingViewParams(tab.url || '');
      if (symbol) push(symbol);
    }
    if (symbolScopeSymbol) push(symbolScopeSymbol);
    if (nativeChartSymbol) push(nativeChartSymbol);
    return list;
  }, [activeTabId, nativeChartSymbol, symbolScopeSymbol, tabs]);
  const activeTvParams = React.useMemo(() => getTradingViewParams(activeTab?.url || ''), [activeTab?.url]);
  const activeTvTimeframeLabel = React.useMemo(
    () => formatTradingViewIntervalLabel(activeTvParams?.interval || ''),
    [activeTvParams?.interval]
  );
  const [activeBrokerSymbol, setActiveBrokerSymbol] = useState('');
  const [activeTvPrice, setActiveTvPrice] = useState<number | null>(null);
  const [activeTvPriceUpdatedAtMs, setActiveTvPriceUpdatedAtMs] = useState<number | null>(null);
  const tvPriceFetchAtRef = React.useRef(0);

  const resolvedPatternSymbols = React.useMemo(() => {
    const list: string[] = [];
    const seen = new Set<string>();
    const push = (raw: any) => {
      const sym = String(raw || '').trim();
      if (!sym) return;
      const key = sym.toUpperCase();
      if (seen.has(key)) return;
      seen.add(key);
      list.push(sym);
    };
    if (patternSymbolMode === 'auto' || patternSymbolMode === 'scope') {
      push(symbolScopeSymbol);
    }
    if (patternSymbolMode === 'auto' || patternSymbolMode === 'active') {
      push(activeBrokerSymbol);
    }
    if (patternSymbolMode === 'auto') {
      brokerWatchSymbols.forEach(push);
    }
    if (patternSymbolMode === 'auto' || patternSymbolMode === 'custom') {
      patternSymbols.forEach(push);
    }
    return list;
  }, [activeBrokerSymbol, brokerWatchSymbols, patternSymbolMode, patternSymbols, symbolScopeSymbol]);
  const patternWatchSymbols = React.useMemo(() => {
    if (patternSymbolMode === 'custom') return patternSymbols;
    if (patternSymbolMode === 'scope') return symbolScopeSymbol ? [symbolScopeSymbol] : [];
    if (patternSymbolMode === 'active') return activeBrokerSymbol ? [activeBrokerSymbol] : [];
    return resolvedPatternSymbols;
  }, [activeBrokerSymbol, patternSymbolMode, patternSymbols, resolvedPatternSymbols, symbolScopeSymbol]);
  const patternWatchTimeframes = React.useMemo(() => normalizePatternTimeframes(patternTimeframes), [patternTimeframes]);
  const patternDetectorsResolved = React.useMemo(() => {
    const list = Array.isArray(patternDetectors) ? patternDetectors : [];
    return list.length > 0 ? list : [...DEFAULT_PATTERN_DETECTORS];
  }, [patternDetectors]);

  const formatTimeframeLabel = useCallback((value: any) => {
    const normalized = normalizeTimeframeKey(String(value || '').trim());
    if (!normalized) return '';
    if (normalized.endsWith('m')) return normalized;
    return normalized;
  }, []);

  const formatSignalPrice = useCallback((value: any) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return '--';
    const abs = Math.abs(num);
    const decimals = abs >= 1000 ? 2 : abs >= 1 ? 4 : 6;
    return num.toFixed(decimals).replace(/\.?0+$/, '');
  }, []);

  const buildSignalTelegramText = useCallback((entry: SignalEntry, status: SignalEntryStatus) => {
    const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
    const reason = entry.reason || entry.tradeProposal?.reason || '';
    const idLabel = entry.id ? entry.id.slice(-6) : '';
    const lines = [
      `Signal ${status}`,
      `${entry.action} ${entry.symbol}${tfLabel ? `  ${tfLabel}` : ''}`,
      `Entry ${formatSignalPrice(entry.entryPrice)} | SL ${formatSignalPrice(entry.stopLoss)} | TP ${formatSignalPrice(entry.takeProfit)}`,
      idLabel ? `ID ${idLabel}` : null,
      Number.isFinite(Number(entry.probability)) ? `Prob ${Math.round(entry.probability)}%` : null,
      entry.strategyMode ? `Mode ${entry.strategyMode}` : null,
      entry.agentName ? `Agent ${entry.agentName}` : null,
      reason ? `Reason: ${reason}` : null
    ].filter(Boolean) as string[];
    return lines.join('\n');
  }, [formatSignalPrice, formatTimeframeLabel]);

  const symbolScopeTimeframesLabel = React.useMemo(() => {
    return symbolScopeTimeframes.map((tf) => formatTimeframeLabel(tf)).filter(Boolean).join('/');
  }, [formatTimeframeLabel, symbolScopeTimeframes]);
  const symbolScopeFramesResolved = React.useMemo(() => {
    return symbolScopeTimeframes.map((tf) => {
      const raw = String(tf || '').trim().toLowerCase();
      if (raw === '1w') return '1W';
      if (raw === '1d') return '1D';
      if (raw === '4h') return '4H';
      if (raw === '1h') return '1H';
      if (raw === '30m') return '30m';
      if (raw === '15m') return '15m';
      if (raw === '5m') return '5m';
      if (raw === '1m') return '1m';
      return String(tf || '');
    }).filter(Boolean);
  }, [symbolScopeTimeframes]);

  const persistSymbolScope = useCallback((next: SymbolScope | null) => {
    try {
      if (!next) {
        localStorage.removeItem(SYMBOL_SCOPE_STORAGE_KEY);
        return;
      }
      localStorage.setItem(SYMBOL_SCOPE_STORAGE_KEY, JSON.stringify(next));
    } catch {
      // ignore storage failures
    }
  }, []);

  const persistSymbolScopeLedger = useCallback(async (next: SymbolScope | null) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory && !ledger?.deleteAgentMemory) return;
    try {
      if (!next) {
        if (ledger?.deleteAgentMemory) {
          await ledger.deleteAgentMemory({ key: SYMBOL_SCOPE_LEDGER_KEY });
        }
        return;
      }
      const timeframes = Array.isArray(next.timeframes) && next.timeframes.length > 0
        ? next.timeframes
        : [...DEFAULT_SYMBOL_SCOPE_TIMEFRAMES];
      const summary = [next.symbol, timeframes.join('/')].filter(Boolean).join(' ');
      await ledger.upsertAgentMemory({
        key: SYMBOL_SCOPE_LEDGER_KEY,
        familyKey: 'symbol_scope',
        scope: 'global',
        category: 'system',
        subcategory: 'symbol_scope',
        kind: 'symbol_scope',
        symbol: next.symbol,
        timeframe: timeframes[0] || undefined,
        summary: summary ? `Symbol scope ${summary}` : 'Symbol scope',
        payload: {
          symbol: next.symbol,
          timeframes,
          updatedAtMs: next.updatedAtMs,
          source: next.source ?? null
        },
        source: next.source ?? 'app',
        tags: [next.symbol, ...timeframes, 'symbol_scope'].filter(Boolean),
        createdAtMs: next.updatedAtMs
      });
    } catch {
      // ignore ledger failures
    }
  }, []);

  const pushSymbolScopeHistory = useCallback((symbol: string) => {
    const raw = String(symbol || '').trim();
    if (!raw) return;
    try {
      const existingRaw = localStorage.getItem(SYMBOL_SCOPE_HISTORY_KEY);
      const existing = existingRaw ? JSON.parse(existingRaw) : [];
      const list = Array.isArray(existing) ? existing : [];
      const upper = raw.toUpperCase();
      const merged = [upper, ...list.filter((s: any) => String(s || '').toUpperCase() !== upper)].slice(0, 24);
      localStorage.setItem(SYMBOL_SCOPE_HISTORY_KEY, JSON.stringify(merged));
    } catch {
      // ignore
    }
  }, []);

  const updateSymbolScope = useCallback(
    (symbol: string, opts?: { timeframes?: string[]; source?: string }) => {
      const cleaned = String(symbol || '').trim();
      if (!cleaned) return;
      const timeframes = normalizeScopeTimeframes(opts?.timeframes || symbolScopeTimeframes);
      const next: SymbolScope = {
        symbol: cleaned.toUpperCase(),
        timeframes,
        updatedAtMs: Date.now(),
        source: opts?.source ?? null
      };
      setSymbolScope(next);
      persistSymbolScope(next);
      void persistSymbolScopeLedger(next);
      pushSymbolScopeHistory(next.symbol);
      crossPanelContextEngine.publish({
        symbol: next.symbol,
        timeframe: timeframes[0] || null,
        originPanel: opts?.source || null
      }, { debounceMs: 0 });
    },
    [persistSymbolScope, persistSymbolScopeLedger, pushSymbolScopeHistory, symbolScopeTimeframes]
  );

  const clearSymbolScope = useCallback(() => {
    setSymbolScope(null);
    persistSymbolScope(null);
    void persistSymbolScopeLedger(null);
    crossPanelContextEngine.clear('scope_clear');
  }, [persistSymbolScope, persistSymbolScopeLedger]);

  const persistSignalSettings = useCallback((next: SignalSettings) => {
    try {
      localStorage.setItem(SIGNAL_SETTINGS_STORAGE_KEY, JSON.stringify(next));
    } catch {
      // ignore storage failures
    }
  }, []);

  const updateSignalSettings = useCallback((patch: Partial<SignalSettings>) => {
    setSignalSettings((prev) => {
      const merged = normalizeSignalSettings({ ...prev, ...patch });
      persistSignalSettings(merged);
      return merged;
    });
  }, [persistSignalSettings]);

  const updateSignalTelegram = useCallback((patch: Partial<SignalTelegramConfig>) => {
    updateSignalSettings({
      telegram: {
        ...signalTelegramConfig,
        ...patch
      }
    });
  }, [signalTelegramConfig, updateSignalSettings]);

  const updateSignalSnapshotWarmup = useCallback((patch: {
    barsDefault?: number;
    bars1d?: number;
    bars1w?: number;
    timeoutMs?: number;
  }) => {
    const next: Partial<SignalSettings> = {};
    if (patch.barsDefault != null) next.snapshotWarmupBarsDefault = patch.barsDefault;
    if (patch.bars1d != null) next.snapshotWarmupBars1d = patch.bars1d;
    if (patch.bars1w != null) next.snapshotWarmupBars1w = patch.bars1w;
    if (patch.timeoutMs != null) next.snapshotWarmupTimeoutMs = patch.timeoutMs;
    if (Object.keys(next).length > 0) updateSignalSettings(next);
  }, [updateSignalSettings]);

  const persistPatternSettings = useCallback((next: PatternSettings) => {
    try {
      localStorage.setItem(PATTERN_SETTINGS_STORAGE_KEY, JSON.stringify(next));
    } catch {
      // ignore storage failures
    }
  }, []);

  const updatePatternSettings = useCallback((patch: Partial<PatternSettings>) => {
    setPatternSettings((prev) => {
      const merged = normalizePatternSettings({ ...prev, ...patch });
      persistPatternSettings(merged);
      return merged;
    });
  }, [persistPatternSettings]);

  const persistAcademySettings = useCallback((next: AcademySettings) => {
    try {
      localStorage.setItem(ACADEMY_SETTINGS_STORAGE_KEY, JSON.stringify(next));
    } catch {
      // ignore storage failures
    }
  }, []);

  const updateAcademySettings = useCallback((patch: Partial<AcademySettings>) => {
    setAcademySettings((prev) => {
      const merged = normalizeAcademySettings({ ...prev, ...patch });
      persistAcademySettings(merged);
      return merged;
    });
  }, [persistAcademySettings]);

  const persistSnapshotPanelState = useCallback((next: SnapshotPanelState) => {
    try {
      localStorage.setItem(SNAPSHOT_PANEL_STORAGE_KEY, JSON.stringify(next));
    } catch {
      // ignore storage failures
    }
  }, []);

  useEffect(() => {
    persistSnapshotPanelState({
      symbol: snapshotPanelSymbol,
      applyToSignals: snapshotPanelApplyToSignals
    });
  }, [persistSnapshotPanelState, snapshotPanelApplyToSignals, snapshotPanelSymbol]);

  useEffect(() => {
    const cleaned = String(snapshotPanelSymbol || '').trim();
    const prevApply = snapshotPanelApplyRef.current;
    const prevSymbol = String(snapshotPanelLastSymbolRef.current || '').trim();
    snapshotPanelApplyRef.current = snapshotPanelApplyToSignals;
    snapshotPanelLastSymbolRef.current = snapshotPanelSymbol;
    if (!snapshotPanelApplyToSignals) return;
    if (!cleaned) return;
    if (!prevApply || cleaned !== prevSymbol) {
      updateSignalSettings({ symbols: [cleaned] });
    }
  }, [snapshotPanelApplyToSignals, snapshotPanelSymbol, updateSignalSettings]);

  const handleSignalAddSymbol = useCallback((nextSymbol: string) => {
    const cleaned = normalizeSignalSymbolEntry(nextSymbol);
    if (!cleaned) return;
    const existing = new Set(signalSymbols.map((entry) => normalizeSignalSymbolEntry(entry)));
    if (existing.has(cleaned)) return;
    const next = [...signalSymbols, cleaned];
    updateSignalSettings({ symbols: next });
    if (!signalPrimarySymbol) {
      const timeframes = signalTimeframes.length > 0 ? signalTimeframes : DEFAULT_SIGNAL_TIMEFRAMES;
      updateSymbolScope(cleaned, { timeframes, source: 'signal' });
    }
  }, [signalPrimarySymbol, signalSymbols, signalTimeframes, updateSignalSettings, updateSymbolScope]);

  const handleSignalRemoveSymbol = useCallback((symbol: string) => {
    const cleaned = normalizeSignalSymbolEntry(symbol);
    if (!cleaned) return;
    const next = signalSymbols.filter((entry) => normalizeSignalSymbolEntry(entry) !== cleaned);
    if (next.length === signalSymbols.length) return;
    updateSignalSettings({ symbols: next });
    const nextPrimary = next[0] || '';
    if (nextPrimary && nextPrimary !== signalPrimarySymbol) {
      const timeframes = signalTimeframes.length > 0 ? signalTimeframes : DEFAULT_SIGNAL_TIMEFRAMES;
      updateSymbolScope(nextPrimary, { timeframes, source: 'signal' });
    }
  }, [signalPrimarySymbol, signalSymbols, signalTimeframes, updateSignalSettings, updateSymbolScope]);

  const handleSignalTimeframesChange = useCallback((next: string[]) => {
    const timeframes = normalizeScopeTimeframes(next);
    updateSignalSettings({ timeframes });
    if (signalPrimarySymbol) {
      updateSymbolScope(signalPrimarySymbol, { timeframes, source: 'signal' });
    }
  }, [signalPrimarySymbol, updateSignalSettings, updateSymbolScope]);

  const handlePatternAddSymbol = useCallback((symbol: string) => {
    const cleaned = String(symbol || '').trim().toUpperCase();
    if (!cleaned) return;
    const existing = new Set(patternSymbols.map((entry) => String(entry || '').trim().toUpperCase()));
    if (existing.has(cleaned)) return;
    updatePatternSettings({ symbols: [...patternSymbols, cleaned] });
  }, [patternSymbols, updatePatternSettings]);

  const handlePatternRemoveSymbol = useCallback((symbol: string) => {
    const cleaned = String(symbol || '').trim().toUpperCase();
    if (!cleaned) return;
    updatePatternSettings({ symbols: patternSymbols.filter((entry) => String(entry || '').trim().toUpperCase() !== cleaned) });
  }, [patternSymbols, updatePatternSettings]);

  const handlePatternTimeframesChange = useCallback((next: string[]) => {
    updatePatternSettings({ timeframes: normalizePatternTimeframes(next) });
  }, [updatePatternSettings]);

  const handlePatternDetectorsChange = useCallback((next: string[]) => {
    const cleaned = Array.from(new Set(next.map((entry) => String(entry || '').trim()).filter(Boolean)));
    updatePatternSettings({ detectors: cleaned });
  }, [updatePatternSettings]);

  useEffect(() => {
    if (signalSymbols.length > 0 || !symbolScopeSymbol) return;
    handleSignalAddSymbol(symbolScopeSymbol);
  }, [handleSignalAddSymbol, signalSymbols.length, symbolScopeSymbol]);

  useEffect(() => {
    signalEntriesRef.current = signalEntries;
  }, [signalEntries]);

  useEffect(() => {
    signalTelegramSentRef.current.clear();
    signalTelegramWarmStartRef.current = true;
    signalTelegramAlertSentRef.current.clear();
    telegramConfidenceRef.current.clear();
    telegramConfidenceSeenRef.current.clear();
    telegramPendingActionsRef.current.clear();
    telegramDrawdownAlertRef.current = { dateKey: '', sent: false };
    telegramMt5PositionSnapshotRef.current = { initialized: false, byId: {} };
    telegramTlPositionSnapshotRef.current = { initialized: false, byId: {} };
    telegramMt5AlertInFlightRef.current = false;
    telegramDigestSentRef.current = {};
    telegramWatcherResumeRef.current.clear();
  }, [signalTelegramBotToken, signalTelegramChatId, signalTelegramEnabled, signalTelegramSendOnKey]);

  useEffect(() => {
    academyCasesRef.current = academyCases;
  }, [academyCases]);

  useEffect(() => {
    academyLessonsRef.current = academyLessons;
  }, [academyLessons]);

  useEffect(() => {
    academySymbolLearningsRef.current = academySymbolLearnings;
  }, [academySymbolLearnings]);
  useEffect(() => {
    calendarRulesRef.current = calendarRules;
  }, [calendarRules]);

  useEffect(() => {
    let cancelled = false;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.getAgentMemory && !ledger?.listAgentMemory) return;
    (async () => {
      try {
        let memory: any = null;
        if (ledger?.getAgentMemory) {
          const res = await ledger.getAgentMemory({ key: SYMBOL_SCOPE_LEDGER_KEY });
          if (res?.ok && res.memory) memory = res.memory;
        } else if (ledger?.listAgentMemory) {
          const res = await ledger.listAgentMemory({ kind: 'symbol_scope', limit: 1 });
          if (res?.ok && Array.isArray(res.memories) && res.memories.length > 0) {
            memory = res.memories[0];
          }
        }
        if (cancelled) return;
        const ledgerScope = parseSymbolScope(memory?.payload || memory);
        const localScope = loadSymbolScope();
        if (ledgerScope && (!localScope || ledgerScope.updatedAtMs > localScope.updatedAtMs)) {
          setSymbolScope(ledgerScope);
          persistSymbolScope(ledgerScope);
        } else if (localScope && (!ledgerScope || ledgerScope.updatedAtMs < localScope.updatedAtMs)) {
          await persistSymbolScopeLedger(localScope);
        }
      } catch {
        // ignore ledger hydrate failures
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [persistSymbolScope, persistSymbolScopeLedger]);

  useEffect(() => {
    if (!symbolScopeSymbol) return;
    setNativeChartSymbol(symbolScopeSymbol);
    setBacktestSymbol(symbolScopeSymbol);
  }, [symbolScopeSymbol]);

  const tabsRef = React.useRef(tabs);
  const activeTabRef = React.useRef(activeTab);
  const activeTabIdRef = React.useRef(activeTabId);
  const chartSessionsRef = React.useRef(chartSessions.sessions);
  const sidebarControlRef = React.useRef<{
    openSidebarMode?: (mode: SidebarMode) => void;
    switchMode?: (mode: SidebarMode) => void;
    openSidebar?: () => void;
    closeSidebar?: () => void;
    toggleSidebar?: () => void;
  }>({});
  useEffect(() => { tabsRef.current = tabs; }, [tabs]);
  useEffect(() => { activeTabRef.current = activeTab; }, [activeTab]);
  useEffect(() => { activeTabIdRef.current = activeTabId; }, [activeTabId]);
  useEffect(() => { chartSessionsRef.current = chartSessions.sessions; }, [chartSessions.sessions]);

  const browserControlsRef = React.useRef<BrowserControls | null>(null);
  const handleControlsReady = useCallback((controls: BrowserControls) => {
    browserControlsRef.current = controls;
  }, []);

  type TabCaptureOptions = { format?: 'jpeg' | 'png'; quality?: number; width?: number; height?: number };
  type CachedTabCapture = { mimeType: string; data: string; capturedAtMs: number };

  const captureCacheRef = React.useRef<Record<string, CachedTabCapture>>({});
  const captureInFlightRef = React.useRef<Record<string, Promise<CachedTabCapture | null>>>({});

  const captureTabCached = useCallback(async (
    tabId: string,
    options: TabCaptureOptions = {},
    maxAgeMs: number = 0
  ): Promise<CachedTabCapture | null> => {
    const id = String(tabId || '').trim();
    if (!id) return null;

    const fmt = options?.format || 'jpeg';
    const q = options?.quality ?? '';
    const w = options?.width ?? '';
    const h = options?.height ?? '';
    const cacheKey = `${id}|${fmt}|${q}|${w}|${h}`;

    const now = Date.now();
    const cached = captureCacheRef.current[cacheKey];
    if (cached && maxAgeMs > 0 && now - cached.capturedAtMs <= maxAgeMs) {
      return cached;
    }

    const inflight = captureInFlightRef.current[cacheKey];
    if (inflight) return await inflight;

    const promise = (async () => {
      const capture = browserControlsRef.current?.captureTab;
      if (!capture) return null;

      const frame = await capture(id, options);
      if (!frame?.data) return null;

      const mimeType = frame.mimeType || (fmt === 'png' ? 'image/png' : 'image/jpeg');
      const next: CachedTabCapture = { mimeType, data: frame.data, capturedAtMs: Date.now() };
      captureCacheRef.current[cacheKey] = next;

      // Prune to avoid holding too many base64 frames in memory.
      const entries = Object.entries(captureCacheRef.current);
      const MAX = 24;
      if (entries.length > MAX) {
        entries
          .sort((a, b) => (a[1]?.capturedAtMs || 0) - (b[1]?.capturedAtMs || 0))
          .slice(0, Math.max(0, entries.length - MAX))
          .forEach(([k]) => { delete captureCacheRef.current[k]; });
      }

      return next;
    })().finally(() => {
      delete captureInFlightRef.current[cacheKey];
    });

    captureInFlightRef.current[cacheKey] = promise;
    return await promise;
  }, []);

  type ContextSource = 'active' | 'pinned' | 'watched' | 'tradingview' | 'nativechart';
  type ContextImage = {
    dataUrl?: string;
    label?: string;
    meta?: {
      label: string;
      url?: string;
      capturedAtMs?: number;
      changed?: boolean;
      source?: ContextSource;
    };
  };
  type ChatContextFrameState = { hash: string; changedAtMs: number; checkedAtMs: number };
  type ChatContextRoiPreset = 'full' | 'center' | 'chart_focus';
  type ChatContextRedactionPreset = 'none' | 'top_left' | 'top_right' | 'top_corners' | 'top_bar';

  const chatContextLastFrameByTabRef = React.useRef<Record<string, ChatContextFrameState>>({});

  const applyVisionTransform = useCallback(async (
    dataUrl: string,
    opts: { roi: ChatContextRoiPreset; redaction: ChatContextRedactionPreset }
  ): Promise<string> => {
    const safeUrl = String(dataUrl || '').trim();
    if (!safeUrl) return safeUrl;
    if (opts.roi === 'full' && opts.redaction === 'none') return safeUrl;

    const getRoi = (w: number, h: number) => {
      if (opts.roi === 'center') {
        const mx = Math.round(w * 0.08);
        const my = Math.round(h * 0.08);
        return { x: mx, y: my, w: Math.max(1, w - mx * 2), h: Math.max(1, h - my * 2) };
      }
      if (opts.roi === 'chart_focus') {
        const mx = Math.round(w * 0.04);
        const my = Math.round(h * 0.08);
        return { x: mx, y: my, w: Math.max(1, w - mx * 2), h: Math.max(1, h - my * 2) };
      }
      return { x: 0, y: 0, w, h };
    };

    const applyRedaction = (ctx: CanvasRenderingContext2D, w: number, h: number) => {
      if (opts.redaction === 'none') return;
      const barH = Math.max(1, Math.round(h * 0.12));
      const cornerW = Math.max(1, Math.round(w * 0.22));
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      if (opts.redaction === 'top_bar' || opts.redaction === 'top_corners') {
        ctx.fillRect(0, 0, w, barH);
      }
      if (opts.redaction === 'top_left' || opts.redaction === 'top_corners') {
        ctx.fillRect(0, 0, cornerW, barH);
      }
      if (opts.redaction === 'top_right' || opts.redaction === 'top_corners') {
        ctx.fillRect(w - cornerW, 0, cornerW, barH);
      }
      ctx.restore();
    };

    return await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          const roi = getRoi(img.width || 1, img.height || 1);
          canvas.width = roi.w;
          canvas.height = roi.h;
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            resolve(safeUrl);
            return;
          }
          ctx.drawImage(img, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);
          applyRedaction(ctx, roi.w, roi.h);
          resolve(canvas.toDataURL('image/jpeg', 0.7));
        } catch {
          resolve(safeUrl);
        }
      };
      img.onerror = () => resolve(safeUrl);
      img.src = safeUrl;
    });
  }, []);

  const readChatTabContextTransform = useCallback(() => {
    const roiRaw = String(localStorage.getItem('glass_chat_tab_context_roi') || '').trim().toLowerCase();
    const redactionRaw = String(localStorage.getItem('glass_chat_tab_context_redaction') || '').trim().toLowerCase();
    const roi = roiRaw === 'center' || roiRaw === 'chart_focus' ? (roiRaw as ChatContextRoiPreset) : 'full';
    const redaction =
      redactionRaw === 'top_left' ||
      redactionRaw === 'top_right' ||
      redactionRaw === 'top_corners' ||
      redactionRaw === 'top_bar'
        ? (redactionRaw as ChatContextRedactionPreset)
        : 'none';
    return { roi, redaction };
  }, []);

  const captureChatTabContextImages = useCallback(async (): Promise<ContextImage[] | null> => {
    const tabsNow = tabsRef.current || [];
    const activeId = String(activeTabIdRef.current || '').trim();
    const activeNow = activeTabRef.current;

    if (!activeId || !activeNow || tabsNow.length === 0) return null;

    const readMaxTabs = () => {
      try {
        const raw = localStorage.getItem('glass_chat_tab_context_max_tabs');
        const n = raw ? Number(raw) : NaN;
        if (Number.isFinite(n)) return Math.min(6, Math.max(1, Math.floor(n)));
      } catch {
        // ignore
      }
      return 3;
    };

    const readContextMode = () => {
      try {
        const raw = String(localStorage.getItem('glass_chat_tab_context_mode') || '').trim().toLowerCase();
        if (raw === 'active' || raw === 'active_watched' || raw === 'tradingview_all') return raw;
      } catch {
        // ignore
      }
      return 'tradingview_all';
    };

    const readChangeOnly = () => {
      try {
        const raw = localStorage.getItem('glass_chat_tab_context_change_only');
        if (raw == null) return true;
        return !(raw === '0' || raw === 'false');
      } catch {
        return true;
      }
    };

    const maxTabs = readMaxTabs();
    const mode = readContextMode();
    const changeOnly = readChangeOnly();
    const transform = readChatTabContextTransform();

    const pushUnique = (
      list: Array<{ tab: (typeof tabsNow)[number]; source: ContextSource }>,
      seen: Set<string>,
      tab: (typeof tabsNow)[number] | undefined,
      source: ContextSource
    ) => {
      if (!tab) return;
      if (!tab.id || seen.has(tab.id)) return;
      seen.add(tab.id);
      list.push({ tab, source });
    };

    const seen = new Set<string>();
    const selected: Array<{ tab: (typeof tabsNow)[number]; source: ContextSource }> = [];

    const activeTab = tabsNow.find((t) => t.id === activeId);
    pushUnique(selected, seen, activeTab, 'active');

    for (const t of tabsNow) {
      if (t.aiPinned) pushUnique(selected, seen, t, 'pinned');
    }

    if (mode === 'active_watched') {
      const watched = tabsNow
        .filter((t) => t.isWatched)
        .sort((a, b) => {
          const aManual = a.watchSource === 'manual' ? 1 : 0;
          const bManual = b.watchSource === 'manual' ? 1 : 0;
          if (aManual !== bManual) return bManual - aManual;
          const aAuto = a.watchSource === 'auto' ? 1 : 0;
          const bAuto = b.watchSource === 'auto' ? 1 : 0;
          if (aAuto !== bAuto) return bAuto - aAuto;
          return 0;
        });
      for (const t of watched) pushUnique(selected, seen, t, 'watched');
    } else if (mode === 'tradingview_all') {
      const tradingViewTabs = tabsNow
        .filter((t) => isTradingViewUrl(String(t.url || '')))
        .sort((a, b) => {
          const aManual = a.watchSource === 'manual' ? 1 : 0;
          const bManual = b.watchSource === 'manual' ? 1 : 0;
          if (aManual !== bManual) return bManual - aManual;
          const aAuto = a.watchSource === 'auto' ? 1 : 0;
          const bAuto = b.watchSource === 'auto' ? 1 : 0;
          if (aAuto !== bAuto) return bAuto - aAuto;
          return 0;
        });
      for (const t of tradingViewTabs) pushUnique(selected, seen, t, t.isWatched ? 'watched' : 'tradingview');
    }

    const ordered = selected.slice(0, maxTabs);
    if (ordered.length === 0) return null;

    const captures = await Promise.all(
      ordered.map(async ({ tab, source }) => {
        if (!tab) return null;
        const width = tab.id === activeId ? 1280 : 1024;
        const quality = tab.id === activeId ? 60 : 55;
        const frame = await captureTabCached(tab.id, { format: 'jpeg', quality, width }, 1200);
        if (!frame?.data) return null;

        const url = String(tab.url || '').trim();
        const tv = isTradingViewUrl(url) ? getTradingViewParams(url) : { symbol: '', interval: '' };
        const aiLabel = tab.aiLabel ? String(tab.aiLabel).trim() : '';
        const tfLabel = aiLabel || (tv.interval ? formatTradingViewIntervalLabel(tv.interval) : '');
        const symPart = tv.symbol ? String(tv.symbol).trim() : '';
        const labelCore = [symPart, tfLabel].filter(Boolean).join(' ').trim();
        const title = String(tab.title || '').trim() || url;
        const labelShort = labelCore || aiLabel || title || url || 'Tab';

        const role =
          source === 'active'
            ? 'ACTIVE TAB'
            : source === 'pinned'
              ? 'PINNED TAB'
              : source === 'watched'
                ? 'WATCHED TAB'
                : 'TAB';

        const labelLong = `${role}${labelCore ? ` ${labelCore}` : ''}\nTitle: ${title}\nURL: ${url}`;

        const rawDataUrl = `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
        const transformed = await applyVisionTransform(rawDataUrl, transform);
        const base64 = transformed.split(',')[1] || '';
        if (!base64) return null;

        const now = Date.now();
        const prev = chatContextLastFrameByTabRef.current[tab.id];
        const nextHash = hashStringSampled(base64);
        const changed = !prev || prev.hash !== nextHash;

        chatContextLastFrameByTabRef.current[tab.id] = {
          hash: nextHash,
          changedAtMs: changed ? now : (prev?.changedAtMs || now),
          checkedAtMs: now
        };

        if (changeOnly && !changed) {
          return {
            label: `NO_CHANGE: ${labelShort}`,
            meta: {
              label: labelShort,
              url,
              capturedAtMs: now,
              changed: false,
              source
            }
          } satisfies ContextImage;
        }

        return {
          dataUrl: transformed,
          label: labelLong,
          meta: {
            label: labelShort,
            url,
            capturedAtMs: now,
            changed,
            source
          }
        } satisfies ContextImage;
      })
    );

    const out = captures.filter(Boolean) as ContextImage[];
    try {
      const chart = nativeChartRef.current;
      const meta = chart?.getMeta?.();
      const frames = Array.isArray(meta?.frames) ? meta.frames : [];
      const hasBars = frames.some((frame) => (frame?.bars || 0) > 0);
      const dataUrl = hasBars ? chart?.captureSnapshot?.() : null;
      if (dataUrl) {
        const frameLabel = frames
          .map((frame) => String(frame?.resolution || frame?.label || '').trim())
          .filter(Boolean)
          .join('/');
        const labelParts = ['Native Chart', meta?.symbol || '', frameLabel].filter(Boolean).join(' ').trim();
        const labelLong = `NATIVE CHART ${labelParts || ''}`.trim();
        out.push({
          dataUrl,
          label: labelLong,
          meta: {
            label: labelParts || 'Native Chart',
            capturedAtMs: Date.now(),
            source: 'nativechart'
          }
        });
      }
    } catch {
      // ignore
    }
    return out.length ? out : null;
  }, [applyVisionTransform, captureTabCached, readChatTabContextTransform]);

  const [isFullscreen, setIsFullscreen] = useState<boolean>(() => {
    try {
      const raw = localStorage.getItem('glass_ui_fullscreen');
      return raw === '1' || raw === 'true';
    } catch {
      return false;
    }
  });
  const [isChartFullscreen, setIsChartFullscreen] = useState(false);
  const chartFullscreenRestoreRef = React.useRef<boolean | null>(null);

  useEffect(() => {
    try {
      localStorage.setItem('glass_ui_fullscreen', isFullscreen ? '1' : '0');
    } catch {
      // ignore
    }

    const api = window.glass?.window;
    if (api?.setFullscreen) {
      try {
        void api.setFullscreen(isFullscreen);
      } catch {
        // ignore
      }
    }
  }, [isFullscreen]);

  useEffect(() => {
    if (isChartFullscreen) {
      if (chartFullscreenRestoreRef.current === null) {
        chartFullscreenRestoreRef.current = isFullscreen;
      }
      if (!isFullscreen) {
        setIsFullscreen(true);
      }
      return;
    }

    if (chartFullscreenRestoreRef.current !== null) {
      const restore = chartFullscreenRestoreRef.current;
      chartFullscreenRestoreRef.current = null;
      if (restore !== isFullscreen) {
        setIsFullscreen(restore);
      }
    }
  }, [isChartFullscreen, isFullscreen]);

  const toggleFullscreen = useCallback(() => {
    setIsFullscreen(prev => !prev);
  }, []);

  const handleBack = useCallback(() => browserControlsRef.current?.goBack(), []);
  const handleForward = useCallback(() => browserControlsRef.current?.goForward(), []);
  const handleRefresh = useCallback(() => {
    refresh();
    browserControlsRef.current?.reload();
  }, [refresh]);

  const toggleTabPin = useCallback((tabId: string) => {
    const id = String(tabId || '').trim();
    if (!id) return;
    const tab = (tabsRef.current || []).find((t) => t.id === id);
    updateTab(id, { aiPinned: !tab?.aiPinned });
  }, [updateTab]);

  const setTabLabel = useCallback((tabId: string, label: string) => {
    const id = String(tabId || '').trim();
    if (!id) return;
    const trimmed = String(label || '').trim();
    updateTab(id, { aiLabel: trimmed || undefined });
  }, [updateTab]);
  
  // State for Auto-Journaling
  const [journalEntry, setJournalEntry] = useState<string | null>(null);

  // State for Notifications
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [liveErrors, setLiveErrors] = useState<LiveErrorEntry[]>([]);
  const liveErrorsRef = React.useRef<LiveErrorEntry[]>([]);
  const [brokerLinkConfig, setBrokerLinkConfig] = useState(() => loadBrokerLinkConfig());
  const brokerLinkConfigRef = React.useRef(brokerLinkConfig);
  const [tlSnapshotSourceKey, setTlSnapshotSourceKey] = useState(() => {
    try {
      return localStorage.getItem(TL_SNAPSHOT_SOURCE_KEY) || '';
    } catch {
      return '';
    }
  });
  const [tlSnapshotAutoSwitch, setTlSnapshotAutoSwitch] = useState(() => {
    try {
      const raw = localStorage.getItem(TL_SNAPSHOT_AUTO_KEY);
      return raw === '1' || raw === 'true';
    } catch {
      return false;
    }
  });
  const [tlSnapshotFallbackOrder, setTlSnapshotFallbackOrder] = useState<string[]>(() => parseJsonArray(TL_SNAPSHOT_FALLBACK_KEY));
  const [tlExecutionTargets, setTlExecutionTargets] = useState<string[]>(() => parseJsonArray(TL_EXECUTION_TARGETS_KEY));
  const [tlNormalizeEnabled, setTlNormalizeEnabled] = useState(() => {
    try {
      const raw = localStorage.getItem(TL_NORMALIZE_ENABLED_KEY);
      return raw === '1' || raw === 'true';
    } catch {
      return false;
    }
  });
  const [tlNormalizeRefKey, setTlNormalizeRefKey] = useState(() => {
    try {
      return localStorage.getItem(TL_NORMALIZE_REF_KEY) || '';
    } catch {
      return '';
    }
  });
  const tlSnapshotSourceKeyRef = React.useRef(tlSnapshotSourceKey);
  const tlSnapshotAutoSwitchRef = React.useRef(tlSnapshotAutoSwitch);
  const tlSnapshotFallbackRef = React.useRef(tlSnapshotFallbackOrder);
  const tlExecutionTargetsRef = React.useRef(tlExecutionTargets);
  const tlNormalizeEnabledRef = React.useRef(tlNormalizeEnabled);
  const tlNormalizeRefKeyRef = React.useRef(tlNormalizeRefKey);
  const [brokerRateLimitSuppressUntilMs, setBrokerRateLimitSuppressUntilMs] = useState(0);
  const openSettings = useCallback(() => setIsSettingsOpen(true), []);
  const [commandPaletteOpen, setCommandPaletteOpen] = useState(false);
  const [commandPaletteQuery, setCommandPaletteQuery] = useState('');
  const closeCommandPalette = useCallback(() => setCommandPaletteOpen(false), []);
  const openCommandPalette = useCallback(() => {
    setCommandPaletteQuery('');
    setCommandPaletteOpen(true);
  }, []);

  useEffect(() => {
    brokerLinkConfigRef.current = brokerLinkConfig;
    saveBrokerLinkConfig(brokerLinkConfig);
  }, [brokerLinkConfig]);

  useEffect(() => {
    tlSnapshotSourceKeyRef.current = tlSnapshotSourceKey;
    try {
      localStorage.setItem(TL_SNAPSHOT_SOURCE_KEY, tlSnapshotSourceKey || '');
    } catch {
      // ignore
    }
  }, [tlSnapshotSourceKey]);

  useEffect(() => {
    tlSnapshotAutoSwitchRef.current = tlSnapshotAutoSwitch;
    try {
      localStorage.setItem(TL_SNAPSHOT_AUTO_KEY, tlSnapshotAutoSwitch ? '1' : '0');
    } catch {
      // ignore
    }
  }, [tlSnapshotAutoSwitch]);

  useEffect(() => {
    tlSnapshotFallbackRef.current = tlSnapshotFallbackOrder;
    try {
      localStorage.setItem(TL_SNAPSHOT_FALLBACK_KEY, JSON.stringify(tlSnapshotFallbackOrder || []));
    } catch {
      // ignore
    }
  }, [tlSnapshotFallbackOrder]);

  useEffect(() => {
    tlExecutionTargetsRef.current = tlExecutionTargets;
    try {
      localStorage.setItem(TL_EXECUTION_TARGETS_KEY, JSON.stringify(tlExecutionTargets || []));
    } catch {
      // ignore
    }
  }, [tlExecutionTargets]);

  useEffect(() => {
    tlNormalizeEnabledRef.current = tlNormalizeEnabled;
    try {
      localStorage.setItem(TL_NORMALIZE_ENABLED_KEY, tlNormalizeEnabled ? '1' : '0');
    } catch {
      // ignore
    }
  }, [tlNormalizeEnabled]);

  useEffect(() => {
    tlNormalizeRefKeyRef.current = tlNormalizeRefKey;
    try {
      localStorage.setItem(TL_NORMALIZE_REF_KEY, tlNormalizeRefKey || '');
    } catch {
      // ignore
    }
  }, [tlNormalizeRefKey]);

  const prefetchedSidebarModesRef = React.useRef<Set<string>>(new Set());
  const prefetchSidebarMode = useCallback((nextMode: SidebarMode) => {
    const key = String(nextMode || '').trim().toLowerCase();
    if (!key) return;
    if (prefetchedSidebarModesRef.current.has(key)) return;
    const deviceMemory = Number((navigator as any)?.deviceMemory || 0);
    if (Number.isFinite(deviceMemory) && deviceMemory > 0 && deviceMemory <= 2) {
      return;
    }
    const safe = (p: any) => {
      try {
        if (p && typeof p.catch === 'function') p.catch(() => {});
      } catch {
        // ignore
      }
    };

    switch (nextMode) {
      case 'chat':
      case 'chartchat':
        safe(loadChatInterface());
        break;
      case 'notes':
        safe(loadNotesInterface());
        break;
      case 'autopilot':
        safe(loadAutoPilotInterface());
        safe(loadShadowInterface());
        break;
      case 'leaderboard':
        safe(loadLeaderboardInterface());
        break;
      case 'academy':
        safe(loadAcademyInterface());
        break;
      case 'dashboard':
        safe(loadPerformanceDashboardInterface());
        break;
      case 'monitor':
        safe(loadMonitorInterface());
        break;
      case 'mt5':
        safe(loadMT5Interface());
        break;
      case 'tradelocker':
        safe(loadTradeLockerInterface());
        break;
      case 'nativechart':
        safe(loadNativeChartInterface());
        break;
      case 'backtester':
        safe(loadBacktesterInterface());
        break;
      case 'setups':
        safe(loadSetupsInterface());
        break;
      case 'agentcreator':
        safe(loadAgentCreatorInterface());
        break;
      case 'signal':
        safe(loadSignalInterface());
        break;
      case 'snapshot':
        safe(loadSnapshotInterface());
        break;
      case 'patterns':
        safe(loadPatternsInterface());
        break;
      case 'shadow':
        safe(loadShadowInterface());
        safe(loadAutoPilotInterface());
        break;
      case 'calendar':
        safe(loadCalendarInterface());
        break;
      case 'agentmemory':
        safe(loadAgentMemoryInterface());
        break;
      case 'agentlab':
        safe(loadAgentLabInterface());
        break;
      case 'audit':
        safe(loadAuditTrailInterface());
        break;
      case 'changes':
        safe(loadChangesInterface());
        break;
      default:
        break;
    }
    prefetchedSidebarModesRef.current.add(key);
  }, []);

  // Keyboard shortcut: Ctrl/Cmd + ,
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      const isCmdOrCtrl = e.metaKey || e.ctrlKey;
      if (isCmdOrCtrl && e.key === ',') {
        e.preventDefault();
        setIsSettingsOpen(true);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  // Keyboard shortcut: Ctrl/Cmd + K for command palette.
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      const isCmdOrCtrl = e.metaKey || e.ctrlKey;
      if (!isCmdOrCtrl) return;
      if (isTextInputElement(e.target)) return;
      const key = String(e.key || '').toLowerCase();
      if (key === 'k') {
        e.preventDefault();
        setCommandPaletteOpen((prev) => !prev);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  // Keyboard shortcut: F11 toggles fullscreen; Esc exits fullscreen.
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === 'F11') {
        e.preventDefault();
        setIsFullscreen(prev => !prev);
        return;
      }
      if (e.key === 'Escape' && isFullscreen && !isChartFullscreen) {
        setIsFullscreen(false);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [isChartFullscreen, isFullscreen]);

  // Portfolio Management
  const {
    balance: simBalance,
    equity: simEquity,
    positions: simPositions,
    simAvailable,
    simUpdatedAtMs
  } = usePortfolio();
  
  // --- Notification Helpers ---
  const appendLiveError = useCallback((input: {
    message: string;
    source?: string;
    level?: 'error' | 'warn' | 'info';
    stack?: string | null;
    detail?: any;
    ts?: number;
  }) => {
    try {
      const ts = typeof input.ts === 'number' && Number.isFinite(input.ts) ? input.ts : Date.now();
      const level = input.level || 'error';
      const detailKey = [
        input?.detail?.code != null ? String(input.detail.code) : '',
        input?.detail?.method != null ? String(input.detail.method) : '',
        input?.detail?.symbol != null ? String(input.detail.symbol) : '',
        input?.detail?.resolution != null ? String(input.detail.resolution) : '',
        input?.detail?.timeframe != null ? String(input.detail.timeframe) : ''
      ].filter(Boolean).join('|');
      const shouldEmit = diagnosticsRateLimiter.shouldEmit({
        source: input.source || 'app',
        message: String(input.message || 'Unknown error'),
        detailKey: detailKey || null,
        level,
        atMs: ts
      });
      if (!shouldEmit) return;
      const entry: LiveErrorEntry = {
        id: `err_${ts}_${Math.random().toString(36).slice(2, 8)}`,
        ts,
        level,
        source: input.source || 'app',
        message: String(input.message || 'Unknown error'),
        stack: input.stack != null ? String(input.stack) : null,
        detail: input.detail,
        count: 1
      };

      const list = liveErrorsRef.current.slice();
      const last = list[list.length - 1];
      const key = (e: LiveErrorEntry) => `${e.source}|${e.message}|${e.stack || ''}`;
      if (last && key(last) === key(entry) && ts - last.ts < 2000) {
        const merged = { ...last, ts, count: (last.count || 1) + 1 };
        list[list.length - 1] = merged;
      } else {
        list.push(entry);
      }

      if (list.length > MAX_LIVE_ERRORS) {
        list.splice(0, list.length - MAX_LIVE_ERRORS);
      }

      const aggregated = diagnosticsRateLimiter.drainAggregated();
      if (aggregated.length > 0) {
        for (const agg of aggregated) {
          list.push({
            id: `err_agg_${agg.lastAtMs}_${Math.random().toString(36).slice(2, 8)}`,
            ts: agg.lastAtMs,
            level: agg.level,
            source: agg.source,
            message: `${agg.message} x${agg.count}`,
            stack: null,
            detail: {
              aggregatedCount: agg.count,
              suppressedCount: Math.max(0, agg.count - 1),
              windowMs: agg.windowMs,
              firstAtMs: agg.firstAtMs,
              lastAtMs: agg.lastAtMs
            },
            count: agg.count
          });
        }
        if (list.length > MAX_LIVE_ERRORS) {
          list.splice(0, list.length - MAX_LIVE_ERRORS);
        }
      }

      liveErrorsRef.current = list;
      setLiveErrors(list);

      appendTechAgentLog({
        ts,
        level: entry.level,
        source: entry.source,
        message: entry.message,
        detail: entry.stack || entry.detail ? { stack: entry.stack || null, detail: entry.detail ?? null } : undefined
      });

      const ledger = window.glass?.tradeLedger;
      if (ledger?.append) {
        void ledger.append({
          kind: 'app_error',
          schemaVersion: 'app_error_v1',
          ts,
          source: entry.source,
          status: entry.level,
          payload: {
            message: entry.message,
            stack: entry.stack,
            detail: entry.detail,
            count: entry.count || 1
          }
        }).catch(() => {});
      }
    } catch {
      // ignore logging failures
    }
  }, []);

  const clearLiveErrors = useCallback(() => {
    liveErrorsRef.current = [];
    setLiveErrors([]);
  }, []);

  const addNotification = useCallback((title: string, message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info') => {
    const id = Date.now().toString();
    const newNotif: Notification = { id, title, message, type, timestamp: new Date() };
    setNotifications(prev => [newNotif, ...prev]);
    
    playSound('notification');

    if (type === 'error' || type === 'warning') {
      appendLiveError({
        source: 'notification',
        level: type === 'warning' ? 'warn' : 'error',
        message: `${title}${message ? `: ${message}` : ''}`
      });
    } else {
      appendTechAgentLog({
        level: type === 'warning' ? 'warn' : 'info',
        source: 'notification',
        message: `${title}${message ? `: ${message}` : ''}`
      });
    }

    // Auto dismiss
    deferMs(() => {
        setNotifications(prev => prev.filter(n => n.id !== id));
    }, 5000);
    }, [appendLiveError]);

  const dismissNotification = (id: string) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  };

  const buildTelegramSignalToken = useCallback((entry: SignalEntry) => {
    const raw = String(entry?.id || '').trim();
    if (!raw) return '';
    if (raw.length <= 18) return raw;
    return raw.slice(-12);
  }, []);

  const buildTelegramSignalInlineActions = useCallback((entry: SignalEntry, status: SignalEntryStatus) => {
    if (!signalTelegramCommandsEnabled || !signalTelegramAllowManage || signalTelegramCommandMode !== 'manage') return null;
    if (!signalTelegramInlineActionsEnabled) return null;
    if (status !== 'PROPOSED') return null;
    const token = buildTelegramSignalToken(entry);
    if (!token) return null;
    return {
      inline_keyboard: [
        [
          { text: 'Execute', callback_data: `sig:exec:${token}` },
          { text: 'Reject', callback_data: `sig:reject:${token}` }
        ],
        [
          { text: 'Send MT5', callback_data: `sig:exec:mt5:${token}` },
          { text: 'Send Locker', callback_data: `sig:exec:tradelocker:${token}` }
        ]
      ]
    };
  }, [
    buildTelegramSignalToken,
    signalTelegramAllowManage,
    signalTelegramCommandMode,
    signalTelegramCommandsEnabled,
    signalTelegramInlineActionsEnabled
  ]);

  const sendSignalTelegramMessage = useCallback(async (entry: SignalEntry, status: SignalEntryStatus) => {
    const sender = window.glass?.telegram?.sendMessage;
    if (!sender) return { ok: false, error: 'Telegram relay unavailable.' };
    const text = buildSignalTelegramText(entry, status);
    if (!text) return { ok: false, error: 'Telegram payload empty.' };
    const replyMarkup = buildTelegramSignalInlineActions(entry, status);
    const res = await sender({
      botToken: signalTelegramBotToken,
      chatId: signalTelegramChatId,
      text,
      replyMarkup
    });
    if (!res?.ok) {
      const err = res?.error ? String(res.error) : 'Telegram send failed.';
      addNotification('Telegram Relay', err, 'error');
    }
    return res;
  }, [addNotification, buildSignalTelegramText, buildTelegramSignalInlineActions, signalTelegramBotToken, signalTelegramChatId]);

  useEffect(() => {
    if (!signalTelegramEnabled) return;
    if (!signalTelegramBotToken || !signalTelegramChatId) return;
    const sendOnSet = new Set(signalTelegramSendOn);
    if (sendOnSet.size === 0) return;
    const sentMap = signalTelegramSentRef.current;
    if (signalTelegramWarmStartRef.current) {
      signalEntries.forEach((entry) => {
        const status = String(entry.status || 'PROPOSED').toUpperCase();
        const statusSet = sentMap.get(entry.id) || new Set();
        statusSet.add(status);
        sentMap.set(entry.id, statusSet);
      });
      signalTelegramWarmStartRef.current = false;
      return;
    }
    for (const entry of signalEntries) {
      const status = String(entry.status || 'PROPOSED').toUpperCase() as SignalEntryStatus;
      if (!sendOnSet.has(status)) continue;
      const statusSet = sentMap.get(entry.id) || new Set();
      if (statusSet.has(status)) continue;
      statusSet.add(status);
      sentMap.set(entry.id, statusSet);
      void sendSignalTelegramMessage(entry, status);
    }
  }, [
    sendSignalTelegramMessage,
    signalEntries,
    signalTelegramChatId,
    signalTelegramEnabled,
    signalTelegramBotToken,
    signalTelegramSendOn
  ]);

  useEffect(() => {
    appendTechAgentLog({
      level: 'info',
      source: 'app',
      message: 'Session started.'
    });
  }, []);

  const handleSettingsSaved = () => {
    addNotification('Settings Saved', 'API keys updated locally.', 'success');
  };

  useEffect(() => {
    const handleWindowError = (event: ErrorEvent) => {
      appendLiveError({
        source: 'window.error',
        message: event?.message || 'Unhandled window error.',
        stack: event?.error?.stack || null,
        detail: {
          filename: event?.filename || null,
          lineno: event?.lineno || null,
          colno: event?.colno || null
        }
      });
    };

    const handleRejection = (event: PromiseRejectionEvent) => {
      const reason: any = event?.reason;
      appendLiveError({
        source: 'unhandledrejection',
        message: reason?.message ? String(reason.message) : String(reason || 'Unhandled promise rejection'),
        stack: reason?.stack || null,
        detail: reason != null && typeof reason === 'object' ? reason : null
      });
    };

    const originalConsoleError = console.error;
    console.error = (...args: any[]) => {
      try {
        const err = args.find((a) => a instanceof Error) as Error | undefined;
        const message = args
          .map((a) => {
            if (a instanceof Error) return a.message || a.toString();
            if (typeof a === 'string') return a;
            try {
              return JSON.stringify(a);
            } catch {
              return String(a);
            }
          })
          .join(' ');

        appendLiveError({
          source: 'console.error',
          message: message || 'Console error',
          stack: err?.stack || null,
          detail: err ? { name: err.name } : null
        });
      } catch {
        // ignore
      }
      originalConsoleError.apply(console, args);
    };

    const originalConsoleWarn = console.warn;
    console.warn = (...args: any[]) => {
      try {
        const err = args.find((a) => a instanceof Error) as Error | undefined;
        const message = args
          .map((a) => {
            if (a instanceof Error) return a.message || a.toString();
            if (typeof a === 'string') return a;
            try {
              return JSON.stringify(a);
            } catch {
              return String(a);
            }
          })
          .join(' ');

        appendLiveError({
          source: 'console.warn',
          level: 'warn',
          message: message || 'Console warning',
          stack: err?.stack || null,
          detail: err ? { name: err.name } : null
        });
      } catch {
        // ignore
      }
      originalConsoleWarn.apply(console, args);
    };

    window.addEventListener('error', handleWindowError);
    window.addEventListener('unhandledrejection', handleRejection);
    return () => {
      console.error = originalConsoleError;
      console.warn = originalConsoleWarn;
      window.removeEventListener('error', handleWindowError);
      window.removeEventListener('unhandledrejection', handleRejection);
    };
  }, [appendLiveError]);
  
  const AGENT_TOOL_DEDUPE_WINDOW_MS = 30_000;
  const autoPilotConfigRef = React.useRef<any>(null); // Quick hack to access config inside callback
  const tradeLockerExecRef = React.useRef<any>(null);
  const chartChatContextRef = React.useRef<{ url: string; title: string } | null>({ url: 'chart://engine', title: 'Chart Engine' });
  const chartChatHandlersRef = React.useRef<{
    sendMessage?: (
      text: string,
      context?: any,
      monitored?: string[],
      image?: any,
      options?: { symbol?: string; timeframes?: string[] }
    ) => Promise<void> | void;
    clearChat?: () => void;
    setReplyMode?: (mode: any) => void;
    setAutoTabVisionEnabled?: (enabled: boolean) => void;
    startLiveSession?: (type: 'camera' | 'screen' | 'audio') => Promise<any> | void;
    stopLiveSession?: () => void;
    liveStream?: MediaStream | null;
    setSessionBias?: (bias: string) => void;
  }>({});
  const executeTradeRequestRef = React.useRef<any>(null);
  const startupBridgeGateRef = React.useRef<{ ready: boolean; error: string | null }>({
    ready: false,
    error: null
  });
  const tradeLockerExecutionGateRef = React.useRef<{ connected: boolean; upstreamBlockedUntilMs: number | null }>({
    connected: false,
    upstreamBlockedUntilMs: null
  });
  const executeBrokerActionRequestRef = React.useRef<((action: BrokerAction) => Promise<any>) | null>(null);
  const executeTradeProposalRef = React.useRef<((messageId: string, proposal: TradeProposal, source?: string) => void) | null>(null);
  const tradeDedupeFallbackRef = React.useRef<Map<string, number>>(new Map());
  const executionQueueDedupeFallbackRef = React.useRef<Map<string, number>>(new Map());
  const brokerActionDedupeFallbackRef = React.useRef<Map<string, number>>(new Map());
  const agentToolDedupeRef = React.useRef<Map<string, number>>(new Map());
  const executeAgentToolRequestRef = React.useRef<((action: AgentToolAction, onProgress?: (update: Partial<AgentToolAction>) => void) => Promise<AgentToolResult>) | null>(null);
  const brokerHistoryRef = React.useRef<{ key: string; updatedAtMs: number }>({ key: '', updatedAtMs: 0 });
  const nativeChartRef = React.useRef<NativeChartHandle | null>(null);
  const lastNativeChartSnapshotRef = React.useRef<{ dataUrl: string; meta: NativeChartMeta | null; capturedAtMs: number } | null>(null);
  const lastChartSnapshotMemoryRef = React.useRef<{ key: string; savedPath?: string | null; capturedAtMs: number; symbol?: string | null; timeframe?: string | null } | null>(null);
  const chartChatSnapshotRef = React.useRef<{
    payload: any;
    contextText: string;
    imageDataUrl?: string | null;
    truncated?: boolean;
  } | null>(null);
  const openSymbolPanelRef = React.useRef<(
    (target: 'nativechart' | 'mt5' | 'tradelocker', symbol: string, timeframe?: string | null) => void
  ) | null>(null);
  const chartChatSnapshotStatusRef = React.useRef<ChartChatSnapshotStatus | null>(null);
  const signalRunRef = React.useRef<{ runId: string; canceled: boolean } | null>(null);
  const signalExecutionInFlightRef = React.useRef<Set<string>>(new Set());
  const signalCancelInFlightRef = React.useRef<Set<string>>(new Set());
  const shadowFollowInFlightRef = React.useRef<Set<string>>(new Set());
  const shadowLiveDeployInFlightRef = React.useRef<Set<string>>(new Set());
  const livePendingScanRef = React.useRef<{ running: boolean; lastAtMs: number }>({ running: false, lastAtMs: 0 });
  const maybeExecutePendingLiveSignalsRef = React.useRef<((opts?: {
    agentId?: string | null;
    excludeIds?: Set<string>;
    profileOverride?: ShadowProfile | null;
  }) => Promise<void>) | null>(null);
  const liveStopSyncInFlightRef = React.useRef<Set<string>>(new Set());
  const signalEntriesRef = React.useRef<SignalEntry[]>([]);
  const simulatedOutcomeRef = React.useRef(new Map<string, {
    createdAtMs: number;
    outcome: 'WIN' | 'LOSS' | 'EXPIRED';
    resolvedAtMs: number;
    exitPrice?: number | null;
    timeframe: string;
    barsToOutcome?: number | null;
    durationMs?: number | null;
  }>());
  const signalTelegramSentRef = React.useRef<Map<string, Set<string>>>(new Map());
  const signalTelegramWarmStartRef = React.useRef(true);
  const signalTelegramAlertSentRef = React.useRef<Map<string, Set<string>>>(new Map());
  const telegramPendingActionsRef = React.useRef<Map<string, TelegramPendingAction>>(new Map());
  const telegramPendingCleanupAtRef = React.useRef<number>(0);
  const telegramConfidenceRef = React.useRef<Map<string, number>>(new Map());
  const telegramConfidenceSeenRef = React.useRef<Set<string>>(new Set());
  const telegramDrawdownAlertRef = React.useRef<{ dateKey: string; sent: boolean }>({ dateKey: '', sent: false });
  const telegramMt5PositionSnapshotRef = React.useRef<{ initialized: boolean; byId: Record<string, any> }>({ initialized: false, byId: {} });
  const telegramTlPositionSnapshotRef = React.useRef<{ initialized: boolean; byId: Record<string, any> }>({ initialized: false, byId: {} });
  const telegramMt5AlertInFlightRef = React.useRef(false);
  const telegramDigestSentRef = React.useRef<{ dailyKey?: string | null; weeklyKey?: string | null }>({});
  const telegramWatcherResumeRef = React.useRef<Set<string>>(new Set());
  const setAutoPilotConfigRef = React.useRef<((updater: any) => void) | null>(null);
  const telegramUpdateIdRef = React.useRef<number>(0);
  const telegramCommandInFlightRef = React.useRef<Set<number>>(new Set());
  const telegramPollingActiveRef = React.useRef(false);
  const signalEntryPersistTimerRef = React.useRef<number | null>(null);
  const signalHistoryFetchAtRef = React.useRef(0);
  const scorecardPersistedRef = React.useRef<Map<string, string>>(new Map());
  const academyCasesRef = React.useRef<AcademyCase[]>([]);
  const academyLessonsRef = React.useRef<AcademyLesson[]>([]);
  const academySymbolLearningsRef = React.useRef<AcademySymbolLearning[]>([]);
  const academyLessonContextRef = React.useRef<string>('');
  const academyExportNotBeforeRef = React.useRef<number>(0);
  const academyAnalystInFlightRef = React.useRef<Set<string>>(new Set());
  const academyAutoAcceptRef = React.useRef<Set<string>>(new Set());
  const calendarBackfillRef = React.useRef(false);
  const calendarIngestRef = React.useRef<{ inFlight: boolean; lastRunAtMs: number | null; lastError: string | null }>({
    inFlight: false,
    lastRunAtMs: null,
    lastError: null
  });
  const autoCalendarStateRef = React.useRef<{ enabled?: boolean; killSwitch?: boolean; mode?: string | null }>({});
  const shadowFollowStateRef = React.useRef<boolean | null>(null);
  const calendarRulesRef = React.useRef<CalendarRule[]>([]);
  const signalEntriesPersistedRef = React.useRef<Map<string, string>>(new Map());
  const pendingChartFocusRef = React.useRef<{ symbol: string; timeframe?: string } | null>(null);
  const chartEngineQuoteRef = React.useRef<Map<string, number>>(new Map());
  const patternWatchWarningRef = React.useRef(0);
  const backtesterRef = React.useRef<BacktesterHandle | null>(null);
  const pendingBacktestApplyRef = React.useRef<BacktesterOptimizationApply | null>(null);
  const backtestOptimizationCancelRef = React.useRef<Map<string, { cancelled: boolean }>>(new Map());
  const constraintsCacheRef = React.useRef<Map<string, { res: any; fetchedAtMs: number }>>(new Map());
  const constraintsInFlightRef = React.useRef<Map<string, Promise<any>>>(new Map());
  const spreadAtrCacheRef = React.useRef<Map<string, { atr: number; fetchedAtMs: number }>>(new Map());
  const spreadAtrInFlightRef = React.useRef<Map<string, Promise<{ ok: boolean; atr?: number; fetchedAtMs?: number; error?: string }>>>(new Map());
  const agentMemoryRef = React.useRef<any[]>([]);
  const chartChatAgentsRef = React.useRef<Agent[]>([]);
  const agentBaseInstructionRef = React.useRef<Map<string, string>>(new Map());
  const agentAcademyOverlayRef = React.useRef<Map<string, string>>(new Map());
  const agentInstructionUpdateAtRef = React.useRef<number>(0);
  const agentRunnerRef = React.useRef<ReturnType<typeof createAgentRunner> | null>(null);
  const updateAgentRef = React.useRef<((agent: Agent) => void) | null>(null);
  const getContextPackRef = React.useRef<(() => string) | null>(null);
  const taskTreeRef = React.useRef<TaskTreeOrchestrator | null>(null);
  const actionTaskTreeRef = React.useRef<TaskTreeOrchestrator | null>(null);
  const playbookTaskTreeRef = React.useRef<TaskTreeOrchestrator | null>(null);
  const taskTreeStateRef = React.useRef<{ signal: any | null; action: any | null }>({ signal: null, action: null });
  const taskTreePersistTimerRef = React.useRef<{ signal?: number | null; action?: number | null }>({});
  const taskTreeLastSummaryRef = React.useRef<{ signal: TaskTreeRunSummary | null; action: TaskTreeRunSummary | null }>({ signal: null, action: null });
  const recordTaskTreeRunRef = React.useRef<((summary: any, taskType: 'signal' | 'action') => void) | null>(null);
  const persistTaskTreeStateRef = React.useRef<((taskType: 'signal' | 'action', snapshot: TaskTreeStateSnapshot, opts?: { immediate?: boolean }) => void) | null>(null);
  const updateRecommendedActionFlowsRef = React.useRef<(() => void) | null>(null);
  const recordActionTraceRef = React.useRef<((input: any, result?: any) => Promise<void> | void) | null>(null);
  const runRecommendedActionFlowRef = React.useRef<((flow: ActionFlowRecommendation, opts?: any) => { ok: boolean; runId?: string | null; queued?: number | null; error?: string }) | null>(null);
  const handleTradeLockerPlaceOrderRef = React.useRef<((args: any) => Promise<any>) | null>(null);
  const tlSavedConfigRef = React.useRef<any>(null);
  const tlConnectAttemptAtRef = React.useRef<number>(0);
  const tlConnectInFlightRef = React.useRef(false);
  const ensureTradeLockerConnectedRef = React.useRef<((reason?: string) => Promise<any>) | null>(null);
  const ensureActionTaskTreeRef = React.useRef<(() => TaskTreeOrchestrator) | null>(null);
  const refreshSnapshotRef = React.useRef<((args?: any) => Promise<any>) | null>(null);
  const refreshQuotesRef = React.useRef<((args?: any) => Promise<any>) | null>(null);
  const tlCancelOrderRef = React.useRef<((id: string) => Promise<any>) | null>(null);
  const tlClosePositionRef = React.useRef<((id: string, qty?: number) => Promise<any>) | null>(null);
  const tlSearchInstrumentsRef = React.useRef<((query: string, limit?: number) => Promise<any>) | null>(null);
  const tlOrdersRef = React.useRef<any[]>([]);
  const tlOrdersHistoryRef = React.useRef<any[]>([]);
  const tlPositionsRef = React.useRef<any[]>([]);
  const quotesBySymbolRef = React.useRef<Record<string, any> | null>(null);
  const tradeLockerAccountLockRef = React.useRef<Promise<void>>(Promise.resolve());
  const tradeLockerAccountBusyRef = React.useRef(false);
  const tlAccountMapRef = React.useRef<Map<string, { env: string; server: string; accountId: number; accNum: number }>>(new Map());
  const resolveSnapshotSourceKeyRef = React.useRef<(() => string | null) | null>(null);
  const resolveSnapshotFallbackOrderRef = React.useRef<((currentKey: string | null) => string[]) | null>(null);
  const ensureTradeLockerAccountRef = React.useRef<((accountKey: string | null, reason?: string) => Promise<any>) | null>(null);
  const getTradeLockerAccountKeyRef = React.useRef<(() => string | null) | null>(null);
  const upsertTradeLockerAccountQuoteRef = React.useRef<((accountKey: string, quote: TradeLockerQuote) => void) | null>(null);
  const tlSetActiveAccountRef = React.useRef<((accountId: number, accNum?: number) => Promise<any>) | null>(null);
  const tlAccountQuotesRef = React.useRef<Map<string, Record<string, TradeLockerQuote>>>(new Map());
  const tlNormalizationStateRef = React.useRef<Map<string, {
    bidOffsets: number[];
    askOffsets: number[];
    medianBid: number | null;
    medianAsk: number | null;
    madBid: number | null;
    madAsk: number | null;
    emaBid: number | null;
    emaAsk: number | null;
    updatedAtMs: number;
  }>>(new Map());
  const tlSnapshotAutoSwitchAtRef = React.useRef<number>(0);
  const enqueueCatalogActionRef = React.useRef<((input: {
    actionId: string;
    payload?: Record<string, any> | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    mode?: string | null;
    source?: string | null;
    dedupeKey?: string | null;
    correlationId?: string | null;
  }) => { ok: boolean; runId?: string; queued?: boolean; error?: string }) | null>(null);
  const taskTreeUpdatedAtRef = React.useRef<number | null>(null);
  const setupSignalDedupeRef = React.useRef<Map<string, number>>(new Map());
  const setupSignalCooldownRef = React.useRef<Map<string, number>>(new Map());
  const setupSignalExpiryAtRef = React.useRef(0);
  const backgroundWatcherStateRef = React.useRef<Map<string, { lastFetchMs: number; lastTriggerBarTs: number }>>(new Map());
  const backgroundWatcherRunningRef = React.useRef(false);
  const backgroundWatchersEnabledRef = React.useRef(true);
  const backgroundSymbolCacheRef = React.useRef<Map<string, string>>(new Map());
  const backgroundWatcherLastTickAtRef = React.useRef<number | null>(null);
  const setupWatcherLastEvalAtRef = React.useRef<number | null>(null);
  const setupWatcherLastSignalAtRef = React.useRef<number | null>(null);
  const healthSnapshotRef = React.useRef<HealthSnapshot | null>(null);
  const lastSuccessfulSignalScanAtRef = React.useRef<number | null>(null);
  const schedulerCircuitPausedRef = React.useRef<boolean>(false);
  const agentDriftReportsRef = React.useRef<ReturnType<typeof computeAgentDriftReports>>([]);
  const autoPilotStateRef = React.useRef<AutoPilotStateSnapshot | null>(null);
  const buildHealthSnapshotRef = React.useRef<(() => HealthSnapshot) | null>(null);
  const lastHealthAuditAtRef = React.useRef<number>(0);
  const recoveryAppliedRef = React.useRef<boolean>(false);
  const driftActionRef = React.useRef<Map<string, number>>(new Map());
  const driftRetestRef = React.useRef<Map<string, number>>(new Map());
  const driftRetestInFlightRef = React.useRef<Set<string>>(new Set());
  const appendAuditEventRef = React.useRef<((event: {
    eventType: string;
    level?: 'info' | 'warn' | 'error';
    symbol?: string | null;
    runId?: string | null;
    toolId?: string | null;
    decisionId?: string | null;
    executionId?: string | null;
    brokerResponseId?: string | null;
    correlationId?: string | null;
    payload?: Record<string, any> | null;
  }) => void) | null>(null);
  const truthProjectionRef = React.useRef<TruthProjection | null>(null);
  const truthProjectionUpdatedAtRef = React.useRef<number>(0);
  const truthBrokerSnapshotAtRef = React.useRef<number>(0);
  const truthBrokerQuotesAtRef = React.useRef<number>(0);
  const truthBrokerStreamAtRef = React.useRef<number>(0);
  const truthBrokerStreamStatusRef = React.useRef<string | null>(null);
  const truthBrokerStatusRef = React.useRef<string | null>(null);
  const brokerRateLimitLastAtRef = React.useRef<number | null>(null);
  const brokerRateLimitLastMessageRef = React.useRef<string | null>(null);
  const truthChartSessionAtRef = React.useRef<Map<string, number>>(new Map());
  const signalOutcomeTriggerRef = React.useRef<(() => void) | null>(null);
  const resolveTradeLockerSymbolRef = React.useRef<((symbol: string) => Promise<string>) | null>(null);
  const brokerSymbolCacheRef = React.useRef<Map<string, { value: string; atMs: number }>>(new Map());
  const activeBrokerIdRef = React.useRef<{ id: BrokerId | null; updatedAtMs: number } | null>(null);
  const executionQueueRef = React.useRef<ExecutionQueueItem[]>([]);
  const executionQueueInFlightRef = React.useRef<number>(0);
  const executionQueueDrainScheduledRef = React.useRef<boolean>(false);
  const executionQueueDrainRef = React.useRef<(() => void) | null>(null);
  const executionQueueKnownRef = React.useRef<Set<string>>(new Set());
  const executionQueueRehydratedRef = React.useRef<boolean>(false);
  const perfStatsRef = React.useRef<PerfStats>({
    windowStartMs: Date.now(),
    auditEvents: 0,
    brokerRequests: 0,
    brokerResponses: 0,
    brokerTimeouts: 0,
    brokerRateLimits: 0,
    quoteUpdates: 0,
    quoteIngests: 0,
    backgroundWatcherTicks: 0,
    backgroundWatcherLastDurationMs: null,
    signalScans: 0,
    signalScanLastDurationMs: null,
    chartRefreshRequests: 0,
    chartRefreshCoalesced: 0,
    patternWatchSyncCoalesced: 0,
    chartRefreshRuns: 0,
    chartRefreshLastDurationMs: null,
    signalSnapshotWarmups: 0,
    signalSnapshotWarmupTimeouts: 0,
    signalSnapshotWarmupLastDurationMs: null
  });
  const auditThrottleRef = React.useRef<Map<string, number>>(new Map());

  const sanitizeBrokerArgs = useCallback((method: string, args: any) => {
    const payload: Record<string, any> = { method };
    if (!args || typeof args !== 'object') return payload;
    const symbol = args.symbol || args.symbols || args.instrument || args.ticker;
    if (symbol != null) payload.symbol = symbol;
    if (args.timeframe != null) payload.timeframe = args.timeframe;
    if (args.resolution != null) payload.resolution = args.resolution;
    if (args.from != null) payload.from = args.from;
    if (args.to != null) payload.to = args.to;
    if (args.limit != null) payload.limit = args.limit;
    if (args.query != null) payload.query = args.query;
    if (args.routeId != null) payload.routeId = args.routeId;
    if (args.accountId != null) payload.accountId = args.accountId;
    return payload;
  }, []);

  const resolveActiveBrokerId = useCallback(async () => {
    const cached = activeBrokerIdRef.current;
    const now = Date.now();
    if (cached && now - cached.updatedAtMs < ACTIVE_BROKER_CACHE_TTL_MS) {
      return cached.id;
    }
    const brokerApi = (window as any)?.glass?.broker;
    if (!brokerApi?.getActive) return cached?.id ?? null;
    try {
      const res = await brokerApi.getActive();
      const activeRaw = String(res?.activeId || '').toLowerCase();
      const id = activeRaw === 'tradelocker' ? 'tradelocker' : activeRaw === 'mt5' ? 'mt5' : null;
      activeBrokerIdRef.current = { id, updatedAtMs: Date.now() };
      return id;
    } catch {
      return cached?.id ?? null;
    }
  }, []);

  type PerfCounterKey = Exclude<keyof PerfStats, 'windowStartMs'>;

  const recordPerf = useCallback((key: PerfCounterKey, value?: number) => {
    const stats = perfStatsRef.current;
    if (key.endsWith('DurationMs')) {
      (stats as any)[key] = value ?? null;
      return;
    }
    const delta = Number.isFinite(Number(value)) ? Number(value) : 1;
    (stats as any)[key] = Number((stats as any)[key] || 0) + delta;
  }, []);

  const snapshotPerf = useCallback((now: number) => {
    const stats = perfStatsRef.current;
    const windowMs = Math.max(0, now - stats.windowStartMs);
    if (windowMs > PERF_WINDOW_MS) {
      stats.windowStartMs = now;
      stats.auditEvents = 0;
      stats.brokerRequests = 0;
      stats.brokerResponses = 0;
      stats.brokerTimeouts = 0;
      stats.brokerRateLimits = 0;
      stats.quoteUpdates = 0;
      stats.quoteIngests = 0;
      stats.backgroundWatcherTicks = 0;
      stats.signalScans = 0;
      stats.chartRefreshRequests = 0;
      stats.chartRefreshCoalesced = 0;
      stats.patternWatchSyncCoalesced = 0;
      stats.chartRefreshRuns = 0;
      stats.signalSnapshotWarmups = 0;
      stats.signalSnapshotWarmupTimeouts = 0;
      brokerQueueMetrics.reset();
    }
    const queueMetrics = brokerQueueMetrics.snapshot();
    const coordinatorStats = brokerRequestCoordinator.getStats();
    return {
      windowMs,
      auditEvents: stats.auditEvents,
      brokerRequests: stats.brokerRequests,
      brokerResponses: stats.brokerResponses,
      brokerTimeouts: stats.brokerTimeouts,
      brokerRateLimits: stats.brokerRateLimits,
      brokerQueueDepth: brokerQueue.length,
      brokerQueueMaxDepth: queueMetrics.maxDepth,
      brokerQueueMaxWaitMs: queueMetrics.maxWaitMs,
      brokerInFlight,
      quoteUpdates: stats.quoteUpdates,
      quoteIngests: stats.quoteIngests,
      backgroundWatcherTicks: stats.backgroundWatcherTicks,
      backgroundWatcherLastDurationMs: stats.backgroundWatcherLastDurationMs,
      signalScans: stats.signalScans,
      signalScanLastDurationMs: stats.signalScanLastDurationMs,
      chartRefreshRequests: stats.chartRefreshRequests,
      chartRefreshCoalesced: stats.chartRefreshCoalesced,
      patternWatchSyncCoalesced: stats.patternWatchSyncCoalesced,
      chartRefreshRuns: stats.chartRefreshRuns,
      chartRefreshLastDurationMs: stats.chartRefreshLastDurationMs,
      signalSnapshotWarmups: stats.signalSnapshotWarmups,
      signalSnapshotWarmupTimeouts: stats.signalSnapshotWarmupTimeouts,
      signalSnapshotWarmupLastDurationMs: stats.signalSnapshotWarmupLastDurationMs,
      brokerCoordinatorRequests: coordinatorStats.requests,
      brokerCoordinatorExecutions: coordinatorStats.executions,
      brokerCoordinatorCacheHits: coordinatorStats.cacheHits,
      brokerCoordinatorDedupeHits: coordinatorStats.dedupeHits,
      brokerCoordinatorCacheHitRate: coordinatorStats.cacheHitRate,
      brokerCoordinatorDedupeRate: coordinatorStats.dedupeRate
    };
  }, []);

  const syncSimQuote = useCallback((quote: any) => {
    const broker = (window as any)?.glass?.broker;
    if (!broker?.request || !quote || typeof quote !== 'object') return;
    const symbol = String(quote.symbol || '').trim();
    if (!symbol) return;
    const payload = {
      symbol,
      bid: quote.bid ?? null,
      ask: quote.ask ?? null,
      mid: quote.mid ?? null,
      last: quote.last ?? null,
      fetchedAtMs: quote.fetchedAtMs ?? null,
      timestampMs: quote.timestampMs ?? null
    };
    void requestBroker('setQuote', payload, { brokerId: 'sim' });
  }, []);

  const syncSimHistorySeries = useCallback((args: any, res: any) => {
    const broker = (window as any)?.glass?.broker;
    if (!broker?.request || !res?.ok || !Array.isArray(res?.bars)) return;
    const symbol = String(args?.symbol || res?.symbol || '').trim();
    const resolution = String(args?.resolution || args?.timeframe || res?.resolution || res?.timeframe || '').trim();
    if (!symbol || !resolution) return;
    const bars = res.bars.slice(-2000);
    const payload = {
      symbol,
      resolution,
      bars,
      fetchedAtMs: res?.fetchedAtMs ?? null
    };
    void requestBroker('setHistorySeries', payload, { brokerId: 'sim' });
  }, []);

  const requestBrokerWithAudit = useCallback(async (
    method: string,
    args?: any,
    meta?: { symbol?: string | null; runId?: string | null; source?: string | null; brokerId?: BrokerId | null }
  ) => {
    const logger = appendAuditEventRef.current;
    const payload = sanitizeBrokerArgs(method, args);
    const sourceTag = String(meta?.source || 'other').trim() || 'other';
    const requestedBrokerId =
      meta?.brokerId === 'mt5' || meta?.brokerId === 'tradelocker'
        ? meta.brokerId
        : null;
    const symbol = meta?.symbol ?? payload.symbol ?? null;
    const runId = meta?.runId ?? null;
    const isSnapshotMethod = TRADELOCKER_SNAPSHOT_METHODS.has(method);
    const resolveSnapshotKey = () => {
      const fn = resolveSnapshotSourceKeyRef.current;
      return fn ? fn() : null;
    };
    const resolveSnapshotFallback = (currentKey: string | null) => {
      const fn = resolveSnapshotFallbackOrderRef.current;
      return fn ? fn(currentKey) : [];
    };
    const ensureAccount = async (accountKey: string, reason?: string) => {
      const fn = ensureTradeLockerAccountRef.current;
      if (!fn) return { ok: false as const, error: 'TradeLocker account switching unavailable.' };
      return fn(accountKey, reason);
    };
    let accountKeyHint: string | null = isSnapshotMethod ? resolveSnapshotKey() : null;
    const resolveSymbolCached = async (raw: string, brokerId: BrokerId | null) => {
      const input = String(raw || '').trim();
      if (!input) return input;
      if (!brokerId) return input;
      const cacheKey = `${brokerId}:${input}`;
      const cache = brokerSymbolCacheRef.current;
      const cached = cache.get(cacheKey);
      const now = Date.now();
      if (cached && now - cached.atMs < 10 * 60 * 1000) return cached.value;
      const linkCfg = brokerLinkConfigRef.current || DEFAULT_BROKER_LINK_CONFIG;
      const tlResolver = resolveTradeLockerSymbolRef.current;
      const adapter = brokerId === 'mt5'
        ? createMt5Adapter()
        : brokerId === 'tradelocker'
          ? createTradeLockerAdapter({
              api: (window as any)?.glass?.tradelocker,
              resolveSymbol: tlResolver ? (symbol) => tlResolver(symbol) : undefined
            })
          : null;
      if (!adapter) return input;
      try {
        const resolved = await resolveBrokerSymbol({
          symbol: input,
          brokerId,
          config: linkCfg,
          adapter
        });
        const cleaned = String(resolved || '').trim() || input;
        cache.set(cacheKey, { value: cleaned, atMs: now });
        return cleaned;
      } catch {
        return input;
      }
    };
    let argsResolved = args;
    if (args && typeof args === 'object') {
      const brokerHint = requestedBrokerId || (isSnapshotMethod ? 'tradelocker' : await resolveActiveBrokerId());
      const next: Record<string, any> = { ...(args as any) };
      let changed = false;
      if (typeof next.symbol === 'string' && next.symbol.trim()) {
        const resolved = await resolveSymbolCached(next.symbol, brokerHint);
        if (resolved && resolved !== next.symbol) {
          next.symbol = resolved;
          changed = true;
        }
      }
      if (Array.isArray(next.symbols)) {
        const resolvedList = await Promise.all(next.symbols.map((sym: any) => resolveSymbolCached(sym, brokerHint)));
        if (resolvedList.length === next.symbols.length) {
          const changedList = resolvedList.some((sym, idx) => String(sym || '') !== String(next.symbols[idx] || ''));
          if (changedList) {
            next.symbols = resolvedList;
            changed = true;
          }
        }
      }
      if (typeof next.instrument === 'string' && next.instrument.trim()) {
        const resolved = await resolveSymbolCached(next.instrument, brokerHint);
        if (resolved && resolved !== next.instrument) {
          next.instrument = resolved;
          changed = true;
        }
      }
      if (typeof next.ticker === 'string' && next.ticker.trim()) {
        const resolved = await resolveSymbolCached(next.ticker, brokerHint);
        if (resolved && resolved !== next.ticker) {
          next.ticker = resolved;
          changed = true;
        }
      }
      if (changed) argsResolved = next;
    }
    const blocked = brokerCircuitBreaker.shouldBlock({ method, source: sourceTag });
    if (blocked.blocked) {
      const message = blocked.reason || `Broker request suppressed for ${Math.max(1, Math.ceil(blocked.retryAfterMs / 1000))}s.`;
      appendLiveError({
        source: 'broker.request',
        level: 'warn',
        message,
        detail: {
          method,
          source: sourceTag,
          blocked: true,
          retryAfterMs: blocked.retryAfterMs,
          ...payload
        }
      });
      if (logger) {
        logger({
          eventType: 'broker_error',
          symbol,
          runId,
          payload: {
            ...payload,
            source: sourceTag,
            accountKey: accountKeyHint,
            ok: false,
            error: message,
            blocked: true,
            retryAfterMs: blocked.retryAfterMs
          }
        });
      }
      return {
        ok: false,
        error: message,
        blocked: true,
        retryAfterMs: blocked.retryAfterMs
      };
    }
    recordPerf('brokerRequests');
    if (logger) {
      logger({
        eventType: 'broker_request',
        symbol,
        runId,
        payload: {
          ...payload,
          source: sourceTag,
          accountKey: accountKeyHint
        }
      });
    }
    const runRequest = async () => {
      const accountMap = tlAccountMapRef.current;
      if (isSnapshotMethod && accountMap.size > 0) {
        const snapshotKey = accountKeyHint || resolveSnapshotKey();
        if (snapshotKey) {
          accountKeyHint = snapshotKey;
          await ensureAccount(snapshotKey, 'broker_request');
        }
      }
      return requestBroker(method, argsResolved, {
        brokerId: requestedBrokerId,
        source: sourceTag
      });
    };

    const runWithAccountLock = async <T,>(fn: () => Promise<T> | T) => {
      const previous = tradeLockerAccountLockRef.current;
      let release: (() => void) | null = null;
      tradeLockerAccountLockRef.current = new Promise((resolve) => {
        release = resolve;
      });
      await previous;
      tradeLockerAccountBusyRef.current = true;
      try {
        return await fn();
      } finally {
        tradeLockerAccountBusyRef.current = false;
        if (release) release();
      }
    };

    const getActiveAccountKey = () => {
      const fn = getTradeLockerAccountKeyRef.current;
      return fn ? fn() : null;
    };
    const activeKey = getActiveAccountKey();
    const desiredKey = isSnapshotMethod ? (accountKeyHint || resolveSnapshotKey()) : null;
    if (desiredKey) accountKeyHint = desiredKey;
    const needsSwitch = !!(isSnapshotMethod && desiredKey && activeKey && desiredKey !== activeKey);

    let res = needsSwitch
      ? await runWithAccountLock(runRequest)
      : await runRequest();

    if (isSnapshotMethod && tlSnapshotAutoSwitchRef.current && res?.ok === false) {
      const now = Date.now();
      const lastSwitchAt = tlSnapshotAutoSwitchAtRef.current || 0;
      if (now - lastSwitchAt > 15_000) {
        const currentKey = accountKeyHint || resolveSnapshotKey();
        const fallbackOrder = resolveSnapshotFallback(currentKey);
        const nextKey = fallbackOrder.length > 0 ? fallbackOrder[0] : null;
        if (nextKey) {
          tlSnapshotAutoSwitchAtRef.current = now;
          res = await runWithAccountLock(async () => {
            const switchRes = await ensureAccount(nextKey, 'snapshot_autoswitch');
            if (!switchRes.ok) return res;
            accountKeyHint = nextKey;
            const retry = await requestBroker(method, argsResolved, {
              brokerId: requestedBrokerId,
              source: sourceTag
            });
            if (retry?.ok !== false) {
              setTlSnapshotSourceKey(nextKey);
            }
            return retry;
          });
        }
      }
    }
    recordPerf('brokerResponses');
    if (res?.timeout) {
      recordPerf('brokerTimeouts');
    }
    const errorMessage = res?.ok === false && res?.error ? String(res.error) : null;
    const retryAtMs = Number(res?.retryAtMs || 0);
    const rateLimitedUntilMs = Number(res?.rateLimitedUntilMs || 0);
    const retryAfterMsRaw = Number(res?.retryAfterMs || 0);
    const retryAfterMs = Number.isFinite(retryAfterMsRaw) && retryAfterMsRaw > 0 ? retryAfterMsRaw : 0;
    const isRateLimited =
      res?.rateLimited === true ||
      (errorMessage ? /429|rate limit|too many requests/i.test(errorMessage) : false);
    if (res?.ok === false) {
      brokerCircuitBreaker.noteFailure(
        { method, source: sourceTag },
        {
          error: errorMessage,
          rateLimited: isRateLimited,
          retryAfterMs:
            (Number.isFinite(rateLimitedUntilMs) && rateLimitedUntilMs > Date.now()) ? (rateLimitedUntilMs - Date.now()) :
            (Number.isFinite(retryAtMs) && retryAtMs > Date.now()) ? (retryAtMs - Date.now()) :
            retryAfterMs > 0 ? retryAfterMs : null
        }
      );
      if (isRateLimited) {
        const now = Date.now();
        const suppressUntil =
          (Number.isFinite(rateLimitedUntilMs) && rateLimitedUntilMs > now) ? rateLimitedUntilMs :
          (Number.isFinite(retryAtMs) && retryAtMs > now) ? retryAtMs :
          retryAfterMs > 0 ? (now + retryAfterMs) :
          now + 8_000;
        setBrokerRateLimitSuppressUntilMs((prev) => Math.max(Number(prev || 0), suppressUntil));
        brokerRateLimitLastAtRef.current = now;
        brokerRateLimitLastMessageRef.current = errorMessage || `${method} rate-limited`;
        recordPerf('brokerRateLimits');
      }
      appendLiveError({
        source: 'broker.request',
        level: 'warn',
        message: errorMessage || `${method} failed`,
        detail: {
          method,
          source: sourceTag,
          ...payload,
          ok: false
        }
      });
    } else {
      brokerCircuitBreaker.noteSuccess({ method, source: sourceTag });
    }
    if (logger) {
      logger({
        eventType: res?.ok === false ? 'broker_error' : 'broker_response',
        symbol,
        runId,
        payload: {
          ...payload,
          source: sourceTag,
          accountKey: accountKeyHint,
          ok: res?.ok !== false,
          error: res?.ok === false ? String(res?.error || '') : null
        }
      });
    }
    if (res?.ok) {
      const sourceBroker = res?.brokerId || res?.sourceBroker || null;
      if (sourceBroker && sourceBroker !== 'sim') {
        if (method === 'getQuote' && res?.quote) {
          syncSimQuote(res.quote);
        } else if (method === 'getQuotes' && res?.quotes) {
          const list = Array.isArray(res.quotes)
            ? res.quotes
            : typeof res.quotes === 'object'
              ? Object.values(res.quotes)
              : [];
          for (const quote of list) {
            syncSimQuote(quote);
          }
        } else if (method === 'getHistorySeries' && Array.isArray(res?.bars)) {
          syncSimHistorySeries(argsResolved, res);
        }
      }
    }
    return res;
  }, [
    appendLiveError,
    recordPerf,
    resolveActiveBrokerId,
    sanitizeBrokerArgs,
    syncSimHistorySeries,
    syncSimQuote
  ]);

  const chartPersistence = React.useMemo<ChartPersistence>(() => {
    const normalizeWatch = (entry: any): ChartWatchConfig | null => {
      if (!entry) return null;
      const payload = entry.payload && typeof entry.payload === 'object' ? entry.payload : {};
      const keyRaw = String(entry.key || payload.key || payload.watchId || entry.id || '').trim();
      const watchId = keyRaw.replace(/^chart_watch:/, '') || String(payload.watchId || '').trim();
      const symbol = String(payload.symbol || entry.symbol || '').trim();
      const timeframe = String(payload.timeframe || entry.timeframe || '').trim();
      if (!watchId || !symbol || !timeframe) return null;
      const detectors = Array.isArray(payload.detectorsEnabled) ? payload.detectorsEnabled : undefined;
      return {
        watchId,
        symbol,
        timeframe,
        detectorsEnabled: detectors,
        enabled: payload.enabled !== false,
        createdAtMs: Number(payload.createdAtMs || entry.createdAtMs) || Date.now(),
        updatedAtMs: Number(payload.updatedAtMs || entry.updatedAtMs) || Date.now(),
        source: payload.source || entry.source || null
      };
    };

    const normalizeEvent = (entry: any): PatternEvent | null => {
      if (!entry) return null;
      const payload = entry.payload && typeof entry.payload === 'object' ? entry.payload : {};
      const id = String(payload.id || entry.key || entry.id || '').trim();
      const symbol = String(payload.symbol || entry.symbol || '').trim();
      const timeframe = String(payload.timeframe || entry.timeframe || '').trim();
      const type = String(payload.type || payload.eventType || '').trim();
      const ts = Number(payload.ts || payload.timestamp || entry.updatedAtMs || entry.createdAtMs);
      if (!id || !symbol || !timeframe || !type || !Number.isFinite(ts)) return null;
      return {
        id,
        watchId: payload.watchId || null,
        symbol,
        timeframe,
        ts,
        type,
        strength: payload.strength ?? null,
        payload: payload.payload ?? payload
      };
    };

    return {
      loadWatches: async () => {
        const ledger = window.glass?.tradeLedger;
        if (!ledger?.listAgentMemory) return [];
        const res = await ledger.listAgentMemory({ limit: 200, kind: 'chart_watch' });
        if (!res?.ok || !Array.isArray(res.memories)) return [];
        return res.memories.map(normalizeWatch).filter(Boolean) as ChartWatchConfig[];
      },
      saveWatch: async (watch) => {
        const ledger = window.glass?.tradeLedger;
        if (!ledger?.upsertAgentMemory) return;
        const key = `chart_watch:${watch.watchId}`;
        const summary = `${watch.symbol} ${watch.timeframe}`;
        await ledger.upsertAgentMemory({
          key,
          familyKey: `chart_watch:${watch.symbol}`,
          scope: 'shared',
          category: 'chart',
          subcategory: 'watch',
          kind: 'chart_watch',
          symbol: watch.symbol,
          timeframe: watch.timeframe,
          summary: `Chart watch ${summary}`,
          payload: watch,
          source: watch.source || 'ui',
          tags: [watch.symbol, watch.timeframe, 'chart', 'watch'].filter(Boolean)
        });
      },
      deleteWatch: async (watchId) => {
        const ledger = window.glass?.tradeLedger;
        if (!ledger?.deleteAgentMemory) return;
        await ledger.deleteAgentMemory({ key: `chart_watch:${watchId}` });
      },
      listEvents: async ({ limit } = {}) => {
        const ledger = window.glass?.tradeLedger;
        if (!ledger?.listAgentMemory) return [];
        const lim = Number.isFinite(Number(limit)) ? Math.max(1, Math.min(500, Math.floor(Number(limit)))) : 200;
        const res = await ledger.listAgentMemory({ limit: lim, kind: 'chart_event' });
        if (!res?.ok || !Array.isArray(res.memories)) return [];
        return res.memories.map(normalizeEvent).filter(Boolean) as PatternEvent[];
      },
      appendEvent: async (event) => {
        const ledger = window.glass?.tradeLedger;
        if (!ledger?.upsertAgentMemory) return;
        const key = String(event.id || '').trim();
        if (!key) return;
        await ledger.upsertAgentMemory({
          key,
          familyKey: `chart_event:${event.symbol}:${event.timeframe}`,
          scope: 'shared',
          category: 'chart',
          subcategory: 'event',
          kind: 'chart_event',
          symbol: event.symbol,
          timeframe: event.timeframe,
          summary: `Pattern ${event.type} ${event.symbol} ${event.timeframe}`,
          payload: event,
          source: 'chart_engine',
          tags: [event.symbol, event.timeframe, event.type, 'chart', 'event'].filter(Boolean)
        });
      }
    };
  }, []);

  const resolveActiveRunContext = useCallback((symbol?: string | null, timeframe?: string | null) => {
    const symbolKey = symbol ? normalizeSymbolKey(symbol) : '';
    const timeframeKey = timeframe ? normalizeTimeframeKey(timeframe) : '';
    const matches = (ctx?: { symbol?: string; timeframe?: string } | null) => {
      if (!ctx) return false;
      if (symbolKey && normalizeSymbolKey(ctx.symbol || '') !== symbolKey) return false;
      if (timeframeKey && normalizeTimeframeKey(ctx.timeframe || '') !== timeframeKey) return false;
      return true;
    };

    const actionCtx = taskTreeStateRef.current?.action?.current?.context || null;
    if (matches(actionCtx)) return { runId: actionCtx?.runId || null, source: actionCtx?.source || null };

    const signalCtx = taskTreeStateRef.current?.signal?.current?.context || null;
    if (matches(signalCtx)) return { runId: signalCtx?.runId || null, source: signalCtx?.source || null };

    const playbookRun = taskPlaybookActiveRunRef.current;
    if (playbookRun && matches(playbookRun)) {
      return { runId: playbookRun.runId || null, source: 'playbook' };
    }

    const pickQueued = (queue: any[] | null | undefined) => {
      if (!Array.isArray(queue) || queue.length === 0) return null;
      let best: { runId: string | null; source: string | null; ts: number } | null = null;
      for (const job of queue) {
        if (!job) continue;
        const ctx = job.context || job?.payload?.context || null;
        if (!matches(ctx)) continue;
        const runId = ctx?.runId ? String(ctx.runId) : (job.runId ? String(job.runId) : '');
        if (!runId) continue;
        const tsRaw = Number(job.enqueuedAtMs || ctx?.createdAtMs || 0);
        const ts = Number.isFinite(tsRaw) ? tsRaw : 0;
        if (!best || ts > best.ts) {
          best = { runId, source: ctx?.source ? String(ctx.source) : null, ts };
        }
      }
      return best;
    };

    const queuedAction = pickQueued(taskTreeStateRef.current?.action?.queue);
    const queuedSignal = pickQueued(taskTreeStateRef.current?.signal?.queue);
    const queued = queuedAction && queuedSignal
      ? (queuedAction.ts >= queuedSignal.ts ? queuedAction : queuedSignal)
      : queuedAction || queuedSignal;
    if (queued) return { runId: queued.runId || null, source: queued.source || null };

    return null;
  }, []);

  const chartEngineOnUpdate = useCallback((update: { sessionId: string; revision: number; updatedAtMs: number | null; event?: PatternEvent | null }) => {
    const logger = appendAuditEventRef.current;
    if (!logger) return;
    const event = update.event;
    if (event) {
      setPatternEvents((prev) => {
        const list = Array.isArray(prev) ? prev : [];
        const exists = event.id ? list.some((entry) => entry?.id === event.id) : false;
        if (exists) return list;
        return [...list, event].slice(-300);
      });
      const runContext = resolveActiveRunContext(event.symbol, event.timeframe);
      logger({
        eventType: 'chart_pattern',
        symbol: event.symbol || null,
        runId: runContext?.runId || null,
        payload: {
          sessionId: update.sessionId,
          timeframe: event.timeframe,
          type: event.type,
          strength: event.strength ?? null,
          ts: event.ts,
          watchId: event.watchId || null,
          details: event.payload || null,
          runId: runContext?.runId || null,
          source: runContext?.source || null
        }
      });
      return;
    }

    const ts = Number(update.updatedAtMs || 0) || Date.now();
    const last = truthChartSessionAtRef.current.get(update.sessionId) || 0;
    if (ts - last < 15_000) return;
    truthChartSessionAtRef.current.set(update.sessionId, ts);
    logger({
      eventType: 'chart_update',
      payload: {
        sessionId: update.sessionId,
        revision: update.revision,
        updatedAtMs: ts
      }
    });
    const trigger = signalOutcomeTriggerRef.current;
    if (trigger) {
      try {
        trigger();
      } catch {
        // ignore
      }
    }
  }, [resolveActiveRunContext]);

  const chartHistorySeriesFetcher = React.useMemo(() => {
    return createSnapshotHistoryFetcher({
      fetcher: (args) =>
        requestBrokerWithAudit('getHistorySeries', { ...args, aggregate: args?.aggregate ?? true }),
      resolvePartition: () => {
        const brokerId = String(activeBrokerIdRef.current?.id || '').trim().toLowerCase() || 'auto';
        const accountKeyFn = getTradeLockerAccountKeyRef.current;
        const accountKey = accountKeyFn ? String(accountKeyFn() || '').trim().toLowerCase() : '';
        return `${brokerId}|${accountKey || 'default'}`;
      }
    });
  }, [requestBrokerWithAudit]);

  const chartEngine = React.useMemo(() => {
    return new ChartEngine({
      getHistorySeries: chartHistorySeriesFetcher,
      persistence: chartPersistence,
      onUpdate: chartEngineOnUpdate,
      historyFetchConcurrency: CHART_HISTORY_FETCH_CONCURRENCY,
      historyFetchTimeoutMs: CHART_HISTORY_FETCH_TIMEOUT_MS
    });
  }, [chartEngineOnUpdate, chartHistorySeriesFetcher, chartPersistence]);

  const chartRefreshStateRef = React.useRef({
    inFlight: false,
    lastAtMs: 0,
    pending: false,
    pendingFetches: 0
  });

  const requestChartRefresh = useCallback((fetches: number) => {
    const state = chartRefreshStateRef.current;
    const requested = Math.max(1, Math.floor(Number(fetches) || 1));
    recordPerf('chartRefreshRequests');
    const runRefresh = (count: number) => {
      const now = Date.now();
      const capped = Math.max(1, Math.min(6, count));
      if (state.inFlight || now - state.lastAtMs < CHART_REFRESH_MIN_GAP_MS) {
        state.pending = true;
        state.pendingFetches = Math.max(state.pendingFetches, capped);
        recordPerf('chartRefreshCoalesced');
        return;
      }
      state.inFlight = true;
      state.lastAtMs = Date.now();
      recordPerf('chartRefreshRuns');
      const refreshStartedAt = Date.now();
      void chartEngine.refreshStaleSessions(capped).finally(() => {
        recordPerf('chartRefreshLastDurationMs', Date.now() - refreshStartedAt);
        state.inFlight = false;
        if (state.pending) {
          const pendingFetches = state.pendingFetches;
          state.pending = false;
          state.pendingFetches = 0;
          runRefresh(pendingFetches);
        }
      });
    };
    runRefresh(requested);
  }, [chartEngine, recordPerf]);

  const marketData = React.useMemo(() => {
    return createMarketDataService({
      requestQuote: (symbol) => requestBrokerWithAudit('getQuote', { symbol, maxAgeMs: 0 }, { symbol }),
      chartEngine,
      symbolVariants: buildSymbolKeyVariants
    });
  }, [chartEngine, requestBrokerWithAudit]);
  const marketDataRef = React.useRef(marketData);

  useEffect(() => {
    marketDataRef.current = marketData;
  }, [marketData]);

  const patternWatchRefreshCoalescer = React.useMemo(() => {
    return createPatternRefreshCoalescer<{
      entries: Array<{ watchId: string; symbol: string; timeframe: string }>;
      detectors: string[];
    }>({
      delayMs: 180,
      onCoalesced: () => {
        recordPerf('patternWatchSyncCoalesced');
      },
      onRun: async (input) => {
        const entries = Array.isArray(input?.entries) ? input.entries : [];
        const detectors = Array.isArray(input?.detectors) ? input.detectors.filter(Boolean) : [];
        const existing = chartEngine
          .listWatches()
          .filter((watch) => watch.source === 'patterns_panel' || String(watch.watchId || '').startsWith('patterns:'));
        const desiredMap = new Map<string, { symbol: string; timeframe: string }>();
        for (const entry of entries) desiredMap.set(entry.watchId, { symbol: entry.symbol, timeframe: entry.timeframe });

        for (const watch of existing) {
          if (!watch?.watchId) continue;
          if (!desiredMap.has(watch.watchId)) {
            await chartEngine.removeWatch(watch.watchId);
          }
        }

        for (const entry of entries) {
          await chartEngine.addWatch({
            watchId: entry.watchId,
            symbol: entry.symbol,
            timeframe: entry.timeframe,
            detectorsEnabled: detectors,
            enabled: true,
            source: 'patterns_panel'
          });
        }

        if (entries.length > 0) {
          const fetches = Math.max(1, Math.min(4, entries.length));
          requestChartRefresh(fetches);
        }
      }
    });
  }, [chartEngine, recordPerf, requestChartRefresh]);

  useEffect(() => {
    return () => {
      patternWatchRefreshCoalescer.dispose();
    };
  }, [patternWatchRefreshCoalescer]);

  useEffect(() => {
    const symbols = patternWatchSymbols.filter(Boolean);
    const timeframes = patternWatchTimeframes.filter(Boolean);
    const detectors = patternDetectorsResolved.filter(Boolean);
    const desired: Array<{ watchId: string; symbol: string; timeframe: string }> = [];
    for (const symbol of symbols) {
      for (const timeframe of timeframes) {
        const symbolKey = String(symbol || '').trim();
        desired.push({
          watchId: `patterns:${symbolKey}:${normalizeTimeframeKey(timeframe)}`,
          symbol: symbolKey,
          timeframe
        });
      }
    }

    const capped = desired.slice(0, PATTERN_WATCH_LIMIT);
    const truncated = Math.max(0, desired.length - capped.length);
    setPatternWatchSummary({ watchCount: capped.length, truncated });

    if (truncated > 0) {
      const now = Date.now();
      if (now - patternWatchWarningRef.current > 15_000) {
        patternWatchWarningRef.current = now;
        addNotification(
          'Patterns Watch Limit',
          `Watching ${capped.length} of ${desired.length} pattern streams. Reduce symbols/timeframes to include all.`,
          'warning'
        );
      }
    }

    patternWatchRefreshCoalescer.schedule({
      entries: capped,
      detectors
    });
  }, [addNotification, patternDetectorsResolved, patternWatchSymbols, patternWatchTimeframes, patternWatchRefreshCoalescer]);

  useEffect(() => {
    if (!patternAutoRefreshEnabled) return;
    if (patternRefreshMode === 'bar') return;
    const intervalMs = Math.max(10_000, Math.min(600_000, Number(patternRefreshIntervalMs) || DEFAULT_PATTERN_REFRESH_MS));
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs,
        onTick: () => {
          const fetches = Math.max(1, Math.min(4, patternWatchSummary.watchCount || 1));
          requestChartRefresh(fetches);
        }
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [patternAutoRefreshEnabled, patternRefreshIntervalMs, patternRefreshMode, patternWatchSummary.watchCount, requestChartRefresh]);

  const ingestBrokerQuote = useCallback((quote: TradeLockerQuote) => {
    const market = marketDataRef.current;
    if (!quote || !market) return;
    const symbol = String(quote.symbol || '').trim();
    if (!symbol) return;
    recordPerf('quoteUpdates');
    const now = Date.now();
    const ts = Number(quote.timestampMs ?? quote.fetchedAtMs ?? now);
    const key = normalizeSymbolLoose(symbol);
    if (!key) return;
    const last = chartEngineQuoteRef.current.get(key) || 0;
    if (Number.isFinite(ts) && ts <= last) return;
    if (Number.isFinite(ts)) chartEngineQuoteRef.current.set(key, ts);
    market.ingestQuote({
      symbol,
      tradableInstrumentId: quote.tradableInstrumentId ?? null,
      routeId: quote.routeId ?? null,
      bid: quote.bid ?? null,
      ask: quote.ask ?? null,
      last: quote.last ?? null,
      mid: quote.mid ?? null,
      bidSize: quote.bidSize ?? null,
      askSize: quote.askSize ?? null,
      spread: quote.spread ?? null,
      timestampMs: quote.timestampMs ?? null,
      fetchedAtMs: quote.fetchedAtMs ?? null
    });
    syncSimQuote(quote);
    const getKey = getTradeLockerAccountKeyRef.current;
    const upsertQuote = upsertTradeLockerAccountQuoteRef.current;
    const activeKey = getKey ? getKey() : null;
    if (activeKey && upsertQuote) {
      upsertQuote(activeKey, quote);
    }
    recordPerf('quoteIngests');
  }, [recordPerf, syncSimQuote]);

  const [agentMemoryUpdatedAtMs, setAgentMemoryUpdatedAtMs] = useState<number | null>(null);
  const [agentMemoryError, setAgentMemoryError] = useState<string | null>(null);
  const [setupWatchers, setSetupWatchers] = useState<SetupWatcher[]>(() => loadSetupWatchers());
  const [watchProfiles, setWatchProfiles] = useState<WatchProfile[]>([]);
  const [setupSignals, setSetupSignals] = useState<SetupSignal[]>([]);
  const [reviewAnnotations, setReviewAnnotations] = useState<ReviewAnnotation[]>([]);
  const [setupRegimes, setSetupRegimes] = useState<Record<string, RegimeSnapshot>>({});
  const [setupRegimeBlocks, setSetupRegimeBlocks] = useState<Record<string, RegimeBlockState>>({});
  const [setupLibraryEntries, setSetupLibraryEntries] = useState<SetupLibraryEntry[]>([]);
  const [taskPlaybooks, setTaskPlaybooks] = useState<TaskPlaybook[]>([]);
  const [taskPlaybookUpdatedAtMs, setTaskPlaybookUpdatedAtMs] = useState<number | null>(null);
  const [taskPlaybookError, setTaskPlaybookError] = useState<string | null>(null);
  const [taskTreeRunsState, setTaskTreeRunsState] = useState<TaskTreeRunEntry[]>([]);
  const [actionTaskTreeRunsState, setActionTaskTreeRunsState] = useState<TaskTreeRunEntry[]>([]);
  const [taskTreeResumeEntries, setTaskTreeResumeEntries] = useState<TaskTreeResumeEntry[]>([]);
  const [recommendedActionFlowsState, setRecommendedActionFlowsState] = useState<ActionFlowRecommendation[]>([]);
  const [setupPerformanceByWatcher, setSetupPerformanceByWatcher] = useState<Record<string, SetupPerformance>>({});
  const [setupPerformanceByLibrary, setSetupPerformanceByLibrary] = useState<Record<string, SetupPerformance>>({});
  const [setupPerformanceByMode, setSetupPerformanceByMode] = useState<Record<string, SetupPerformance>>({});
  const [setupPerformanceBySymbol, setSetupPerformanceBySymbol] = useState<Record<string, SetupPerformance>>({});
  const [setupPerformanceSummary, setSetupPerformanceSummary] = useState<SetupPerformance | null>(null);
  const [healthSnapshot, setHealthSnapshot] = useState<HealthSnapshot | null>(null);
  const [truthProjection, setTruthProjection] = useState<TruthProjection | null>(null);
  const [playbookStatusByWatcher, setPlaybookStatusByWatcher] = useState<Record<string, any>>({});
  const [lossStreakState, setLossStreakState] = useState<{ streak: number; lastClosedAtMs?: number | null; updatedAtMs?: number | null; accountKey?: string | null } | null>(null);
  const [lastTradeBlock, setLastTradeBlock] = useState<TradeBlockInfo | null>(null);
  const [setupPerformanceUpdatedAtMs, setSetupPerformanceUpdatedAtMs] = useState<number | null>(null);
  const [setupPerformanceError, setSetupPerformanceError] = useState<string | null>(null);
  const [shadowTradeStats, setShadowTradeStats] = useState<ShadowTradeStats | null>(null);
  const shadowTradeStatsRef = React.useRef<ShadowTradeStats | null>(null);
  const shadowOpenTradesRef = React.useRef<Map<string, any>>(new Map());
  const shadowTradePollAtRef = React.useRef<number>(0);
  const [shadowTradeCompare, setShadowTradeCompare] = useState<ShadowTradeCompareSummary | null>(null);
  const shadowTradeCompareRef = React.useRef<ShadowTradeCompareSummary | null>(null);
  const shadowTradeCompareAtRef = React.useRef<number>(0);
  const lastTradeBlockRef = React.useRef<TradeBlockInfo | null>(null);
  const shadowLedgerCacheRef = React.useRef<{ atMs: number; entries: any[] } | null>(null);
  const shadowProfilesRef = React.useRef<ShadowProfile[]>([]);
  const shadowAccountsRef = React.useRef<ShadowAccountSnapshot[]>([]);
  const shadowTradeViewsRef = React.useRef<ShadowTradeView[]>([]);
  const mt5AccountSpecRef = React.useRef<BrokerAccountSpec | null>(null);
  const shadowOutcomeSyncedRef = React.useRef<Map<string, number>>(new Map());
  const setupLibraryRef = React.useRef<SetupLibraryEntry[]>([]);
  const taskPlaybooksRef = React.useRef<TaskPlaybook[]>([]);
  const taskPlaybookRunsRef = React.useRef<TaskPlaybookRun[]>([]);
  const agentTestPendingRef = React.useRef<Map<string, { scenario: AgentTestScenario; run: AgentTestRun }>>(new Map());
  const taskPlaybookActiveRunRef = React.useRef<TaskPlaybookRun | null>(null);
  const taskPlaybookUpdatedAtRef = React.useRef(0);
  const [setupLibraryUpdatedAtMs, setSetupLibraryUpdatedAtMs] = useState<number | null>(null);
  const [setupLibraryError, setSetupLibraryError] = useState<string | null>(null);
  const setupWatchersRef = React.useRef<SetupWatcher[]>(setupWatchers);
  const watchProfilesRef = React.useRef<WatchProfile[]>(watchProfiles);
  const watchProfilesByIdRef = React.useRef<Map<string, WatchProfile>>(new Map());
  const setupSignalsRef = React.useRef<SetupSignal[]>(setupSignals);
  const setupSignalStatsRef = React.useRef({ emitted: 0, deduped: 0, throttled: 0, persisted: 0, lastLogAtMs: 0 });
  const setupSignalPruneAtRef = React.useRef(0);
  const actionTracePruneAtRef = React.useRef(0);
  const actionFlowStateRef = React.useRef(new Map<string, {
    intentKey: string;
    intentLabel?: string | null;
    symbol?: string | null;
    timeframe?: string | null;
    sequences: Map<string, { sequence: string[]; count: number; successCount: number; lastSeenAtMs: number }>;
    recent: Array<{ actionId: string; ok: boolean; atMs: number }>;
  }>());
  const actionFlowUpdatedAtRef = React.useRef(0);
  const sidebarModeRef = React.useRef<SidebarMode>('chat');
  const sidebarStateRef = React.useRef<{ isOpen: boolean; mode: SidebarMode }>({ isOpen: false, mode: 'chat' });
  const liveStatusRef = React.useRef({ isLive: false, chartChatIsLive: false });
  useEffect(() => {
    lastTradeBlockRef.current = lastTradeBlock;
  }, [lastTradeBlock]);
  const enqueuePlaybookRunRef = React.useRef<((input: {
    playbookId?: string | null;
    playbook?: TaskPlaybook | null;
    symbol?: string | null;
    timeframe?: string | null;
    timeframes?: string[] | null;
    strategy?: string | null;
    mode?: TaskPlaybookMode | null;
    source?: string | null;
    reason?: string | null;
  }) => { ok: boolean; runId?: string; queued?: boolean; error?: string }) | null>(null);
  const resumePlaybookRunRef = React.useRef<((runId: string, opts?: {
    action?: 'resume' | 'approve' | 'skip' | 'abort';
    stepId?: string | null;
    actionId?: string | null;
    overrides?: {
      symbol?: string;
      timeframe?: string;
      strategy?: string;
      timeframes?: string[];
      data?: Record<string, any>;
    };
  }) => Promise<any>) | null>(null);
  const chatStateRef = React.useRef<{
    isThinking: boolean;
    replyMode: string | null;
    isLive: boolean;
    chartChatIsLive: boolean;
    chartChatThinking: boolean;
    liveMode: string | null;
    autoTabVisionEnabled: boolean;
    chartWatchEnabled: boolean;
    chartWatchMode: string | null;
    chartWatchSnoozedUntilMs: number | null;
    postTradeReviewEnabled: boolean;
    postTradeReviewAgentId: string | null;
    chartWatchLeadAgentId: string | null;
    sessionBias: string | null;
    activeAgentId: string | null;
    agentsCount: number;
    messagesCount: number;
    lastMessageAtMs: number | null;
    chartChatMessagesCount: number;
    chartChatLastMessageAtMs: number | null;
  }>({
    isThinking: false,
    replyMode: null,
    isLive: false,
    chartChatIsLive: false,
    chartChatThinking: false,
    liveMode: null,
    autoTabVisionEnabled: false,
    chartWatchEnabled: false,
    chartWatchMode: null,
    chartWatchSnoozedUntilMs: null,
    postTradeReviewEnabled: false,
    postTradeReviewAgentId: null,
    chartWatchLeadAgentId: null,
    sessionBias: null,
    activeAgentId: null,
    agentsCount: 0,
    messagesCount: 0,
    lastMessageAtMs: null,
    chartChatMessagesCount: 0,
    chartChatLastMessageAtMs: null
  });
  const setupRegimesRef = React.useRef<Record<string, RegimeSnapshot>>(setupRegimes);
  const setupWatcherStateRef = React.useRef<Map<string, any>>(new Map());
  const setupPerformanceFetchAtRef = React.useRef<number>(0);

  const categorizeTruthEvent = useCallback((eventType: string) => {
    const key = String(eventType || '').trim();
    if (!key) return 'other';
    if (key.startsWith('trade_')) return 'trade';
    if (key.startsWith('broker_')) return 'broker';
    if (key.startsWith('chart_')) return 'chart';
    if (key.startsWith('setup_')) return 'setup';
    if (key.startsWith('agent_')) return 'agent';
    if (key.startsWith('task_tree_')) return 'task';
    if (key.startsWith('playbook_')) return 'playbook';
    if (key.startsWith('action_')) return 'action';
    if (key.startsWith('health_')) return 'health';
    return 'other';
  }, []);

  const applyTruthEventToProjection = useCallback((prev: TruthProjection | null, event: TruthEventRecord): TruthProjection => {
    const eventType = String(event?.eventType || '').trim();
    const eventAtMsRaw = Number(
      event?.createdAtMs ??
      event?.payload?.ts ??
      event?.payload?.updatedAtMs ??
      event?.payload?.timestampMs ??
      Date.now()
    );
    const eventAtMs = Number.isFinite(eventAtMsRaw) ? Math.floor(eventAtMsRaw) : Date.now();
    if (!eventType) {
      return prev || { updatedAtMs: eventAtMs, counts: {} };
    }

    const base: TruthProjection = prev ? { ...prev } : { updatedAtMs: eventAtMs, counts: {} };
    const counts = { ...(base.counts || {}) };
    const category = categorizeTruthEvent(eventType);
    counts[category] = (counts[category] || 0) + 1;

    const next: TruthProjection = {
      ...base,
      updatedAtMs: Math.max(base.updatedAtMs || 0, eventAtMs),
      counts
    };

    const lastEventAtMs = Number(base.lastEventAtMs || 0);
    if (!lastEventAtMs || eventAtMs >= lastEventAtMs) {
      next.lastEventAtMs = eventAtMs;
      next.lastEventType = eventType;
      next.lastEvent = { ...event, eventType, createdAtMs: eventAtMs };
    }

    if (category === 'broker') {
      const broker = { ...(base.broker || {}) };
      if (eventType.includes('snapshot')) broker.lastSnapshotAtMs = eventAtMs;
      if (eventType.includes('quotes')) broker.lastQuotesAtMs = eventAtMs;
      if (eventType.includes('stream')) {
        broker.lastStreamAtMs = eventAtMs;
        broker.lastStreamStatus = event?.payload?.status ?? event?.payload?.streamStatus ?? broker.lastStreamStatus ?? null;
      }
      if (eventType === 'broker_status') {
        broker.lastStatus = event?.payload?.status ?? broker.lastStatus ?? null;
      }
      if (event?.level === 'error' && event?.payload?.error) {
        broker.lastError = String(event.payload.error);
      }
      next.broker = broker;
    } else if (category === 'chart') {
      const chart = { ...(base.chart || {}) };
      chart.lastEventAtMs = eventAtMs;
      chart.lastEventType = eventType;
      chart.lastSymbol = event.symbol ?? event?.payload?.symbol ?? chart.lastSymbol ?? null;
      chart.lastTimeframe = event?.payload?.timeframe ?? chart.lastTimeframe ?? null;
      next.chart = chart;
    } else if (category === 'setup') {
      const setup = { ...(base.setup || {}) };
      setup.lastSignalAtMs = eventAtMs;
      setup.lastSignalId = event?.payload?.signalId ?? event?.payload?.id ?? setup.lastSignalId ?? null;
      setup.lastProfileId = event?.payload?.profileId ?? setup.lastProfileId ?? null;
      next.setup = setup;
    } else if (category === 'agent') {
      const agent = { ...(base.agent || {}) };
      agent.lastToolAtMs = eventAtMs;
      agent.lastToolId = event?.toolId ?? event?.payload?.toolId ?? event?.payload?.type ?? agent.lastToolId ?? null;
      next.agent = agent;
    } else if (category === 'task') {
      const task = { ...(base.task || {}) };
      task.lastEventAtMs = eventAtMs;
      task.lastEventType = eventType;
      next.task = task;
    } else if (category === 'playbook') {
      const playbook = { ...(base.playbook || {}) };
      playbook.lastEventAtMs = eventAtMs;
      playbook.lastEventType = eventType;
      next.playbook = playbook;
    } else if (category === 'trade') {
      const trade = { ...(base.trade || {}) };
      trade.lastEventAtMs = eventAtMs;
      trade.lastEventType = eventType;
      next.trade = trade;
    }

    return next;
  }, [categorizeTruthEvent]);

  const hydrateTruthProjection = useCallback((events: TruthEventRecord[]) => {
    const list = Array.isArray(events) ? [...events] : [];
    list.sort((a, b) => (Number(a?.createdAtMs || 0) - Number(b?.createdAtMs || 0)));
    let projection: TruthProjection | null = truthProjectionRef.current || null;
    for (const event of list) {
      if (!event || !event.eventType) continue;
      projection = applyTruthEventToProjection(projection, event);
    }
    if (projection) {
      truthProjectionRef.current = projection;
      truthProjectionUpdatedAtRef.current = projection.updatedAtMs || Date.now();
      setTruthProjection(projection);
    }
  }, [applyTruthEventToProjection]);

  const buildTruthReplay = useCallback(async (input: { runId?: string | null; symbol?: string | null; limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listEvents) return { ok: false, error: 'Truth ledger unavailable.' };
    const runId = input?.runId ? String(input.runId).trim() : '';
    const symbol = input?.symbol ? String(input.symbol).trim() : '';
    const limit = Number.isFinite(Number(input?.limit)) ? Math.max(1, Math.min(5000, Math.floor(Number(input?.limit)))) : 400;
    try {
      const res = await ledger.listEvents({
        limit,
        kind: 'truth_event',
        runId: runId || undefined,
        symbol: symbol || undefined
      });
      if (!res?.ok || !Array.isArray(res.entries)) {
        return { ok: false, error: res?.error ? String(res.error) : 'Unable to load truth events.' };
      }
      const events = res.entries as TruthEventRecord[];
      const sorted = [...events].sort((a, b) => (Number(a?.createdAtMs || 0) - Number(b?.createdAtMs || 0)));
      let projection: TruthProjection | null = null;
      for (const event of sorted) {
        if (!event?.eventType) continue;
        projection = applyTruthEventToProjection(projection, event);
      }
      const startedAtMs = sorted.length > 0 ? Number(sorted[0]?.createdAtMs || 0) : null;
      const finishedAtMs = sorted.length > 0 ? Number(sorted[sorted.length - 1]?.createdAtMs || 0) : null;
      const replay: TruthReplay = {
        runId: runId || null,
        symbol: symbol || null,
        events: sorted,
        projection,
        startedAtMs: Number.isFinite(startedAtMs) ? startedAtMs : null,
        finishedAtMs: Number.isFinite(finishedAtMs) ? finishedAtMs : null
      };
      return { ok: true, replay };
    } catch (err: any) {
      return { ok: false, error: err?.message ? String(err.message) : 'Unable to load truth events.' };
    }
  }, [applyTruthEventToProjection]);

  const appendTruthEvent = useCallback(async (event: {
    eventType: string;
    level?: 'info' | 'warn' | 'error';
    symbol?: string | null;
    runId?: string | null;
    toolId?: string | null;
    actionId?: string | null;
    decisionId?: string | null;
    executionId?: string | null;
    brokerResponseId?: string | null;
    correlationId?: string | null;
    payload?: Record<string, any> | null;
    source?: string | null;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.append) return;
    const eventType = String(event.eventType || '').trim();
    if (!eventType) return;
    const createdAtMs = Date.now();
    const entry = {
      kind: 'truth_event',
      schemaVersion: 'truth_v1',
      eventType,
      level: event.level || 'info',
      symbol: event.symbol || null,
      runId: event.runId || null,
      toolId: event.toolId || null,
      actionId: event.actionId || null,
      decisionId: event.decisionId || null,
      executionId: event.executionId || null,
      brokerResponseId: event.brokerResponseId || null,
      correlationId: event.correlationId || null,
      payload: event.payload || null,
      source: event.source || 'app',
      createdAtMs
    };
    try {
      await ledger.append(entry);
    } catch {
      // ignore ledger failures
    }
    const projection = applyTruthEventToProjection(truthProjectionRef.current, {
      eventType,
      level: entry.level,
      symbol: entry.symbol,
      runId: entry.runId,
      toolId: entry.toolId,
      actionId: entry.actionId,
      decisionId: entry.decisionId,
      executionId: entry.executionId,
      brokerResponseId: entry.brokerResponseId,
      correlationId: entry.correlationId || null,
      payload: entry.payload,
      createdAtMs,
      source: entry.source
    });
    truthProjectionRef.current = projection;
    truthProjectionUpdatedAtRef.current = projection.updatedAtMs || createdAtMs;
    setTruthProjection(projection);
  }, []);

  const shouldThrottleAudit = useCallback((eventType: string, symbol: string | null, payload?: Record<string, any> | null) => {
    if (!AUDIT_THROTTLE_TYPES.has(eventType)) return false;
    const now = Date.now();
    const method = payload?.method != null ? String(payload.method) : '';
    const key = `${eventType}:${method}:${symbol || ''}`;
    const last = auditThrottleRef.current.get(key) || 0;
    if (now - last < AUDIT_THROTTLE_WINDOW_MS) return true;
    auditThrottleRef.current.set(key, now);
    return false;
  }, []);

  const appendAuditEvent = useCallback(async (event: {
    eventType: string;
    level?: 'info' | 'warn' | 'error';
    symbol?: string | null;
    runId?: string | null;
    toolId?: string | null;
    decisionId?: string | null;
    executionId?: string | null;
    brokerResponseId?: string | null;
    correlationId?: string | null;
    payload?: Record<string, any> | null;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.append) return;
    const eventType = String(event.eventType || '').trim();
    if (!eventType) return;
    if (eventType === 'trade_blocked' || eventType === 'trade_validation_failed') {
      const payload = event.payload && typeof event.payload === 'object' ? event.payload : {};
      const reasonRaw = (payload as any)?.reason ?? (payload as any)?.error ?? (payload as any)?.message ?? null;
      const codeRaw = (payload as any)?.block ?? (payload as any)?.code ?? null;
      const brokerRaw = (payload as any)?.broker ?? null;
      const blockRaw = (payload as any)?.block ?? null;
      const next: TradeBlockInfo = {
        atMs: Date.now(),
        symbol: event.symbol ?? null,
        broker: brokerRaw != null ? String(brokerRaw) : null,
        reason: reasonRaw != null ? String(reasonRaw) : null,
        code: codeRaw != null ? String(codeRaw) : null,
        block: blockRaw != null ? String(blockRaw) : null,
        source: (payload as any)?.source != null ? String((payload as any).source) : null,
        executionMode: (payload as any)?.executionMode != null ? String((payload as any).executionMode) : null,
        autoPilotState: (payload as any)?.autoPilotState != null ? String((payload as any).autoPilotState) : null,
        autoPilotReason: (payload as any)?.autoPilotReason != null ? String((payload as any).autoPilotReason) : null,
        agentId: (payload as any)?.agentId != null ? String((payload as any).agentId) : null,
        messageId: (payload as any)?.messageId != null ? String((payload as any).messageId) : null,
        decisionId: event.decisionId ?? null,
        correlationId: event.correlationId ?? null,
        details: payload || null
      };
      lastTradeBlockRef.current = next;
      setLastTradeBlock(next);
    }
    if (shouldThrottleAudit(eventType, event.symbol ?? null, event.payload || null)) return;
    recordPerf('auditEvents');
    const entry = {
      kind: 'audit_event',
      schemaVersion: 'audit_v1',
      eventType,
      level: event.level || 'info',
      symbol: event.symbol || null,
      runId: event.runId || null,
      toolId: event.toolId || null,
      decisionId: event.decisionId || null,
      executionId: event.executionId || null,
      brokerResponseId: event.brokerResponseId || null,
      correlationId: event.correlationId || null,
      payload: event.payload || null,
      source: 'app'
    };
    try {
      await ledger.append(entry);
    } catch {
      // ignore audit failures
    }
    const mirrorPrefixes = [
      'trade_',
      'broker_',
      'broker_action_',
      'task_tree_',
      'task_',
      'playbook_',
      'setup_',
      'setups_',
      'watcher_',
      'agent_',
      'agent_test_',
      'chart_',
      'health_',
      'action_',
      'audit_',
      'autopilot_',
      'backtest_',
      'backtester_',
      'changes_',
      'chat_',
      'dashboard_',
      'ledger_',
      'live_',
      'mt5_',
      'notes_',
      'post_',
      'session_',
      'settings_',
      'shadow_',
      'symbol_',
      'tradelocker_',
      'truth_',
      'ui_'
    ];
    if (mirrorPrefixes.some((prefix) => eventType.startsWith(prefix))) {
      void appendTruthEvent({
        eventType,
        level: event.level || 'info',
        symbol: event.symbol || null,
        runId: event.runId || null,
        toolId: event.toolId || null,
        decisionId: event.decisionId || null,
        executionId: event.executionId || null,
        brokerResponseId: event.brokerResponseId || null,
        correlationId: event.correlationId || null,
        payload: event.payload || null,
        source: event.payload?.source || 'audit'
      });
    }
  }, [appendTruthEvent, recordPerf, shouldThrottleAudit]);

  useEffect(() => {
    appendAuditEventRef.current = appendAuditEvent;
  }, [appendAuditEvent]);

  useEffect(() => {
    const handler = (event: Event) => {
      const detail = (event as CustomEvent).detail;
      if (!detail || typeof detail !== 'object') return;
      const logger = appendAuditEventRef.current;
      if (!logger) return;
      const phase = String(detail.phase || '').trim() || 'event';
      const level = detail.error ? 'error' : phase === 'start' ? 'info' : 'info';
      void logger({
        eventType: 'openai_request',
        level,
        payload: detail
      });
    };
    window.addEventListener('glass_openai_audit', handler as EventListener);
    return () => window.removeEventListener('glass_openai_audit', handler as EventListener);
  }, []);

  useEffect(() => {
    if (agentRunnerRef.current) return;
    agentRunnerRef.current = createAgentRunner({
      onAudit: (event) => {
        void appendAuditEvent({
          eventType: event.eventType,
          level: event.level,
          payload: event.payload || null
        });
      }
    });
  }, [appendAuditEvent]);

  const symbolScopeEventRef = React.useRef<{ initialized: boolean; lastKey: string }>({
    initialized: false,
    lastKey: ''
  });

  useEffect(() => {
    const symbol = symbolScope?.symbol ? String(symbolScope.symbol).trim() : '';
    const timeframes = Array.isArray(symbolScope?.timeframes)
      ? symbolScope?.timeframes.map((tf) => String(tf || '').trim()).filter(Boolean)
      : [];
    const key = symbol ? `${symbol}:${timeframes.join(',')}` : '';
    const ref = symbolScopeEventRef.current;
    if (!ref.initialized) {
      ref.initialized = true;
      ref.lastKey = key;
      return;
    }
    if (ref.lastKey === key) return;
    ref.lastKey = key;
    if (!symbolScope) {
      void appendTruthEvent({
        eventType: 'symbol_scope_clear',
        payload: { updatedAtMs: Date.now() },
        source: 'app'
      });
      return;
    }
    void appendTruthEvent({
      eventType: 'symbol_scope_set',
      symbol: symbolScope.symbol,
      payload: {
        symbol: symbolScope.symbol,
        timeframes: symbolScope.timeframes,
        updatedAtMs: symbolScope.updatedAtMs,
        source: symbolScope.source ?? null
      },
      source: symbolScope.source ?? 'app'
    });
  }, [appendTruthEvent, symbolScope]);

  useEffect(() => {
    let cancelled = false;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listEvents) return;
    (async () => {
      try {
        const res = await ledger.listEvents({ limit: 400, kind: 'truth_event' });
        if (cancelled) return;
        if (res?.ok && Array.isArray(res.entries)) {
          hydrateTruthProjection(res.entries as TruthEventRecord[]);
        }
      } catch {
        // ignore hydrate failures
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [hydrateTruthProjection]);

  useEffect(() => {
    let cancelled = false;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list) return;
    (async () => {
      try {
        const res = await ledger.list({ limit: 300 });
        if (cancelled || !res?.ok || !Array.isArray(res.entries)) return;
        const blocked = res.entries
          .filter((entry: any) => entry?.kind === 'audit_event')
          .filter((entry: any) => {
            const type = String(entry?.eventType || '').trim();
            return type === 'trade_blocked' || type === 'trade_validation_failed';
          })
          .sort((a: any, b: any) => Number(b?.createdAtMs || 0) - Number(a?.createdAtMs || 0));
        if (blocked.length === 0) return;
        const latest = blocked[0];
        const payload = latest?.payload && typeof latest.payload === 'object' ? latest.payload : {};
        const reasonRaw = payload?.reason ?? payload?.error ?? payload?.message ?? null;
        const codeRaw = payload?.block ?? payload?.code ?? null;
        const brokerRaw = payload?.broker ?? null;
        const blockRaw = payload?.block ?? null;
        const next: TradeBlockInfo = {
          atMs: Number(latest?.createdAtMs || Date.now()),
          symbol: latest?.symbol ?? null,
          broker: brokerRaw != null ? String(brokerRaw) : null,
          reason: reasonRaw != null ? String(reasonRaw) : null,
          code: codeRaw != null ? String(codeRaw) : null,
          block: blockRaw != null ? String(blockRaw) : null,
          source: payload?.source != null ? String(payload.source) : null,
          executionMode: payload?.executionMode != null ? String(payload.executionMode) : null,
          autoPilotState: payload?.autoPilotState != null ? String(payload.autoPilotState) : null,
          autoPilotReason: payload?.autoPilotReason != null ? String(payload.autoPilotReason) : null,
          agentId: payload?.agentId != null ? String(payload.agentId) : null,
          messageId: payload?.messageId != null ? String(payload.messageId) : null,
          decisionId: latest?.decisionId ?? null,
          correlationId: latest?.correlationId ?? null,
          details: payload || null
        };
        lastTradeBlockRef.current = next;
        setLastTradeBlock(next);
      } catch {
        // ignore audit hydration failures
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);

  const appendSetupSignalTransition = useCallback(async (entry: {
    signal: SetupSignal;
    fromStatus: SetupSignal['payload']['status'];
    toStatus: SetupSignal['payload']['status'];
    reasonCodes?: string[];
    note?: string | null;
    details?: Record<string, any> | null;
  }) => {
    if (!isSetupSignalDebugEnabled()) return;
    const signal = entry.signal;
    if (!signal?.id) return;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;

    const ts = Date.now();
    const transitionId = `setup_signal_transition_${hashStringSampled(`${signal.id}:${ts}`)}`;
    const profileId = signal.profileId || null;
    const signalType = signal.payload?.signalType || null;
    const payload: SetupSignalTransition = {
      id: transitionId,
      signalId: signal.id,
      profileId,
      symbol: signal.symbol,
      timeframe: signal.timeframe,
      signalType,
      ts,
      fromStatus: entry.fromStatus,
      toStatus: entry.toStatus,
      reasonCodes: entry.reasonCodes || [],
      note: entry.note || null,
      details: entry.details || null
    };

    const tags = [
      signal.symbol,
      signal.timeframe,
      profileId ? `profile:${profileId}` : '',
      signalType ? `type:${signalType}` : '',
      `status:${entry.toStatus}`
    ].filter(Boolean);

    const summary = `${entry.fromStatus} -> ${entry.toStatus}`;
    try {
      await ledger.upsertAgentMemory({
        key: `setup_signal_transition:${signal.id}:${ts}`,
        familyKey: `setup_signal_transition:${signal.symbol}:${signal.timeframe}`,
        kind: 'setup_signal_transition',
        symbol: signal.symbol,
        timeframe: signal.timeframe,
        summary,
        payload,
        tags,
        source: 'setup_signal'
      });
    } catch {
      // ignore transition logging failures
    }
  }, []);

  const loadWatchProfilesFromLedger = useCallback(async (filters?: { symbol?: string; timeframe?: string }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return [];
    try {
      const args: any = { limit: 200, kind: 'watch_profile' };
      if (filters?.symbol) args.symbol = filters.symbol;
      if (filters?.timeframe) args.timeframe = filters.timeframe;
      const res = await ledger.listAgentMemory(args);
      if (!res?.ok || !Array.isArray(res.memories)) return [];
      const profiles = res.memories.map(normalizeWatchProfile).filter(Boolean) as WatchProfile[];
      profiles.sort((a, b) => (b.updatedAtMs || 0) - (a.updatedAtMs || 0));
      return profiles;
    } catch {
      return [];
    }
  }, []);

  const refreshWatchProfiles = useCallback(async (filters?: { symbol?: string; timeframe?: string }) => {
    const profiles = await loadWatchProfilesFromLedger(filters);
    if (!filters?.symbol && !filters?.timeframe) {
      setWatchProfiles(profiles);
    }
    return profiles;
  }, [loadWatchProfilesFromLedger]);

  const getWatchProfilesForSymbol = useCallback(async (symbol?: string, timeframe?: string) => {
    const symbolKey = symbol ? normalizeSymbolKey(symbol) : '';
    const timeframeKey = timeframe ? normalizeTimeframeKey(timeframe) : '';
    const fromLedger = await loadWatchProfilesFromLedger({ symbol, timeframe });
    if (fromLedger.length > 0) return fromLedger;
    const snapshot = watchProfilesRef.current || [];
    return snapshot.filter((profile) => {
      if (symbolKey && normalizeSymbolKey(profile.symbol) !== symbolKey) return false;
      if (timeframeKey && normalizeTimeframeKey(profile.timeframe) !== timeframeKey) return false;
      return true;
    });
  }, [loadWatchProfilesFromLedger]);

  const refreshSetupSignals = useCallback(async (filters?: { symbol?: string; timeframe?: string; limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return [];
    try {
      const args: any = { limit: filters?.limit ?? 200, kind: 'setup_signal' };
      if (filters?.symbol) args.symbol = filters.symbol;
      if (filters?.timeframe) args.timeframe = filters.timeframe;
      const res = await ledger.listAgentMemory(args);
      if (!res?.ok || !Array.isArray(res.memories)) return [];
      const retentionMs = readSetupSignalRetentionMs();
      const now = Date.now();
      const signals = res.memories
        .map(normalizeSetupSignal)
        .filter(Boolean)
        .filter((signal) => retentionMs <= 0 || now - (signal.ts || 0) <= retentionMs) as SetupSignal[];
      const mergedMap = new Map<string, SetupSignal>();
      for (const signal of signals) {
        if (!signal || !signal.id) continue;
        const existing = mergedMap.get(signal.id);
        mergedMap.set(signal.id, existing ? mergeSetupSignals(existing, signal) : signal);
      }
      const mergedSignals = Array.from(mergedMap.values()).sort((a, b) => (b.ts || 0) - (a.ts || 0));
      if (mergedSignals.length > 0) {
        void pruneSetupSignalMemories(
          mergedSignals.map((signal) => ({
            profileId: signal.profileId,
            symbol: signal.symbol,
            timeframe: signal.timeframe
          }))
        );
      }
      if (!filters?.symbol && !filters?.timeframe) {
        setSetupSignals(mergedSignals.slice(0, MAX_SETUP_SIGNALS));
      }
      return mergedSignals;
    } catch {
      return [];
    }
  }, []);

  const pruneSetupSignalMemories = useCallback(async (entries: Array<{ profileId?: string | null; symbol?: string | null; timeframe?: string | null }>) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory || !ledger?.deleteAgentMemory) return;
    const now = Date.now();
    const lastPruneAt = setupSignalPruneAtRef.current || 0;
    if (now - lastPruneAt < 60_000) return;
    setupSignalPruneAtRef.current = now;

    const retentionMs = readSetupSignalRetentionMs();
    const retentionLimit = readSetupSignalRetentionLimit();
    const groups = new Map<string, { profileId: string; symbol: string; timeframe: string }>();

    entries.forEach((entry) => {
      const profileId = String(entry.profileId || '').trim();
      const symbol = String(entry.symbol || '').trim();
      const timeframe = String(entry.timeframe || '').trim();
      if (!symbol || !timeframe) return;
      const key = `${profileId || 'na'}:${symbol}:${timeframe}`;
      if (!groups.has(key)) groups.set(key, { profileId, symbol, timeframe });
    });

    for (const group of groups.values()) {
      const tags = group.profileId ? [`profile:${group.profileId}`] : undefined;
      try {
        const res = await ledger.listAgentMemory({
          kind: 'setup_signal',
          symbol: group.symbol,
          timeframe: group.timeframe,
          tags,
          limit: 5000
        });
        if (!res?.ok || !Array.isArray(res.memories)) continue;
        const memories = res.memories;
        const sorted = memories.slice().sort((a, b) => (Number(b?.updatedAtMs) || 0) - (Number(a?.updatedAtMs) || 0));
        const toRemove: Array<{ key?: string; id?: string }> = [];
        if (retentionMs > 0) {
          for (const mem of sorted) {
            const updatedAt = Number(mem?.updatedAtMs || mem?.createdAtMs || 0);
            if (updatedAt && now - updatedAt > retentionMs) {
              toRemove.push({ key: mem.key, id: mem.id });
            }
          }
        }
        if (retentionLimit > 0 && sorted.length > retentionLimit) {
          sorted.slice(retentionLimit).forEach((mem) => {
            toRemove.push({ key: mem.key, id: mem.id });
          });
        }
        const seen = new Set<string>();
        for (const target of toRemove) {
          const key = `${target.key || ''}:${target.id || ''}`;
          if (seen.has(key)) continue;
          seen.add(key);
          await ledger.deleteAgentMemory({ key: target.key, id: target.id });
        }
      } catch {
        // ignore prune failures
      }
    }
  }, []);

  const pruneActionTraceMemories = useCallback(async (opts?: { force?: boolean }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory || !ledger?.deleteAgentMemory) return;
    const now = Date.now();
    const lastPruneAt = actionTracePruneAtRef.current || 0;
    if (!opts?.force && now - lastPruneAt < 120_000) return;
    actionTracePruneAtRef.current = now;

    const retentionMs = readActionTraceRetentionMs();
    const retentionLimit = readActionTraceRetentionLimit();

    try {
      const res = await ledger.listAgentMemory({ kind: 'action_trace', limit: 5000 });
      if (!res?.ok || !Array.isArray(res.memories)) return;
      const memories = res.memories.slice();
      memories.sort((a, b) => (Number(b?.updatedAtMs || b?.createdAtMs || 0) - Number(a?.updatedAtMs || a?.createdAtMs || 0)));
      const toRemove: Array<{ key?: string; id?: string }> = [];
      if (retentionMs > 0) {
        for (const mem of memories) {
          const updatedAt = Number(mem?.updatedAtMs || mem?.createdAtMs || 0);
          if (updatedAt && now - updatedAt > retentionMs) {
            toRemove.push({ key: mem.key, id: mem.id });
          }
        }
      }
      if (retentionLimit > 0 && memories.length > retentionLimit) {
        memories.slice(retentionLimit).forEach((mem) => {
          toRemove.push({ key: mem.key, id: mem.id });
        });
      }
      const seen = new Set<string>();
      for (const target of toRemove) {
        const key = `${target.key || ''}:${target.id || ''}`;
        if (seen.has(key)) continue;
        seen.add(key);
        await ledger.deleteAgentMemory({ key: target.key, id: target.id });
      }
    } catch {
      // ignore prune failures
    }
  }, []);

  const upsertWatchProfile = useCallback(async (profile: WatchProfile) => {
    if (!profile) return null;
    const ledger = window.glass?.tradeLedger;
    if (ledger?.upsertAgentMemory) {
      const key = `watch_profile:${profile.profileId}`;
      const summary = `Watch profile ${profile.symbol} ${profile.timeframe} ${profile.strategy}`;
      try {
        await ledger.upsertAgentMemory({
          key,
          familyKey: `watch_profile:${profile.symbol}`,
          kind: 'watch_profile',
          symbol: profile.symbol,
          timeframe: profile.timeframe,
          summary,
          payload: profile,
          source: profile.source || 'optimizer',
          tags: [profile.symbol, profile.timeframe, profile.strategy, 'watch', 'profile'].filter(Boolean)
        });
      } catch {
        // ignore ledger failures
      }
    }
    setWatchProfiles((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.profileId === profile.profileId);
      if (idx >= 0) next[idx] = profile;
      else next.unshift(profile);
      next.sort((a, b) => (b.updatedAtMs || 0) - (a.updatedAtMs || 0));
      return next;
    });
    return profile;
  }, []);

  const updateLossStreak = useCallback((accountKey: string, entryId: string, pnl: number, closedAtMs?: number | null) => {
    if (!accountKey) return null;
    const storageKey = getLossStreakStorageKey(accountKey);
    const prev = readLocalJson(storageKey) || {};
    const prevEntryId = prev?.lastEntryId != null ? String(prev.lastEntryId) : '';
    const prevClosedAtMs = Number(prev?.lastClosedAtMs || 0);
    const nextClosedAtMs = Number(closedAtMs || 0) || Date.now();
    const nextEntryId = entryId ? String(entryId) : '';

    if (prevEntryId && nextEntryId && prevEntryId === nextEntryId) return prev;
    if (prevClosedAtMs && nextClosedAtMs <= prevClosedAtMs) return prev;

    let streak = Number(prev?.streak || 0);
    if (Number.isFinite(pnl) && pnl < 0) streak += 1;
    else streak = 0;

    const next = {
      streak,
      lastEntryId: nextEntryId || prevEntryId || null,
      lastClosedAtMs: nextClosedAtMs || null,
      lastPnl: Number.isFinite(pnl) ? pnl : null,
      updatedAtMs: Date.now()
    };
    writeLocalJson(storageKey, next);
    setLossStreakState((current) => {
      if (current?.accountKey && current.accountKey !== accountKey) return current;
      return { ...next, accountKey };
    });
    return next;
  }, []);

  useEffect(() => {
    setupWatchersRef.current = setupWatchers;
    watchProfilesRef.current = watchProfiles;
    const map = new Map<string, WatchProfile>();
    for (const profile of watchProfiles) {
      if (profile?.profileId) map.set(profile.profileId, profile);
    }
    watchProfilesByIdRef.current = map;
    setupSignalsRef.current = setupSignals;
    setupRegimesRef.current = setupRegimes;
    try {
      localStorage.setItem(SETUP_WATCHER_STORAGE_KEY, JSON.stringify(setupWatchers));
    } catch {
      // ignore
    }
  }, [setupRegimes, setupSignals, setupWatchers, watchProfiles]);

  useEffect(() => {
    setupLibraryRef.current = setupLibraryEntries;
  }, [setupLibraryEntries]);

  useEffect(() => {
    taskPlaybooksRef.current = taskPlaybooks;
  }, [taskPlaybooks]);

  const getBrokerQuoteForSymbol = useCallback((symbol: string) => {
    return marketDataRef.current.getQuote(symbol);
  }, []);

  const fetchBrokerQuoteForSymbol = useCallback(async (symbol: string, opts?: { maxAgeMs?: number }) => {
    return marketDataRef.current.fetchQuote(symbol, opts);
  }, []);

  const getBrokerReferencePriceFromQuote = useCallback((quote: any) => {
    if (!quote || typeof quote !== 'object') return null;
    const mid = Number(quote.mid);
    if (Number.isFinite(mid)) return mid;
    const bid = Number(quote.bid);
    const ask = Number(quote.ask);
    if (Number.isFinite(bid) && Number.isFinite(ask)) return (bid + ask) / 2;
    const last = Number(quote.last);
    if (Number.isFinite(last)) return last;
    if (Number.isFinite(bid)) return bid;
    if (Number.isFinite(ask)) return ask;
    return null;
  }, []);

  const ensureTaskTree = useCallback(() => {
    if (taskTreeRef.current) return taskTreeRef.current;

    const orchestrator = new TaskTreeOrchestrator({
      dedupeWindowMs: 60_000,
      maxQueue: 250,
      maxRetries: 1,
      shouldRetry: ({ result, retryCount }) => {
        const code = result?.code ? String(result.code) : '';
        if (code === 'missing_levels' && retryCount < 1) {
          return { retry: true, retryAfterMs: 1200, note: 'missing_levels_retry' };
        }
        return { retry: false };
      },
      onState: (snapshot) => {
        taskTreeUpdatedAtRef.current = Date.now();
        persistTaskTreeStateRef.current?.('signal', snapshot);
      },
      onAudit: (event) => {
        taskTreeUpdatedAtRef.current = Date.now();
        void appendAuditEvent({
          eventType: event.eventType,
          runId: event.runId || null,
          level: event.level || 'info',
          correlationId: event.correlationId || event.payload?.correlationId || null,
          symbol: event.payload?.symbol || null,
          payload: {
            step: event.step || null,
            status: event.status || null,
            note: event.note || null,
            error: event.error || null,
            taskType: 'signal',
            ...(event.payload || {})
          }
        });
        const depthRaw = (actionTaskTreeRef.current as any)?.queue?.length;
        const depth = Number.isFinite(Number(depthRaw)) ? Number(depthRaw) : 0;
        setActionTaskQueueDepth(depth);
      },
      onPersist: (summary) => {
        taskTreeUpdatedAtRef.current = Date.now();
        taskTreeLastSummaryRef.current = { ...taskTreeLastSummaryRef.current, signal: summary };
        void appendAuditEvent({
          eventType: 'task_tree_persist',
          runId: summary.runId || null,
          symbol: summary.context?.symbol || null,
          correlationId: summary.context?.correlationId || null,
          payload: { ...(summary as any), taskType: 'signal' }
        });
        recordTaskTreeRunRef.current?.(summary, 'signal');
        const snapshot = orchestrator.getSnapshot();
        persistTaskTreeStateRef.current?.('signal', snapshot, { immediate: true });
        const depthRaw = (actionTaskTreeRef.current as any)?.queue?.length;
        const depth = Number.isFinite(Number(depthRaw)) ? Number(depthRaw) : 0;
        setActionTaskQueueDepth(depth);
      }
    });

    orchestrator.setHandlers({
      observe: (ctx) => {
        const quote = ctx.symbol ? getBrokerQuoteForSymbol(ctx.symbol) : null;
        const refPrice = quote ? getBrokerReferencePriceFromQuote(quote) : null;
        return { ok: true, data: { brokerQuote: quote, referencePrice: refPrice } };
      },
      evaluate: (ctx) => {
        const signal = ctx.signal || {};
        const watcher = ctx.watcher || {};
        const params = watcher.params && typeof watcher.params === 'object' ? watcher.params : {};
        const strategyConfig = ctx.strategy ? buildStrategyConfig(ctx.strategy, params) : null;
        const library = watcher.libraryKey || watcher.libraryTier || watcher.libraryWinRateTier
          ? {
            key: watcher.libraryKey || null,
            tier: watcher.libraryTier || null,
            score: watcher.libraryScore ?? null,
            winRateTier: watcher.libraryWinRateTier || null,
            stats: watcher.libraryStats || null
          }
          : null;
        return {
          ok: true,
          data: {
            signalType: signal.payload?.signalType || null,
            signalDetails: signal.payload?.details || null,
            strategyConfig,
            library
          }
        };
      },
      decide: async (ctx) => {
        const signal = ctx.signal || {};
        const details = signal.payload?.details || {};
        let entryPrice = Number(details.entryPrice);
        let stopLoss = Number(details.stopLoss);
        let takeProfit = Number(details.takeProfit);
        const missingEntry = !Number.isFinite(entryPrice);
        const missingStop = !Number.isFinite(stopLoss);
        const missingTake = !Number.isFinite(takeProfit);
        if (missingEntry || missingStop || missingTake) {
          const taskState = ctx.data?._taskTree && typeof ctx.data._taskTree === 'object' ? ctx.data._taskTree : null;
          const missingAttempts = Number(taskState?.missingLevelsAttempts || 0);
          if (taskState && missingAttempts < 1) {
            taskState.missingLevelsAttempts = missingAttempts + 1;
          }
          if (missingAttempts < 1) {
            try {
              await tradeLockerExecRef.current?.refreshSnapshot?.();
            } catch {
              // ignore refresh errors
            }
            return {
              ok: false,
              error: 'Missing entry/stop/take-profit levels. Refreshing broker snapshot.',
              code: 'missing_levels',
              retryable: true
            };
          }

          const symbol = String(ctx.symbol || signal.symbol || ctx.watcher?.symbol || '').trim();
          const side = String(signal.payload?.side || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
          const quoteCached = symbol ? getBrokerQuoteForSymbol(symbol) : null;
          let brokerRef = getBrokerReferencePriceFromQuote(quoteCached);
          if (!Number.isFinite(Number(brokerRef)) && symbol) {
            const quoteRes = await fetchBrokerQuoteForSymbol(symbol, { maxAgeMs: 0 });
            brokerRef = getBrokerReferencePriceFromQuote(quoteRes?.quote || null);
          }
          if (!Number.isFinite(entryPrice)) {
            entryPrice = Number.isFinite(Number(brokerRef)) ? Number(brokerRef) : Number(entryPrice);
          }

          const cfg = autoPilotConfigRef.current || {};
          const effectiveAutoCfg = resolveAutoPilotPolicy(cfg).effective || {};
          const rrRaw = Number(details.rr ?? ctx.watcher?.params?.rr ?? effectiveAutoCfg.defaultRR);
          const rr = Number.isFinite(rrRaw) && rrRaw > 0 ? rrRaw : 2;
          const stopModel = String(effectiveAutoCfg.stopModel || 'percent').toLowerCase();
          let distance: number | null = null;
          let modelUsed = '';
          if (stopModel === 'atr' && symbol) {
            const atrRes = await getAtr14Cached(symbol);
            const atrMultRaw = Number(ctx.watcher?.params?.stopAtrMult ?? effectiveAutoCfg.stopAtrMult);
            const atrMult = Number.isFinite(atrMultRaw) && atrMultRaw > 0 ? atrMultRaw : 1;
            if (atrRes.ok && Number.isFinite(atrRes.atr) && atrRes.atr > 0) {
              distance = atrRes.atr * atrMult;
              modelUsed = 'atr';
            }
          }
          if (!distance || !Number.isFinite(distance) || distance <= 0) {
            const pctRaw = Number(effectiveAutoCfg.stopPercent);
            const pct = Number.isFinite(pctRaw) && pctRaw > 0 ? pctRaw : 0.2;
            if (Number.isFinite(entryPrice) && entryPrice > 0) {
              distance = Number(entryPrice) * (pct / 100);
              modelUsed = 'percent';
            }
          }

          if (Number.isFinite(entryPrice) && entryPrice > 0 && Number.isFinite(distance) && distance > 0) {
            if (!Number.isFinite(stopLoss)) {
              stopLoss = side === 'SELL' ? entryPrice + distance : entryPrice - distance;
            }
            if (!Number.isFinite(takeProfit)) {
              takeProfit = side === 'SELL' ? entryPrice - distance * rr : entryPrice + distance * rr;
            }
            if (Number.isFinite(stopLoss) && Number.isFinite(takeProfit)) {
              ctx.data.fallbackLevels = {
                entryPrice,
                stopLoss,
                takeProfit,
                model: modelUsed,
                rr,
                source: 'autopilot'
              };
            }
          }

          if (!Number.isFinite(entryPrice) || !Number.isFinite(stopLoss) || !Number.isFinite(takeProfit)) {
            return { ok: true, skip: true, note: 'missing_levels', code: 'missing_levels' };
          }
        }
        const side = String(signal.payload?.side || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
        const watcher = ctx.watcher || {};
        const profileId = watcher.profileId || signal.profileId || null;
        const paramsHash = watcher.profileParamsHash || (details?.profileParamsHash ?? null);
        const library = watcher.libraryKey || watcher.libraryTier || watcher.libraryWinRateTier
          ? {
              key: watcher.libraryKey || null,
              tier: watcher.libraryTier || null,
              score: watcher.libraryScore ?? null,
              winRateTier: watcher.libraryWinRateTier || null
            }
          : (details?.library || null);
        const playbook = normalizeExecutionPlaybook(watcher.playbook || null);
        const setup = {
          watcherId: watcher.id || signal.payload?.watcherId || null,
          strategy: ctx.strategy || signal.payload?.strategy || watcher.strategy || null,
          timeframe: ctx.timeframe || signal.timeframe || watcher.timeframe || null,
          signalId: signal.id || null,
          signalType: signal.payload?.signalType || null,
          profileId,
          paramsHash,
          libraryKey: library?.key || null,
          libraryTier: library?.tier || null,
          libraryScore: library?.score ?? null,
          libraryWinRateTier: library?.winRateTier || null,
          mode: ctx.mode || watcher.mode || null,
          source: ctx.source || 'setup_signal',
          playbook: playbook || null
        };
        const baseReason = `Setup ${ctx.strategy || ''}${ctx.data?.fallbackLevels ? ' (fallback levels)' : ''}`.trim();

        const cfg = autoPilotConfigRef.current || {};
        const decisionMode = String(cfg.decisionMode || 'deterministic').trim().toLowerCase();
        if (decisionMode === 'agent') {
          const agentRunner = agentRunnerRef.current;
          const agents = agentsRef.current || [];
          const preferredAgentId = String(cfg.decisionAgentId || '').trim();
          const isEligibleAgent = (agent?: Agent | null) => {
            if (!agent) return false;
            if (agent.type !== 'openai') return false;
            const caps = normalizeAgentCapabilities(agent.capabilities);
            return caps.trade && caps.broker;
          };
          let selectedAgent = preferredAgentId ? agents.find((agent) => agent.id === preferredAgentId) : null;
          if (!isEligibleAgent(selectedAgent)) {
            selectedAgent = agents.find((agent) => isEligibleAgent(agent)) || null;
          }
          if (!agentRunner) {
            return { ok: true, skip: true, note: 'agent_runner_unavailable' };
          }
          if (!selectedAgent) {
            return { ok: true, skip: true, note: 'agent_not_found' };
          }
          const context = getContextPackRef.current ? getContextPackRef.current() : '';
          const quote = ctx.data?.brokerQuote || (ctx.symbol ? getBrokerQuoteForSymbol(ctx.symbol) : null);
          const agentSessionId = `ar_${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;
          const decision = await agentRunner.evaluateSignal({
            agent: selectedAgent,
            signal,
            watcher,
            symbol: ctx.symbol || signal.symbol || watcher.symbol,
            timeframe: ctx.timeframe || signal.timeframe || watcher.timeframe,
            strategy: ctx.strategy || signal.payload?.strategy || watcher.strategy,
            context,
            quote,
            allAgents: agents,
            memories: agentMemoryRef.current || [],
            maxCommandsPerMinute: cfg.maxAgentCommandsPerMinute,
            reasoningEffort: cfg.decisionReasoningEffort,
            sessionId: agentSessionId
          });
          const rawDecisionText = decision?.text ? String(decision.text).trim() : '';
          const decisionText = rawDecisionText.length > 1200 ? `${rawDecisionText.slice(0, 1197)}...` : rawDecisionText;
          if (!decision?.ok) {
            return {
              ok: true,
              skip: true,
              note: decision?.code || 'agent_error',
              data: decisionText ? { agentDecisionText: decisionText } : undefined
            };
          }
          if (!decision.proposal) {
            return {
              ok: true,
              skip: true,
              note: 'agent_no_trade',
              data: decisionText ? { agentDecisionText: decisionText } : undefined
            };
          }

          const proposalBase = decision.proposal;
          const proposalSymbol = String(
            proposalBase.symbol || ctx.symbol || signal.symbol || watcher.symbol || ''
          ).trim();
          const proposalAction =
            proposalBase.action === 'SELL' ? 'SELL' : proposalBase.action === 'BUY' ? 'BUY' : side;
          const finalEntry = Number.isFinite(Number(proposalBase.entryPrice))
            ? Number(proposalBase.entryPrice)
            : entryPrice;
          const finalStop = Number.isFinite(Number(proposalBase.stopLoss))
            ? Number(proposalBase.stopLoss)
            : stopLoss;
          const finalTake = Number.isFinite(Number(proposalBase.takeProfit))
            ? Number(proposalBase.takeProfit)
            : takeProfit;
          if (!proposalSymbol || !Number.isFinite(finalEntry) || !Number.isFinite(finalStop) || !Number.isFinite(finalTake)) {
            return { ok: true, skip: true, note: 'agent_missing_levels' };
          }
          const reason = proposalBase.reason || decisionText || baseReason || 'Agent decision';
          return {
            ok: true,
            data: {
              proposal: {
                symbol: proposalSymbol,
                action: proposalAction,
                entryPrice: finalEntry,
                stopLoss: finalStop,
                takeProfit: finalTake,
                reason,
                fallbackLevels: ctx.data?.fallbackLevels || null,
                setup,
                agentId: proposalBase.agentId || selectedAgent.id
              },
              ...(decisionText ? { agentDecisionText: decisionText } : {})
            }
          };
        }

        const action = side;
        const reason = baseReason;
        return {
          ok: true,
          data: {
            proposal: {
              symbol: ctx.symbol,
              action,
              entryPrice,
              stopLoss,
              takeProfit,
              reason,
              fallbackLevels: ctx.data?.fallbackLevels || null,
              setup
            }
          }
        };
      },
      verify: (ctx) => {
        const cfg = autoPilotConfigRef.current || {};
        const { mode: policyMode, policy, effective } = resolveAutoPilotPolicy(cfg);
        const mode = String(ctx.mode || 'suggest').toLowerCase();
        const confirmed =
          ctx.data?.confirmed === true ||
          ctx.data?.confirmation === true ||
          ctx.data?._taskTree?.confirmation === true;
        if (!effective.enabled) return { ok: true, skip: true, note: 'autopilot_disabled' };
        if (effective.killSwitch) return { ok: true, skip: true, note: 'kill_switch' };
        if (effective.requireConfirmation && mode !== 'suggest' && !confirmed) {
          return {
            ok: false,
            blocked: true,
            note: 'confirmation_required',
            code: 'confirmation_required',
            error: 'Confirmation required.'
          };
        }
        if (mode === 'live' && ctx.data?.fallbackLevels && !confirmed) {
          if ((mode === 'live' || mode === 'paper') && !confirmed) {
            return {
              ok: false,
              blocked: true,
              note: 'confirmation_required',
              code: 'confirmation_required',
              error: 'Confirmation required for fallback levels.'
            };
          }
        }
        if (mode === 'live') {
          const meta = tradeLockerExecRef.current;
          if (!meta?.connected || !meta?.tradingEnabled) return { ok: true, skip: true, note: 'broker_unavailable' };
          if (!meta?.autoPilotEnabled) return { ok: true, skip: true, note: 'autopilot_disabled_broker' };
        }
        if (policy?.allowedStrategies && policy.allowedStrategies.length > 0) {
          const strategy = String(ctx.strategy || '').toUpperCase();
          if (strategy && !policy.allowedStrategies.includes(strategy as any)) {
            return { ok: true, skip: true, note: 'mode_strategy_blocked' };
          }
        }
        if (policy?.allowedTimeframes && policy.allowedTimeframes.length > 0) {
          const tf = normalizeTimeframeKey(String(ctx.timeframe || ''));
          const allowed = new Set(policy.allowedTimeframes.map((item) => normalizeTimeframeKey(String(item || ''))));
          if (tf && allowed.size > 0 && !allowed.has(tf)) {
            return { ok: true, skip: true, note: 'mode_timeframe_blocked' };
          }
        }
        if (policyMode === 'swing') {
          const risk = Number(effective.riskPerTrade);
          const maxOpen = Number(effective.maxOpenPositions);
          if (Number.isFinite(risk) && risk >= 0.5 && Number.isFinite(maxOpen) && maxOpen > 3) {
            return { ok: true, skip: true, note: 'swing_risk_requires_low_positions' };
          }
        }
        if (!ctx.data?.proposal) return { ok: true, skip: true, note: 'no_proposal' };
        return { ok: true };
      },
      execute: async (ctx) => {
        const mode = String(ctx.mode || 'suggest').toLowerCase();
        const proposal = ctx.data?.proposal;
        if (!proposal) return { ok: true, skip: true, note: 'no_proposal' };
        if (mode === 'suggest') return { ok: true, skip: true, note: 'suggest_only' };

        const runId = ctx.runId;
        const enriched: TradeProposal = {
          ...proposal,
          messageId: runId,
          agentId: proposal.agentId || 'autopilot'
        };
        const configuredMode = normalizeExecutionMode(autoPilotConfigRef.current?.executionMode) || 'live';
        const executionMode = mode === 'paper' ? 'paper' : configuredMode;
        const forceBroker = executionMode === 'live' ? 'tradelocker' : 'sim';
        const exec = executeTradeRequestRef.current;
        if (!exec) {
          return { ok: false, error: 'Execution handler unavailable.' };
        }
        const result = await exec(enriched, 'autopilot', { forceBroker, executionMode, runId });
        if (!result?.ok) {
          return { ok: false, error: result?.error || 'Execution failed.' };
        }
        return { ok: true, data: { broker: result?.broker || null } };
      },
      monitor: () => ({ ok: true }),
      review: () => ({ ok: true })
    });

    taskTreeRef.current = orchestrator;
    return orchestrator;
  }, [
    appendAuditEvent,
    fetchBrokerQuoteForSymbol,
    getBrokerQuoteForSymbol,
    getBrokerReferencePriceFromQuote,
    getContextPackRef
  ]);

  const handleReplayTaskTree = useCallback((summary: TaskTreeRunSummary) => {
    if (!summary || !summary.runId) return;
    const runId = String(summary.runId);
    const context = summary.context || {};
    taskTreeUpdatedAtRef.current = Date.now();
    void appendAuditEvent({
      eventType: 'task_tree_replay_start',
      runId,
      symbol: context.symbol || null,
      payload: {
        status: summary.status,
        createdAtMs: summary.createdAtMs,
        finishedAtMs: summary.finishedAtMs,
        context
      }
    });

    (summary.steps || []).forEach((step) => {
      void appendAuditEvent({
        eventType: 'task_tree_replay_step',
        runId,
        symbol: context.symbol || null,
        payload: {
          step: step.step,
          status: step.status,
          startedAtMs: step.startedAtMs,
          finishedAtMs: step.finishedAtMs,
          attempts: (step as any).attempts ?? null,
          retryCount: (step as any).retryCount ?? null,
          error: step.error || null,
          note: step.note || null
        }
      });
    });

    void appendAuditEvent({
      eventType: 'task_tree_replay_complete',
      runId,
      symbol: context.symbol || null,
      payload: { status: summary.status }
    });
  }, [appendAuditEvent]);

  const resolveSetupSignalProfileKey = useCallback((signal: SetupSignal) => {
    const profileId = String(signal?.profileId || '').trim();
    if (profileId) return profileId;
    const watcherId = String(signal?.payload?.watcherId || '').trim();
    if (watcherId) return watcherId;
    const strategy = String(signal?.payload?.strategy || '').trim();
    return [signal?.symbol, signal?.timeframe, strategy].filter(Boolean).join(':') || 'na';
  }, []);

  const resolveSetupSignalLifecycleTs = useCallback((signal: SetupSignal) => {
    const details = signal?.payload?.details && typeof signal.payload.details === 'object' ? signal.payload.details : null;
    const raw =
      (details as any)?.signalBarTime ||
      (details as any)?.signalTime ||
      signal?.payload?.barTime ||
      signal?.ts ||
      0;
    return toSignalEpochMs(raw, Number(signal?.ts || 0));
  }, []);

  const resolveSetupSignalBucket = useCallback((signal: SetupSignal) => {
    const lifecycleTs = resolveSetupSignalLifecycleTs(signal);
    if (!Number.isFinite(lifecycleTs) || lifecycleTs <= 0) return 0;
    return getSetupSignalBucketTime(signal.timeframe || '', lifecycleTs);
  }, [resolveSetupSignalLifecycleTs]);

  const buildSetupSignalLifecycleKey = useCallback(
    (signal: SetupSignal) => {
      const profileKey = resolveSetupSignalProfileKey(signal);
      const lifecycleTs = resolveSetupSignalLifecycleTs(signal);
      return buildSetupSignalBucketId(profileKey, signal.timeframe || '', lifecycleTs);
    },
    [resolveSetupSignalLifecycleTs, resolveSetupSignalProfileKey]
  );

  const buildSetupSignalKey = useCallback(
    (signal: SetupSignal) => {
      const profileKey = resolveSetupSignalProfileKey(signal);
      const signalType = signal?.payload?.signalType || 'na';
      const lifecycleTs = resolveSetupSignalLifecycleTs(signal);
      return buildSetupSignalDedupeId(profileKey, signalType, signal.timeframe || '', lifecycleTs);
    },
    [resolveSetupSignalLifecycleTs, resolveSetupSignalProfileKey]
  );

  const buildSetupSignalId = useCallback(
    (signal: SetupSignal) => {
      const key = buildSetupSignalLifecycleKey(signal);
      return `setup_signal_${hashStringSampled(key)}`;
    },
    [buildSetupSignalLifecycleKey]
  );

  const getWatcherLookbackBars = useCallback((watcher: SetupWatcher) => {
    if (!watcher) return 120;
    const cfg = buildStrategyConfig(watcher.strategy, watcher.params || {});
    const clampBars = (value: number) => Math.min(1200, Math.max(120, Math.floor(value) || 0));

    if (watcher.strategy === 'FVG_RETRACE') {
      const maxWait = Math.max(0, Math.floor(Number((cfg as any).maxWaitBars) || 0));
      const atr = Math.max(1, Math.floor(Number((cfg as any).atrPeriod) || 0));
      return clampBars(Math.max(maxWait + 3, atr + 2));
    }
    if (watcher.strategy === 'TREND_PULLBACK') {
      const fast = Math.max(1, Math.floor(Number((cfg as any).fastEma) || 0));
      const slow = Math.max(1, Math.floor(Number((cfg as any).slowEma) || 0));
      const atr = Math.max(1, Math.floor(Number((cfg as any).atrPeriod) || 0));
      return clampBars(Math.max(fast, slow, atr) + 2);
    }
    if (watcher.strategy === 'MEAN_REVERSION') {
      const sma = Math.max(1, Math.floor(Number((cfg as any).smaPeriod) || 0));
      const atr = Math.max(1, Math.floor(Number((cfg as any).atrPeriod) || 0));
      const rsi = (cfg as any).useRsiFilter ? Math.max(1, Math.floor(Number((cfg as any).rsiPeriod) || 0)) : 0;
      return clampBars(Math.max(sma, atr, rsi) + 2);
    }
    if (watcher.strategy === 'BREAK_RETEST') {
      const lookback = Math.max(2, Math.floor(Number((cfg as any).lookbackBars) || 0));
      const retestBars = Math.max(1, Math.floor(Number((cfg as any).retestBars) || 0));
      const atr = Math.max(1, Math.floor(Number((cfg as any).atrPeriod) || 0));
      return clampBars(Math.max(lookback + retestBars + 2, atr + 2));
    }
    const lookback = Math.max(2, Math.floor(Number((cfg as any).lookbackBars) || 0));
    const atr = Math.max(1, Math.floor(Number((cfg as any).atrPeriod) || 0));
    return clampBars(Math.max(lookback + 2, atr + 2));
  }, []);

  const resolveTradeLockerSymbolBestEffort = useCallback(async (raw: string) => {
      const input = String(raw || '').trim();
      if (!input) return raw;

      const afterColon = input.includes(':') ? (input.split(':').pop() || input) : input;
      const token = afterColon.split(/\s+/).filter(Boolean)[0] || afterColon;
      const candidates = Array.from(new Set([input, afterColon, token].map((v) => String(v || '').trim()).filter(Boolean)));
      const keyVariants = new Set<string>();
      for (const cand of candidates) {
        for (const key of buildSymbolKeyVariantsShared(cand)) {
          keyVariants.add(String(key).toUpperCase());
        }
        const normalized = normalizeSymbolKeyShared(cand);
        if (normalized) keyVariants.add(normalized.toUpperCase());
        const loose = normalizeSymbolLooseShared(cand);
        if (loose) keyVariants.add(loose.toUpperCase());
      }

      const matchesCandidate = (symbol: string | null | undefined) => {
        if (!symbol) return false;
        const sym = String(symbol || '').trim();
        if (!sym) return false;
        const variants = buildSymbolKeyVariantsShared(sym).map((v) => String(v).toUpperCase());
        const normalized = normalizeSymbolKeyShared(sym);
        if (normalized) variants.push(normalized.toUpperCase());
        const loose = normalizeSymbolLooseShared(sym);
        if (loose) variants.push(loose.toUpperCase());
        return variants.some((v) => keyVariants.has(v));
      };

      const linkCfg = brokerLinkConfigRef.current;
      const map = linkCfg?.symbolMap || [];
      for (const entry of map) {
        if (!entry) continue;
        const candidates = [entry.canonical, entry.mt5, entry.tradelocker].filter(Boolean) as string[];
        if (candidates.length === 0) continue;
        if (!candidates.some((candidate) => matchesCandidate(candidate))) continue;
        const mapped = entry.tradelocker || entry.canonical || entry.mt5;
        if (mapped) return String(mapped);
      }

      if (activeBrokerSymbol && matchesCandidate(activeBrokerSymbol)) return activeBrokerSymbol;
      if (symbolScopeSymbol && matchesCandidate(symbolScopeSymbol)) return symbolScopeSymbol;

      try {
        const rawHistory = localStorage.getItem(SYMBOL_SCOPE_HISTORY_KEY);
        const history = rawHistory ? JSON.parse(rawHistory) : [];
        if (Array.isArray(history)) {
          for (const entry of history) {
            const sym = String(entry || '').trim();
            if (!sym) continue;
            if (matchesCandidate(sym)) return sym;
          }
        }
      } catch {
        // ignore history failures
      }

      try {
        const ensureConnect = ensureTradeLockerConnectedRef.current;
        if (ensureConnect) {
          try {
            await ensureConnect('symbol_resolve');
          } catch {
            // ignore broker connect failures
          }
        }
        const res = await requestBrokerWithAudit('searchInstruments', { query: token || input, limit: 12 });
        const list = res?.results ?? res?.result ?? res?.items ?? res?.data ?? null;
        if (Array.isArray(list)) {
          let best: { symbol: string; score: number } | null = null;
          for (const item of list) {
            const symbol = String(item?.symbol ?? item?.Symbol ?? item?.symbolName ?? '').trim();
            if (!symbol) continue;
            const normalized = normalizeSymbolKeyShared(symbol).toUpperCase();
            const loose = normalizeSymbolLooseShared(symbol).toUpperCase();
            const variants = buildSymbolKeyVariantsShared(symbol).map((v) => String(v).toUpperCase());
            let score = 0;
            if (keyVariants.has(normalized)) score += 100;
            if (keyVariants.has(loose)) score += 60;
            if (variants.some((v) => keyVariants.has(v))) score += 40;
            if (symbol.includes('.')) score += 5;
            if (!best || score > best.score) best = { symbol, score };
          }
          if (best && best.score > 0) return best.symbol;
        }
      } catch {
        // ignore broker lookup failures
      }

      return String(token || input).trim() || raw;
    }, [activeBrokerSymbol, requestBrokerWithAudit, symbolScopeSymbol]);

  const resolveSetupSymbolCached = useCallback(async (symbol: string) => {
    const key = normalizeSymbolKey(symbol);
    if (!key) return symbol;
    const cached = backgroundSymbolCacheRef.current.get(key);
    if (cached) return cached;
    const resolved = await resolveTradeLockerSymbolBestEffort(symbol);
    if (resolved) backgroundSymbolCacheRef.current.set(key, resolved);
    return resolved || symbol;
  }, [resolveTradeLockerSymbolBestEffort]);

  const brokerLinkStatus = useBrokerLinkEngine({
    config: brokerLinkConfig,
    tradeLockerRef: tradeLockerExecRef,
    resolveTradeLockerSymbol: resolveTradeLockerSymbolBestEffort,
    onEvent: (event) => {
      if (!event || !event.type) return;
      const level = event.type.includes('failed') || event.type.includes('error') ? 'warn' : 'info';
      void appendAuditEvent({
        eventType: event.type,
        level,
        symbol: event.payload?.symbol ?? null,
        payload: event.payload || {}
      });
    }
  });

  const searchSymbolSuggestions = useCallback(async (query: string) => {
    const raw = String(query || '').trim();
    if (!raw) return [];
    const needle = raw.toUpperCase();
    const needleLoose = normalizeSymbolLooseShared(raw).toUpperCase();
    const results: Array<{ symbol: string; label?: string; raw?: any }> = [];
    const seen = new Set<string>();
    const push = (symbol: string, label?: string, rawEntry?: any) => {
      const cleaned = String(symbol || '').trim();
      if (!cleaned) return;
      const key = cleaned.toUpperCase();
      if (seen.has(key)) return;
      seen.add(key);
      results.push({ symbol: cleaned, label, raw: rawEntry });
    };

    if (symbolScopeSymbol && symbolScopeSymbol.toUpperCase().includes(needle)) {
      push(symbolScopeSymbol, 'Current scope');
    }
    if (activeBrokerSymbol && activeBrokerSymbol.toUpperCase().includes(needle)) {
      push(activeBrokerSymbol, 'Active broker symbol');
    }

    const map = brokerLinkConfig?.symbolMap || [];
    if (map.length > 0) {
      const matchesNeedle = (value: string) => {
        const sym = String(value || '').trim();
        if (!sym) return false;
        const upper = sym.toUpperCase();
        if (upper.includes(needle)) return true;
        if (needleLoose) {
          const loose = normalizeSymbolLooseShared(sym).toUpperCase();
          if (loose.includes(needleLoose)) return true;
        }
        const variants = buildSymbolKeyVariantsShared(sym).map((v) => String(v).toUpperCase());
        return variants.some((v) => v.includes(needle) || (needleLoose && v.includes(needleLoose)));
      };
      for (const entry of map) {
        if (!entry) continue;
        const candidates = [entry.canonical, entry.mt5, entry.tradelocker].filter(Boolean) as string[];
        if (candidates.length === 0) continue;
        if (!candidates.some((candidate) => matchesNeedle(candidate))) continue;
        for (const candidate of candidates) {
          push(candidate, 'Symbol map', entry);
        }
      }
    }

    try {
      const ensureConnect = ensureTradeLockerConnectedRef.current;
      if (ensureConnect) {
        try {
          await ensureConnect('symbol_scope_search');
        } catch {
          // ignore
        }
      }
      const res = await requestBrokerWithAudit('searchInstruments', { query: raw, limit: 8 });
      const list = res?.results ?? res?.result ?? res?.items ?? res?.data ?? null;
      if (Array.isArray(list)) {
        for (const item of list) {
          const symbol = item?.symbol ?? item?.Symbol ?? item?.symbolName ?? '';
          const name = item?.name ?? item?.Name ?? item?.description ?? item?.Description ?? '';
          const label = name ? String(name) : '';
          push(String(symbol || '').trim(), label, item);
        }
      }
    } catch {
      // ignore broker search failures
    }

    if (results.length < 6) {
      try {
        const rawHistory = localStorage.getItem(SYMBOL_SCOPE_HISTORY_KEY);
        const list = rawHistory ? JSON.parse(rawHistory) : [];
        if (Array.isArray(list)) {
          for (const entry of list) {
            const symbol = String(entry || '').trim();
            if (!symbol) continue;
            if (!symbol.toUpperCase().includes(needle)) continue;
            push(symbol, 'Recent');
            if (results.length >= 8) break;
          }
        }
      } catch {
        // ignore
      }
    }

    return results;
  }, [activeBrokerSymbol, brokerLinkConfig, requestBrokerWithAudit, symbolScopeSymbol]);

  resolveTradeLockerSymbolRef.current = resolveTradeLockerSymbolBestEffort;

  const isSignalSessionOpen = useCallback((sessions: SignalSessionWindow[]) => {
    const enabled = Array.isArray(sessions) ? sessions.filter((s) => s && s.enabled) : [];
    if (enabled.length === 0) return true;
    const enabledIds = new Set(enabled.map((session) => String(session.id || '').trim().toLowerCase()));
    if (enabledIds.has('asia') && enabledIds.has('london') && enabledIds.has('ny')) return true;
    const hour = new Date().getHours();
    return enabled.some((session) => {
      const start = Number.isFinite(Number(session.startHour)) ? Number(session.startHour) : 0;
      const end = Number.isFinite(Number(session.endHour)) ? Number(session.endHour) : 0;
      if (start === end) return true;
      if (start < end) return hour >= start && hour < end;
      return hour >= start || hour < end;
    });
  }, []);

  const normalizeSignalProbability = useCallback((value: any) => {
    const raw = Number(value);
    if (!Number.isFinite(raw)) return 0;
    if (raw <= 1) return Math.max(0, Math.min(100, raw * 100));
    return Math.max(0, Math.min(100, raw));
  }, []);

  const parseSignalPayload = useCallback((text: string) => {
    const trimmed = String(text || '').trim();
    if (!trimmed) return null;
    const tryParse = (value: string) => {
      try {
        return JSON.parse(value);
      } catch {
        return null;
      }
    };
    let parsed = tryParse(trimmed);
    if (parsed) return parsed;
    const firstBrace = trimmed.indexOf('{');
    const lastBrace = trimmed.lastIndexOf('}');
    if (firstBrace >= 0 && lastBrace > firstBrace) {
      parsed = tryParse(trimmed.slice(firstBrace, lastBrace + 1));
      if (parsed) return parsed;
    }
    const firstBracket = trimmed.indexOf('[');
    const lastBracket = trimmed.lastIndexOf(']');
    if (firstBracket >= 0 && lastBracket > firstBracket) {
      parsed = tryParse(trimmed.slice(firstBracket, lastBracket + 1));
      if (parsed) return parsed;
    }
    return null;
  }, []);

  const buildSignalPrompt = useCallback((opts: {
    symbol: string;
    timeframes: string[];
    strategyModes: SignalStrategyMode[];
    expiryMinutes: number;
    allowMemoryTools?: boolean;
  }) => {
    const tfLabel = opts.timeframes.map((tf) => formatTimeframeLabel(tf)).filter(Boolean).join('/');
    const modes = opts.strategyModes.length > 0 ? opts.strategyModes : ['scalp', 'day', 'swing'];
    const toolRule = opts.allowMemoryTools
      ? '- You may call listAgentMemory/getAgentMemory to fetch signal_history/signal_review/academy_lesson if needed (no other tools).'
      : '- Do not call tools.';
    return [
      'SIGNAL PANEL MODE (RETURN JSON ONLY).',
      'You are generating trade signals, not free-form commentary.',
      'Use CHART_SNAPSHOT_JSON (frames + candles) as ground truth.',
      `Symbol: ${opts.symbol}`,
      `Timeframes: ${tfLabel || '5m/15m/1H/4H'}`,
      `Strategy modes: ${modes.join(', ')}`,
      `Signal expiry: ${opts.expiryMinutes} minutes`,
      '',
      'Return JSON only (no markdown):',
      '{',
      '  "signals": [',
      '    {',
      '      "symbol": "XAUUSD.R",',
      '      "timeframe": "15m",',
      '      "action": "BUY" | "SELL",',
      '      "entry": 0,',
      '      "stop": 0,',
      '      "targets": [0],',
      '      "probability": 0-100,',
      '      "strategyMode": "scalp" | "day" | "swing",',
      '      "reason": "short explanation"',
      '    }',
      '  ]',
      '}',
      '',
      'Rules:',
      '- If there is no valid signal, return {"signals": []}.',
      '- Use numeric values only (no strings).',
      '- If NEWS SNAPSHOT is provided, factor it into the setup and mention its impact in "reason".',
      '- Use NEWS SNAPSHOT tone (positive/negative/mixed/neutral) to bias risk/side and mention it if relevant.',
      '- If NEWS SNAPSHOT includes "Trump News", treat it as potential volatility risk and mention it if relevant.',
      '- Keep probability within the configured range when possible (see system context).',
      toolRule,
      '- Do not add extra keys.',
      '- Probability must be 0-100.'
    ].join('\n');
  }, [formatTimeframeLabel]);

  const ingestSetupSignals = useCallback((signals: SetupSignal[], source: 'native_chart' | 'background') => {
    if (!Array.isArray(signals) || signals.length === 0) return;
    const now = Date.now();
    const dedupe = setupSignalDedupeRef.current;
    const cooldowns = setupSignalCooldownRef.current;
    const cooldownMs = readSetupSignalCooldownMs();
    const batchStats = { emitted: signals.length, deduped: 0, throttled: 0, persisted: 0 };
    const fresh: SetupSignal[] = [];
    for (const signal of signals) {
      if (!signal) continue;
      const signalType = signal?.payload?.signalType || 'setup_ready';
      if (signal.payload) {
        signal.payload.signalType = signalType as SetupSignal['payload']['signalType'];
        signal.payload.status = normalizeSetupSignalStatus(signal.payload.status, signalType);
      }
      const profileKey = resolveSetupSignalProfileKey(signal);
      const cooldownKey = profileKey ? `${profileKey}:${signalType}` : '';
      if (cooldownKey) {
        const lastCooldown = cooldowns.get(cooldownKey);
        if (lastCooldown && now - lastCooldown < cooldownMs) {
          batchStats.throttled += 1;
          continue;
        }
      }
      const key = buildSetupSignalKey(signal);
      const last = dedupe.get(key);
      if (last && now - last < 6 * 60 * 60_000) {
        batchStats.deduped += 1;
        continue;
      }
      dedupe.set(key, now);
      if (cooldownKey) cooldowns.set(cooldownKey, now);
      signal.id = buildSetupSignalId(signal);
      fresh.push(signal);
    }
    if (dedupe.size > 2000) {
      for (const [key, ts] of dedupe.entries()) {
        if (now - ts > 6 * 60 * 60_000) dedupe.delete(key);
      }
    }
    if (cooldowns.size > 1000) {
      for (const [key, ts] of cooldowns.entries()) {
        if (now - ts > 6 * 60 * 60_000) cooldowns.delete(key);
      }
    }
    if (fresh.length === 0) return;
    setupWatcherLastSignalAtRef.current = now;

    const stats = setupSignalStatsRef.current;
    stats.emitted += batchStats.emitted;
    stats.deduped += batchStats.deduped;
    stats.throttled += batchStats.throttled;

    const ledger = window.glass?.tradeLedger;
    const allowSetupSignalExecution = !SIGNAL_PANEL_PRIMARY;
    const orchestrator = allowSetupSignalExecution ? ensureTaskTree() : null;
    const watchers = setupWatchersRef.current;
    const watcherMap = new Map<string, SetupWatcher>();
    for (const watcher of watchers) {
      if (watcher?.id) watcherMap.set(watcher.id, watcher);
    }

    for (const signal of fresh) {
      const watcherId = signal.payload?.watcherId || '';
      const watcher = watcherId ? watcherMap.get(watcherId) : undefined;
      const runContext = resolveActiveRunContext(signal.symbol, signal.timeframe);
      const dedupeKey = `signal:${buildSetupSignalKey(signal)}`;
      const enqueueRes = orchestrator
        ? orchestrator.enqueue({
            source: 'setup_signal',
            symbol: signal.symbol,
            timeframe: signal.timeframe,
            strategy: signal.payload?.strategy,
            watcherId,
            mode: watcher?.mode,
            signal,
            watcher,
            dedupeKey,
            data: { signalId: signal.id, source }
          })
        : null;
      const runId = enqueueRes?.runId || runContext?.runId || null;
      if (signal.payload && runId) {
        signal.payload.runId = runId;
        signal.payload.taskTreeRunId = runId;
      }

      void appendAuditEvent({
        eventType: 'setup_signal',
        symbol: signal.symbol || null,
        runId,
        payload: {
          signalId: signal.id || null,
          watcherId: signal.payload?.watcherId || null,
          profileId: signal.profileId || null,
          signalType: signal.payload?.signalType || null,
          status: signal.payload?.status || null,
          side: signal.payload?.side || null,
          timeframe: signal.timeframe,
          strategy: signal.payload?.strategy || null,
          barTime: signal.payload?.barTime || null,
          strength: signal.strength,
          reasonCodes: signal.reasonCodes || [],
          source,
          executionDisabled: !allowSetupSignalExecution,
          runId,
          details: signal.payload?.details || null
        }
      });

      if (ledger?.upsertAgentMemory) {
        const signalId = signal.id || buildSetupSignalId(signal);
        const key = signalId.startsWith('setup_signal_')
          ? `setup_signal:${signalId.slice('setup_signal_'.length)}`
          : `setup_signal:${hashStringSampled(signalId)}`;
        void ledger.upsertAgentMemory({
          key,
          familyKey: `setup_signal:${signal.symbol}:${signal.timeframe}`,
          kind: 'setup_signal',
          symbol: signal.symbol,
          timeframe: signal.timeframe,
          summary: `Setup signal ${signal.payload?.status || signal.payload?.signalType || 'na'} ${signal.symbol} ${signal.timeframe}`,
          payload: signal,
          source,
          tags: [
            signal.symbol,
            signal.timeframe,
            signal.payload?.strategy,
            signal.payload?.signalType,
            signal.payload?.status,
            signal.profileId ? `profile:${signal.profileId}` : ''
          ].filter(Boolean)
        });
        batchStats.persisted += 1;
      }
    }

    stats.persisted += batchStats.persisted;
    if (isSetupSignalDebugEnabled()) {
      const lastLogAt = stats.lastLogAtMs || 0;
      if (now - lastLogAt > 15_000 || batchStats.deduped + batchStats.throttled > 0) {
        console.info('[setup_signal] batch', {
          emitted: batchStats.emitted,
          deduped: batchStats.deduped,
          throttled: batchStats.throttled,
          persisted: batchStats.persisted,
          total: { ...stats }
        });
        stats.lastLogAtMs = now;
      }
    }

    setSetupSignals((prev) => {
      const map = new Map<string, SetupSignal>();
      for (const sig of prev) {
        if (!sig || !sig.id) continue;
        map.set(sig.id, sig);
      }
      for (const sig of fresh) {
        if (!sig || !sig.id) continue;
        const existing = map.get(sig.id);
        map.set(sig.id, existing ? mergeSetupSignals(existing, sig) : sig);
      }
      const merged = Array.from(map.values()).sort((a, b) => (b.ts || 0) - (a.ts || 0));
      return merged.slice(0, MAX_SETUP_SIGNALS);
    });

    setSetupWatchers((prev) => {
      const map = new Map<string, SetupSignal>();
      for (const sig of fresh) {
        const watcherId = sig.payload?.watcherId;
        if (watcherId) map.set(watcherId, sig);
      }
      if (map.size === 0) return prev;
      const stamp = Date.now();
      return prev.map((watcher) => {
        const sig = map.get(watcher.id);
        if (!sig) return watcher;
        return {
          ...watcher,
          lastSignalType: sig.payload?.signalType || watcher.lastSignalType,
          lastSignalAtMs: sig.ts || stamp,
          updatedAtMs: stamp
        };
      });
    });
    void pruneSetupSignalMemories(
      fresh.map((signal) => ({
        profileId: signal.profileId,
        symbol: signal.symbol,
        timeframe: signal.timeframe
      }))
    );
  }, [appendAuditEvent, buildSetupSignalId, buildSetupSignalKey, ensureTaskTree, pruneSetupSignalMemories, resolveSetupSignalProfileKey]);

  const updateRegimeSnapshot = useCallback((symbol: string, timeframe: string, bars: any[]) => {
    const snapshot = getRegimeSnapshot(bars);
    if (!snapshot) return;
    const symbolKey = normalizeSymbolKey(symbol);
    const timeframeKey = normalizeTimeframeKey(timeframe);
    if (!symbolKey || !timeframeKey) return;
    const key = `${symbolKey}:${timeframeKey}`;
    const now = Date.now();
    const existing = setupRegimesRef.current[key];
    if (existing) {
      const sameLabel = existing.label === snapshot.label;
      const recent = existing.updatedAtMs && now - existing.updatedAtMs < 30_000;
      const trendDiff = Math.abs((existing.trendStrength ?? 0) - (snapshot.trendStrength ?? 0));
      const volDiff = Math.abs((existing.volatilityPct ?? 0) - (snapshot.volatilityPct ?? 0));
      if (sameLabel && recent && trendDiff < 0.05 && volDiff < 0.1) {
        return;
      }
    }

    const nextSnapshot = {
      ...snapshot,
      symbol,
      timeframe,
      updatedAtMs: now
    };
    const runContext = resolveActiveRunContext(symbol, timeframe);
    void appendAuditEvent({
      eventType: 'chart_regime_snapshot',
      symbol,
      runId: runContext?.runId || null,
      payload: {
        timeframe,
        label: snapshot.label,
        trendStrength: snapshot.trendStrength ?? null,
        volatilityPct: snapshot.volatilityPct ?? null,
        atr: snapshot.atr ?? null,
        close: snapshot.close ?? null,
        updatedAtMs: now,
        runId: runContext?.runId || null,
        source: runContext?.source || null
      }
    });

    setSetupRegimes((prev) => ({
      ...prev,
      [key]: nextSnapshot
    }));
  }, [appendAuditEvent, resolveActiveRunContext]);

  const resolveProfileRegimeConstraint = useCallback((watcher: SetupWatcher) => {
    if (!watcher?.profileId) return null;
    const profile = watchProfilesByIdRef.current.get(watcher.profileId);
    return profile?.regimeConstraint || null;
  }, []);

  const applyProfileRegimeConstraints = useCallback((
    signals: SetupSignal[],
    watchers: SetupWatcher[],
    bars: Array<{ t: number; h?: number | null; l?: number | null; c?: number | null }>,
    symbol: string,
    timeframe: string
  ) => {
    if (!Array.isArray(watchers) || watchers.length === 0) return signals;
    if (!Array.isArray(bars) || bars.length < 3) return signals;
    const label = classifyRegime({ bars, timeframe, symbol, referenceBars: bars });
    const currentRegimeKey = label?.regimeKey ? String(label.regimeKey) : '';
    if (!currentRegimeKey) return signals;

    const symbolKey = normalizeSymbolKey(symbol);
    const timeframeKey = normalizeTimeframeKey(timeframe);
    const blockUpdates: Record<string, RegimeBlockState> = {};

    for (const watcher of watchers) {
      if (!watcher) continue;
      if (symbolKey && normalizeSymbolKey(watcher.symbol) !== symbolKey) continue;
      if (timeframeKey && normalizeTimeframeKey(watcher.timeframe) !== timeframeKey) continue;
      const constraint = resolveProfileRegimeConstraint(watcher);
      if (!constraint || !Array.isArray(constraint.keys) || constraint.keys.length === 0) {
        if (watcher.id) {
          blockUpdates[watcher.id] = {
            blocked: false,
            currentRegimeKey,
            requiredKeys: [],
            mode: null
          };
        }
        continue;
      }
      const mode = constraint.mode || 'require';
      const keys = constraint.keys.map((entry) => String(entry));
      const isMatch = keys.includes(currentRegimeKey);
      const blocked = mode === 'exclude' ? isMatch : !isMatch;
      blockUpdates[watcher.id] = { blocked, currentRegimeKey, requiredKeys: keys, mode };
    }

    if (Object.keys(blockUpdates).length > 0) {
      setSetupRegimeBlocks((prev) => {
        const next = { ...prev };
        for (const [id, info] of Object.entries(blockUpdates)) {
          if (!info || (!info.blocked && (!info.requiredKeys || info.requiredKeys.length === 0))) {
            delete next[id];
          } else {
            next[id] = info;
          }
        }
        return next;
      });
    }

    if (!Array.isArray(signals) || signals.length === 0) return signals;
    const filtered: SetupSignal[] = [];
    for (const signal of signals) {
      const watcherId = String(signal?.payload?.watcherId || '').trim();
      const block = watcherId ? blockUpdates[watcherId] : null;
      if (block?.blocked) {
        if (isSetupSignalDebugEnabled()) {
          console.info('[setup_signal] blocked_by_regime', {
            watcherId,
            profileId: signal.profileId || null,
            currentRegimeKey: block.currentRegimeKey,
            requiredKeys: block.requiredKeys || [],
            mode: block.mode || 'require'
          });
        }
        continue;
      }
      filtered.push(signal);
    }
    return filtered;
  }, [resolveProfileRegimeConstraint]);

  const handleNativeBarClose = useCallback((event: { symbol: string; resolution: string; bar: any; bars: any[] }) => {
    if (!event || !event.symbol || !event.resolution || !Array.isArray(event.bars)) return;
    const barTimeRaw = Number(event.bar?.t ?? event.bar?.time ?? event.bar?.timestamp ?? 0);
    const barTime = Number.isFinite(barTimeRaw) && barTimeRaw > 1e11
      ? Math.floor(barTimeRaw)
      : Number.isFinite(barTimeRaw) && barTimeRaw > 0
        ? Math.floor(barTimeRaw * 1000)
        : null;
    const runContext = resolveActiveRunContext(event.symbol, event.resolution);
    void appendAuditEvent({
      eventType: 'chart_bar_close',
      symbol: event.symbol,
      runId: runContext?.runId || null,
      payload: {
        timeframe: event.resolution,
        barTime: barTime ?? null,
        close: Number.isFinite(Number(event.bar?.c ?? event.bar?.close)) ? Number(event.bar?.c ?? event.bar?.close) : null,
        bars: Array.isArray(event.bars) ? event.bars.length : null,
        runId: runContext?.runId || null,
        source: runContext?.source || null
      }
    });
    chartEngine.ingestBar(event.symbol, event.resolution, event.bar, event.bars);
    if (patternAutoRefreshEnabled && (patternRefreshMode === 'bar' || patternRefreshMode === 'both')) {
      requestChartRefresh(1);
    }
    const watchers = setupWatchersRef.current;
    if (!Array.isArray(watchers) || watchers.length === 0) return;

    void (async () => {
      const signals = await evaluateWatchersWorker({
        watchers,
        bars: event.bars as any,
        symbol: event.symbol,
        timeframe: event.resolution,
        stateMap: setupWatcherStateRef.current
      });
      setupWatcherLastEvalAtRef.current = Number.isFinite(Number(event.updatedAtMs))
        ? Number(event.updatedAtMs)
        : Date.now();

      const filteredSignals = applyProfileRegimeConstraints(
        signals,
        watchers,
        event.bars,
        event.symbol,
        event.resolution
      );
      ingestSetupSignals(filteredSignals, 'native_chart');
      updateRegimeSnapshot(event.symbol, event.resolution, event.bars);
    })();
  }, [
    appendAuditEvent,
    applyProfileRegimeConstraints,
    chartEngine,
    ingestSetupSignals,
    patternAutoRefreshEnabled,
    patternRefreshMode,
    requestChartRefresh,
    resolveActiveRunContext,
    updateRegimeSnapshot
  ]);

  const persistPromotionEvent = useCallback(async (input: {
    eventType: string;
    source?: string | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    watcher?: SetupWatcher | null;
    profile?: WatchProfile | null;
    library?: SetupLibraryEntry | null;
    meta?: Record<string, any> | null;
  }) => {
    if (!input?.eventType) return;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;

    const symbol = String(
      input.symbol ||
      input.watcher?.symbol ||
      input.profile?.symbol ||
      input.library?.symbol ||
      ''
    ).trim();
    const timeframe = String(
      input.timeframe ||
      input.watcher?.timeframe ||
      input.profile?.timeframe ||
      input.library?.timeframe ||
      ''
    ).trim();
    const strategy = String(
      input.strategy ||
      input.watcher?.strategy ||
      input.profile?.strategy ||
      input.library?.strategy ||
      ''
    ).trim();
    const eventType = String(input.eventType || '').trim() || 'promotion';
    const source = String(input.source || '').trim() || 'optimizer';
    const meta = input.meta && typeof input.meta === 'object' ? input.meta : {};
    const experimentEntry = buildExperimentRegistryEntry({
      symbol: symbol || 'NA',
      timeframe: timeframe || 'NA',
      strategy: strategy || 'NA',
      config: {
        watcher: input.watcher || null,
        profile: input.profile || null,
        library: input.library || null,
        meta
      },
      source,
      experimentId: meta?.experimentId ? String(meta.experimentId) : null
    });
    let policyDecision: ReturnType<typeof evaluatePromotionPolicy> | ReturnType<typeof evaluateAutoDemotionPolicy> | null = null;
    if (eventType.toLowerCase().includes('promot')) {
      policyDecision = evaluatePromotionPolicy({
        experiment: experimentEntry,
        tradeCount: Number(meta?.tradeCount),
        walkForwardStability: Number(meta?.walkForwardStability),
        maxDrawdownPct: Number(meta?.maxDrawdownPct),
        consistency: Number(meta?.consistency),
        score: Number(meta?.score)
      });
      if (policyDecision.pass) {
        livePolicyService.promote({ experimentId: experimentEntry.experimentId, decision: policyDecision });
      }
    } else if (eventType.toLowerCase().includes('demot') || eventType.toLowerCase().includes('rollback')) {
      policyDecision = evaluateAutoDemotionPolicy({
        experimentId: experimentEntry.experimentId,
        liveDriftSeverity: meta?.liveDriftSeverity || null,
        liveDrawdownPct: Number(meta?.liveDrawdownPct)
      });
      if (policyDecision.pass) {
        livePolicyService.demote({ reason: policyDecision.reasons.join(',') || 'policy', decision: policyDecision });
      }
    }
    const key = `experiment_promotion:${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;
    const familyKey = `experiment_promotion:${symbol || 'na'}:${timeframe || 'na'}:${strategy || 'na'}`;
    const summaryParts = [symbol, timeframe, strategy].filter(Boolean);
    const summary = `Promotion ${eventType}${summaryParts.length ? `: ${summaryParts.join(' ')}` : ''}`;
    const payload = {
      eventType,
      source,
      symbol: symbol || null,
      timeframe: timeframe || null,
      strategy: strategy || null,
      profileId: input.profile?.profileId || null,
      profileParamsHash: input.profile?.paramsHash || null,
      profileObjectivePreset: input.profile?.objectivePresetId || input.profile?.objectivePresetName || null,
      profileSessionId: input.profile?.optimizerSessionId || null,
      profileBaselineRunId: input.profile?.baselineRunId || null,
      watcherId: input.watcher?.id || null,
      watcherMode: input.watcher?.mode || null,
      watcherEnabled: typeof input.watcher?.enabled === 'boolean' ? input.watcher?.enabled : null,
      watcherProfileId: input.watcher?.profileId || null,
      watcherProfileParamsHash: input.watcher?.profileParamsHash || null,
      watcherLibraryKey: input.watcher?.libraryKey || null,
      watcherLibraryTier: input.watcher?.libraryTier ?? null,
      watcherLibraryScore: input.watcher?.libraryScore ?? null,
      watcherLibraryWinRateTier: input.watcher?.libraryWinRateTier || null,
      optimizerSessionId: input.watcher?.optimizerSessionId || input.profile?.optimizerSessionId || null,
      optimizerRound: input.watcher?.optimizerRound ?? null,
      optimizerWinnerId: input.watcher?.optimizerWinnerId || null,
      libraryKey: input.library?.configKey || input.library?.key || null,
      libraryTier: input.library?.tier ?? null,
      libraryScore: input.library?.score ?? null,
      libraryWinRateTier: input.library?.winRateTier || null,
      experimentId: experimentEntry.experimentId,
      configHash: experimentEntry.configHash,
      policyDecision: policyDecision || null,
      livePolicy: livePolicyService.getSnapshot(),
      recordedAtMs: Date.now(),
      meta: meta || null
    };
    const tags = [
      symbol,
      timeframe,
      strategy,
      'promotion',
      eventType,
      source,
      input.profile ? 'profile' : null,
      input.watcher ? 'watcher' : null,
      input.library ? 'library' : null
    ].filter(Boolean);
    try {
      await ledger.upsertAgentMemory({
        key,
        familyKey,
        kind: 'experiment_promotion',
        symbol: symbol || null,
        timeframe: timeframe || null,
        summary,
        payload,
        source,
        tags
      });
    } catch {
      // ignore ledger failures
    }
  }, []);

  const addSetupWatcher = useCallback((input: {
    symbol: string;
    timeframe: string;
    strategy: SetupWatcher['strategy'];
    params: Record<string, any>;
    playbook?: ExecutionPlaybook | null;
    mode?: SetupWatcher['mode'];
    enabled?: boolean;
    library?: SetupLibraryEntry | null;
    profileId?: string | null;
    profileLabel?: string | null;
    profileObjectivePreset?: string | null;
    profileSessionId?: string | null;
    profileBaselineRunId?: string | null;
    profileParamsHash?: string | null;
    optimizerSessionId?: string | null;
    optimizerRound?: number | null;
    optimizerWinnerId?: string | null;
    regime?: SetupWatcher['regime'];
  }) => {
    const symbol = String(input.symbol || '').trim();
    const timeframe = String(input.timeframe || '').trim();
    const strategy = String(input.strategy || '').trim().toUpperCase();
    if (!symbol || !timeframe || !strategy) return null;
    const explicitPlaybook = normalizeExecutionPlaybook(input.playbook);
    const extracted = extractPlaybookFromParams(input.params || {});
    const playbook = explicitPlaybook || extracted.playbook;
    const params = extracted.params;
    const now = Date.now();
    const id = `watch_${now}_${Math.random().toString(16).slice(2, 8)}`;
    const libraryKey = input.library?.configKey ?? input.library?.key ?? null;
    const regime = input.regime ? normalizeSetupRegimeGate(input.regime) : getDefaultRegimeGate(strategy);
    const watcher: SetupWatcher = {
      id,
      symbol,
      timeframe,
      strategy: strategy as SetupWatcher['strategy'],
      params,
      playbook,
      mode: input.mode || 'suggest',
      enabled: input.enabled !== false,
      regime,
      createdAtMs: now,
      updatedAtMs: now,
      lastSignalType: null,
      lastSignalAtMs: null,
      profileId: input.profileId ? String(input.profileId).trim() : null,
      profileLabel: input.profileLabel ? String(input.profileLabel).trim() : null,
      profileObjectivePreset: input.profileObjectivePreset ? String(input.profileObjectivePreset).trim() : null,
      profileSessionId: input.profileSessionId ? String(input.profileSessionId).trim() : null,
      profileBaselineRunId: input.profileBaselineRunId ? String(input.profileBaselineRunId).trim() : null,
      profileParamsHash: input.profileParamsHash ? String(input.profileParamsHash).trim() : null,
      optimizerSessionId: input.optimizerSessionId ? String(input.optimizerSessionId).trim() : null,
      optimizerRound: Number.isFinite(Number(input.optimizerRound))
        ? Math.max(1, Math.floor(Number(input.optimizerRound)))
        : null,
      optimizerWinnerId: input.optimizerWinnerId ? String(input.optimizerWinnerId).trim() : null,
      libraryKey,
      libraryTier: input.library?.tier ?? null,
      libraryScore: input.library?.score ?? null,
      libraryWinRateTier: input.library?.winRateTier ?? null,
      libraryStats: input.library
        ? {
          total: input.library.stats?.total ?? null,
          winRate: input.library.stats?.winRate ?? null,
          expectancy: input.library.stats?.expectancy ?? null,
          profitFactor: input.library.stats?.profitFactor ?? null,
          netR: input.library.performance?.netR ?? null,
          maxDrawdown: input.library.performance?.maxDrawdown ?? null
        }
        : null
    };
    setSetupWatchers((prev) => [watcher, ...prev]);
    const logger = appendAuditEventRef.current;
    if (logger) {
      logger({
        eventType: 'setup_watcher_created',
        symbol: watcher.symbol,
        payload: {
          watcherId: watcher.id,
          timeframe: watcher.timeframe,
          strategy: watcher.strategy,
          mode: watcher.mode,
          enabled: watcher.enabled,
          profileId: watcher.profileId || null,
          profileParamsHash: watcher.profileParamsHash || null,
          optimizerSessionId: watcher.optimizerSessionId || null,
          optimizerRound: watcher.optimizerRound ?? null,
          optimizerWinnerId: watcher.optimizerWinnerId || null
        }
      });
    }
    const promotionSource = watcher.libraryKey
      ? 'setup_library'
      : watcher.profileId || watcher.optimizerSessionId || watcher.optimizerWinnerId
        ? 'optimizer'
        : '';
    if (promotionSource) {
      void persistPromotionEvent({
        eventType: 'setup_watcher_created',
        source: promotionSource,
        watcher,
        library: input.library || null
      });
    }
    return watcher;
  }, [persistPromotionEvent]);

  const updateSetupWatcher = useCallback((id: string, patch: Partial<SetupWatcher>) => {
    const key = String(id || '').trim();
    if (!key) return;
    const now = Date.now();
    const normalizedPatch: Partial<SetupWatcher> = { ...patch };
    if (normalizedPatch.params && typeof normalizedPatch.params === 'object') {
      const explicitPlaybook = normalizeExecutionPlaybook(normalizedPatch.playbook);
      const extracted = extractPlaybookFromParams(normalizedPatch.params);
      normalizedPatch.params = extracted.params;
      if (explicitPlaybook || extracted.playbook) {
        normalizedPatch.playbook = explicitPlaybook || extracted.playbook;
      }
    } else if (normalizedPatch.playbook != null) {
      normalizedPatch.playbook = normalizeExecutionPlaybook(normalizedPatch.playbook);
    }
    if (normalizedPatch.regime != null) {
      normalizedPatch.regime = normalizeSetupRegimeGate(normalizedPatch.regime);
    }
    setSetupWatchers((prev) => prev.map((watcher) => {
      if (watcher.id !== key) return watcher;
      return { ...watcher, ...normalizedPatch, updatedAtMs: now };
    }));
    const logger = appendAuditEventRef.current;
    if (logger) {
      logger({
        eventType: 'setup_watcher_updated',
        payload: {
          watcherId: key,
          fields: Object.keys(normalizedPatch),
          mode: normalizedPatch.mode ?? null,
          enabled: typeof normalizedPatch.enabled === 'boolean' ? normalizedPatch.enabled : null,
          profileId: normalizedPatch.profileId || null,
          optimizerSessionId: normalizedPatch.optimizerSessionId || null,
          optimizerRound: normalizedPatch.optimizerRound ?? null,
          optimizerWinnerId: normalizedPatch.optimizerWinnerId || null
        }
      });
    }
  }, []);

  const removeSetupWatcher = useCallback((id: string) => {
    const key = String(id || '').trim();
    if (!key) return;
    setSetupWatchers((prev) => prev.filter((watcher) => watcher.id !== key));
    setupWatcherStateRef.current.delete(key);
    const logger = appendAuditEventRef.current;
    if (logger) {
      logger({
        eventType: 'setup_watcher_removed',
        payload: { watcherId: key }
      });
    }
  }, []);

  const clearSetupSignals = useCallback(() => {
    setSetupSignals([]);
  }, []);

  const resolveSetupSignalId = useCallback((rawId: string) => {
    const id = String(rawId || '').trim();
    if (!id) return '';
    const current = setupSignalsRef.current || [];
    if (current.some((signal) => signal?.id === id)) return id;
    if (!id.startsWith('setup_signal_')) {
      const hashed = `setup_signal_${hashStringSampled(id)}`;
      if (current.some((signal) => signal?.id === hashed)) return hashed;
    }
    return id;
  }, []);

  const updateSetupSignalStatus = useCallback(async (input: {
    signalId: string;
    status: SetupSignal['payload']['status'];
    reason?: string;
    match?: {
      profileId?: string | null;
      watcherId?: string | null;
      paramsHash?: string | null;
      signalType?: string | null;
    };
  }) => {
    const resolvedId = resolveSetupSignalId(input.signalId);
    if (!resolvedId) return null;
    const current = setupSignalsRef.current || [];
    const existing = current.find((signal) => signal?.id === resolvedId) || null;
    if (!existing) return null;

    const status = normalizeSetupSignalStatus(input.status, existing.payload?.signalType);
    const existingStatus = normalizeSetupSignalStatus(existing.payload?.status, existing.payload?.signalType);
    const existingRank = SETUP_SIGNAL_STATUS_RANK[existingStatus] || 0;
    const nextRank = SETUP_SIGNAL_STATUS_RANK[status] || 0;
      if (existingStatus === 'triggered' || existingStatus === 'invalidated') {
        if (isSetupSignalDebugEnabled()) {
          console.info('[setup_signal] status update ignored (terminal)', {
            id: resolvedId,
            symbol: existing.symbol,
            timeframe: existing.timeframe,
            status,
            existingStatus
          });
          void appendSetupSignalTransition({
            signal: existing,
            fromStatus: existingStatus,
            toStatus: existingStatus,
            note: 'ignored_terminal'
          });
        }
        return existing;
      }
      if (nextRank < existingRank && status !== 'invalidated' && status !== 'triggered') {
        if (isSetupSignalDebugEnabled()) {
          console.info('[setup_signal] status update ignored (regression)', {
            id: resolvedId,
            symbol: existing.symbol,
            timeframe: existing.timeframe,
            status,
            existingStatus
          });
          void appendSetupSignalTransition({
            signal: existing,
            fromStatus: existingStatus,
            toStatus: existingStatus,
            note: 'ignored_regression'
          });
        }
        return existing;
      }

    const match = input.match || null;
    if (match) {
      const profileId = match.profileId ? String(match.profileId).trim() : '';
      const watcherId = match.watcherId ? String(match.watcherId).trim() : '';
      const paramsHash = match.paramsHash ? String(match.paramsHash).trim() : '';
      const signalType = match.signalType ? String(match.signalType).trim() : '';
      const existingWatcherId = existing.payload?.watcherId ? String(existing.payload.watcherId).trim() : '';
      const existingProfileId = existing.profileId ? String(existing.profileId).trim() : '';
      const existingSignalType = existing.payload?.signalType ? String(existing.payload.signalType).trim() : '';
      const existingParamsHash =
        existing.payload?.details && typeof existing.payload.details === 'object'
          ? String((existing.payload.details as any).profileParamsHash || (existing.payload.details as any).paramsHash || '').trim()
          : '';

      const requireStrict = status === 'triggered';
        if (requireStrict && !profileId) {
          if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update blocked (missing profileId)', { id: resolvedId });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_missing_profileId'
            });
          }
          return null;
        }
        if (requireStrict && !watcherId && !paramsHash) {
          if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update blocked (missing watcherId/paramsHash)', { id: resolvedId });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_missing_watcher_or_params'
            });
          }
          return null;
        }

        if (profileId && profileId !== existingProfileId) {
          if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update blocked (profile mismatch)', {
              id: resolvedId,
              profileId,
              existingProfileId
            });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_profile_mismatch'
            });
          }
          return null;
        }
        if (signalType && existingSignalType && signalType !== existingSignalType) {
          if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update blocked (signalType mismatch)', {
              id: resolvedId,
              signalType,
              existingSignalType
            });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_signalType_mismatch'
            });
          }
          return null;
        }

      let matched = false;
        if (watcherId) {
          if (existingWatcherId === watcherId) matched = true;
          else if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update watcherId mismatch', {
              id: resolvedId,
              watcherId,
              existingWatcherId
            });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_watcherId_mismatch'
            });
          }
        }
        if (paramsHash) {
          if (existingParamsHash && existingParamsHash === paramsHash) matched = true;
          else if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update paramsHash mismatch', {
              id: resolvedId,
              paramsHash,
              existingParamsHash
            });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_paramsHash_mismatch'
            });
          }
        }
        if (!matched && (watcherId || paramsHash)) {
          if (isSetupSignalDebugEnabled()) {
            console.info('[setup_signal] status update blocked (no safe match)', {
              id: resolvedId,
              watcherId,
              paramsHash
            });
            void appendSetupSignalTransition({
              signal: existing,
              fromStatus: existingStatus,
              toStatus: existingStatus,
              note: 'blocked_no_safe_match'
            });
          }
          return null;
        }
    }
    const now = Date.now();
    const reasonCode = input.reason ? String(input.reason).trim() : '';
    const invalidReasonCodes =
      status === 'invalidated' && reasonCode
        ? Array.from(new Set([...(existing.payload?.invalidReasonCodes || []), reasonCode]))
        : existing.payload?.invalidReasonCodes || [];
    const patch: SetupSignal = {
      ...existing,
      ts: now,
      reasonCodes: reasonCode ? [...(existing.reasonCodes || []), reasonCode, status] : [...(existing.reasonCodes || []), status],
      payload: {
        ...existing.payload,
        status,
        invalidReasonCodes: invalidReasonCodes.length ? invalidReasonCodes : undefined,
        confirmation: status === 'triggered' ? { type: status, ts: now } : existing.payload?.confirmation
      }
    };
    const merged = mergeSetupSignals(existing, patch);

    setSetupSignals((prev) => prev.map((signal) => (signal?.id === resolvedId ? merged : signal)));

    const ledger = window.glass?.tradeLedger;
    if (ledger?.upsertAgentMemory) {
      const key = resolvedId.startsWith('setup_signal_')
        ? `setup_signal:${resolvedId.slice('setup_signal_'.length)}`
        : `setup_signal:${hashStringSampled(resolvedId)}`;
      await ledger.upsertAgentMemory({
        key,
        familyKey: `setup_signal:${merged.symbol}:${merged.timeframe}`,
        kind: 'setup_signal',
        symbol: merged.symbol,
        timeframe: merged.timeframe,
        summary: `Setup signal ${merged.payload?.status || merged.payload?.signalType || 'na'} ${merged.symbol} ${merged.timeframe}`,
        payload: merged,
        source: 'lifecycle_update',
        tags: [
          merged.symbol,
          merged.timeframe,
          merged.payload?.strategy,
          merged.payload?.signalType,
          merged.payload?.status,
          merged.profileId ? `profile:${merged.profileId}` : ''
        ].filter(Boolean)
      });
    }

      if (isSetupSignalDebugEnabled()) {
        console.info('[setup_signal] status updated', {
          id: resolvedId,
          symbol: merged.symbol,
          timeframe: merged.timeframe,
          status: merged.payload?.status,
          previous: existingStatus
        });
      }
      if (existingStatus !== status || input.reason) {
        void appendSetupSignalTransition({
          signal: merged,
          fromStatus: existingStatus,
          toStatus: status,
          reasonCodes: merged.reasonCodes || [],
          note: input.reason || null,
          details: merged.payload?.details || null
        });
      }

      return merged;
    }, [appendSetupSignalTransition, resolveSetupSignalId]);

  const expireStaleSetupSignals = useCallback(async (signals?: SetupSignal[]) => {
    const now = Date.now();
    const lastExpireAt = setupSignalExpiryAtRef.current || 0;
    if (now - lastExpireAt < 60_000) return;
    setupSignalExpiryAtRef.current = now;

    const expiryBars = readSetupSignalExpiryBars();
    const expiryHours = readSetupSignalExpiryHours();
    if (expiryBars <= 0 && expiryHours <= 0) return;

    const list = Array.isArray(signals) && signals.length > 0 ? signals : (setupSignalsRef.current || []);
    const candidates: SetupSignal[] = [];
    for (const signal of list) {
      if (!signal) continue;
      const status = normalizeSetupSignalStatus(signal.payload?.status, signal.payload?.signalType);
      if (status === 'invalidated' || status === 'triggered') continue;
      const ts = Number(signal.ts || 0);
      if (!Number.isFinite(ts) || ts <= 0) continue;

      const thresholds: number[] = [];
      if (expiryHours > 0) thresholds.push(expiryHours * 60 * 60_000);
      const resMs = getSetupSignalResolutionMs(signal.timeframe || '');
      if (expiryBars > 0 && resMs > 0) thresholds.push(expiryBars * resMs);
      if (thresholds.length === 0) continue;
      const thresholdMs = Math.min(...thresholds);
      if (thresholdMs > 0 && now - ts >= thresholdMs) {
        candidates.push(signal);
      }
    }

    if (candidates.length === 0) return;
    for (const signal of candidates) {
      void updateSetupSignalStatus({
        signalId: signal.id,
        status: 'invalidated',
        reason: 'expired'
      });
    }

    if (isSetupSignalDebugEnabled()) {
      console.info('[setup_signal] expired signals', {
        count: candidates.length,
        expiryBars,
        expiryHours
      });
    }
  }, [updateSetupSignalStatus]);

  useEffect(() => {
    void expireStaleSetupSignals(setupSignals);
  }, [expireStaleSetupSignals, setupSignals]);

  const runSetupWatcherBackgroundTick = useCallback(async () => {
    if (!backgroundWatchersEnabledRef.current) return;
    if (backgroundWatcherRunningRef.current) return;
    backgroundWatcherRunningRef.current = true;
    const startedAt = Date.now();
    let didRun = false;
    try {
      const brokerAvailable =
        !!(window as any)?.glass?.broker?.request || !!(window as any)?.glass?.tradelocker?.getHistorySeries;
      const meta = tradeLockerExecRef.current;
      if (!brokerAvailable || !meta?.connected) return;
      didRun = true;

      const watchers = setupWatchersRef.current;
      if (!Array.isArray(watchers) || watchers.length === 0) return;

      const targetMap = new Map<string, { symbol: string; timeframe: string; lookbackBars: number; watchers: SetupWatcher[] }>();
      for (const watcher of watchers) {
        if (!watcher?.enabled) continue;
        const symbolKey = normalizeSymbolKey(watcher.symbol);
        const timeframeKey = normalizeTimeframeKey(watcher.timeframe);
        if (!symbolKey || !timeframeKey || !BROKER_RESOLUTION_MS[timeframeKey]) continue;
        const key = `${symbolKey}:${timeframeKey}`;
        const entry = targetMap.get(key) || {
          symbol: watcher.symbol,
          timeframe: timeframeKey,
          lookbackBars: 0,
          watchers: []
        };
        entry.watchers.push(watcher);
        entry.lookbackBars = Math.max(entry.lookbackBars, getWatcherLookbackBars(watcher));
        targetMap.set(key, entry);
      }

      if (targetMap.size === 0) return;
      const now = Date.now();
      const stateMap = backgroundWatcherStateRef.current;
      const activeKeys = new Set(targetMap.keys());
      for (const key of Array.from(stateMap.keys())) {
        if (!activeKeys.has(key)) stateMap.delete(key);
      }

      for (const [key, target] of targetMap.entries()) {
        const resMs = BROKER_RESOLUTION_MS[target.timeframe];
        if (!resMs) continue;
        const state = stateMap.get(key) || { lastFetchMs: 0, lastTriggerBarTs: 0 };
        const minInterval = Math.min(60_000, Math.max(5_000, Math.floor(resMs / 4)));
        if (now - state.lastFetchMs < minInterval) continue;

        state.lastFetchMs = now;
        stateMap.set(key, state);

        const resolvedSymbol = await resolveSetupSymbolCached(target.symbol);
        const lookbackBars = Math.max(30, Math.min(1200, Math.floor(target.lookbackBars || 0)));
        const from = now - resMs * lookbackBars;
        const maxAgeMs = Math.min(60_000, Math.max(5_000, Math.floor(resMs / 2)));
        const res = await requestBrokerWithAudit('getHistorySeries', {
          symbol: resolvedSymbol,
          resolution: target.timeframe,
          from,
          to: now,
          aggregate: true,
          maxAgeMs
        }, { symbol: resolvedSymbol });
        if (!res?.ok || !Array.isArray(res.bars) || res.bars.length < 3) continue;

        let bars = res.bars.slice(-lookbackBars);
        if (bars.length < 3) continue;
        const lastBar = bars[bars.length - 1];
        const lastOpen = Number(lastBar?.t);
        if (!Number.isFinite(lastOpen)) continue;

        let triggerBarTs = 0;
        let barsForSignals = bars;

        if (lastOpen > state.lastTriggerBarTs) {
          triggerBarTs = lastOpen;
        } else {
          const nextOpen = lastOpen + resMs;
          if (now >= nextOpen && nextOpen > state.lastTriggerBarTs) {
            const quote = getBrokerQuoteForSymbol(resolvedSymbol);
            const quotePrice = getBrokerReferencePriceFromQuote(quote);
            const lastClose = Number(lastBar?.c ?? lastBar?.o);
            const basePrice = Number.isFinite(quotePrice) ? quotePrice : lastClose;
            const open = Number.isFinite(lastClose) ? lastClose : basePrice;
            const price = Number.isFinite(basePrice) ? basePrice : open;
            if (Number.isFinite(price) && Number.isFinite(open)) {
              const synthetic = {
                t: nextOpen,
                o: open,
                h: Math.max(open, price),
                l: Math.min(open, price),
                c: price,
                v: null
              };
              const sliceSize = Math.max(1, lookbackBars - 1);
              barsForSignals = [...bars.slice(-sliceSize), synthetic];
              triggerBarTs = nextOpen;
            }
          }
        }

        if (!triggerBarTs) continue;
        state.lastTriggerBarTs = triggerBarTs;
        stateMap.set(key, state);

        const signals = await evaluateWatchersWorker({
          watchers: target.watchers,
          bars: barsForSignals as any,
          symbol: resolvedSymbol,
          timeframe: target.timeframe,
          stateMap: setupWatcherStateRef.current
        });
        const evalAt = Date.now();
        setupWatcherLastEvalAtRef.current = evalAt;
        backgroundWatcherLastTickAtRef.current = evalAt;
        const filteredSignals = applyProfileRegimeConstraints(
          signals,
          target.watchers,
          barsForSignals,
          resolvedSymbol,
          target.timeframe
        );
        ingestSetupSignals(filteredSignals, 'background');
        updateRegimeSnapshot(resolvedSymbol, target.timeframe, barsForSignals);
      }
    } finally {
      backgroundWatcherRunningRef.current = false;
      if (didRun) {
        recordPerf('backgroundWatcherTicks');
        recordPerf('backgroundWatcherLastDurationMs', Date.now() - startedAt);
      }
    }
  }, [applyProfileRegimeConstraints, getBrokerQuoteForSymbol, getBrokerReferencePriceFromQuote, getWatcherLookbackBars, ingestSetupSignals, recordPerf, resolveSetupSymbolCached, requestBrokerWithAudit, updateRegimeSnapshot]);

  useEffect(() => {
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadSetupWatcherBackgroundControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createSetupWatcherBackgroundController({
        tick: () => runSetupWatcherBackgroundTick(),
        isEnabled: () => backgroundWatchersEnabledRef.current === true,
        enabledIntervalMs: 8_000,
        disabledIntervalMs: 60_000,
        initialEnabledDelayMs: 4_000,
        initialDisabledDelayMs: 20_000
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [runSetupWatcherBackgroundTick]);

  useEffect(() => {
    const ids = new Set(setupWatchers.map((watcher) => watcher.id));
    const stateMap = setupWatcherStateRef.current;
    for (const key of stateMap.keys()) {
      if (!ids.has(key)) stateMap.delete(key);
    }
  }, [setupWatchers]);

  useEffect(() => {
    const ids = new Set(setupWatchers.map((watcher) => watcher.id));
    setSetupRegimeBlocks((prev) => {
      const next: Record<string, RegimeBlockState> = {};
      for (const [id, info] of Object.entries(prev)) {
        if (ids.has(id)) next[id] = info;
      }
      return next;
    });
  }, [setupWatchers]);

  const getInstrumentConstraintsCached = useCallback(async (symbol: string) => {
    const brokerAvailable =
      !!(window as any)?.glass?.broker?.request || !!(window as any)?.glass?.tradelocker?.getInstrumentConstraints;
    if (!brokerAvailable) return { ok: false, error: 'Broker constraints API unavailable.' };
    const key = normalizeSymbolKey(symbol);
    if (!key) return { ok: false, error: 'Symbol missing.' };
    const now = Date.now();
    const cache = constraintsCacheRef.current.get(key);
    if (cache && now - cache.fetchedAtMs < 60_000) return cache.res;
    const inflight = constraintsInFlightRef.current.get(key);
    if (inflight) return inflight;

    const promise = requestBrokerWithAudit('getInstrumentConstraints', { symbol }, { symbol })
      .catch((err: any) => ({ ok: false, error: err?.message ? String(err.message) : 'Constraints request failed.' }));
    constraintsInFlightRef.current.set(key, promise);
    const res = await promise;
    constraintsInFlightRef.current.delete(key);
    constraintsCacheRef.current.set(key, { res, fetchedAtMs: now });
    return res;
  }, [requestBrokerWithAudit]);

  const validateBrokerStopLevels = useCallback(async (args: {
    symbol: string;
    side: 'BUY' | 'SELL';
    stopLoss?: number | null;
    takeProfit?: number | null;
    referencePrice?: number | null;
  }) => {
    const symbol = String(args.symbol || '').trim();
    if (!symbol) return { ok: true as const };
    const res = await getInstrumentConstraintsCached(symbol);
    if (!res?.ok) {
      const warning = formatConstraintError(res?.error || 'Constraints unavailable.');
      return { ok: true as const, warning };
    }

    const constraints = res?.constraints || {};
    const sessionOpen = constraints.sessionOpen;
    const sessionLabel = constraints.sessionStatus?.status || constraints.sessionStatus?.state || '';
    if (sessionOpen === false) {
      const detail = sessionLabel ? ` (${String(sessionLabel).toUpperCase()})` : '';
      return { ok: false as const, error: `Session is closed${detail}.` };
    }

    const minStopDistance = Number(constraints.minStopDistance);
    if (!Number.isFinite(minStopDistance) || minStopDistance <= 0) {
      return { ok: true as const };
    }

    const ref = args.referencePrice != null ? Number(args.referencePrice) : null;
    if (!Number.isFinite(ref)) {
      return { ok: true as const, warning: 'Broker quote unavailable; unable to validate min stop distance.' };
    }

    const errors: string[] = [];
    const side = args.side;
    const sl = args.stopLoss != null ? Number(args.stopLoss) : null;
    const tp = args.takeProfit != null ? Number(args.takeProfit) : null;
    const minLabel = formatBrokerPrice(minStopDistance);

    if (sl != null && Number.isFinite(sl)) {
      if (side === 'BUY' && sl >= ref) errors.push('Stop loss must be below current price.');
      if (side === 'SELL' && sl <= ref) errors.push('Stop loss must be above current price.');
      const dist = Math.abs(ref - sl);
      if (dist < minStopDistance) {
        errors.push(`Stop loss too close (min ${minLabel}).`);
      }
    }

    if (tp != null && Number.isFinite(tp)) {
      if (side === 'BUY' && tp <= ref) errors.push('Take profit must be above current price.');
      if (side === 'SELL' && tp >= ref) errors.push('Take profit must be below current price.');
      const dist = Math.abs(ref - tp);
      if (dist < minStopDistance) {
        errors.push(`Take profit too close (min ${minLabel}).`);
      }
    }

    if (errors.length > 0) {
      return { ok: false as const, error: errors.join(' ') };
    }

    return { ok: true as const };
  }, [getInstrumentConstraintsCached]);

  const getAtr14Cached = useCallback(async (symbol: string) => {
    const brokerAvailable =
      !!(window as any)?.glass?.broker?.request || !!(window as any)?.glass?.tradelocker?.getHistorySeries;
    if (!brokerAvailable) return { ok: false as const, error: 'Broker history API unavailable.' };
    const key = normalizeSymbolKey(symbol);
    if (!key) return { ok: false as const, error: 'Symbol missing.' };
    const now = Date.now();
    const cache = spreadAtrCacheRef.current.get(key);
    if (cache && now - cache.fetchedAtMs < 60_000) {
      return { ok: true as const, atr: cache.atr, fetchedAtMs: cache.fetchedAtMs };
    }
    const inflight = spreadAtrInFlightRef.current.get(key);
    if (inflight) return inflight;

    const fromMs = now - BROKER_RESOLUTION_MS['1m'] * 300;
    const promise = requestBrokerWithAudit('getHistorySeries', {
      symbol,
      resolution: '1m',
      from: fromMs,
      to: now,
      aggregate: true,
      maxAgeMs: 60_000
    }, { symbol }).then((res: any) => {
      if (!res?.ok || !Array.isArray(res.bars)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'History unavailable.' };
      }
      const atr = computeAtr14FromBars(res.bars);
      if (!Number.isFinite(atr)) {
        return { ok: false as const, error: 'ATR unavailable.' };
      }
      const entry = { atr: Number(atr), fetchedAtMs: Date.now() };
      spreadAtrCacheRef.current.set(key, entry);
      return { ok: true as const, atr: entry.atr, fetchedAtMs: entry.fetchedAtMs };
    }).catch((err: any) => ({
      ok: false as const,
      error: err?.message ? String(err.message) : 'ATR request failed.'
    }));

    spreadAtrInFlightRef.current.set(key, promise);
    const out = await promise;
    spreadAtrInFlightRef.current.delete(key);
    return out;
  }, [requestBrokerWithAudit]);

  const getBrokerContext = useCallback(() => {
    const meta = tradeLockerExecRef.current || {};
    const status = meta.status || (meta.connected ? 'connected' : 'disconnected');
    const statusLabel = String(status || 'disconnected').toUpperCase();
    if (statusLabel !== 'CONNECTED') {
      const err = meta.lastError ? ` Last error: ${String(meta.lastError).trim()}` : '';
      return `TradeLocker: ${statusLabel}.${err}`;
    }

    const fmt = (value: any, decimals: number) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      return num.toFixed(decimals).replace(/\.?0+$/, '');
    };
    const fmtPrice = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const abs = Math.abs(num);
      const decimals = abs >= 1000 ? 2 : abs >= 1 ? 4 : 6;
      return fmt(num, decimals);
    };
    const fmtMoney = (value: any) => fmt(value, 2);
    const fmtQty = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const decimals = num >= 1 ? 2 : 4;
      return fmt(num, decimals);
    };
    const fmtVpp = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const abs = Math.abs(num);
      const decimals = abs >= 1 ? 2 : abs >= 0.01 ? 4 : 6;
      return fmt(num, decimals);
    };
    const fmtPnl = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const sign = num >= 0 ? '+' : '-';
      return `${sign}${Math.abs(num).toFixed(2)}`;
    };
    const formatAge = (ms: number) => {
      if (!Number.isFinite(ms) || ms <= 0) return '';
      const seconds = Math.max(1, Math.floor((Date.now() - ms) / 1000));
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h ago`;
    };

    const envLabel = meta.env ? String(meta.env).toUpperCase() : '';
    const serverLabel = meta.server ? String(meta.server).trim() : '';
    const accNumLabel = meta.accNum != null ? `#${meta.accNum}` : '';
    const currency = meta.currency ? String(meta.currency).trim() : '';
    const header = `TradeLocker: ${[envLabel, serverLabel].filter(Boolean).join('-')}${accNumLabel ? ` ${accNumLabel}` : ''}${currency ? ` (${currency})` : ''}`;

    const balance = fmtMoney(meta.balance);
    const equity = fmtMoney(meta.equity);
    const marginUsed = fmtMoney(meta.accountMetrics?.marginUsed ?? meta.marginUsed);
    const marginFree = fmtMoney(meta.accountMetrics?.marginFree ?? meta.marginFree);
    const marginLevel = fmtMoney(meta.accountMetrics?.marginLevel ?? meta.marginLevel);
    const openNetPnl = fmtMoney(meta.accountMetrics?.openNetPnl ?? meta.openNetPnl);

    const metricsLine = [
      balance ? `Balance ${balance}` : '',
      equity ? `Equity ${equity}` : '',
      openNetPnl ? `Open P&L ${openNetPnl}` : ''
    ].filter(Boolean).join(' | ');

    const marginLine = [
      marginUsed ? `Margin Used ${marginUsed}` : '',
      marginFree ? `Free ${marginFree}` : '',
      marginLevel ? `Level ${marginLevel}` : ''
    ].filter(Boolean).join(' | ');

    const positions = Array.isArray(meta.positions) ? meta.positions : [];
    const orders = Array.isArray(meta.orders) ? meta.orders : [];
    const watchSymbols = Array.isArray(meta.watchSymbols) ? meta.watchSymbols : [];
    const quoteMap = meta.quotesBySymbol && typeof meta.quotesBySymbol === 'object' ? meta.quotesBySymbol : {};
    let hasVppHint = false;
    const posLines = positions.slice(0, 6).map((p: any) => {
      const id = p?.id != null ? String(p.id) : '';
      const side = String(p?.type || '').toUpperCase();
      const symbol = String(p?.symbol || 'UNKNOWN');
      const size = fmtQty(p?.size);
      const entry = fmtPrice(p?.entryPrice);
      const pnl = fmtPnl(p?.pnl);
      const sl = fmtPrice(p?.stopLoss);
      const tp = fmtPrice(p?.takeProfit);
      const quoteKey = String(symbol || '').trim().toLowerCase();
      const quote = quoteKey ? quoteMap[quoteKey] : null;
      const refPrice = Number(quote?.mid ?? quote?.last ?? quote?.bid ?? quote?.ask);
      const pnlNum = Number(p?.pnl);
      const entryNum = Number(p?.entryPrice);
      let vppLabel = '';
      if (Number.isFinite(refPrice) && Number.isFinite(entryNum) && Number.isFinite(pnlNum)) {
        const dir = side === 'SELL' ? -1 : 1;
        const delta = (refPrice - entryNum) * dir;
        if (Number.isFinite(delta) && Math.abs(delta) > 1e-6 && Math.abs(pnlNum) > 1e-6) {
          const vpp = fmtVpp(Math.abs(pnlNum / delta));
          if (vpp) {
            vppLabel = `VPP $${vpp}/pt`;
            hasVppHint = true;
          }
        }
      }
      const parts = [
        id ? `ID ${id}` : '',
        `${side} ${symbol}`,
        size ? `${size}` : '',
        entry ? `@ ${entry}` : '',
        pnl ? `PnL ${pnl}` : '',
        sl ? `SL ${sl}` : '',
        tp ? `TP ${tp}` : '',
        vppLabel
      ].filter(Boolean);
      return `- ${parts.join(' ')}`.trim();
    });
    if (positions.length > 6) posLines.push(`- (+${positions.length - 6} more)`);

    const orderLines = orders.slice(0, 6).map((o: any) => {
      const id = o?.id != null ? String(o.id) : '';
      const side = String(o?.side || '').toUpperCase();
      const symbol = String(o?.symbol || 'UNKNOWN');
      const qty = fmtQty(o?.qty);
      const type = String(o?.type || '').toUpperCase();
      const price = fmtPrice(o?.price);
      const status = String(o?.status || '').toUpperCase();
      const parts = [
        id ? `ID ${id}` : '',
        `${side} ${symbol}`,
        qty ? `${qty}` : '',
        type ? `${type}` : '',
        price ? `${price}` : '',
        status ? `(${status})` : ''
      ].filter(Boolean);
      return `- ${parts.join(' ')}`.trim();
    });
    if (orders.length > 6) orderLines.push(`- (+${orders.length - 6} more)`);

    const quoteSymbols = Array.from(new Set([
      ...positions.map((p: any) => p?.symbol),
      ...orders.map((o: any) => o?.symbol),
      ...watchSymbols
    ].filter(Boolean)));
    const quoteLines = quoteSymbols.slice(0, 6).map((sym) => {
      const key = String(sym || '').trim().toLowerCase();
      const quote = quoteMap[key];
      if (!quote) return null;
      const bid = fmtPrice(quote?.bid);
      const ask = fmtPrice(quote?.ask);
      const mid = fmtPrice(quote?.mid);
      const spread = fmtPrice(quote?.spread);
      const age = formatAge(Number(quote?.fetchedAtMs ?? quote?.timestampMs ?? 0));
      const parts = [
        String(sym),
        bid ? `bid ${bid}` : '',
        ask ? `ask ${ask}` : '',
        mid ? `mid ${mid}` : '',
        spread ? `sp ${spread}` : '',
        age ? `${age}` : ''
      ].filter(Boolean);
      return parts.length ? `- ${parts.join(' ')}` : null;
    }).filter(Boolean);
    if (quoteSymbols.length > 6) quoteLines.push(`- (+${quoteSymbols.length - 6} more)`);
    const updatedAtMs = Number(meta.accountMetricsUpdatedAtMs ?? meta.snapshotUpdatedAtMs ?? 0);
    const ageLabel = formatAge(updatedAtMs);

    const priceSource = 'PRICE SOURCE: Use broker quotes for all numeric price calculations. TradingView is visual only unless user explicitly says "use TradingView price". For execution requests, propose the trade directly; the system will fetch broker quotes.';
    const vppHint = hasVppHint ? 'VPP = $ per 1.0 price unit (estimate from PnL + broker quote).' : '';
    const streamStatus = meta.streamStatus ? String(meta.streamStatus).trim().toUpperCase() : '';
    const streamAgeLabel = streamStatus ? formatAge(Number(meta.streamUpdatedAtMs ?? 0)) : '';
    const streamLine = streamStatus ? `Stream ${streamStatus}${streamAgeLabel ? ` (${streamAgeLabel})` : ''}${meta.streamError ? ` - ${String(meta.streamError).trim()}` : ''}` : '';
    const historySummary = typeof meta.brokerHistorySummary === 'string' ? meta.brokerHistorySummary.trim() : '';
    const historyLines = historySummary
      ? historySummary.split('\n').map((line: string) => line.trim()).filter(Boolean)
      : [];

    const lines = [
      header,
      priceSource,
      vppHint,
      streamLine,
      metricsLine,
      marginLine ? `Margin: ${marginLine}` : '',
      `Open Positions (${positions.length})${ageLabel ? ` | Updated ${ageLabel}` : ''}`,
      ...posLines,
      `Open Orders (${orders.length})`,
      ...orderLines,
      quoteLines.length > 0 ? 'Broker Quotes' : '',
      ...quoteLines,
      historyLines.length > 0 ? 'Broker History' : '',
      ...historyLines
    ].filter(Boolean);

    return lines.join('\n');
  }, []);

  const formatAgeShort = useCallback((ms: number | null | undefined) => {
    if (!Number.isFinite(Number(ms)) || Number(ms) <= 0) return '';
    const delta = Math.max(0, Date.now() - Number(ms));
    const seconds = Math.max(1, Math.floor(delta / 1000));
    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    const hours = Math.floor(minutes / 60);
    return `${hours}h ago`;
  }, []);

  const buildHealthContext = useCallback(() => {
    const snapshot = healthSnapshotRef.current || healthSnapshot;
    if (!snapshot) return '';
    const formatLineAge = (value?: number | null) => {
      const label = formatAgeShort(value);
      return label || 'never';
    };
    const brokerStatus = snapshot.brokerStatus ? String(snapshot.brokerStatus).toUpperCase() : 'UNKNOWN';
    const streamStatus = snapshot.brokerStreamStatus ? String(snapshot.brokerStreamStatus).toUpperCase() : 'UNKNOWN';
    const autoState = snapshot.autoPilotState ? String(snapshot.autoPilotState) : 'UNKNOWN';
    const autoReason = snapshot.autoPilotReason ? String(snapshot.autoPilotReason) : '';
    const lines = [
      'HEALTH SNAPSHOT',
      `- Broker ${brokerStatus} | quotes ${formatLineAge(snapshot.brokerQuotesUpdatedAtMs)}${snapshot.brokerQuotesError ? ` | err ${snapshot.brokerQuotesError}` : ''}`,
      `- Stream ${streamStatus} | ${formatLineAge(snapshot.brokerStreamUpdatedAtMs)}${snapshot.brokerStreamError ? ` | err ${snapshot.brokerStreamError}` : ''} | snapshot ${formatLineAge(snapshot.brokerSnapshotUpdatedAtMs)}`,
      `- Watchers ${snapshot.setupWatcherEnabledCount ?? 0}/${snapshot.setupWatcherCount ?? 0} | eval ${formatLineAge(snapshot.setupWatcherEvalAtMs)} | signal ${formatLineAge(snapshot.setupSignalAtMs)}`,
      `- Background watcher tick ${formatLineAge(snapshot.backgroundWatcherTickAtMs)}`,
      `- Native chart ${snapshot.nativeChartSymbol || '--'} | ${formatLineAge(snapshot.nativeChartUpdatedAtMs)} | frames ${snapshot.nativeChartFrames ?? 0}`,
      `- Task tree ${formatLineAge(snapshot.taskTreeUpdatedAtMs)}`,
      `- AutoPilot ${(snapshot.autoPilotEnabled ? 'ON' : 'OFF')}${snapshot.killSwitch ? ' (KILL)' : ''} | mode ${snapshot.autoPilotMode || 'custom'} | state ${autoState}${autoReason ? ` (${autoReason})` : ''}`
    ];
    return lines.join('\n');
  }, [formatAgeShort, healthSnapshot]);

  const refreshAgentMemory = useCallback(async (opts?: {
    symbol?: string;
    timeframe?: string;
    kind?: string;
    limit?: number;
    tags?: string[];
    agentId?: string;
    scope?: string | string[];
    category?: string;
    subcategory?: string;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) {
      setAgentMemoryError('Agent memory unavailable.');
      return { ok: false, error: 'Agent memory unavailable.' };
    }

    const symbol = String(opts?.symbol || '').trim();
    const timeframe = String(opts?.timeframe || '').trim();
    const kind = String(opts?.kind || '').trim();
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(opts?.limit)))) : 6;
    const tags = Array.isArray(opts?.tags) && opts?.tags.length > 0 ? opts?.tags : undefined;

    try {
      const res = await ledger.listAgentMemory({
        limit,
        symbol: symbol || undefined,
        timeframe: timeframe || undefined,
        kind: kind || undefined,
        tags,
        agentId: opts?.agentId,
        scope: opts?.scope,
        category: opts?.category,
        subcategory: opts?.subcategory
      });
      if (!res?.ok) {
        const err = res?.error ? String(res.error) : 'Failed to load agent memory.';
        setAgentMemoryError(err);
        return { ok: false, error: err };
      }
      const memories = Array.isArray(res.memories) ? res.memories : [];
      agentMemoryRef.current = memories;
      const updatedAtMs = Date.now();
      setAgentMemoryUpdatedAtMs(updatedAtMs);
      setAgentMemoryError(null);
      return { ok: true };
    } catch (err: any) {
      const message = err?.message ? String(err.message) : 'Failed to load agent memory.';
      setAgentMemoryError(message);
      return { ok: false, error: message };
    }
  }, []);

  const refreshActionFlows = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false, error: 'Agent memory unavailable.' };
    try {
      const res = await ledger.listAgentMemory({ limit: 200, kind: 'action_flow' });
      if (!res?.ok) {
        return { ok: false, error: res?.error ? String(res.error) : 'Failed to load action flows.' };
      }
      const memories = Array.isArray(res.memories) ? res.memories : [];
      const nextMap = new Map<string, {
        intentKey: string;
        intentLabel?: string | null;
        symbol?: string | null;
        timeframe?: string | null;
        sequences: Map<string, { sequence: string[]; count: number; successCount: number; lastSeenAtMs: number }>;
        recent: Array<{ actionId: string; ok: boolean; atMs: number }>;
      }>();
      for (const memory of memories) {
        const payload = memory?.payload && typeof memory.payload === 'object' ? memory.payload as any : null;
        const intentKey = String(payload?.intentKey || memory?.key || '').replace(/^action_flow:/, '').trim();
        if (!intentKey) continue;
        const sequences = new Map<string, { sequence: string[]; count: number; successCount: number; lastSeenAtMs: number }>();
        const list = Array.isArray(payload?.sequences) ? payload.sequences : [];
        for (const entry of list) {
          const seq = Array.isArray(entry?.sequence) ? entry.sequence.map((s: any) => String(s)) : [];
          if (seq.length === 0) continue;
          const key = seq.join(' > ');
          sequences.set(key, {
            sequence: seq,
            count: Number(entry?.count) || 0,
            successCount: Number(entry?.successCount) || 0,
            lastSeenAtMs: Number(entry?.lastSeenAtMs) || 0
          });
        }
        nextMap.set(intentKey, {
          intentKey,
          intentLabel: payload?.intentLabel != null ? String(payload.intentLabel) : (memory?.summary || null),
          symbol: memory?.symbol != null ? String(memory.symbol) : null,
          timeframe: memory?.timeframe != null ? String(memory.timeframe) : null,
          sequences,
          recent: []
        });
      }
      actionFlowStateRef.current = nextMap;
      updateRecommendedActionFlowsRef.current?.();
      void pruneActionTraceMemories();
      return { ok: true };
    } catch (err: any) {
      return { ok: false, error: err?.message ? String(err.message) : 'Failed to load action flows.' };
    }
  }, [pruneActionTraceMemories]);

  const refreshSetupLibrary = useCallback(async (opts?: { symbol?: string; timeframe?: string; strategy?: string; limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) {
      setSetupLibraryError('Setup library unavailable.');
      return { ok: false, error: 'Setup library unavailable.' };
    }

    const symbol = String(opts?.symbol || '').trim();
    const timeframe = String(opts?.timeframe || '').trim();
    const strategy = String(opts?.strategy || '').trim().toUpperCase();
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(1, Math.min(200, Math.floor(Number(opts?.limit)))) : 50;
    const tags = strategy ? [strategy] : undefined;

    try {
      const res = await ledger.listAgentMemory({
        limit,
        kind: 'setup_library',
        symbol: symbol || undefined,
        timeframe: timeframe || undefined,
        tags
      });
      if (!res?.ok) {
        const err = res?.error ? String(res.error) : 'Failed to load setup library.';
        setSetupLibraryError(err);
        return { ok: false, error: err };
      }

      const memories = Array.isArray(res.memories) ? res.memories : [];
      const map = new Map<string, SetupLibraryEntry>();
      for (const memory of memories) {
        const payload = memory?.payload as SetupLibraryEntry | undefined | null;
        if (!payload || typeof payload !== 'object') continue;
        const key = String(payload.key || memory?.key || '').trim();
        if (!key) continue;
        const existing = map.get(key);
        if (!existing || (payload.score ?? 0) > (existing.score ?? 0)) {
          map.set(key, payload);
        }
      }

      const entries = Array.from(map.values()).sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
      setSetupLibraryEntries(entries);
      setSetupLibraryUpdatedAtMs(Date.now());
      setSetupLibraryError(null);
      return { ok: true, count: entries.length };
    } catch (err: any) {
      const message = err?.message ? String(err.message) : 'Failed to load setup library.';
      setSetupLibraryError(message);
      return { ok: false, error: message };
    }
  }, []);

  const refreshTaskPlaybooks = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) {
      setTaskPlaybookError('Playbook library unavailable.');
      return { ok: false, error: 'Playbook library unavailable.' };
    }

    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(1, Math.min(200, Math.floor(Number(opts?.limit)))) : 50;

    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'task_playbook' });
      if (!res?.ok) {
        const err = res?.error ? String(res.error) : 'Failed to load playbook library.';
        setTaskPlaybookError(err);
        return { ok: false, error: err };
      }
      const memories = Array.isArray(res.memories) ? res.memories : [];
      const playbooks = memories
        .map((memory) => normalizeTaskPlaybook(memory?.payload ?? memory))
        .filter(Boolean) as TaskPlaybook[];
      playbooks.sort((a, b) => (Number(b.updatedAtMs || 0) - Number(a.updatedAtMs || 0)));
      setTaskPlaybooks(playbooks);
      setTaskPlaybookUpdatedAtMs(Date.now());
      setTaskPlaybookError(null);
      return { ok: true, count: playbooks.length };
    } catch (err: any) {
      const message = err?.message ? String(err.message) : 'Failed to load playbook library.';
      setTaskPlaybookError(message);
      return { ok: false, error: message };
    }
  }, []);

  const refreshPlaybookRuns = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listPlaybookRuns) return { ok: false, error: 'Playbook runs unavailable.' };
    try {
      const res = await ledger.listPlaybookRuns({ limit: opts?.limit ?? 40 });
      if (!res?.ok || !Array.isArray(res.runs)) {
        return { ok: false, error: res?.error || 'Failed to load playbook runs.' };
      }
      const runs = res.runs.filter(Boolean) as TaskPlaybookRun[];
      taskPlaybookRunsRef.current = runs;
      const active = runs.find((r) => r?.status === 'running' || r?.status === 'blocked') || runs[0] || null;
      taskPlaybookActiveRunRef.current = active || null;
      taskPlaybookUpdatedAtRef.current = Date.now();
      setTaskPlaybookUpdatedAtMs(Date.now());
      return { ok: true, count: runs.length };
    } catch (err: any) {
      return { ok: false, error: err?.message ? String(err.message) : 'Failed to load playbook runs.' };
    }
  }, []);

  const upsertTaskPlaybook = useCallback(async (input: TaskPlaybook, source?: string | null) => {
    const playbook = normalizeTaskPlaybook(input);
    if (!playbook) return { ok: false, error: 'Invalid playbook.' };
    const ledger = window.glass?.tradeLedger;
    if (ledger?.upsertAgentMemory) {
      const key = `task_playbook:${playbook.id}`;
      const summary = playbook.description || playbook.name;
      try {
        await ledger.upsertAgentMemory({
          key,
          familyKey: `task_playbook:${playbook.id}`,
          scope: 'shared',
          category: 'task',
          subcategory: 'playbook',
          kind: 'task_playbook',
          symbol: playbook.symbol || null,
          timeframe: Array.isArray(playbook.timeframes) ? playbook.timeframes[0] || null : null,
          summary,
          payload: { ...playbook, updatedAtMs: Date.now() },
          source: source || playbook.owner || 'system',
          tags: [playbook.symbol, playbook.strategy, 'playbook', 'task'].filter(Boolean)
        });
      } catch (err: any) {
        const message = err?.message ? String(err.message) : 'Failed to persist playbook.';
        return { ok: false, error: message };
      }
    }

    setTaskPlaybooks((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.id === playbook.id);
      const updated = { ...playbook, updatedAtMs: Date.now() };
      if (idx >= 0) next[idx] = updated;
      else next.unshift(updated);
      next.sort((a, b) => (Number(b.updatedAtMs || 0) - Number(a.updatedAtMs || 0)));
      return next;
    });
    setTaskPlaybookUpdatedAtMs(Date.now());
    setTaskPlaybookError(null);
    return { ok: true, playbook };
  }, []);

  const ensureDefaultTaskPlaybook = useCallback(async () => {
    const defaults = [buildDefaultTradeSessionPlaybook()];
    const existing = taskPlaybooksRef.current || [];
    for (const playbook of defaults) {
      if (existing.find((item) => item.id === playbook.id)) continue;
      await upsertTaskPlaybook(playbook, 'system');
    }
  }, [upsertTaskPlaybook]);

  const buildAgentMemoryContext = useCallback(() => {
    const entries = agentMemoryRef.current || [];
    if (!Array.isArray(entries) || entries.length === 0) {
      if (agentMemoryError) return `AGENT MEMORY: unavailable (${agentMemoryError})`;
      return '';
    }

    const fmtPct = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
    };
    const fmtR = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
    };
    const fmtNum = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? num.toFixed(2) : '--';
    };
    const formatEntry = (entry: any) => {
      if (!entry || typeof entry !== 'object') return null;
      const kind = String(entry.kind || '').trim();
      const symbol = String(entry.symbol || '').trim();
      const timeframe = String(entry.timeframe || '').trim();
      const metaLabel = [kind || 'memory', symbol, timeframe].filter(Boolean).join(' ');
      const updatedAt = formatAgeShort(entry.updatedAtMs || entry.createdAtMs || null);
      const summary = String(entry.summary || '').trim();
      const summaryLine = summary ? summary.split('\n')[0] : '';
      const stats = entry.payload?.stats || {};
      const perf = entry.payload?.performance || {};
      const statsLabel =
        stats && (stats.total != null || stats.winRate != null || stats.expectancy != null || stats.profitFactor != null || perf.netR != null)
          ? `Trades ${stats.total ?? '--'} WR ${fmtPct(stats.winRate)} Exp ${fmtR(stats.expectancy)} PF ${fmtNum(stats.profitFactor)} Net ${fmtR(perf.netR)}`
          : '';
      const key = entry.key ? `Key ${entry.key}` : '';
      const parts = [metaLabel, updatedAt ? `Updated ${updatedAt}` : '', statsLabel, summaryLine, key].filter(Boolean);
      return `- ${parts.join(' | ')}`;
    };

    const lines = entries.slice(0, 3).map(formatEntry).filter(Boolean) as string[];
    if (entries.length > 3) lines.push(`- (+${entries.length - 3} more)`);
    const updatedLabel = formatAgeShort(agentMemoryUpdatedAtMs);
    const header = `AGENT MEMORY${updatedLabel ? ` (refreshed ${updatedLabel})` : ''}`;
    return [header, ...lines].join('\n');
  }, [agentMemoryError, agentMemoryUpdatedAtMs, formatAgeShort]);

  const buildActionFlowContext = useCallback(() => {
    const flows = Array.isArray(recommendedActionFlowsState) ? recommendedActionFlowsState : [];
    if (flows.length === 0) return '';
    const lines = flows.slice(0, 5).map((flow) => {
      const label = flow.intentLabel || flow.intentKey || 'intent';
      const sequence = Array.isArray(flow.sequence) ? flow.sequence.join(' > ') : '';
      const success = Number.isFinite(Number(flow.successRate)) ? `${Math.round(flow.successRate * 100)}%` : '--';
      const meta = [flow.symbol, flow.timeframe].filter(Boolean).join(' ');
      const age = formatAgeShort(flow.lastSeenAtMs || null);
      const parts = [label, meta, `Success ${success}`, age ? `Seen ${age}` : '', sequence].filter(Boolean);
      return `- ${parts.join(' | ')}`;
    });
    return ['ACTION FLOWS', ...lines].join('\n');
  }, [formatAgeShort, recommendedActionFlowsState]);

  const buildSetupContext = useCallback(() => {
    const watchers = Array.isArray(setupWatchers) ? setupWatchers : [];
    const profiles = Array.isArray(watchProfiles) ? watchProfiles : [];
    const libraryEntries = Array.isArray(setupLibraryEntries) ? setupLibraryEntries : [];
    const hasSummary = !!setupPerformanceSummary;
    const regimeEntries = Object.values(setupRegimes || {});
    if (watchers.length === 0 && profiles.length === 0 && libraryEntries.length === 0 && !hasSummary && setupSignals.length === 0 && regimeEntries.length === 0) return '';

    const fmtPct = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
    };
    const fmtNum = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? num.toFixed(2) : '--';
    };
    const fmtCash = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '--';
      const sign = num >= 0 ? '+' : '';
      return `${sign}$${num.toFixed(2)}`;
    };
    const fmtSlip = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '--';
      const sign = num >= 0 ? '+' : '';
      return `${sign}${num.toFixed(2)}`;
    };
    const fmtPctTight = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? `${num.toFixed(2)}%` : '--';
    };

    const formatSignal = (signal: SetupSignal) => {
      if (!signal) return '';
      const age = formatAgeShort(signal.ts);
      const status = signal.payload?.status || signal.payload?.signalType || '';
      const strengthPct = Number.isFinite(Number(signal.strength)) ? Math.round(Number(signal.strength) * 100) : null;
      const details = signal.payload?.details || null;
      const entry = formatBrokerPrice(details?.entryPrice);
      const stop = formatBrokerPrice(details?.stopLoss);
      const tp = formatBrokerPrice(details?.takeProfit);
      const priceParts = [
        entry ? `entry ${entry}` : '',
        stop ? `sl ${stop}` : '',
        tp ? `tp ${tp}` : ''
      ].filter(Boolean).join(' ');
      const evidence =
        signal.payload?.evidence ||
        buildEvidenceCardFromSignal({
          strategy: signal.payload?.strategy,
          signalType: signal.payload?.signalType,
          side: signal.payload?.side || null,
          details,
          reasonCodes: signal.reasonCodes || [],
          strength: signal.strength,
          regime: details?.regime ? String(details.regime) : null,
          createdAtMs: signal.ts || Date.now()
        });
      const evidenceBits = evidence
        ? [
            evidence.bias ? `bias ${evidence.bias}` : '',
            evidence.invalidation ? `inv ${evidence.invalidation}` : '',
            evidence.confidence?.score != null
              ? `conf ${Math.round(Number(evidence.confidence.score) * 100)}%`
              : ''
          ].filter(Boolean)
        : [];
      const base = [
        status,
        signal.payload?.side ? signal.payload.side : '',
        signal.symbol,
        signal.timeframe,
        signal.payload?.strategy,
        age ? `${age} ago` : '',
        strengthPct != null ? `${strengthPct}%` : ''
      ].filter(Boolean).join(' ');
      return `- ${base}${priceParts ? ` | ${priceParts}` : ''}${evidenceBits.length ? ` | ${evidenceBits.join(' | ')}` : ''}`;
    };

    const watcherLines = watchers.slice(0, 6).map((watcher) => {
      const age = formatAgeShort(watcher.updatedAtMs || watcher.createdAtMs);
      const lastSignal = watcher.lastSignalType ? `last ${watcher.lastSignalType}` : 'last none';
      const mode = watcher.mode ? `mode ${watcher.mode}` : '';
      const status = watcher.enabled ? 'on' : 'off';
      const live = setupPerformanceByWatcher?.[watcher.id];
      const drift = live?.drift;
      const driftLabel = drift
        ? `drift ${drift.status}${drift.winRateDelta != null ? ` WR ${fmtPct(drift.winRateDelta)}` : ''}${drift.profitFactorDelta != null ? ` PF ${fmtNum(drift.profitFactorDelta)}` : ''}`
        : '';
      const liveLabel = live
        ? `live ${live.trades} trades WR ${fmtPct(live.winRate)} PF ${fmtNum(live.profitFactor)} PnL ${fmtCash(live.netPnl)}${driftLabel ? ` ${driftLabel}` : ''}`
        : '';
      const parts = [
        watcher.symbol,
        watcher.timeframe,
        watcher.strategy,
        `(${status})`,
        mode,
        `gate ${watcher.regime || 'any'}`,
        lastSignal,
        liveLabel,
        age ? `updated ${age}` : ''
      ].filter(Boolean);
      return `- ${parts.join(' | ')}`;
    });
    if (watchers.length > 6) watcherLines.push(`- (+${watchers.length - 6} more)`);

    const watcherByProfile = new Map<string, SetupWatcher>();
    for (const watcher of watchers) {
      if (watcher?.profileId) watcherByProfile.set(String(watcher.profileId), watcher);
    }
    const profileLines = profiles.slice(0, 6).map((profile) => {
      const watcher = profile.profileId ? watcherByProfile.get(profile.profileId) : undefined;
      const status = watcher?.enabled ? 'on' : 'off';
      const label = profile.objectivePresetName || profile.objectivePresetId || '';
      const lastSignal = watcher?.lastSignalType ? `last ${watcher.lastSignalType}` : '';
      const age = formatAgeShort(profile.updatedAtMs || profile.createdAtMs);
      const parts = [
        profile.symbol,
        profile.timeframe,
        profile.strategy,
        `(${status})`,
        label ? `preset ${label}` : '',
        lastSignal,
        age ? `updated ${age}` : ''
      ].filter(Boolean);
      return `- ${parts.join(' | ')}`;
    });
    if (profiles.length > 6) profileLines.push(`- (+${profiles.length - 6} more)`);

    const summary = setupPerformanceSummary;
    const summaryLine = summary
      ? [
          `Trades ${summary.trades ?? '--'}`,
          `WR ${fmtPct(summary.winRate)}`,
          `PF ${fmtNum(summary.profitFactor)}`,
          `PnL ${fmtCash(summary.netPnl)}`,
          summary.maxDrawdown != null ? `DD ${fmtSlip(-Math.abs(Number(summary.maxDrawdown) || 0))}` : '',
          summary.slippageAvg != null ? `Slip ${fmtSlip(summary.slippageAvg)}` : ''
        ].filter(Boolean).join(' | ')
      : '';

    const recentSignals = [...setupSignals]
      .sort((a, b) => (b.ts || 0) - (a.ts || 0))
      .slice(0, 5)
      .map(formatSignal)
      .filter(Boolean) as string[];
    if (setupSignals.length > 5) recentSignals.push(`- (+${setupSignals.length - 5} more)`);

    const sections: string[] = [];
    if (summaryLine) {
      sections.push('PERFORMANCE SUMMARY');
      sections.push(`- ${summaryLine}`);
    }
    if (profiles.length > 0) {
      sections.push(`WATCH PROFILES (${profiles.length})`, ...profileLines);
    }
    if (regimeEntries.length > 0) {
      const regimeLines = regimeEntries
        .sort((a, b) => (Number(b?.updatedAtMs) || 0) - (Number(a?.updatedAtMs) || 0))
        .slice(0, 4)
        .map((entry) => {
          const label = [entry.symbol, entry.timeframe].filter(Boolean).join(' ');
          const age = formatAgeShort(entry.updatedAtMs);
          const parts = [
            label,
            entry.label ? `regime ${entry.label}` : '',
            entry.trendStrength != null ? `trend ${fmtNum(entry.trendStrength)}` : '',
            entry.volatilityPct != null ? `vol ${fmtPctTight(entry.volatilityPct)}` : '',
            age ? `updated ${age}` : ''
          ].filter(Boolean);
          return `- ${parts.join(' | ')}`;
        });
      if (regimeEntries.length > 4) regimeLines.push(`- (+${regimeEntries.length - 4} more)`);
      sections.push(`REGIME (${regimeEntries.length})`);
      sections.push(...regimeLines);
    }
    if (watchers.length > 0) {
      sections.push(`SETUP WATCHERS (${watchers.length})`, ...watcherLines);
    }
    if (recentSignals.length > 0) {
      sections.push('RECENT SETUP SIGNALS');
      sections.push(...recentSignals);
    }
    if (libraryEntries.length > 0) {
      const fmtR = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
      };
      const libraryLines = libraryEntries.slice(0, 4).map((entry) => {
        const stats = entry.stats || {};
        const perf = entry.performance || {};
        const live = setupPerformanceByLibrary?.[entry.key];
        const drift = live?.drift;
        const driftLabel = drift
          ? `drift ${drift.status}${drift.winRateDelta != null ? ` WR ${fmtPct(drift.winRateDelta)}` : ''}${drift.profitFactorDelta != null ? ` PF ${fmtNum(drift.profitFactorDelta)}` : ''}`
          : '';
        const liveLabel = live
          ? `live ${live.trades} trades WR ${fmtPct(live.winRate)} PF ${fmtNum(live.profitFactor)} PnL ${fmtCash(live.netPnl)}${driftLabel ? ` ${driftLabel}` : ''}`
          : '';
        const evidence = entry.evidence || buildEvidenceCardFromLibraryEntry(entry);
        const evidenceBits = evidence
          ? [
              evidence.bias ? `bias ${evidence.bias}` : '',
              evidence.invalidation ? `inv ${evidence.invalidation}` : '',
              evidence.confidence?.score != null
                ? `conf ${Math.round(Number(evidence.confidence.score) * 100)}%`
                : ''
            ].filter(Boolean).join(' | ')
          : '';
        const parts = [
          entry.symbol,
          entry.timeframe,
          entry.strategy,
          `${entry.tier}`,
          `score ${entry.score}`,
          `WR ${fmtPct(stats.winRate)}`,
          `PF ${fmtNum(stats.profitFactor)}`,
          `Net ${fmtR(perf.netR)}`,
          liveLabel,
          evidenceBits
        ].filter(Boolean);
        return `- ${parts.join(' | ')}`;
      });
      if (libraryEntries.length > 4) libraryLines.push(`- (+${libraryEntries.length - 4} more)`);
      sections.push(`SETUP LIBRARY (${libraryEntries.length})`);
      sections.push(...libraryLines);
    }

    const modeEntries = Object.entries(setupPerformanceByMode || {});
    if (modeEntries.length > 0) {
      const modeLines = modeEntries
        .sort((a, b) => (Number(b[1]?.trades) || 0) - (Number(a[1]?.trades) || 0))
        .slice(0, 4)
        .map(([mode, perf]) => {
          const parts = [
            mode,
            `Trades ${perf.trades ?? '--'}`,
            `WR ${fmtPct(perf.winRate)}`,
            `PF ${fmtNum(perf.profitFactor)}`,
            `PnL ${fmtCash(perf.netPnl)}`
          ].filter(Boolean);
          return `- ${parts.join(' | ')}`;
        });
      sections.push(`MODE PERFORMANCE (${modeEntries.length})`);
      sections.push(...modeLines);
    }

    const symbolEntries = Object.entries(setupPerformanceBySymbol || {});
    if (symbolEntries.length > 0) {
      const symbolLines = symbolEntries
        .sort((a, b) => (Number(b[1]?.trades) || 0) - (Number(a[1]?.trades) || 0))
        .slice(0, 4)
        .map(([key, perf]) => {
          const [symbol, tf] = String(key || '').split(':');
          const label = [symbol || perf.symbol, tf || perf.timeframe].filter(Boolean).join(' ');
          const parts = [
            label,
            `Trades ${perf.trades ?? '--'}`,
            `WR ${fmtPct(perf.winRate)}`,
            `PF ${fmtNum(perf.profitFactor)}`,
            `PnL ${fmtCash(perf.netPnl)}`
          ].filter(Boolean);
          return `- ${parts.join(' | ')}`;
        });
      sections.push(`SYMBOL PERFORMANCE (${symbolEntries.length})`);
      sections.push(...symbolLines);
    }
    return sections.join('\n');
  }, [formatAgeShort, setupLibraryEntries, setupPerformanceByLibrary, setupPerformanceByMode, setupPerformanceBySymbol, setupPerformanceByWatcher, setupPerformanceSummary, setupRegimes, setupSignals, setupWatchers, watchProfiles]);

  const buildPlaybookContext = useCallback(() => {
    const playbooks = taskPlaybooksRef.current || [];
    const activeRun = taskPlaybookActiveRunRef.current;
    if (playbooks.length === 0 && !activeRun) return '';
    const lines: string[] = ['TASK PLAYBOOKS'];
    if (activeRun) {
      const status = activeRun.status ? String(activeRun.status).toUpperCase() : 'UNKNOWN';
      const stepLabel = activeRun.currentActionId ? `step ${activeRun.currentActionId}` : '';
      lines.push(`- Active ${activeRun.playbookName || activeRun.playbookId} | ${status}${stepLabel ? ` | ${stepLabel}` : ''}`);
    }
    const listLines = playbooks.slice(0, 4).map((p) => {
      const meta = [p.symbol, p.strategy, p.timeframes?.join('/')].filter(Boolean).join(' ');
      return `- ${p.id} | ${p.name}${meta ? ` | ${meta}` : ''}`;
    });
    if (listLines.length > 0) lines.push(...listLines);
    if (playbooks.length > 4) lines.push(`- (+${playbooks.length - 4} more)`);
    return lines.join('\n');
  }, []);

  const buildWatchProfileContext = useCallback(() => {
    const profiles = Array.isArray(watchProfiles) ? watchProfiles : [];
    const signals = Array.isArray(setupSignals) ? setupSignals : [];
    if (profiles.length === 0 && signals.length === 0) return '';

    const profileLines = profiles.slice(0, 4).map((profile) => {
      const label = profile.objectivePresetName || profile.objectivePresetId || '';
      const age = formatAgeShort(profile.updatedAtMs || profile.createdAtMs);
      const parts = [
        profile.symbol,
        profile.timeframe,
        profile.strategy,
        label ? `preset ${label}` : '',
        age ? `updated ${age}` : ''
      ].filter(Boolean);
      return `- ${parts.join(' | ')}`;
    });
    if (profiles.length > 4) profileLines.push(`- (+${profiles.length - 4} more)`);

    const signalLines = signals
      .slice()
      .sort((a, b) => (b.ts || 0) - (a.ts || 0))
      .slice(0, 5)
      .map((signal) => {
        const age = formatAgeShort(signal.ts);
        const status = signal.payload?.status || signal.payload?.signalType || '';
        const strengthPct = Number.isFinite(Number(signal.strength)) ? Math.round(Number(signal.strength) * 100) : null;
        const parts = [
          status,
          signal.symbol,
          signal.timeframe,
          signal.payload?.strategy,
          age ? `${age} ago` : '',
          strengthPct != null ? `${strengthPct}%` : ''
        ].filter(Boolean);
        return `- ${parts.join(' | ')}`;
      });
    if (signals.length > 5) signalLines.push(`- (+${signals.length - 5} more)`);

    const sections: string[] = [];
    if (profiles.length > 0) {
      sections.push(`WATCH PROFILES (${profiles.length})`);
      sections.push(...profileLines);
    }
    if (signalLines.length > 0) {
      sections.push('RECENT SETUP SIGNALS');
      sections.push(...signalLines);
    }
    return sections.join('\n');
  }, [formatAgeShort, setupSignals, watchProfiles]);

  const buildGuardrailContext = useCallback(() => {
    const cfg = autoPilotConfigRef.current;
    if (!cfg) return '';
    const { mode, policy, effective } = resolveAutoPilotPolicy(cfg);
    const status = effective.enabled ? 'ENABLED' : 'DISABLED';
    const kill = effective.killSwitch ? 'KILL SWITCH ON' : '';
    const risk = Number.isFinite(Number(effective.riskPerTrade)) ? `${Number(effective.riskPerTrade).toFixed(2)}%` : '--';
    const maxLoss = Number.isFinite(Number(effective.maxDailyLoss)) ? `$${Number(effective.maxDailyLoss).toFixed(2)}` : '--';
    const maxOpen = Number.isFinite(Number(effective.maxOpenPositions)) ? String(effective.maxOpenPositions) : '--';
    const requireConfirm = effective.requireConfirmation ? 'confirm on' : 'confirm off';
    const spreadModel = effective.spreadLimitModel || 'none';
    const spreadLabel =
      spreadModel === 'percent'
        ? Number.isFinite(Number(effective.spreadLimitPct)) ? `${Number(effective.spreadLimitPct).toFixed(3)}%` : '--'
        : spreadModel === 'atr'
          ? Number.isFinite(Number(effective.spreadLimitAtrMult)) ? `${Number(effective.spreadLimitAtrMult).toFixed(2)}x ATR` : '--'
          : 'none';
    const driftWarn = cfg?.driftActionWarn || 'none';
    const driftPoor = cfg?.driftActionPoor || 'none';
    const driftCooldown = Number(cfg?.driftActionCooldownHours);
    const driftCooldownLabel = Number.isFinite(driftCooldown) && driftCooldown > 0 ? `${driftCooldown}h` : '0h';
    const driftRetest = cfg?.driftAutoRetest ? 'on' : 'off';
    const driftRetestCooldown = Number(cfg?.driftRetestCooldownHours);
    const driftRetestCooldownLabel = Number.isFinite(driftRetestCooldown) && driftRetestCooldown > 0 ? `${driftRetestCooldown}h` : '--';
    const driftRange = Number(cfg?.driftRetestRangeDays);
    const driftRangeLabel = Number.isFinite(driftRange) && driftRange > 0 ? `${driftRange}d` : '--';
    const driftCombos = Number(cfg?.driftRetestMaxCombos);
    const driftCombosLabel = Number.isFinite(driftCombos) && driftCombos > 0 ? String(driftCombos) : '--';
    const caps = [];
    if (Number.isFinite(Number(effective.perSymbolMaxPositions)) && Number(effective.perSymbolMaxPositions) > 0) {
      caps.push(`per symbol ${Number(effective.perSymbolMaxPositions)} pos`);
    }
    if (Number.isFinite(Number(effective.perSymbolMaxLot)) && Number(effective.perSymbolMaxLot) > 0) {
      caps.push(`per symbol ${Number(effective.perSymbolMaxLot)} lot`);
    }
    const modeLabel = mode === 'custom' ? 'CUSTOM' : String(mode || 'custom').toUpperCase();
    const filters = [];
    if (policy.allowedStrategies && policy.allowedStrategies.length > 0) {
      filters.push(`strategies ${policy.allowedStrategies.join('/')}`);
    }
    if (policy.allowedTimeframes && policy.allowedTimeframes.length > 0) {
      filters.push(`timeframes ${policy.allowedTimeframes.join('/')}`);
    }

    const lines = [
      `GUARDRAILS: AutoPilot ${status}${kill ? ` (${kill})` : ''} | Mode ${modeLabel}`,
      `- Risk ${risk} | Max daily loss ${maxLoss} | Max open ${maxOpen} | ${requireConfirm}`,
      `- Spread limit ${spreadModel} ${spreadLabel}${caps.length ? ` | ${caps.join(' | ')}` : ''}${filters.length ? ` | ${filters.join(' | ')}` : ''}`,
      `- Drift warn ${String(driftWarn)} | poor ${String(driftPoor)} | cooldown ${driftCooldownLabel} | retest ${driftRetest} (${driftRangeLabel}, ${driftRetestCooldownLabel}, max ${driftCombosLabel})`
    ];
    return lines.join('\n');
  }, []);

  const buildSymbolScopeContext = useCallback(() => {
    if (!symbolScopeSymbol) return '';
    const tfLabel = symbolScopeTimeframesLabel || '5m/15m/1H/4H';
    return `SYMBOL SCOPE: ${symbolScopeSymbol} | Timeframes ${tfLabel}`;
  }, [symbolScopeSymbol, symbolScopeTimeframesLabel]);

  const getContextPack = useCallback(() => {
    const broker = getBrokerContext();
    const memory = buildAgentMemoryContext();
    const flows = buildActionFlowContext();
    const guardrails = buildGuardrailContext();
    const symbolScopeContext = buildSymbolScopeContext();
    const setups = buildSetupContext();
    const playbooks = buildPlaybookContext();
    const health = buildHealthContext();
    const chartContext = chartEngine.buildContextPack({ barsLimit: 50, eventsLimit: 20 });
    const academyLessons = academyAutoApplyEnabled ? (academyLessonContextRef.current || '') : '';
    const sections = [];
    if (broker) sections.push(`BROKER SNAPSHOT:\n${broker}`);
    if (health) sections.push(health);
    if (symbolScopeContext) sections.push(symbolScopeContext);
    if (chartContext) sections.push(chartContext);
    if (guardrails) sections.push(guardrails);
    if (playbooks) sections.push(playbooks);
    if (setups) sections.push(setups);
    if (flows) sections.push(flows);
    if (academyLessons) sections.push(academyLessons);
    if (memory) sections.push(memory);
    return sections.join('\n\n');
  }, [academyAutoApplyEnabled, buildActionFlowContext, buildAgentMemoryContext, buildGuardrailContext, buildHealthContext, buildPlaybookContext, buildSetupContext, buildSymbolScopeContext, chartEngine, getBrokerContext]);

  useEffect(() => {
    getContextPackRef.current = getContextPack;
  }, [getContextPack]);

  const getChartContextPack = useCallback((opts?: { eventsLimit?: number }) => {
    const eventsLimit = Number.isFinite(Number(opts?.eventsLimit))
      ? Math.max(0, Math.floor(Number(opts?.eventsLimit)))
      : 20;
    const chartContext = chartEngine.buildContextPack({ barsLimit: 50, eventsLimit });
    const watchContext = buildWatchProfileContext();
    const symbolScopeContext = buildSymbolScopeContext();
    return [symbolScopeContext, chartContext, watchContext].filter(Boolean).join('\n\n');
  }, [buildSymbolScopeContext, buildWatchProfileContext, chartEngine]);

  const captureContextPack = useCallback(async (opts?: { copy?: boolean; save?: boolean }) => {
    const text = String(getContextPack() || '').trim();
    if (!text) {
      addNotification('Context Pack Empty', 'No broker or setup context to capture yet.', 'warning');
      return { ok: false };
    }
    const doCopy = opts?.copy === true;
    const doSave = opts?.save === true;
    let copied = false;
    let saved = false;

    if (doCopy) {
      try {
        const clipboard = window.glass?.clipboard?.writeText;
        if (clipboard) {
          await clipboard(text);
          copied = true;
        } else if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          copied = true;
        }
      } catch {
        // ignore copy failures
      }
    }

    if (doSave) {
      try {
        const ledger = window.glass?.tradeLedger;
        if (ledger?.upsertAgentMemory) {
          const summary = backtesterRef.current?.getSummary?.();
          const symbol = String(summary?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
          const timeframe = String(summary?.timeframe || activeTvTimeframeLabel || '').trim();
          const keyParts = [symbol || 'na', timeframe || 'na', Date.now()].join(':');
          const key = `context_pack:${keyParts}`;
          const label = [symbol, timeframe].filter(Boolean).join(' ');
          await ledger.upsertAgentMemory({
            key,
            kind: 'context_pack',
            symbol: symbol || undefined,
            timeframe: timeframe || undefined,
            summary: label ? `Context pack ${label}` : 'Context pack snapshot',
            payload: { text },
            source: 'ui',
            tags: [symbol, timeframe, 'context', 'snapshot'].filter(Boolean)
          });
          saved = true;
        }
      } catch {
        // ignore save failures
      }
    }

    if (copied || saved) {
      addNotification(
        'Context Pack Captured',
        `${copied ? 'Copied to clipboard' : ''}${copied && saved ? ' + ' : ''}${saved ? 'saved to memory' : ''}.`,
        'success'
      );
    } else {
      addNotification('Context Pack Failed', 'Unable to capture context pack.', 'warning');
    }

    return { ok: copied || saved, copied, saved };
  }, [activeBrokerSymbol, activeTvParams?.symbol, activeTvTimeframeLabel, addNotification, getContextPack, symbolScopeSymbol]);

  const captureChartContextPack = useCallback(async (opts?: { copy?: boolean; save?: boolean }) => {
    const text = String(getChartContextPack() || '').trim();
    if (!text) {
      addNotification('Chart Context Empty', 'No chart context to capture yet.', 'warning');
      return { ok: false };
    }
    const doCopy = opts?.copy === true;
    const doSave = opts?.save === true;
    let copied = false;
    let saved = false;

    if (doCopy) {
      try {
        const clipboard = window.glass?.clipboard?.writeText;
        if (clipboard) {
          await clipboard(text);
          copied = true;
        } else if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          copied = true;
        }
      } catch {
        // ignore copy failures
      }
    }

    if (doSave) {
      try {
        const ledger = window.glass?.tradeLedger;
        if (ledger?.upsertAgentMemory) {
          const snapshots = chartEngine.getSnapshots({ barsLimit: 1, eventsLimit: 1 });
          const primary = snapshots[0];
          const symbol = String(primary?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
          const timeframe = String(primary?.timeframe || activeTvTimeframeLabel || '').trim();
          const keyParts = [symbol || 'na', timeframe || 'na', Date.now()].join(':');
          const key = `chart_context:${keyParts}`;
          const label = [symbol, timeframe].filter(Boolean).join(' ');
          await ledger.upsertAgentMemory({
            key,
            kind: 'chart_context_pack',
            symbol: symbol || undefined,
            timeframe: timeframe || undefined,
            summary: label ? `Chart context ${label}` : 'Chart context snapshot',
            payload: { text },
            source: 'ui',
            tags: [symbol, timeframe, 'chart', 'context', 'snapshot'].filter(Boolean)
          });
          saved = true;
        }
      } catch {
        // ignore save failures
      }
    }

    if (copied || saved) {
      addNotification(
        'Chart Context Captured',
        `${copied ? 'Copied to clipboard' : ''}${copied && saved ? ' + ' : ''}${saved ? 'saved to memory' : ''}.`,
        'success'
      );
    } else {
      addNotification('Chart Context Failed', 'Unable to capture chart context.', 'warning');
    }

    return { ok: copied || saved, copied, saved };
  }, [activeBrokerSymbol, activeTvParams?.symbol, activeTvTimeframeLabel, addNotification, chartEngine, getChartContextPack, symbolScopeSymbol]);

  const persistChartSnapshotMemory = useCallback(async (input: {
    imageDataUrl: string;
    meta?: NativeChartMeta | null;
    symbol?: string | null;
    timeframe?: string | null;
    source?: string | null;
  }) => {
    const imageDataUrl = String(input.imageDataUrl || '').trim();
    if (!imageDataUrl) return null;
    const meta = input.meta || null;
    const symbol =
      String(input.symbol || meta?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    const frameLabel = meta?.frames && meta.frames.length > 0 ? String(meta.frames[0]?.label || '').trim() : '';
    const timeframe = String(input.timeframe || frameLabel || activeTvTimeframeLabel || '').trim();
    const capturedAtMs = Date.now();
    const keyParts = [symbol || 'na', timeframe || 'na', capturedAtMs].join(':');
    const key = `chart_snapshot:${keyParts}`;
    const ledger = window.glass?.tradeLedger;
    const saver = window.glass?.saveUserFile;
    let savedPath: string | null = null;
    let savedFileName: string | null = null;
    let savedMimeType: string | null = null;
    if (saver) {
      try {
        const prefixParts = ['chart_snapshot', symbol, timeframe].filter(Boolean);
        const prefix = prefixParts.length > 0 ? prefixParts.join('_') : 'chart_snapshot';
        const saved = await saver({ dataUrl: imageDataUrl, subdir: 'chart-snapshots', prefix });
        if (saved?.ok && saved.path) {
          savedPath = String(saved.path);
          savedFileName = saved.filename ? String(saved.filename) : null;
          savedMimeType = saved.mimeType ? String(saved.mimeType) : null;
        }
      } catch {
        // ignore save failures
      }
    }
    if (ledger?.upsertAgentMemory) {
      try {
        const summaryBase = [symbol, timeframe].filter(Boolean).join(' ') || 'Chart snapshot';
        await ledger.upsertAgentMemory({
          key,
          familyKey: `chart_snapshot:${symbol || 'na'}:${timeframe || 'na'}`,
          kind: 'chart_snapshot',
          symbol: symbol || undefined,
          timeframe: timeframe || undefined,
          summary: savedPath ? `${summaryBase} (saved)` : summaryBase,
          payload: {
            imageDataUrl,
            meta,
            capturedAtMs,
            savedPath,
            savedFileName,
            savedMimeType
          },
          source: input.source || 'chart',
          tags: [symbol, timeframe, 'chart', 'snapshot', 'library'].filter(Boolean)
        });
      } catch {
        // ignore ledger failures
      }
    }
    const memoryRecord = {
      key,
      savedPath,
      capturedAtMs,
      symbol: symbol || null,
      timeframe: timeframe || null
    };
    lastChartSnapshotMemoryRef.current = memoryRecord;
    void appendAuditEvent({
      eventType: 'chart_snapshot_captured',
      symbol: symbol || null,
      payload: {
        timeframe: timeframe || null,
        frames: meta?.frames ? meta.frames.length : 0,
        source: input.source || null
      }
    });
    return memoryRecord;
  }, [activeBrokerSymbol, activeTvParams?.symbol, activeTvTimeframeLabel, appendAuditEvent, symbolScopeSymbol]);

  const logChartChatEvent = useCallback((eventType: string, payload: Record<string, any>) => {
    void appendAuditEvent({
      eventType,
      symbol: payload?.symbol || null,
      payload
    });
  }, [appendAuditEvent]);

  const resolveChartChatSymbol = useCallback((override?: string) => {
    const raw = override || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '';
    return String(raw || '').trim();
  }, [activeBrokerSymbol, activeTvParams?.symbol, symbolScopeSymbol]);

  const resolveChartChatTimeframes = useCallback((override?: string[], opts?: { exact?: boolean }) => {
    const overrideList = Array.isArray(override) ? override : [];
    const base = Array.isArray(symbolScopeTimeframes) ? symbolScopeTimeframes : [];
    const merged: string[] = [];
    const seen = new Set<string>();
    const push = (value: any) => {
      const key = normalizeTimeframeKey(String(value || '').trim());
      if (!key || seen.has(key)) return;
      seen.add(key);
      merged.push(key);
    };
    if (opts?.exact && overrideList.length > 0) {
      overrideList.forEach(push);
      return merged;
    }
    overrideList.forEach(push);
    DEFAULT_CHART_CHAT_TIMEFRAMES.forEach(push);
    base.forEach(push);
    return merged;
  }, [symbolScopeTimeframes]);

  const resolveNativeChartFrameIds = useCallback((timeframes: string[]) => {
    return timeframes.map((tf) => formatTimeframeLabel(tf)).filter(Boolean);
  }, [formatTimeframeLabel]);

  const normalizeWarmupTimeframeKey = useCallback((value: string) => {
    const raw = normalizeTimeframeKey(String(value || '').trim());
    return raw ? raw.toLowerCase() : '';
  }, [normalizeTimeframeKey]);

  const buildSignalWarmupBarsByTimeframe = useCallback((timeframes: string[]) => {
    const out: Record<string, number> = {};
    const sessionOpen = isSignalSessionOpen(signalSessions);
    for (const tf of timeframes) {
      const key = normalizeWarmupTimeframeKey(tf);
      if (!key) continue;
      const configuredFloor = key === '1d'
        ? Math.max(signalSnapshotWarmupBars1d, SIGNAL_SNAPSHOT_WARMUP_BARS_1D)
        : key === '1w'
          ? Math.max(signalSnapshotWarmupBars1w, SIGNAL_SNAPSHOT_WARMUP_BARS_1W)
          : Math.max(signalSnapshotWarmupBarsDefault, SIGNAL_SNAPSHOT_WARMUP_BARS_DEFAULT);
      const plan = planWarmup({
        timeframe: key,
        configuredMinBars: configuredFloor,
        sessionOpen,
        cacheCoverageBars: 0,
        volatilityScore: null,
        brokerHealthy: true
      });
      out[key] = plan.requiredBars;
    }
    return out;
  }, [isSignalSessionOpen, normalizeWarmupTimeframeKey, signalSessions, signalSnapshotWarmupBars1d, signalSnapshotWarmupBars1w, signalSnapshotWarmupBarsDefault]);

  const areSnapshotFramesReady = useCallback((
    frames: Array<{ tf?: string; barsCount?: number }> | null | undefined,
    timeframes: string[],
    minBarsByTimeframe: Record<string, number>
  ) => {
    const list = Array.isArray(frames) ? frames : [];
    if (list.length === 0) return false;
    for (const tf of timeframes) {
      const key = normalizeWarmupTimeframeKey(tf);
      if (!key) continue;
      const frame = list.find((entry) => normalizeWarmupTimeframeKey(entry?.tf || '') === key);
      if (!frame) return false;
      const minBars = minBarsByTimeframe[key] ?? 1;
      const barsCount = Number(frame?.barsCount || 0);
      if (barsCount < minBars) return false;
    }
    return true;
  }, [normalizeWarmupTimeframeKey]);

  const warmupSignalSnapshotFrames = useCallback(async (input: {
    msgId: string;
    symbol: string;
    timeframes: string[];
    barsByTimeframe: Record<string, number>;
  }) => {
    const symbol = String(input.symbol || '').trim();
    const timeframes = Array.isArray(input.timeframes) ? input.timeframes : [];
    if (!symbol || timeframes.length === 0) return { ready: false, payloadResult: null };
    await chartEngine.refreshSessionsForSymbol(symbol, timeframes, {
      force: true,
      barsBackfillByTimeframe: input.barsByTimeframe
    });
    const minBarsByTimeframe = input.barsByTimeframe;
    const startedAt = Date.now();
    const sleep = (ms: number) => sleepMs(ms);
    let payloadResult: any = null;
    while (Date.now() - startedAt < signalSnapshotWarmupTimeoutMs) {
      const snapshots = chartEngine.getSnapshots({ barsLimit: CHART_CHAT_MAX_CANDLES, eventsLimit: 0, includeInactive: true });
      payloadResult = buildChartSnapshotPayload({
        msgId: input.msgId,
        symbol,
        timeframes,
        snapshots,
        maxCandles: CHART_CHAT_MAX_CANDLES,
        maxPayloadChars: CHART_CHAT_MAX_PAYLOAD_CHARS,
        capturedAtMs: Date.now(),
        imageIncluded: false
      });
      const frames = Array.isArray(payloadResult?.payload?.frames) ? payloadResult.payload.frames : [];
      if (areSnapshotFramesReady(frames, timeframes, minBarsByTimeframe)) {
        return { ready: true, payloadResult };
      }
      await sleep(SIGNAL_SNAPSHOT_WARMUP_POLL_MS);
    }
    return { ready: false, payloadResult };
  }, [
    areSnapshotFramesReady,
    buildChartSnapshotPayload,
    chartEngine,
    signalSnapshotWarmupTimeoutMs
  ]);

  const captureChartChatSnapshot = useCallback(async (
    msgId: string,
    override?: { symbol?: string; timeframes?: string[]; requireFullFrames?: boolean; exactTimeframes?: boolean }
  ) => {
    const startedAtMs = Date.now();
    const symbol = resolveChartChatSymbol(override?.symbol);
    const timeframes = resolveChartChatTimeframes(override?.timeframes, { exact: override?.exactTimeframes });
    const frameIds = resolveNativeChartFrameIds(timeframes);
    const requireFullFrames = override?.requireFullFrames === true;
    const warmupBarsByTimeframe = requireFullFrames ? buildSignalWarmupBarsByTimeframe(timeframes) : null;
    const captureStartMs = Date.now();
    let snapshotDataUrl: string | null = null;
    let snapshotMeta: NativeChartMeta | null = null;
    let snapshotCached = false;
    let snapshotCapturedAtMs: number | null = null;
    let snapshotReason: ChartSnapshotReasonCode | null = null;

    logChartChatEvent('SNAPSHOT_CAPTURE_START', {
      msgId,
      symbol,
      timeframesRequested: timeframes
    });

    if (!symbol) {
      snapshotReason = 'NO_SYMBOL_SELECTED';
    } else if (timeframes.length === 0) {
      snapshotReason = 'NO_TIMEFRAMES_SUBSCRIBED';
    }

    if (!snapshotReason) {
      if (symbol && timeframes.length > 0) {
        chartEngine.setActiveSessions(
          symbol,
          timeframes,
          warmupBarsByTimeframe ? { barsBackfillByTimeframe: warmupBarsByTimeframe } : undefined
        );
      }

      const ensureConnect = ensureTradeLockerConnectedRef.current;
      if (ensureConnect) {
        try {
          await ensureConnect('chart_chat_snapshot');
        } catch {
          // ignore
        }
      }

      if (!nativeChartMounted) {
        setNativeChartMounted(true);
      }

      let warmupPromise: Promise<{ ready: boolean; payloadResult: any }> | null = null;
      let warmupStartedAt = 0;
      if (requireFullFrames && warmupBarsByTimeframe && symbol && timeframes.length > 0) {
        beginSignalWarmup();
        recordPerf('signalSnapshotWarmups');
        warmupStartedAt = Date.now();
        warmupPromise = warmupSignalSnapshotFrames({
          msgId,
          symbol,
          timeframes,
          barsByTimeframe: warmupBarsByTimeframe
        }).then((result) => {
          if (warmupStartedAt) {
            recordPerf('signalSnapshotWarmupLastDurationMs', Date.now() - warmupStartedAt);
          }
          return result;
        }).finally(() => endSignalWarmup());
      }

      const chart = nativeChartRef.current;
      if (chart) {
        if (chart.setActiveFrames && frameIds.length > 0) {
          chart.setActiveFrames(frameIds);
        }
        if (chart.focusSymbol && symbol) {
          chart.focusSymbol(symbol, frameIds[0] || undefined, { revealSetups: false });
        } else if (chart.ensureFrameActive && frameIds[0]) {
          chart.ensureFrameActive(frameIds[0]);
        }

        const sleep = (ms: number) => sleepMs(ms);
        const startedAt = Date.now();
        while (Date.now() - startedAt < CHART_CHAT_CAPTURE_TIMEOUT_MS) {
          snapshotDataUrl = chart.captureSnapshot ? chart.captureSnapshot() : null;
          if (snapshotDataUrl) {
            snapshotMeta = chart.getMeta ? chart.getMeta() : null;
            snapshotCapturedAtMs = Date.now();
            lastNativeChartSnapshotRef.current = { dataUrl: snapshotDataUrl, meta: snapshotMeta, capturedAtMs: snapshotCapturedAtMs };
            void persistChartSnapshotMemory({
              imageDataUrl: snapshotDataUrl,
              meta: snapshotMeta,
              symbol,
              timeframe: frameIds[0] || null,
              source: 'chart_chat'
            });
            break;
          }
          await sleep(350);
        }
      } else {
        snapshotReason = 'RENDER_FAILED';
      }

      if (!snapshotDataUrl) {
        const cached = lastNativeChartSnapshotRef.current;
        if (cached?.dataUrl) {
          snapshotDataUrl = cached.dataUrl;
          snapshotMeta = cached.meta || null;
          snapshotCached = true;
          snapshotCapturedAtMs = cached.capturedAtMs || Date.now();
        } else if (!snapshotReason) {
          snapshotReason = 'SNAPSHOT_TIMEOUT';
        }
      }

      if (warmupPromise) {
        const warmupResult = await warmupPromise;
        if (!warmupResult?.ready) {
          recordPerf('signalSnapshotWarmupTimeouts');
        }
        if (!warmupResult?.ready && !snapshotReason) {
          snapshotReason = 'WARMUP_TIMEOUT';
        }
      }
    }

    const captureDurationMs = Date.now() - captureStartMs;
    logChartChatEvent('SNAPSHOT_CAPTURE_RESULT', {
      msgId,
      symbol,
      success: !!snapshotDataUrl,
      cached: snapshotCached,
      reasonCode: snapshotReason,
      imageChars: snapshotDataUrl ? snapshotDataUrl.length : 0,
      framesMeta: snapshotMeta?.frames || []
    });

    const framesStartMs = Date.now();
    const snapshots = chartEngine.getSnapshots({ barsLimit: CHART_CHAT_MAX_CANDLES, eventsLimit: 0, includeInactive: true });
    const framesDurationMs = Date.now() - framesStartMs;
    const snapshotContextAtMs = snapshotMeta?.updatedAtMs ?? snapshotCapturedAtMs;

    const payloadResult = buildChartSnapshotPayload({
      msgId,
      symbol,
      timeframes,
      snapshots,
      maxCandles: CHART_CHAT_MAX_CANDLES,
      maxPayloadChars: CHART_CHAT_MAX_PAYLOAD_CHARS,
      capturedAtMs: snapshotContextAtMs,
      imageIncluded: !!snapshotDataUrl
    });

    const payload = payloadResult.payload || {};
    const diagnostics = payload.diagnostics && typeof payload.diagnostics === 'object' ? payload.diagnostics : {};
    let reasonCode = diagnostics.reasonCode || null;
    const warnings = Array.isArray(diagnostics.warnings) ? diagnostics.warnings.slice() : [];

    if (snapshotReason) {
      if (!reasonCode) {
        reasonCode = snapshotReason;
      } else if (snapshotReason !== reasonCode && !warnings.includes(snapshotReason)) {
        warnings.push(snapshotReason);
      }
    }

    if (payloadResult.truncated && !warnings.includes('PAYLOAD_STRIPPED')) {
      warnings.push('PAYLOAD_STRIPPED');
    }

    const framesSummary = Array.isArray(payload.frames)
      ? payload.frames.map((frame: any) => ({
          tf: String(frame.tf || ''),
          barsCount: Number(frame.barsCount || 0) || 0,
          lastUpdatedAtMs: frame.lastUpdatedAtMs ?? null
        }))
      : [];

    if (requireFullFrames && warmupBarsByTimeframe) {
      const framesReady = areSnapshotFramesReady(framesSummary, timeframes, warmupBarsByTimeframe);
      if (framesReady) {
        if (reasonCode === 'WARMUP_TIMEOUT') {
          reasonCode = null;
        }
        if (reasonCode === 'RENDER_FAILED' || reasonCode === 'SNAPSHOT_TIMEOUT') {
          if (!warnings.includes(reasonCode)) warnings.push(reasonCode);
          reasonCode = null;
        }
      }
    }

    payload.diagnostics = {
      ...diagnostics,
      reasonCode: reasonCode || undefined,
      warnings: warnings.length ? warnings : undefined,
      durationsMs: {
        capture: captureDurationMs,
        fetchFrames: framesDurationMs,
        total: Date.now() - startedAtMs
      }
    };

    if (reasonCode || warnings.length > 0) {
      appendLiveError({
        source: 'snapshot',
        level: 'warn',
        message: `Snapshot ${symbol || payload.symbol || ''} ${reasonCode ? `(${reasonCode})` : 'warning'}`.trim(),
        detail: {
          symbol: symbol || payload.symbol || null,
          timeframes,
          reasonCode: reasonCode || null,
          warnings: warnings.length ? warnings : null,
          frames: framesSummary
        }
      });
    }

    const contextText = buildChartSnapshotContext(payload);
    chartChatSnapshotRef.current = {
      payload,
      contextText,
      imageDataUrl: snapshotDataUrl || undefined,
      truncated: payloadResult.truncated
    };

    const status: ChartChatSnapshotStatus = {
      msgId,
      symbol: payload.symbol || symbol || null,
      timeframes: payloadResult.requestedTimeframes || timeframes,
      capturedAtMs: payload.capturedAt || snapshotContextAtMs || snapshotCapturedAtMs || null,
      imageDataUrl: snapshotDataUrl || null,
      frames: framesSummary,
      ok: !reasonCode,
      reasonCode: reasonCode || null,
      warnings: warnings.length ? warnings : undefined,
      payloadChars: payloadResult.serialized ? payloadResult.serialized.length : null
    };

    logChartChatEvent('CHART_STORE_STATE', {
      msgId,
      symbol,
      storeSymbols: payloadResult.availableSymbols,
      storeTimeframes: payloadResult.availableTimeframes,
      framesSummary
    });

    setChartChatSnapshotStatus(status);
    logChartChatEvent('UI_STATUS_BANNER_RENDER', {
      msgId,
      symbol,
      visible: true,
      reasonCode: status.reasonCode,
      framesSummary
    });

    return {
      status,
      payload,
      contextText,
      imageDataUrl: snapshotDataUrl,
      payloadChars: payloadResult.serialized ? payloadResult.serialized.length : 0
    };
  }, [
    buildSignalWarmupBarsByTimeframe,
    buildChartSnapshotPayload,
    buildChartSnapshotContext,
    chartEngine,
    formatTimeframeLabel,
    logChartChatEvent,
    persistChartSnapshotMemory,
    resolveChartChatSymbol,
    resolveChartChatTimeframes,
    resolveNativeChartFrameIds,
    recordPerf,
    warmupSignalSnapshotFrames,
    beginSignalWarmup,
    endSignalWarmup,
    appendLiveError,
    symbolScopeSymbol,
    activeBrokerSymbol,
    activeTvParams?.symbol,
    nativeChartMounted
  ]);

  const getChartChatAgentContext = useCallback((opts?: { includePatterns?: boolean }) => {
    const includePatterns = opts?.includePatterns !== false;
    const base = getChartContextPack({ eventsLimit: includePatterns ? 20 : 0 });
    const snapshotText = chartChatSnapshotRef.current?.contextText || '';
    return [base, snapshotText].filter(Boolean).join('\n\n');
  }, [getChartContextPack]);

  const chartChatSystemPrefix = [
    'You are Chart Analyst Agents.',
    'Use chart-engine data + pattern events as the source of truth.',
    'Chart Chat automatically attaches a native chart snapshot + multi-timeframe bars.',
    'Use CHART_SNAPSHOT_JSON (frames + candles) as ground truth. Do not invent indicators you cannot see.',
    'If diagnostics.reasonCode is present, explain the limitation and suggest the next fix.',
    'Prefer the SYMBOL SCOPE context for default symbol + multi-timeframe analysis.',
    'If data is missing, say so.',
    'Explain structure, key levels, volatility, and invalidation cleanly.',
    'When using chat.* actions, set payload.channel="chart" to target this panel.'
  ].join('\n');

  const fetchNewsSnapshot = useCallback(async (symbol: string, opts?: { force?: boolean }) => {
    const api = window.glass?.news;
    if (!api?.getSnapshot) return null;
    try {
      const res = await api.getSnapshot({ symbol, limit: 12, force: opts?.force === true });
      if (!res?.ok) return null;
      return (res.snapshot || null) as NewsSnapshot | null;
    } catch {
      return null;
    }
  }, []);

  const formatNewsAge = (ms?: number | null) => {
    if (!ms) return '';
    const delta = Math.max(0, Date.now() - ms);
    const minutes = Math.floor(delta / 60000);
    if (minutes < 60) return `${minutes}m`;
    const hours = Math.floor(minutes / 60);
    return `${hours}h`;
  };

  const formatNewsTone = (tone?: string | null, toneScore?: number | null) => {
    const label = String(tone || '').trim().toUpperCase();
    if (!label) return '';
    const score = Number.isFinite(Number(toneScore)) ? Number(toneScore) : null;
    const scoreLabel = score != null && score !== 0 ? ` ${score > 0 ? '+' : ''}${score}` : '';
    return `${label}${scoreLabel}`;
  };

  const buildSignalNewsContext = useCallback((snapshot: NewsSnapshot | null, symbol: string) => {
    if (!snapshot || !Array.isArray(snapshot.items) || snapshot.items.length === 0) {
      return `NEWS SNAPSHOT: No relevant headlines found for ${symbol}.`;
    }
    const impactLabel = snapshot.impactLevel || (snapshot.impactScore >= 70 ? 'high' : snapshot.impactScore >= 40 ? 'medium' : 'low');
    const toneLabel = formatNewsTone(snapshot.tone, snapshot.toneScore) || 'NEUTRAL';
    const trumpFlag = snapshot.trumpNews ? 'YES' : 'no';
    const top = snapshot.items.slice(0, 3).map((item) => {
      const age = formatNewsAge(item.publishedAtMs);
      const score = Number.isFinite(Number(item.impactScore)) ? `impact ${Math.round(Number(item.impactScore))}` : 'impact n/a';
      const tone = formatNewsTone(item.tone, item.toneScore);
      const source = item.source ? `${item.source} ` : '';
      const trump = item.trumpNews ? ' [Trump News]' : '';
      return `- ${source}${item.title}${age ? ` (${age} ago)` : ''} ${score}${tone ? ` tone ${tone}` : ''}${trump}`;
    });
    return [
      `NEWS SNAPSHOT (${symbol})`,
      `Impact: ${impactLabel.toUpperCase()} ${Math.round(snapshot.impactScore || 0)} | Tone: ${toneLabel} | Trump News: ${trumpFlag}`,
      ...top
    ].join('\n');
  }, []);

  const buildSignalSystemContext = useCallback((opts: {
    symbol: string;
    timeframes: string[];
    strategyModes: SignalStrategyMode[];
    expiryMinutes: number;
    thresholdMin: number;
    thresholdMax: number;
    memoryMode?: 'inject' | 'tool' | 'both';
    memoryContext?: string | null;
    newsContext?: string | null;
    includePatterns?: boolean;
    academyContext?: string | null;
    agentContext?: string | null;
  }) => {
    const tfLabel = opts.timeframes.map((tf) => formatTimeframeLabel(tf)).filter(Boolean).join('/');
    const modes = opts.strategyModes.length > 0 ? opts.strategyModes : ['scalp', 'day', 'swing'];
    const memoryMode = opts.memoryMode || 'both';
    const memoryContext = String(opts.memoryContext || '').trim();
    const newsContext = String(opts.newsContext || '').trim();
    const academyContext = opts.academyContext != null
      ? String(opts.academyContext || '').trim()
      : (academyAutoApplyEnabled ? (academyLessonContextRef.current || '') : '');
    const agentContext = String(opts.agentContext || '').trim();
    const memoryRule =
      memoryMode === 'tool'
        ? 'If you need prior outcomes or lessons, call listAgentMemory (kind "signal_history", "signal_review", or "academy_lesson") or getAgentMemory for details. Do not call other tools.'
        : memoryMode === 'both'
          ? 'Use SIGNAL MEMORY if provided. You may call listAgentMemory/getAgentMemory for more history or lessons if needed (do not call other tools).'
          : 'Do not call tools. Use SIGNAL MEMORY if provided.';
    const pack = getChartChatAgentContext({ includePatterns: opts.includePatterns });
    return [
      chartChatSystemPrefix,
      'SIGNAL PANEL: return JSON-only trade signals.',
      `Symbol: ${opts.symbol}`,
      `Timeframes: ${tfLabel || '5m/15m/1H/4H'}`,
      `Strategy modes: ${modes.join(', ')}`,
      `Probability range: ${opts.thresholdMin}%-${opts.thresholdMax}%`,
      `Signal expiry: ${opts.expiryMinutes} minutes`,
      `Pattern context: ${opts.includePatterns === false ? 'OFF' : 'ON'}`,
      memoryRule,
      newsContext ? newsContext : '',
      memoryContext ? `SIGNAL MEMORY:\n${memoryContext}` : '',
      academyContext ? academyContext : '',
      agentContext ? `AGENT SCORECARD:\n${agentContext}` : '',
      pack ? `CONTEXT PACK:\n${pack}` : ''
    ].filter(Boolean).join('\n\n');
  }, [academyAutoApplyEnabled, chartChatSystemPrefix, formatTimeframeLabel, getChartChatAgentContext]);

  const buildAgentScorecardContext = useCallback((agent: Agent) => {
    if (!agent) return '';
    const stats =
      agentPerformanceById.get(agent.id) ||
      (agent.name ? agentPerformanceById.get(`name:${agent.name}`) : null);
    if (!stats) return '';
    const winRate = Number.isFinite(Number(stats.winRate)) ? Math.round(stats.winRate * 100) : 0;
    const totalScore = Number.isFinite(Number(stats.totalScore)) ? Number(stats.totalScore).toFixed(2) : '0.00';
    const avgScore = Number.isFinite(Number(stats.avgScore)) ? Number(stats.avgScore).toFixed(2) : '0.00';
    const formatDuration = (ms?: number | null) => {
      if (!ms || ms <= 0) return '--';
      const seconds = Math.max(1, Math.floor(ms / 1000));
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.floor(hours / 24);
      return `${days}d`;
    };
    const avgHold = formatDuration(stats.avgHoldMs);
    const avgBars = Number.isFinite(Number(stats.avgBars)) ? Number(stats.avgBars).toFixed(1) : '--';
    return `Trades ${stats.trades} | Wins ${stats.wins} / Losses ${stats.losses} | Win ${winRate}% | Net ${totalScore}R | Avg ${avgScore}R | Hold ${avgHold} (${avgBars} bars)`;
  }, [agentPerformanceById]);

  const buildAgentScorecardSnapshots = useCallback((): AgentScorecardSnapshot[] => {
    const entries = Array.from(agentPerformanceById.values());
    if (entries.length === 0) return [];
    const now = Date.now();
    return entries.map((entry) => ({
      agentId: entry.agentId ?? null,
      agentName: entry.agentName ?? null,
      trades: entry.trades,
      wins: entry.wins,
      losses: entry.losses,
      winRate: entry.winRate,
      totalScore: entry.totalScore,
      avgScore: entry.avgScore,
      avgHoldMs: entry.avgHoldMs,
      avgBars: entry.avgBars,
      updatedAtMs: now
    }));
  }, [agentPerformanceById]);

  const persistAgentScorecards = useCallback(async () => {
    const snapshots = buildAgentScorecardSnapshots();
    if (snapshots.length === 0) return;
    setAgentScorecards(snapshots);
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    for (const snapshot of snapshots) {
      const agentKey = snapshot.agentId || snapshot.agentName || '';
      if (!agentKey) continue;
      const key = snapshot.agentId ? `agent_scorecard:${snapshot.agentId}` : `agent_scorecard:name:${agentKey}`;
      const payload = { ...snapshot };
      const fingerprint = (() => {
        try {
          return JSON.stringify(payload);
        } catch {
          return String(payload.updatedAtMs || '');
        }
      })();
      if (scorecardPersistedRef.current.get(key) === fingerprint) continue;
      scorecardPersistedRef.current.set(key, fingerprint);
      const winRatePct = Number.isFinite(Number(snapshot.winRate)) ? Math.round(snapshot.winRate * 100) : 0;
      const totalScoreLabel = Number.isFinite(Number(snapshot.totalScore)) ? snapshot.totalScore.toFixed(2) : '0.00';
      const summary = `${snapshot.agentName || snapshot.agentId || 'Agent'} ${snapshot.trades} trades | ${winRatePct}% win | ${totalScoreLabel}R`;
      const tags = [
        snapshot.agentId ? `agent:${snapshot.agentId}` : '',
        'agent_scorecard'
      ].filter(Boolean);
      await ledger.upsertAgentMemory({
        key,
        agentId: snapshot.agentId ?? null,
        scope: 'shared',
        category: 'scorecard',
        subcategory: 'agent',
        kind: 'agent_scorecard',
        summary,
        payload,
        tags,
        source: 'rank_panel'
      });
    }
  }, [buildAgentScorecardSnapshots]);

  useEffect(() => {
    if (agentPerformanceById.size === 0) return;
    const timer = deferMs(() => {
      void persistAgentScorecards();
    }, 400);
    return () => cancelTimer(timer);
  }, [agentPerformanceById, persistAgentScorecards]);

  const buildAcademyBrokerSnapshot = useCallback((symbol: string) => {
    const meta = tradeLockerExecRef.current || {};
    const quote = symbol ? getBrokerQuoteForSymbol(symbol) : null;
    return {
      broker: meta?.connected ? 'tradelocker' : 'sim',
      connected: !!meta?.connected,
      env: meta?.env ?? null,
      server: meta?.server ?? null,
      accountId: meta?.accountId ?? null,
      accNum: meta?.accNum ?? null,
      balance: meta?.balance ?? null,
      equity: meta?.equity ?? null,
      openPositionsCount: meta?.openPositionsCount ?? null,
      openOrdersCount: meta?.openOrdersCount ?? null,
      spread: quote?.spread ?? null,
      bid: quote?.bid ?? null,
      ask: quote?.ask ?? null,
      mid: quote?.mid ?? null,
      quoteUpdatedAtMs: quote?.fetchedAtMs ?? quote?.timestampMs ?? null,
      executionMode: autoPilotConfigRef.current?.executionMode ?? null,
      autoPilotEnabled: autoPilotConfigRef.current?.enabled ?? false,
      killSwitch: autoPilotConfigRef.current?.killSwitch ?? false
    };
  }, [getBrokerQuoteForSymbol]);

  const resolveSignalOutcome = useCallback((status: SignalEntry['status']) => {
    if (status === 'WIN' || status === 'LOSS' || status === 'EXPIRED' || status === 'REJECTED' || status === 'FAILED') {
      return status;
    }
    return null;
  }, []);

  const computeSignalOutcomeScore = useCallback((entry: SignalEntry, outcome: 'WIN' | 'LOSS') => {
    const entryPrice = Number(entry.entryPrice);
    const stopLoss = Number(entry.stopLoss);
    const takeProfit = Number(entry.takeProfit);
    if (!Number.isFinite(entryPrice) || !Number.isFinite(stopLoss) || !Number.isFinite(takeProfit)) {
      return outcome === 'WIN' ? 1 : -1;
    }
    const risk = Math.abs(entryPrice - stopLoss);
    const reward = Math.abs(takeProfit - entryPrice);
    if (!Number.isFinite(risk) || risk <= 0) return outcome === 'WIN' ? 1 : -1;
    const r = reward / risk;
    if (!Number.isFinite(r)) return outcome === 'WIN' ? 1 : -1;
    return outcome === 'WIN' ? r : -1;
  }, []);

  const buildSimWarmupBarsByTimeframe = useCallback((timeframes: string[], lookaheadMs: number) => {
    const barsByTimeframe: Record<string, number> = {};
    const normalizedLookahead = Number.isFinite(Number(lookaheadMs))
      ? Math.max(60_000, Math.floor(Number(lookaheadMs)))
      : 0;
    for (const tf of timeframes) {
      const tfKey = normalizeTimeframeKey(tf);
      if (!tfKey) continue;
      const resMs = resolutionToMs(tfKey) || 60_000;
      const neededBars = Math.ceil(((normalizedLookahead || resMs) / resMs)) + 2;
      barsByTimeframe[tfKey] = Math.max(10, Math.min(600, neededBars));
    }
    return barsByTimeframe;
  }, []);

  const resolveSimulatedOutcomeFromBars = useCallback((
    entry: SignalEntry,
    bars: Array<{ t: number; o: number; h: number; l: number; c: number }>,
    timeframe: string,
    windowEndMs?: number | null
  ) => {
    if (!entry || !Array.isArray(bars) || bars.length === 0) return null;
    const resMs = resolutionToMs(timeframe) || 60_000;
    const sorted = bars
      .map((bar) => ({
        t: Number(bar?.t ?? bar?.time ?? bar?.timestamp ?? 0) || 0,
        o: Number(bar?.o ?? bar?.open ?? 0) || 0,
        h: Number(bar?.h ?? bar?.high ?? 0) || 0,
        l: Number(bar?.l ?? bar?.low ?? 0) || 0,
        c: Number(bar?.c ?? bar?.close ?? 0) || 0
      }))
      .filter((bar) => Number.isFinite(bar.t) && bar.t > 0)
      .sort((a, b) => a.t - b.t);
    if (sorted.length === 0) return null;
    const startIdx = sorted.findIndex((bar) => (bar.t + resMs) >= entry.createdAtMs);
    if (startIdx < 0) return null;
    const endMs = Number.isFinite(Number(windowEndMs)) ? Number(windowEndMs) : null;
    for (let i = startIdx; i < sorted.length; i += 1) {
      const bar = sorted[i];
      if (!bar?.t) continue;
      if (endMs != null && bar.t > endMs) break;
      const hitTp = entry.action === 'BUY'
        ? bar.h >= entry.takeProfit
        : bar.l <= entry.takeProfit;
      const hitSl = entry.action === 'BUY'
        ? bar.l <= entry.stopLoss
        : bar.h >= entry.stopLoss;
      if (!hitTp && !hitSl) continue;
      let outcome: 'WIN' | 'LOSS';
      if (hitTp && hitSl) {
        if (bar.c === bar.o) {
          const distTp = Math.abs(entry.takeProfit - bar.o);
          const distSl = Math.abs(entry.stopLoss - bar.o);
          outcome = distTp <= distSl ? 'WIN' : 'LOSS';
        } else {
          const bullish = bar.c > bar.o;
          outcome = entry.action === 'BUY'
            ? (bullish ? 'WIN' : 'LOSS')
            : (bullish ? 'LOSS' : 'WIN');
        }
      } else {
        outcome = hitTp ? 'WIN' : 'LOSS';
      }
      const exitPrice = outcome === 'WIN' ? entry.takeProfit : entry.stopLoss;
      const resolvedAtMs = bar.t + resMs;
      return {
        outcome,
        exitPrice,
        resolvedAtMs,
        barsToOutcome: i - startIdx + 1,
        durationMs: Math.max(0, resolvedAtMs - entry.createdAtMs)
      };
    }
    return null;
  }, []);

  const buildSignalEntryFingerprint = useCallback((entry: SignalEntry) => {
    const payload = {
      id: entry.id,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      action: entry.action,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      targets: entry.targets ?? null,
      probability: entry.probability,
      strategyMode: entry.strategyMode ?? null,
      reason: entry.reason ?? null,
      status: entry.status,
      createdAtMs: entry.createdAtMs,
      executedAtMs: entry.executedAtMs ?? null,
      resolvedAtMs: entry.resolvedAtMs ?? null,
      expiresAtMs: entry.expiresAtMs ?? null,
      agentId: entry.agentId ?? null,
      agentName: entry.agentName ?? null,
      executionError: entry.executionError ?? null,
      executionSource: entry.executionSource ?? null,
      executionBroker: entry.executionBroker ?? null,
      executionMode: entry.executionMode ?? null,
      executionLedgerId: entry.executionLedgerId ?? null,
      executionOrderId: entry.executionOrderId ?? null,
      executionPositionId: entry.executionPositionId ?? null,
      executionOrderStatus: entry.executionOrderStatus ?? null,
      shadowLedgerId: entry.shadowLedgerId ?? null,
      runId: entry.runId ?? null,
      newsSnapshot: entry.newsSnapshot ?? null,
      quantTelemetry: entry.quantTelemetry ?? null
    };
    try {
      return JSON.stringify(payload);
    } catch {
      return String(entry.id || '');
    }
  }, []);

  const normalizeSignalEntryMemory = useCallback((memory: any): SignalEntry | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const signalId = String(payload.id || payload.signalId || rawKey.replace(/^signal_entry:/, '') || '').trim();
    if (!signalId) return null;
    const actionRaw = String(payload.action || '').trim().toUpperCase();
    const action = actionRaw === 'SELL' ? 'SELL' : 'BUY';
    const entryPrice = Number(payload.entryPrice);
    const stopLoss = Number(payload.stopLoss);
    const takeProfit = Number(payload.takeProfit);
    const probability = Number(payload.probability);
    const createdAtRaw = Number(payload.createdAtMs ?? memory.createdAtMs ?? memory.updatedAtMs);
    const createdAtMs = Number.isFinite(createdAtRaw) ? createdAtRaw : Date.now();
    const statusRaw = String(payload.status || '').trim().toUpperCase();
    const status: SignalEntry['status'] = (
      statusRaw === 'SUBMITTING' ||
      statusRaw === 'PENDING' ||
      statusRaw === 'EXECUTED' ||
      statusRaw === 'REJECTED' ||
      statusRaw === 'EXPIRED' ||
      statusRaw === 'WIN' ||
      statusRaw === 'LOSS' ||
      statusRaw === 'FAILED'
    ) ? statusRaw as SignalEntry['status'] : 'PROPOSED';
    const quantRaw = payload.quantTelemetry && typeof payload.quantTelemetry === 'object'
      ? payload.quantTelemetry as Record<string, any>
      : null;
    const quantStatusRaw = String(quantRaw?.status || '').trim().toLowerCase();
    const quantStatus =
      quantStatusRaw === 'block' || quantStatusRaw === 'warn' || quantStatusRaw === 'pass'
        ? quantStatusRaw
        : null;
    const quantTelemetry = quantStatus
      ? {
          status: quantStatus,
          evaluatedAtMs: Number.isFinite(Number(quantRaw?.evaluatedAtMs))
            ? Number(quantRaw?.evaluatedAtMs)
            : Date.now(),
          elapsedMs: Number.isFinite(Number(quantRaw?.elapsedMs))
            ? Number(quantRaw?.elapsedMs)
            : 0,
          regimeLabel: quantRaw?.regimeLabel != null ? String(quantRaw.regimeLabel) : null,
          regimeNewsRisk: quantRaw?.regimeNewsRisk === true,
          regimeHighVol: quantRaw?.regimeHighVol === true,
          ensembleAction: quantRaw?.ensembleAction != null ? String(quantRaw.ensembleAction) as 'take' | 'skip' : null,
          ensembleScore: Number.isFinite(Number(quantRaw?.ensembleScore)) ? Number(quantRaw.ensembleScore) : null,
          metaDecision: quantRaw?.metaDecision != null ? String(quantRaw.metaDecision) as 'take' | 'skip' | 'size_down' : null,
          metaConfidence: Number.isFinite(Number(quantRaw?.metaConfidence)) ? Number(quantRaw.metaConfidence) : null,
          portfolioAllowed: typeof quantRaw?.portfolioAllowed === 'boolean' ? quantRaw.portfolioAllowed : null,
          portfolioReasons: Array.isArray(quantRaw?.portfolioReasons)
            ? quantRaw.portfolioReasons.map((item: any) => String(item)).filter(Boolean)
            : null,
          warnReasons: Array.isArray(quantRaw?.warnReasons)
            ? quantRaw.warnReasons.map((item: any) => String(item)).filter(Boolean)
            : null,
          blockReasons: Array.isArray(quantRaw?.blockReasons)
            ? quantRaw.blockReasons.map((item: any) => String(item)).filter(Boolean)
            : null
        } as SignalEntry['quantTelemetry']
      : null;

    return {
      id: signalId,
      symbol: String(payload.symbol || memory.symbol || '').trim(),
      timeframe: payload.timeframe != null ? String(payload.timeframe) : (memory.timeframe != null ? String(memory.timeframe) : null),
      action,
      entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
      stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
      takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
      targets: Array.isArray(payload.targets) ? payload.targets.map((v: any) => Number(v)).filter((v: any) => Number.isFinite(v)) : null,
      probability: Number.isFinite(probability) ? probability : 0,
      strategyMode: payload.strategyMode != null ? String(payload.strategyMode) : null,
      reason: payload.reason != null ? String(payload.reason) : null,
      status,
      createdAtMs,
      executedAtMs: Number.isFinite(Number(payload.executedAtMs)) ? Number(payload.executedAtMs) : null,
      resolvedAtMs: Number.isFinite(Number(payload.resolvedAtMs)) ? Number(payload.resolvedAtMs) : null,
      expiresAtMs: Number.isFinite(Number(payload.expiresAtMs)) ? Number(payload.expiresAtMs) : null,
      agentId: payload.agentId != null ? String(payload.agentId) : null,
      agentName: payload.agentName != null ? String(payload.agentName) : null,
      executionError: payload.executionError != null ? String(payload.executionError) : null,
      executionSource: payload.executionSource != null ? String(payload.executionSource) as any : null,
      executionBroker: payload.executionBroker != null ? String(payload.executionBroker) as any : null,
      executionMode: payload.executionMode != null ? String(payload.executionMode) : null,
      executionLedgerId: payload.executionLedgerId != null ? String(payload.executionLedgerId) : null,
      executionOrderId: payload.executionOrderId != null ? String(payload.executionOrderId) : null,
      executionPositionId: payload.executionPositionId != null ? String(payload.executionPositionId) : null,
      executionOrderStatus: payload.executionOrderStatus != null ? String(payload.executionOrderStatus) : null,
      shadowLedgerId: payload.shadowLedgerId != null ? String(payload.shadowLedgerId) : null,
      runId: payload.runId != null ? String(payload.runId) : null,
      newsSnapshot: payload.newsSnapshot ?? null,
      quantTelemetry
    };
  }, []);

  const normalizeSignalHistoryMemory = useCallback((memory: any): SignalHistoryEntry | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const signalId = String(payload.signalId || payload.id || rawKey.replace(/^signal_history:/, '') || '').trim();
    if (!signalId) return null;
    const actionRaw = String(payload.action || '').trim().toUpperCase();
    const action = actionRaw === 'SELL' ? 'SELL' : 'BUY';
    const entryPrice = Number(payload.entryPrice);
    const stopLoss = Number(payload.stopLoss);
    const takeProfit = Number(payload.takeProfit);
    const scoreRaw = payload.score ?? payload.scoreR ?? payload.pnl ?? null;
    let score = Number.isFinite(Number(scoreRaw)) ? Number(scoreRaw) : null;
    const outcomeRaw = String(payload.outcome || payload.status || '').trim().toUpperCase();
    const outcome =
      outcomeRaw === 'WIN' ||
      outcomeRaw === 'LOSS' ||
      outcomeRaw === 'EXPIRED' ||
      outcomeRaw === 'REJECTED' ||
      outcomeRaw === 'FAILED'
        ? outcomeRaw
        : null;
    if (score == null && (outcome === 'WIN' || outcome === 'LOSS')) {
      const entryValue = Number(entryPrice);
      const stopValue = Number(stopLoss);
      const targetValue = Number(takeProfit);
      const risk = Math.abs(entryValue - stopValue);
      const reward = Math.abs(targetValue - entryValue);
      if (Number.isFinite(risk) && risk > 0 && Number.isFinite(reward)) {
        const r = reward / risk;
        score = Number.isFinite(r) ? (outcome === 'WIN' ? r : -1) : score;
      }
    }

    const executedAtMs = Number.isFinite(Number(payload.executedAtMs)) ? Number(payload.executedAtMs) : null;
    const resolvedAtMs = Number.isFinite(Number(payload.resolvedAtMs)) ? Number(payload.resolvedAtMs) : null;
    const createdAtMs = Number.isFinite(Number(payload.createdAtMs)) ? Number(payload.createdAtMs) : null;
    const durationMs = Number.isFinite(Number(payload.durationMs))
      ? Number(payload.durationMs)
      : (Number.isFinite(Number(resolvedAtMs)) && Number.isFinite(Number(executedAtMs ?? createdAtMs))
          ? Math.max(0, Number(resolvedAtMs) - Number(executedAtMs ?? createdAtMs))
          : null);
    const envelopeRaw = payload.resolvedOutcomeEnvelope && typeof payload.resolvedOutcomeEnvelope === 'object'
      ? payload.resolvedOutcomeEnvelope
      : null;
    const normalizedEnvelope = envelopeRaw || buildResolvedOutcomeEnvelope({
      signalId,
      status: payload.status != null ? String(payload.status) : null,
      outcome,
      createdAtMs,
      executedAtMs,
      resolvedAtMs,
      executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
      executionMode: payload.executionMode != null ? String(payload.executionMode) : null
    });
    const attributionRaw = payload.attribution && typeof payload.attribution === 'object'
      ? payload.attribution
      : buildSignalAttributionRecord({
          signalId,
          status: payload.status != null ? String(payload.status) : null,
          outcome,
          createdAtMs,
          executedAtMs,
          resolvedAtMs,
          executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
          executionMode: payload.executionMode != null ? String(payload.executionMode) : null,
          entryPrice,
          stopLoss,
          takeProfit,
          exitPrice: Number.isFinite(Number(payload.exitPrice)) ? Number(payload.exitPrice) : null,
          score
        });

    return {
      id: String(memory.id || signalId),
      signalId,
      agentId: payload.agentId != null ? String(payload.agentId) : null,
      agentName: payload.agentName != null ? String(payload.agentName) : null,
      symbol: String(payload.symbol || memory.symbol || '').trim(),
      timeframe: payload.timeframe != null ? String(payload.timeframe) : (memory.timeframe != null ? String(memory.timeframe) : null),
      action,
      entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
      stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
      takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
      probability: Number.isFinite(Number(payload.probability)) ? Number(payload.probability) : null,
      strategyMode: payload.strategyMode != null ? String(payload.strategyMode) : null,
      reason: payload.reason != null ? String(payload.reason) : null,
      executionSource: payload.executionSource != null ? String(payload.executionSource) : null,
      executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
      executionMode: payload.executionMode != null ? String(payload.executionMode) : null,
      status: payload.status != null ? String(payload.status) : null,
      outcome: outcome as SignalHistoryEntry['outcome'],
      score,
      executedAtMs,
      resolvedAtMs,
      durationMs,
      barsToOutcome: Number.isFinite(Number(payload.barsToOutcome)) ? Number(payload.barsToOutcome) : null,
      exitPrice: Number.isFinite(Number(payload.exitPrice)) ? Number(payload.exitPrice) : null,
      runId: payload.runId != null ? String(payload.runId) : null,
      ledgerId: payload.ledgerId != null ? String(payload.ledgerId) : null,
      orderId: payload.orderId != null ? String(payload.orderId) : null,
      positionId: payload.positionId != null ? String(payload.positionId) : null,
      newsSnapshot: payload.newsSnapshot ?? null,
      outcomeSource: payload.outcomeSource != null
        ? String(payload.outcomeSource)
        : (normalizedEnvelope?.source ?? null),
      decisionOutcome: payload.decisionOutcome != null
        ? String(payload.decisionOutcome) as any
        : (normalizedEnvelope?.decisionOutcome ?? null),
      executionOutcome: payload.executionOutcome != null
        ? String(payload.executionOutcome) as any
        : (normalizedEnvelope?.executionOutcome ?? null),
      resolvedOutcomeEnvelope: normalizedEnvelope ?? null,
      attribution: attributionRaw ?? null
    };
  }, []);

  const normalizeAgentScorecardMemory = useCallback((memory: any): AgentScorecardSnapshot | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : memory;
    const agentIdRaw = payload.agentId != null ? String(payload.agentId) : (memory.agentId != null ? String(memory.agentId) : '');
    const agentNameRaw = payload.agentName != null ? String(payload.agentName) : (memory.agentName != null ? String(memory.agentName) : '');
    const agentId = agentIdRaw ? agentIdRaw.trim() : null;
    const agentName = agentNameRaw ? agentNameRaw.trim() : null;
    if (!agentId && !agentName) return null;
    const tradesRaw = Number(payload.trades);
    const winsRaw = Number(payload.wins);
    const lossesRaw = Number(payload.losses);
    const winRateRaw = Number(payload.winRate);
    const totalScoreRaw = Number(payload.totalScore);
    const avgScoreRaw = Number(payload.avgScore);
    const avgHoldRaw = Number(payload.avgHoldMs);
    const avgBarsRaw = Number(payload.avgBars);
    const trades = Number.isFinite(tradesRaw) ? tradesRaw : 0;
    const wins = Number.isFinite(winsRaw) ? winsRaw : 0;
    const losses = Number.isFinite(lossesRaw) ? lossesRaw : 0;
    const winRate =
      Number.isFinite(winRateRaw)
        ? winRateRaw
        : (wins + losses > 0 ? wins / (wins + losses) : 0);
    return {
      agentId,
      agentName,
      trades,
      wins,
      losses,
      winRate,
      totalScore: Number.isFinite(totalScoreRaw) ? totalScoreRaw : 0,
      avgScore: Number.isFinite(avgScoreRaw) ? avgScoreRaw : 0,
      avgHoldMs: Number.isFinite(avgHoldRaw) ? avgHoldRaw : null,
      avgBars: Number.isFinite(avgBarsRaw) ? avgBarsRaw : null,
      updatedAtMs: Number.isFinite(Number(payload.updatedAtMs ?? memory.updatedAtMs))
        ? Number(payload.updatedAtMs ?? memory.updatedAtMs)
        : null
    };
  }, []);

  const normalizeShadowProfile = useCallback((input: Partial<ShadowProfile>, agent?: Agent | null): ShadowProfile | null => {
    const agentId = String(input.agentId || agent?.id || '').trim();
    if (!agentId) return null;
    const agentName = input.agentName != null ? String(input.agentName) : agent?.name || null;
    const startingBalanceRaw = Number(input.startingBalance);
    const startingBalance = Number.isFinite(startingBalanceRaw)
      ? Math.max(0, startingBalanceRaw)
      : DEFAULT_SHADOW_START_BALANCE;
    const riskPctRaw = Number(input.riskPct);
    const riskPct = Number.isFinite(riskPctRaw)
      ? Math.max(0.1, Math.min(10, riskPctRaw))
      : DEFAULT_SHADOW_RISK_PCT;
    const lotSizeRaw = Number(input.lotSize);
    const lotSize = Number.isFinite(lotSizeRaw) && lotSizeRaw > 0 ? lotSizeRaw : null;
    const maxDrawdownRaw = Number(input.maxDrawdownPct);
    const maxDrawdownPct = Number.isFinite(maxDrawdownRaw) && maxDrawdownRaw > 0
      ? Math.max(1, Math.min(50, maxDrawdownRaw))
      : null;
  const dailyDrawdownRaw = Number(input.dailyDrawdownPct);
  const dailyDrawdownPct = Number.isFinite(dailyDrawdownRaw) && dailyDrawdownRaw > 0
    ? Math.max(1, Math.min(20, dailyDrawdownRaw))
    : null;
  const liveDeployEnabled = input.liveDeployEnabled === true;
  const liveBrokerRaw = String(input.liveBroker || '').trim().toLowerCase();
  const liveBroker =
    liveBrokerRaw === 'tradelocker' || liveBrokerRaw === 'mt5'
      ? (liveBrokerRaw as 'mt5' | 'tradelocker')
      : DEFAULT_SHADOW_LIVE_BROKER;
  const liveModeRaw = String(input.liveMode || '').trim().toLowerCase();
  const liveMode = liveModeRaw === 'risk' || liveModeRaw === 'fixed'
    ? (liveModeRaw as 'fixed' | 'risk')
    : DEFAULT_SHADOW_LIVE_MODE;
  const liveLotSizeRaw = Number(input.liveLotSize);
  const liveLotSize = Number.isFinite(liveLotSizeRaw) && liveLotSizeRaw > 0
    ? liveLotSizeRaw
    : DEFAULT_SHADOW_LIVE_LOT_SIZE;
  const liveRiskRaw = Number(input.liveRiskPct);
  const liveRiskPct = Number.isFinite(liveRiskRaw) && liveRiskRaw > 0
    ? Math.max(0.1, Math.min(10, liveRiskRaw))
    : DEFAULT_SHADOW_LIVE_RISK_PCT;
  const liveAccountKey = input.liveAccountKey != null ? String(input.liveAccountKey) : null;
  const liveMaxDailyLossRaw = Number(input.liveMaxDailyLoss);
  const liveMaxDailyLoss = Number.isFinite(liveMaxDailyLossRaw) && liveMaxDailyLossRaw > 0
    ? Math.max(0, liveMaxDailyLossRaw)
    : DEFAULT_SHADOW_LIVE_MAX_DAILY_LOSS;
  const liveMaxOpenPositionsRaw = Number(input.liveMaxOpenPositions);
  const liveMaxOpenPositions = Number.isFinite(liveMaxOpenPositionsRaw) && liveMaxOpenPositionsRaw > 0
    ? Math.max(0, Math.floor(liveMaxOpenPositionsRaw))
    : DEFAULT_SHADOW_LIVE_MAX_OPEN_POSITIONS;
  const liveMaxOrdersPerMinuteRaw = Number(input.liveMaxOrdersPerMinute);
  const liveMaxOrdersPerMinute = Number.isFinite(liveMaxOrdersPerMinuteRaw) && liveMaxOrdersPerMinuteRaw > 0
    ? Math.max(0, Math.floor(liveMaxOrdersPerMinuteRaw))
    : DEFAULT_SHADOW_LIVE_MAX_ORDERS_PER_MIN;
  const liveMaxConsecutiveLossesRaw = Number(input.liveMaxConsecutiveLosses);
  const liveMaxConsecutiveLosses = Number.isFinite(liveMaxConsecutiveLossesRaw) && liveMaxConsecutiveLossesRaw > 0
    ? Math.max(0, Math.floor(liveMaxConsecutiveLossesRaw))
    : DEFAULT_SHADOW_LIVE_MAX_CONSECUTIVE_LOSSES;
  const liveSymbolAllowlistRaw =
    input.liveSymbolAllowlistRaw != null ? String(input.liveSymbolAllowlistRaw) : DEFAULT_SHADOW_LIVE_SYMBOL_ALLOWLIST;
  const liveEntryToleranceRaw = Number(input.liveEntryTolerancePct);
  const liveEntryTolerancePct = Number.isFinite(liveEntryToleranceRaw) && liveEntryToleranceRaw >= 0
    ? Math.max(0, Math.min(5, liveEntryToleranceRaw))
    : DEFAULT_SHADOW_LIVE_ENTRY_TOLERANCE_PCT;
  return {
    agentId,
    agentName,
    enabled: input.enabled !== false,
    startingBalance,
    riskPct,
    lotSize,
    maxDrawdownPct,
    dailyDrawdownPct,
    preset: input.preset != null ? String(input.preset) : null,
    liveDeployEnabled,
    liveBroker,
    liveMode,
    liveLotSize,
    liveRiskPct,
    liveAccountKey,
    liveMaxDailyLoss,
    liveMaxOpenPositions,
    liveMaxOrdersPerMinute,
    liveMaxConsecutiveLosses,
    liveSymbolAllowlistRaw,
    liveEntryTolerancePct,
    updatedAtMs: Number.isFinite(Number(input.updatedAtMs)) ? Number(input.updatedAtMs) : Date.now()
  };
}, []);

  const normalizeShadowProfileMemory = useCallback((memory: any): ShadowProfile | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const agentId = String(payload.agentId || payload.id || rawKey.replace(/^shadow_profile:/, '') || '').trim();
    if (!agentId) return null;
    const agentName = payload.agentName != null ? String(payload.agentName) : null;
    return normalizeShadowProfile({
      agentId,
      agentName,
      enabled: payload.enabled,
      startingBalance: payload.startingBalance,
      riskPct: payload.riskPct,
      lotSize: payload.lotSize,
      maxDrawdownPct: payload.maxDrawdownPct,
      dailyDrawdownPct: payload.dailyDrawdownPct,
      preset: payload.preset,
      liveDeployEnabled: payload.liveDeployEnabled,
      liveBroker: payload.liveBroker,
      liveMode: payload.liveMode,
      liveLotSize: payload.liveLotSize,
      liveRiskPct: payload.liveRiskPct,
      liveAccountKey: payload.liveAccountKey,
      liveMaxDailyLoss: payload.liveMaxDailyLoss,
      liveMaxOpenPositions: payload.liveMaxOpenPositions,
      liveMaxOrdersPerMinute: payload.liveMaxOrdersPerMinute,
      liveMaxConsecutiveLosses: payload.liveMaxConsecutiveLosses,
      liveSymbolAllowlistRaw: payload.liveSymbolAllowlistRaw,
      liveEntryTolerancePct: payload.liveEntryTolerancePct,
      updatedAtMs: payload.updatedAtMs ?? memory.updatedAtMs
    }, null);
  }, [normalizeShadowProfile]);

  const buildSignalMemoryContext = useCallback(async (opts: {
    symbol: string;
    limit: number;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return '';
    const symbol = String(opts.symbol || '').trim();
    if (!symbol) return '';
    const limit = Number.isFinite(Number(opts.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(opts.limit)))) : 8;

    const formatAge = (ms?: number | null) => {
      if (!ms || ms <= 0) return '';
      const delta = Math.max(0, Date.now() - ms);
      const seconds = Math.max(1, Math.floor(delta / 1000));
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h`;
    };
    const formatDuration = (ms?: number | null) => {
      if (!ms || ms <= 0) return '';
      const seconds = Math.max(1, Math.floor(ms / 1000));
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.floor(hours / 24);
      return `${days}d`;
    };

    const formatHistoryLine = (entry: SignalHistoryEntry) => {
      const outcome = entry.outcome || entry.status || 'EXECUTED';
      const tf = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
      const prob = Number.isFinite(Number(entry.probability)) ? `${Math.round(Number(entry.probability))}%` : '';
      const score = entry.score != null ? `${Number(entry.score).toFixed(2)}R` : '';
      const age = formatAge(entry.resolvedAtMs || entry.executedAtMs);
      const duration = formatDuration(entry.durationMs);
      const bars = Number.isFinite(Number(entry.barsToOutcome)) ? `bars:${Number(entry.barsToOutcome)}` : '';
      const parts = [
        outcome,
        entry.action,
        entry.symbol,
        tf,
        prob,
        score,
        duration ? `dur:${duration}` : '',
        bars,
        age ? `@${age}` : ''
      ].filter(Boolean);
      const reason = entry.reason ? `Reason: ${entry.reason}` : '';
      return reason ? `${parts.join(' ')} - ${reason}` : parts.join(' ');
    };

    const formatReviewLine = (entry: any) => {
      if (!entry || typeof entry !== 'object') return '';
      const summaryRaw = String(entry.summary || '').trim();
      const payload = entry.payload && typeof entry.payload === 'object' ? entry.payload : {};
      const outcome = payload?.outcome ? String(payload.outcome) : '';
      const score = payload?.score != null && Number.isFinite(Number(payload.score)) ? `${Number(payload.score).toFixed(2)}R` : '';
      const duration = formatDuration(payload?.durationMs);
      const bars = Number.isFinite(Number(payload?.barsToOutcome)) ? `bars:${Number(payload.barsToOutcome)}` : '';
      const tf = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
      const age = formatAge(entry.updatedAtMs || entry.createdAtMs);
      const head = [
        outcome || 'REVIEW',
        entry.symbol || payload?.symbol || '',
        tf,
        score,
        duration ? `dur:${duration}` : '',
        bars,
        age ? `@${age}` : ''
      ].filter(Boolean).join(' ');
      const summary = summaryRaw || String(payload?.summary || '').trim();
      return summary ? `${head} - ${summary.split('\n')[0]}` : head;
    };

    try {
      const [historyRes, reviewRes] = await Promise.all([
        ledger.listAgentMemory({ kind: 'signal_history', symbol, limit }),
        ledger.listAgentMemory({ kind: 'signal_review', symbol, limit })
      ]);

      const historyItems = historyRes?.ok && Array.isArray(historyRes.memories)
        ? historyRes.memories.map(normalizeSignalHistoryMemory).filter(Boolean) as SignalHistoryEntry[]
        : [];
      const reviewItems = reviewRes?.ok && Array.isArray(reviewRes.memories)
        ? reviewRes.memories
        : [];

      const historyLines = historyItems.slice(0, limit).map(formatHistoryLine).filter(Boolean);
      const reviewLines = reviewItems.slice(0, limit).map(formatReviewLine).filter(Boolean);

      const sections: string[] = [];
      if (historyLines.length > 0) {
        sections.push(['RECENT SIGNALS', ...historyLines.map((line) => `- ${line}`)].join('\n'));
      }
      if (reviewLines.length > 0) {
        sections.push(['RECENT REVIEWS', ...reviewLines.map((line) => `- ${line}`)].join('\n'));
      }
      return sections.join('\n\n');
    } catch {
      return '';
    }
  }, [formatTimeframeLabel, normalizeSignalHistoryMemory]);

  const persistSignalEntries = useCallback(async (entries: SignalEntry[]) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const now = Date.now();
    const cutoff = now - SIGNAL_ENTRY_RETENTION_MS;
    for (const entry of entries) {
      if (!entry || !entry.id) continue;
      const createdAtMs = Number(entry.createdAtMs || 0);
      if (Number.isFinite(createdAtMs) && createdAtMs > 0 && createdAtMs < cutoff) {
        signalEntriesPersistedRef.current.delete(entry.id);
        continue;
      }
      const fingerprint = buildSignalEntryFingerprint(entry);
      const lastFingerprint = signalEntriesPersistedRef.current.get(entry.id);
      if (lastFingerprint === fingerprint) continue;

      signalEntriesPersistedRef.current.set(entry.id, fingerprint);

      const payload = {
        id: entry.id,
        signalId: entry.id,
        symbol: entry.symbol,
        timeframe: entry.timeframe ?? null,
        action: entry.action,
        entryPrice: entry.entryPrice,
        stopLoss: entry.stopLoss,
        takeProfit: entry.takeProfit,
        targets: entry.targets ?? null,
        probability: entry.probability,
        strategyMode: entry.strategyMode ?? null,
        reason: entry.reason ?? null,
        status: entry.status ?? null,
        createdAtMs: entry.createdAtMs ?? now,
        executedAtMs: entry.executedAtMs ?? null,
        resolvedAtMs: entry.resolvedAtMs ?? null,
        expiresAtMs: entry.expiresAtMs ?? null,
        agentId: entry.agentId ?? null,
        agentName: entry.agentName ?? null,
        executionError: entry.executionError ?? null,
        executionSource: entry.executionSource ?? null,
        executionBroker: entry.executionBroker ?? null,
        executionMode: entry.executionMode ?? null,
        executionLedgerId: entry.executionLedgerId ?? null,
        executionOrderId: entry.executionOrderId ?? null,
        executionPositionId: entry.executionPositionId ?? null,
        executionOrderStatus: entry.executionOrderStatus ?? null,
        shadowLedgerId: entry.shadowLedgerId ?? null,
        runId: entry.runId ?? null,
        newsSnapshot: entry.newsSnapshot ?? null,
        quantTelemetry: entry.quantTelemetry ?? null,
        updatedAtMs: now,
        source: 'signal_panel'
      };

      const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
      const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(Number(entry.probability))}%` : '';
      const summaryParts = [
        entry.status || 'PROPOSED',
        entry.action,
        entry.symbol,
        tfLabel,
        probLabel
      ].filter(Boolean);
      const summary = summaryParts.join(' ');

      const tags = [
        entry.symbol,
        entry.timeframe || '',
        entry.strategyMode ? `mode:${entry.strategyMode}` : '',
        entry.status ? `status:${String(entry.status).toLowerCase()}` : '',
        entry.newsSnapshot?.impactLevel ? `news:${entry.newsSnapshot.impactLevel}` : '',
        entry.newsSnapshot?.trumpNews ? 'trump_news' : '',
        'signal_entry'
      ].filter(Boolean);

      const symbolKey = normalizeSymbolKey(entry.symbol);
      const tfKey = entry.timeframe ? normalizeTimeframeKey(entry.timeframe) : '';

      await ledger.upsertAgentMemory({
        key: `signal_entry:${entry.id}`,
        familyKey: symbolKey ? `signal_entry:${symbolKey}:${tfKey}` : undefined,
        agentId: entry.agentId ?? null,
        scope: 'shared',
        category: 'signal',
        subcategory: 'entry',
        kind: 'signal_entry',
        symbol: entry.symbol,
        timeframe: entry.timeframe ?? null,
        summary,
        payload,
        tags,
        source: 'signal_panel'
      });
    }
  }, [buildSignalEntryFingerprint, formatTimeframeLabel, normalizeSymbolKey, normalizeTimeframeKey]);

  const refreshSignalEntries = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Signal entries unavailable.' };
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(50, Math.min(2000, Math.floor(Number(opts?.limit)))) : 500;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'signal_entry' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load signal entries.' };
      }
      const now = Date.now();
      const cutoff = now - SIGNAL_ENTRY_RETENTION_MS;
      const staleKeys: Array<{ key?: string; id?: string }> = [];
      for (const memory of res.memories) {
        if (!memory) continue;
        const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload : {};
        const createdAtRaw = Number(payload?.createdAtMs ?? memory.createdAtMs ?? memory.updatedAtMs);
        const createdAtMs = Number.isFinite(createdAtRaw) ? createdAtRaw : 0;
        if (createdAtMs > 0 && createdAtMs < cutoff) {
          const key = memory.key != null ? String(memory.key) : '';
          const id = memory.id != null ? String(memory.id) : '';
          if (key || id) staleKeys.push({ key: key || undefined, id: id || undefined });
        }
      }
      if (staleKeys.length > 0 && ledger?.deleteAgentMemory) {
        for (const stale of staleKeys) {
          try {
            await ledger.deleteAgentMemory({ key: stale.key, id: stale.id });
          } catch {
            // ignore delete failures
          }
        }
      }
      const entries = res.memories.map(normalizeSignalEntryMemory).filter(Boolean) as SignalEntry[];
      const freshEntries = entries.filter((entry) => {
        const createdAtMs = Number(entry.createdAtMs || 0);
        return !(createdAtMs > 0 && createdAtMs < cutoff);
      });
      freshEntries.sort((a, b) => (Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0)));
      setSignalEntries((prev) => {
        if (!Array.isArray(prev) || prev.length === 0) return freshEntries;
        const map = new Map(prev.filter((entry) => {
          const createdAtMs = Number(entry?.createdAtMs || 0);
          return !(createdAtMs > 0 && createdAtMs < cutoff);
        }).map((entry) => [entry.id, entry]));
        for (const entry of freshEntries) {
          if (!map.has(entry.id)) map.set(entry.id, entry);
        }
        return Array.from(map.values()).sort((a, b) => (Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0)));
      });
      signalEntriesPersistedRef.current = new Map();
      for (const entry of freshEntries) {
        signalEntriesPersistedRef.current.set(entry.id, buildSignalEntryFingerprint(entry));
      }
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load signal entries.' };
    }
  }, [buildSignalEntryFingerprint, normalizeSignalEntryMemory]);

  const persistShadowProfile = useCallback(async (profile: ShadowProfile) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const agentId = String(profile.agentId || '').trim();
    if (!agentId) return;
    const key = `shadow_profile:${agentId}`;
    const payload = {
      ...profile,
      updatedAtMs: Date.now()
    };
    const tags = [agentId, profile.enabled ? 'enabled' : 'disabled', 'shadow_profile'].filter(Boolean);
    await ledger.upsertAgentMemory({
      key,
      agentId,
      scope: 'agent',
      category: 'shadow',
      subcategory: 'profile',
      kind: SHADOW_PROFILE_KIND,
      summary: `${agentId} shadow profile`,
      payload,
      tags,
      source: 'shadow_panel'
    });
  }, []);

  const refreshShadowProfiles = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    const agentsNow = agentsRef.current || [];
    let profiles: ShadowProfile[] = [];
    if (ledger?.listAgentMemory) {
      try {
        const res = await ledger.listAgentMemory({ kind: SHADOW_PROFILE_KIND, limit: 500 });
        if (res?.ok && Array.isArray(res.memories)) {
          profiles = res.memories.map(normalizeShadowProfileMemory).filter(Boolean) as ShadowProfile[];
        }
      } catch {
        profiles = [];
      }
    }

    const byAgentId = new Map<string, ShadowProfile>();
    for (const profile of profiles) {
      if (!profile?.agentId) continue;
      byAgentId.set(profile.agentId, profile);
    }

    const next: ShadowProfile[] = [];
    for (const agent of agentsNow) {
      const existing = byAgentId.get(agent.id);
      const normalized = normalizeShadowProfile(existing || { agentId: agent.id, agentName: agent.name }, agent);
      if (!normalized) continue;
      next.push(normalized);
      if (!existing) {
        void persistShadowProfile(normalized);
      }
    }

    for (const profile of profiles) {
      if (!profile?.agentId) continue;
      if (!agentsNow.some((agent) => agent.id === profile.agentId)) {
        next.push(profile);
      }
    }

    setShadowProfiles(next);
    return { ok: true as const, profiles: next };
  }, [normalizeShadowProfile, normalizeShadowProfileMemory, persistShadowProfile]);

  const getTradeLockerAccountKey = useCallback(() => {
    const meta = tradeLockerExecRef.current || {};
    if (!meta.connected) return null;
    const accountId = parseTradeLockerAccountNumber(meta.accountId);
    const accNum = parseTradeLockerAccountNumber(meta.accNum);
    if (accountId == null || accNum == null) return null;
    const env = meta.env != null ? String(meta.env) : '';
    const server = meta.server != null ? String(meta.server) : '';
    return `${env}:${server}:${String(accountId)}:${String(accNum)}`;
  }, []);

  getTradeLockerAccountKeyRef.current = getTradeLockerAccountKey;

  const getMt5AccountKey = useCallback(() => {
    const spec = mt5AccountSpecRef.current;
    const key = spec?.accountKey;
    return key != null ? String(key) : null;
  }, []);

  const withTradeLockerAccountLock = useCallback(async <T,>(fn: () => Promise<T> | T) => {
    const previous = tradeLockerAccountLockRef.current;
    let release: (() => void) | null = null;
    tradeLockerAccountLockRef.current = new Promise((resolve) => {
      release = resolve;
    });
    await previous;
    tradeLockerAccountBusyRef.current = true;
    try {
      return await fn();
    } finally {
      tradeLockerAccountBusyRef.current = false;
      if (release) release();
    }
  }, []);

  const ensureTradeLockerAccount = useCallback(async (accountKey: string | null, reason?: string) => {
    if (!accountKey) return { ok: false as const, error: 'TradeLocker account missing.' };
    const activeKey = getTradeLockerAccountKey();
    if (activeKey && activeKey === accountKey) return { ok: true as const, changed: false };
    const accountMap = tlAccountMapRef.current;
    const acct = accountMap.get(accountKey);
    if (!acct) return { ok: false as const, error: 'TradeLocker account not found.' };
    const setActiveAccount = tlSetActiveAccountRef.current;
    if (!setActiveAccount) return { ok: false as const, error: 'TradeLocker account switching unavailable.' };
    const res = await setActiveAccount(acct.accountId, acct.accNum);
    if (res?.ok === false) {
      const err = res?.error ? String(res.error) : 'Failed to switch TradeLocker account.';
      appendLiveError({
        source: 'tradelocker.account',
        level: 'warn',
        message: err,
        detail: { accountKey, reason: reason || null }
      });
      return { ok: false as const, error: err };
    }
    return { ok: true as const, changed: true };
  }, [appendLiveError, getTradeLockerAccountKey]);

  ensureTradeLockerAccountRef.current = ensureTradeLockerAccount;

  const resolveSnapshotSourceKey = useCallback(() => {
    const accountMap = tlAccountMapRef.current;
    const explicit = tlSnapshotSourceKeyRef.current || '';
    if (explicit && accountMap.has(explicit)) return explicit;
    const activeKey = getTradeLockerAccountKey();
    if (activeKey && accountMap.has(activeKey)) return activeKey;
    const first = accountMap.keys().next();
    return first && !first.done ? first.value : null;
  }, [getTradeLockerAccountKey]);

  resolveSnapshotSourceKeyRef.current = resolveSnapshotSourceKey;

  const resolveSnapshotFallbackOrder = useCallback((currentKey: string | null) => {
    const explicit = Array.isArray(tlSnapshotFallbackRef.current) ? tlSnapshotFallbackRef.current : [];
    const accountMap = tlAccountMapRef.current;
    const base = explicit.length ? explicit : Array.from(accountMap.keys());
    return base.filter((key) => key && key !== currentKey);
  }, []);

  resolveSnapshotFallbackOrderRef.current = resolveSnapshotFallbackOrder;

  const resolveTradeLockerExecutionTargets = useCallback(() => {
    const selected = Array.isArray(tlExecutionTargetsRef.current) ? tlExecutionTargetsRef.current : [];
    const accountMap = tlAccountMapRef.current;
    const valid = selected.filter((key) => accountMap.has(key));
    if (valid.length > 0) return valid;
    const active = getTradeLockerAccountKey();
    if (active && accountMap.has(active)) return [active];
    const first = accountMap.keys().next();
    return first && !first.done ? [first.value] : [];
  }, [getTradeLockerAccountKey]);

  const resolveNormalizationReferenceKey = useCallback(() => {
    const configured = tlNormalizeRefKeyRef.current || '';
    const accountMap = tlAccountMapRef.current;
    if (configured && accountMap.has(configured)) return configured;
    return resolveSnapshotSourceKey();
  }, [resolveSnapshotSourceKey]);

  const updateSnapshotSourceKey = useCallback((nextKey: string) => {
    if (!nextKey) return;
    setTlSnapshotSourceKey(nextKey);
  }, []);

  const handleSnapshotSourceChange = useCallback(async (nextKey: string) => {
    if (!nextKey) return;
    updateSnapshotSourceKey(nextKey);
    await withTradeLockerAccountLock(async () => {
      await ensureTradeLockerAccount(nextKey, 'snapshot_manual');
    });
  }, [ensureTradeLockerAccount, updateSnapshotSourceKey, withTradeLockerAccountLock]);

  const handleNormalizationChange = useCallback((patch: { enabled?: boolean; referenceKey?: string | null }) => {
    if (typeof patch.enabled === 'boolean') {
      setTlNormalizeEnabled(patch.enabled);
    }
    if (patch.referenceKey != null) {
      setTlNormalizeRefKey(String(patch.referenceKey));
    }
  }, []);

  const updateNormalizationSeries = useCallback((series: {
    bidOffsets: number[];
    askOffsets: number[];
    medianBid: number | null;
    medianAsk: number | null;
    madBid: number | null;
    madAsk: number | null;
    emaBid: number | null;
    emaAsk: number | null;
    updatedAtMs: number;
  } | null, bidOffset: number, askOffset: number) => {
    const next = series || {
      bidOffsets: [],
      askOffsets: [],
      medianBid: null,
      medianAsk: null,
      madBid: null,
      madAsk: null,
      emaBid: null,
      emaAsk: null,
      updatedAtMs: 0
    };

    const bidMedian = computeMedian(next.bidOffsets);
    const askMedian = computeMedian(next.askOffsets);
    const bidMad = computeMad(next.bidOffsets, bidMedian);
    const askMad = computeMad(next.askOffsets, askMedian);
    const bidOutlier = bidMad != null && bidMad > 0 && Math.abs(bidOffset - (bidMedian ?? 0)) > TL_NORMALIZE_OUTLIER_MAD * bidMad;
    const askOutlier = askMad != null && askMad > 0 && Math.abs(askOffset - (askMedian ?? 0)) > TL_NORMALIZE_OUTLIER_MAD * askMad;
    if (bidOutlier || askOutlier) return next;

    next.bidOffsets.push(bidOffset);
    next.askOffsets.push(askOffset);
    if (next.bidOffsets.length > TL_NORMALIZE_WINDOW) next.bidOffsets.shift();
    if (next.askOffsets.length > TL_NORMALIZE_WINDOW) next.askOffsets.shift();

    const nextBidMedian = computeMedian(next.bidOffsets);
    const nextAskMedian = computeMedian(next.askOffsets);
    next.medianBid = nextBidMedian;
    next.medianAsk = nextAskMedian;
    next.madBid = computeMad(next.bidOffsets, nextBidMedian);
    next.madAsk = computeMad(next.askOffsets, nextAskMedian);
    if (nextBidMedian != null && Number.isFinite(nextBidMedian)) {
      next.emaBid = next.emaBid == null ? nextBidMedian : next.emaBid * (1 - TL_NORMALIZE_ALPHA) + nextBidMedian * TL_NORMALIZE_ALPHA;
    }
    if (nextAskMedian != null && Number.isFinite(nextAskMedian)) {
      next.emaAsk = next.emaAsk == null ? nextAskMedian : next.emaAsk * (1 - TL_NORMALIZE_ALPHA) + nextAskMedian * TL_NORMALIZE_ALPHA;
    }
    next.updatedAtMs = Date.now();
    return next;
  }, []);

  const upsertTradeLockerAccountQuote = useCallback((accountKey: string, quote: TradeLockerQuote) => {
    if (!accountKey || !quote) return;
    const symbolKey = normalizeSymbolKeyShared(String(quote.symbol || ''));
    if (!symbolKey) return;
    const existing = tlAccountQuotesRef.current.get(accountKey) || {};
    existing[symbolKey] = quote;
    tlAccountQuotesRef.current.set(accountKey, existing);

    const refKey = resolveNormalizationReferenceKey();
    if (!refKey || refKey === accountKey) return;
    const refQuotes = tlAccountQuotesRef.current.get(refKey);
    if (!refQuotes) return;
    const refQuote = refQuotes[symbolKey];
    if (!refQuote) return;
    const bidOffset = Number(quote.bid) - Number(refQuote.bid);
    const askOffset = Number(quote.ask) - Number(refQuote.ask);
    if (!Number.isFinite(bidOffset) || !Number.isFinite(askOffset)) return;

    const seriesKey = `${accountKey}|${symbolKey}`;
    const series = tlNormalizationStateRef.current.get(seriesKey) || null;
    const next = updateNormalizationSeries(series, bidOffset, askOffset);
    tlNormalizationStateRef.current.set(seriesKey, next);
  }, [resolveNormalizationReferenceKey, updateNormalizationSeries]);

  upsertTradeLockerAccountQuoteRef.current = upsertTradeLockerAccountQuote;

  const getNormalizationOffsetForAccount = useCallback((accountKey: string, symbol: string) => {
    const symbolKey = normalizeSymbolKeyShared(symbol);
    if (!symbolKey || !accountKey) return null;
    const seriesKey = `${accountKey}|${symbolKey}`;
    const series = tlNormalizationStateRef.current.get(seriesKey);
    if (!series) return null;
    const samples = Math.min(series.bidOffsets.length, series.askOffsets.length);
    if (samples < TL_NORMALIZE_MIN_SAMPLES) return null;
    const bid = series.emaBid != null ? series.emaBid : series.medianBid;
    const ask = series.emaAsk != null ? series.emaAsk : series.medianAsk;
    if (!Number.isFinite(Number(bid)) || !Number.isFinite(Number(ask))) return null;
    return {
      bidOffset: Number(bid),
      askOffset: Number(ask),
      samples,
      updatedAtMs: series.updatedAtMs || null
    };
  }, []);

  const fetchTradeLockerQuotesForAccount = useCallback(async (
    accountKey: string,
    symbols: string[],
    opts?: { skipLock?: boolean; restoreKey?: string | null }
  ) => {
    if (!accountKey || !Array.isArray(symbols) || symbols.length === 0) return { ok: false as const };
    const runner = async () => {
      const restoreKey = opts?.restoreKey === undefined ? resolveSnapshotSourceKey() : opts?.restoreKey;
      const switchRes = await ensureTradeLockerAccount(accountKey, 'quote_refresh');
      if (!switchRes.ok) return { ok: false as const, error: switchRes.error };
      const tl = (window as any)?.glass?.tradelocker;
      if (!tl?.getQuotes && !tl?.getQuote) return { ok: false as const, error: 'TradeLocker quote API unavailable.' };

      let res: any = null;
      if (tl.getQuotes) {
        res = await tl.getQuotes({ symbols, maxAgeMs: 0 });
      } else {
        const quotes: any[] = [];
        for (const sym of symbols) {
          const single = await tl.getQuote({ symbol: sym, maxAgeMs: 0 });
          if (single?.ok) quotes.push(single);
        }
        res = { ok: quotes.length > 0, quotes };
      }

      if (res?.ok && Array.isArray(res.quotes)) {
        for (const item of res.quotes) {
          const sym = String(item?.symbol || '').trim();
          if (!sym) continue;
          const quote = item?.quote || item;
          upsertTradeLockerAccountQuote(accountKey, {
            symbol: sym,
            tradableInstrumentId: Number.isFinite(Number(item?.tradableInstrumentId)) ? Number(item.tradableInstrumentId) : null,
            routeId: Number.isFinite(Number(item?.routeId)) ? Number(item.routeId) : null,
            bid: quote?.bid ?? null,
            ask: quote?.ask ?? null,
            last: quote?.last ?? null,
            mid: quote?.mid ?? null,
            bidSize: quote?.bidSize ?? null,
            askSize: quote?.askSize ?? null,
            spread: quote?.spread ?? null,
            timestampMs: quote?.timestampMs ?? null,
            fetchedAtMs: item?.fetchedAtMs ?? null
          });
        }
      }

      if (restoreKey && restoreKey !== accountKey) {
        await ensureTradeLockerAccount(restoreKey, 'quote_restore');
      }

      return res?.ok ? { ok: true as const } : { ok: false as const, error: res?.error ? String(res.error) : 'Quote refresh failed.' };
    };

    if (opts?.skipLock) return runner();
    return withTradeLockerAccountLock(runner);
  }, [ensureTradeLockerAccount, resolveSnapshotSourceKey, upsertTradeLockerAccountQuote, withTradeLockerAccountLock]);

  const resolveLiveAccountKey = useCallback(async (broker: BrokerId) => {
    if (broker === 'tradelocker') return getTradeLockerAccountKey();
    const existing = getMt5AccountKey();
    if (existing) return existing;
    try {
      const spec = await fetchMt5AccountSpec();
      if (spec) {
        setMt5AccountSpec(spec);
        return spec.accountKey != null ? String(spec.accountKey) : null;
      }
    } catch {
      // ignore MT5 lookup failures
    }
    return null;
  }, [getMt5AccountKey, getTradeLockerAccountKey]);

  const getLiveAccountSnapshot = useCallback((broker: BrokerId) => {
    if (broker === 'tradelocker') {
      const meta = tradeLockerExecRef.current || {};
      const metrics = meta.accountMetrics && typeof meta.accountMetrics === 'object' ? meta.accountMetrics : null;
      const balance = Number(metrics?.balance);
      const equity = Number(metrics?.equity);
      const openPositions = Number(meta?.openPositionsCount);
      return {
        broker: 'tradelocker' as const,
        accountKey: getTradeLockerAccountKey(),
        balance: Number.isFinite(balance) ? balance : null,
        equity: Number.isFinite(equity) ? equity : null,
        openPositions: Number.isFinite(openPositions) ? openPositions : null
      };
    }
    const spec = mt5AccountSpecRef.current;
    const balance = Number(spec?.balance);
    const equity = Number(spec?.equity);
    return {
      broker: 'mt5' as const,
      accountKey: spec?.accountKey != null ? String(spec.accountKey) : null,
      balance: Number.isFinite(balance) ? balance : null,
      equity: Number.isFinite(equity) ? equity : null,
      openPositions: null
    };
  }, [getTradeLockerAccountKey]);

  const buildLiveSizingOverride = useCallback((profile: ShadowProfile, broker: BrokerId) => {
    if (!profile?.liveDeployEnabled) return {};
    const mode = profile.liveMode === 'risk' ? 'risk' : 'fixed';
    if (mode === 'fixed') {
      const lot = Number(profile.liveLotSize);
      return Number.isFinite(lot) && lot > 0 ? { lotSize: lot } : {};
    }
    const riskPct = Number(profile.liveRiskPct);
    if (!Number.isFinite(riskPct) || riskPct <= 0) return {};
    const live = getLiveAccountSnapshot(broker);
    const equity = Number(live?.equity);
    const approxLot = Number.isFinite(equity) && equity > 0 ? (equity * (riskPct / 100)) / 100 : null;
    const override: Record<string, any> = { riskPerTrade: riskPct };
    if (Number.isFinite(approxLot) && approxLot > 0) override.lotSize = approxLot;
    return override;
  }, [getLiveAccountSnapshot]);

  const resolveLiveEntryTolerancePct = useCallback((profile: ShadowProfile) => {
    const raw = Number(profile.liveEntryTolerancePct);
    if (Number.isFinite(raw) && raw >= 0) return Math.max(0, Math.min(5, raw));
    return DEFAULT_SHADOW_LIVE_ENTRY_TOLERANCE_PCT;
  }, []);

  const buildLiveGuardrailOverride = useCallback((profile: ShadowProfile) => {
    const maxDailyLoss = Number(profile.liveMaxDailyLoss);
    const maxOpenPositions = Number(profile.liveMaxOpenPositions);
    const maxOrdersPerMinute = Number(profile.liveMaxOrdersPerMinute);
    const maxConsecutiveLosses = Number(profile.liveMaxConsecutiveLosses);
    const allowlistRaw = profile.liveSymbolAllowlistRaw != null ? String(profile.liveSymbolAllowlistRaw) : '';
    return {
      enabled: true,
      killSwitch: false,
      maxDailyLoss: Number.isFinite(maxDailyLoss) && maxDailyLoss > 0 ? Math.max(0, maxDailyLoss) : 0,
      maxOpenPositions: Number.isFinite(maxOpenPositions) && maxOpenPositions > 0 ? Math.max(0, Math.floor(maxOpenPositions)) : 0,
      maxOrdersPerMinute: Number.isFinite(maxOrdersPerMinute) && maxOrdersPerMinute > 0 ? Math.max(0, Math.floor(maxOrdersPerMinute)) : 0,
      maxConsecutiveLosses: Number.isFinite(maxConsecutiveLosses) && maxConsecutiveLosses > 0 ? Math.max(0, Math.floor(maxConsecutiveLosses)) : 0,
      symbolAllowlistRaw: allowlistRaw,
      mode: 'custom',
      requireConfirmation: false
    };
  }, []);

  const updateShadowProfile = useCallback((agentId: string, patch: Partial<ShadowProfile>) => {
    const existing = (shadowProfilesRef.current || []).find((profile) => profile.agentId === agentId) || null;
    const nextPatch: Partial<ShadowProfile> = { ...patch };
    const requestedBrokerRaw = String(nextPatch.liveBroker || existing?.liveBroker || DEFAULT_SHADOW_LIVE_BROKER).trim().toLowerCase();
    const requestedBroker: BrokerId = requestedBrokerRaw === 'tradelocker' ? 'tradelocker' : 'mt5';
    const requestedLive = nextPatch.liveDeployEnabled === true;
    const brokerChangedWhileLive = nextPatch.liveBroker && existing?.liveDeployEnabled && !requestedLive;

    const applyUpdate = (accountKeyOverride?: string | null, overridePatch?: Partial<ShadowProfile>) => {
      const finalPatch = { ...nextPatch, ...(overridePatch || {}) };
      const updatedProfiles: ShadowProfile[] = [];
      let updatedProfile: ShadowProfile | null = null;
      setShadowProfiles((prev) => {
        let next = prev.map((profile) => {
          if (profile.agentId !== agentId) return profile;
          const merged = { ...profile, ...finalPatch, agentId };
          if (accountKeyOverride !== undefined) {
            merged.liveAccountKey = accountKeyOverride;
          }
          const normalized = normalizeShadowProfile(merged, null);
          if (normalized) updatedProfiles.push(normalized);
          return normalized || profile;
        });
        const updated = next.find((profile) => profile.agentId === agentId);
        if (updated) updatedProfile = updated;
        if (updated?.liveDeployEnabled && updated.liveAccountKey) {
          next = next.map((profile) => {
            if (profile.agentId === updated.agentId) return profile;
            if (!profile.liveDeployEnabled || !profile.liveAccountKey) return profile;
            if (profile.liveAccountKey !== updated.liveAccountKey) return profile;
            const normalized = normalizeShadowProfile({
              ...profile,
              liveDeployEnabled: false,
              liveAccountKey: null
            }, null);
            if (normalized) updatedProfiles.push(normalized);
            return normalized || profile;
          });
        }
        return next;
      });
      if (updatedProfiles.length > 0) {
        for (const profile of updatedProfiles) {
          void persistShadowProfile(profile);
        }
      }
      return updatedProfile;
    };

    if (requestedLive || brokerChangedWhileLive) {
      const existingKey = requestedBroker === 'tradelocker' ? getTradeLockerAccountKey() : getMt5AccountKey();
      if (existingKey) {
        const updatedProfile = applyUpdate(existingKey);
        if (updatedProfile?.liveDeployEnabled) {
          const runner = maybeExecutePendingLiveSignalsRef.current;
          if (runner) {
            void runner({ agentId, profileOverride: updatedProfile });
          }
        }
        return;
      }
      if (requestedBroker === 'mt5') {
        void (async () => {
          const resolved = await resolveLiveAccountKey('mt5');
          if (resolved) {
            const updatedProfile = applyUpdate(resolved);
            if (updatedProfile?.liveDeployEnabled) {
              const runner = maybeExecutePendingLiveSignalsRef.current;
              if (runner) {
                void runner({ agentId, profileOverride: updatedProfile });
              }
            }
            return;
          }
          addNotification('Live Deploy Blocked', 'MT5 account not available. Connect MT5 and try again.', 'warning');
          applyUpdate(null, { liveDeployEnabled: false });
        })();
        return;
      }
      void (async () => {
        const resolved = await resolveLiveAccountKey('tradelocker');
        if (resolved) {
          const updatedProfile = applyUpdate(resolved);
          if (updatedProfile?.liveDeployEnabled) {
            const runner = maybeExecutePendingLiveSignalsRef.current;
            if (runner) {
              void runner({ agentId, profileOverride: updatedProfile });
            }
          }
          return;
        }
        addNotification('Live Deploy Blocked', 'TradeLocker account not selected. Connect TradeLocker and try again.', 'warning');
        applyUpdate(null, { liveDeployEnabled: false });
      })();
      return;
    }

    if (nextPatch.liveDeployEnabled === false) {
      applyUpdate(null);
      return;
    }

    applyUpdate(undefined);
  }, [addNotification, getMt5AccountKey, getTradeLockerAccountKey, normalizeShadowProfile, persistShadowProfile, resolveLiveAccountKey]);

  const refreshSignalHistory = useCallback(async (opts?: { force?: boolean; limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Signal history unavailable.' };
    const now = Date.now();
    if (!opts?.force && now - signalHistoryFetchAtRef.current < 5_000) {
      return { ok: true as const, skipped: true };
    }
    signalHistoryFetchAtRef.current = now;
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(20, Math.min(2000, Math.floor(Number(opts?.limit)))) : 1000;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'signal_history' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load signal history.' };
      }
      const entries = res.memories.map(normalizeSignalHistoryMemory).filter(Boolean) as SignalHistoryEntry[];
      entries.sort((a, b) => {
        const aTime = a.resolvedAtMs ?? a.executedAtMs ?? 0;
        const bTime = b.resolvedAtMs ?? b.executedAtMs ?? 0;
        return bTime - aTime;
      });
      setSignalHistory(entries);
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load signal history.' };
    }
  }, [normalizeSignalHistoryMemory]);

  useEffect(() => {
    void refreshSignalHistory({ force: true });
  }, [refreshSignalHistory]);

  const refreshAgentScorecards = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Agent scorecards unavailable.' };
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(20, Math.min(500, Math.floor(Number(opts?.limit)))) : 200;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'agent_scorecard' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load agent scorecards.' };
      }
      const entries = res.memories
        .map(normalizeAgentScorecardMemory)
        .filter(Boolean) as AgentScorecardSnapshot[];
      entries.sort((a, b) => (Number(b.updatedAtMs || 0) - Number(a.updatedAtMs || 0)));
      setAgentScorecards(entries);
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load agent scorecards.' };
    }
  }, [normalizeAgentScorecardMemory]);

  useEffect(() => {
    if (signalHistory.length > 0) return;
    void refreshAgentScorecards({ limit: 200 });
  }, [refreshAgentScorecards, signalHistory.length]);

  useEffect(() => {
    void refreshSignalEntries({ limit: 500 });
  }, [refreshSignalEntries]);


  useEffect(() => {
    if (signalEntryPersistTimerRef.current != null) {
      cancelTimer(signalEntryPersistTimerRef.current);
    }
    signalEntryPersistTimerRef.current = deferMs(() => {
      void persistSignalEntries(signalEntriesRef.current || []);
    }, 300);
    return () => {
      if (signalEntryPersistTimerRef.current != null) {
        cancelTimer(signalEntryPersistTimerRef.current);
      }
    };
  }, [persistSignalEntries, signalEntries]);

  const upsertCalendarEvent = useCallback(async (input: {
    id?: string;
    type: string;
    title?: string | null;
    symbol?: string | null;
    timeframe?: string | null;
    broker?: string | null;
    agentId?: string | null;
    outcome?: string | null;
    rMultiple?: number | null;
    startAtMs?: number | null;
    endAtMs?: number | null;
    durationMs?: number | null;
    status?: string | null;
    signalId?: string | null;
    caseId?: string | null;
    lessonId?: string | null;
    metadata?: Record<string, any> | null;
    source?: string | null;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const type = String(input.type || '').trim() || 'event';
    const refId = String(input.signalId || input.caseId || input.lessonId || input.id || '').trim();
    const id = refId ? `${type}:${refId}` : `${type}:${Date.now()}`;
    const key = `calendar_event:${id}`;
    const summary = input.title ? String(input.title) : type;
    const payload = {
      id,
      type,
      title: input.title ?? summary,
      startAtMs: Number.isFinite(Number(input.startAtMs)) ? Number(input.startAtMs) : null,
      endAtMs: Number.isFinite(Number(input.endAtMs)) ? Number(input.endAtMs) : null,
      durationMs: Number.isFinite(Number(input.durationMs)) ? Number(input.durationMs) : null,
      status: input.status ?? null,
      agentId: input.agentId ?? null,
      broker: input.broker ?? null,
      signalId: input.signalId ?? null,
      caseId: input.caseId ?? null,
      lessonId: input.lessonId ?? null,
      outcome: input.outcome ?? null,
      rMultiple: Number.isFinite(Number(input.rMultiple)) ? Number(input.rMultiple) : null,
      notes: null,
      metadata: input.metadata ?? null
    };
    const tags = [
      input.symbol || '',
      input.timeframe || '',
      input.agentId ? `agent:${input.agentId}` : '',
      input.broker ? `broker:${input.broker}` : '',
      input.outcome ? `outcome:${String(input.outcome).toLowerCase()}` : '',
      type
    ].filter(Boolean);

    await ledger.upsertAgentMemory({
      key,
      agentId: input.agentId ?? null,
      scope: 'shared',
      category: 'calendar',
      subcategory: 'event',
      kind: 'calendar_event',
      symbol: input.symbol || undefined,
      timeframe: input.timeframe || undefined,
      summary,
      payload,
      tags,
      createdAtMs: payload.startAtMs || undefined,
      source: input.source || 'calendar'
    });
  }, []);

  const syncEconomicCalendar = useCallback(async (opts?: { force?: boolean; reason?: string }) => {
    const api = window.glass?.calendar;
    if (!api?.getEvents) return { ok: false, error: 'Calendar service unavailable.' };
    if (calendarIngestRef.current.inFlight) return { ok: true, skipped: true };
    calendarIngestRef.current.inFlight = true;
    try {
      const res = await api.getEvents({
        lookbackHours: 36,
        lookaheadHours: 10 * 24,
        force: opts?.force === true
      });
      if (!res?.ok || !Array.isArray(res.events)) {
        const errMsg = res?.error ? String(res.error) : 'Calendar ingest failed.';
        calendarIngestRef.current.lastError = errMsg;
        return { ok: false, error: errMsg };
      }
      for (const rawEvent of res.events) {
        if (!rawEvent || !rawEvent.title) continue;
        const currency = rawEvent.currency ? String(rawEvent.currency).trim().toUpperCase() : '';
        const country = rawEvent.country ? String(rawEvent.country).trim() : '';
        const impactRaw = rawEvent.impact ? String(rawEvent.impact).trim() : '';
        const impact = impactRaw ? impactRaw.toLowerCase() : '';
        const status = impact ? impact.toUpperCase() : (rawEvent.status ? String(rawEvent.status).trim() : null);
        const titleParts = [currency || country, rawEvent.title].filter(Boolean);
        const title = titleParts.join(' ').trim();
        const symbol = currency || country || null;
        const metadata = {
          source: rawEvent.source || null,
          url: rawEvent.url || null,
          currency: currency || null,
          country: country || null,
          impact: impact || null,
          actual: rawEvent.actual ?? null,
          forecast: rawEvent.forecast ?? null,
          previous: rawEvent.previous ?? null
        };
        await upsertCalendarEvent({
          id: rawEvent.id,
          type: 'economic_event',
          title: title || rawEvent.title,
          symbol,
          startAtMs: Number.isFinite(Number(rawEvent.startAtMs)) ? Number(rawEvent.startAtMs) : null,
          endAtMs: Number.isFinite(Number(rawEvent.endAtMs)) ? Number(rawEvent.endAtMs) : null,
          status,
          metadata,
          source: 'calendar'
        });
      }
      calendarIngestRef.current.lastRunAtMs = Date.now();
      calendarIngestRef.current.lastError = null;
      return { ok: true, cached: res.cached === true, count: res.events.length };
    } catch (err: any) {
      const errMsg = err?.message ? String(err.message) : 'Calendar ingest failed.';
      calendarIngestRef.current.lastError = errMsg;
      return { ok: false, error: errMsg };
    } finally {
      calendarIngestRef.current.inFlight = false;
    }
  }, [upsertCalendarEvent]);

  const loadCalendarPnlSnapshot = useCallback(async (input?: {
    monthKey?: string;
    timezone?: string;
    symbol?: string | null;
    agentId?: string | null;
    broker?: string | null;
    accountKey?: string | null;
    accountId?: number | null;
    accNum?: number | null;
    limit?: number;
  }): Promise<CalendarPnlSnapshot> => {
    const ledger = window.glass?.tradeLedger;
    let entries: any[] = [];
    if (ledger?.list) {
      const limitRaw = Number(input?.limit);
      const limit = Number.isFinite(limitRaw) ? Math.max(200, Math.min(10_000, Math.floor(limitRaw))) : 5_000;
      const res = await ledger.list({ limit });
      if (!res?.ok) {
        throw new Error(res?.error ? String(res.error) : 'Failed to load trade ledger.');
      }
      entries = Array.isArray(res.entries) ? res.entries : [];
    }
    const timezone = String(
      input?.timezone ||
      (() => {
        try {
          return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
        } catch {
          return 'UTC';
        }
      })()
    ).trim() || 'UTC';
    const meta = tradeLockerExecRef.current || {};
    const savedCfg = tlSavedConfigRef.current || {};
    const requestedAccountKeyRaw = String(input?.accountKey || '').trim();
    const normalizeKey = (value: any) => String(value || '').trim().toLowerCase();
    const parseAccountIdentityFromKey = (value: any) => {
      const raw = String(value || '').trim();
      if (!raw) return null;
      const parts = raw.split(':').map((part) => part.trim()).filter(Boolean);
      if (parts.length < 4) return null;
      const accNum = parseTradeLockerAccountNumber(parts[parts.length - 1]);
      const accountId = parseTradeLockerAccountNumber(parts[parts.length - 2]);
      if (accountId == null || accNum == null) return null;
      const server = String(parts[parts.length - 3] || '').trim();
      const env = String(parts[parts.length - 4] || '').trim();
      if (!env || !server) return null;
      return { env, server, accountId, accNum };
    };
    const requestedFromKey = requestedAccountKeyRaw
      ? (parseTradeLockerAccountKey(requestedAccountKeyRaw) || parseAccountIdentityFromKey(requestedAccountKeyRaw))
      : null;
    const requestedAccountId = parseTradeLockerAccountNumber(input?.accountId) ?? (requestedFromKey?.accountId ?? null);
    const requestedAccNum = parseTradeLockerAccountNumber(input?.accNum) ?? (requestedFromKey?.accNum ?? null);
    const requestedEnv = requestedFromKey?.env ? String(requestedFromKey.env) : '';
    const requestedServer = requestedFromKey?.server ? String(requestedFromKey.server) : '';
    const activeEnv = String(meta?.env || savedCfg?.env || '').trim();
    const activeServer = String(meta?.server || savedCfg?.server || '').trim();
    const activeAccountId = parseTradeLockerAccountNumber(meta?.accountId)
      ?? parseTradeLockerAccountNumber(savedCfg?.accountId);
    const activeAccNum = parseTradeLockerAccountNumber(meta?.accNum)
      ?? parseTradeLockerAccountNumber(savedCfg?.accNum);
    const activeAccountKey = buildTradeLockerAccountKey({
      env: activeEnv || null,
      server: activeServer || null,
      accountId: activeAccountId,
      accNum: activeAccNum
    });
    const requestedHasIdentity =
      requestedAccountId != null ||
      requestedAccNum != null ||
      !!requestedEnv ||
      !!requestedServer;
    const accountMetrics = meta?.accountMetrics && typeof meta.accountMetrics === 'object'
      ? meta.accountMetrics
      : null;
    const toLooseNumber = (value: any): number | null => {
      if (value == null || value === '') return null;
      const raw = typeof value === 'number' ? value : Number(String(value).replace(/,/g, '').trim());
      return Number.isFinite(raw) ? raw : null;
    };
    const toEpochMs = (value: any): number | null => {
      if (value == null || value === '') return null;
      if (typeof value === 'number' && Number.isFinite(value)) return value > 1e12 ? value : value * 1000;
      const parsed = Date.parse(String(value));
      return Number.isFinite(parsed) ? parsed : null;
    };
    const readHistoryPnl = (order: any): number | null => {
      const raw = order?.raw && typeof order.raw === 'object' ? order.raw : {};
      const candidates = [
        order?.realizedPnl,
        order?.positionClosedPnl,
        order?.pnl,
        order?.profit,
        order?.profitLoss,
        order?.netPnl,
        order?.closedPnl,
        raw?.realizedPnl,
        raw?.positionClosedPnl,
        raw?.pnl,
        raw?.profit,
        raw?.profitLoss,
        raw?.netPnl,
        raw?.closedPnl,
        raw?.openNetPnL,
        raw?.openNetPnl,
        raw?.openGrossPnL,
        raw?.openGrossPnl
      ];
      for (const candidate of candidates) {
        const next = toLooseNumber(candidate);
        if (next != null) return next;
      }
      return null;
    };
    const entryMatchesRequestedAccount = (entry: any) => {
      const requestedKey = normalizeKey(requestedAccountKeyRaw);
      const entryEnv = String(entry?.env || '').trim();
      const entryServer = String(entry?.server || '').trim();
      const entryAccountId = parseTradeLockerAccountNumber(entry?.accountId);
      const entryAccNum = parseTradeLockerAccountNumber(entry?.accNum);
      const synthesizedKey =
        buildTradeLockerAccountKey({
          env: entryEnv || null,
          server: entryServer || null,
          accountId: entryAccountId,
          accNum: entryAccNum
        }) ||
        String(entry?.accountKey || '').trim();

      if (requestedKey) {
        if (requestedKey === 'unassigned') return !synthesizedKey && entryAccountId == null;
        if (normalizeKey(synthesizedKey) === requestedKey) return true;
        if (!requestedHasIdentity) return false;
      }
      if (requestedAccountId != null) {
        if (entryAccountId == null || entryAccountId !== requestedAccountId) return false;
      }
      if (requestedAccNum != null) {
        if (entryAccNum == null || entryAccNum !== requestedAccNum) return false;
      }
      if (requestedEnv) {
        if (!entryEnv || normalizeKey(entryEnv) !== normalizeKey(requestedEnv)) return false;
      }
      if (requestedServer) {
        if (!entryServer || normalizeKey(entryServer) !== normalizeKey(requestedServer)) return false;
      }
      return true;
    };
    const activeAccountMatchState = (() => {
      const requestedKey = normalizeKey(requestedAccountKeyRaw);
      const activeKey = normalizeKey(activeAccountKey);
      if (!requestedKey && !requestedHasIdentity) return 'match';
      if (requestedKey && activeKey && requestedKey === activeKey) return 'match';
      if (!requestedHasIdentity) return 'unknown';
      if (requestedAccountId != null && activeAccountId != null && activeAccountId !== requestedAccountId) {
        return 'mismatch';
      }
      if (requestedAccNum != null && activeAccNum != null && activeAccNum !== requestedAccNum) {
        return 'mismatch';
      }
      if (requestedEnv && activeEnv && normalizeKey(activeEnv) !== normalizeKey(requestedEnv)) {
        return 'mismatch';
      }
      if (requestedServer && activeServer && normalizeKey(activeServer) !== normalizeKey(requestedServer)) {
        return 'mismatch';
      }
      if (
        (requestedAccountId != null && activeAccountId == null) ||
        (requestedAccNum != null && activeAccNum == null) ||
        (requestedEnv && !activeEnv) ||
        (requestedServer && !activeServer)
      ) {
        return 'unknown';
      }
      return 'match';
    })();
    let accountBalance = Number.isFinite(Number(accountMetrics?.balance))
      ? Number(accountMetrics.balance)
      : (Number.isFinite(Number(meta?.balance)) ? Number(meta.balance) : null);
    let accountEquity = Number.isFinite(Number(accountMetrics?.equity))
      ? Number(accountMetrics.equity)
      : (Number.isFinite(Number(meta?.equity)) ? Number(meta.equity) : null);
    const tradeLockerApi = window.glass?.tradelocker;

    if (activeAccountMatchState === 'mismatch') {
      accountBalance = null;
      accountEquity = null;
    }

    if (activeAccountMatchState !== 'mismatch' && (accountBalance == null || accountEquity == null) && tradeLockerApi?.getAccountMetrics) {
      try {
        const metricsRes = await tradeLockerApi.getAccountMetrics({ maxAgeMs: 12_000 });
        if (metricsRes?.ok) {
          const fallbackBalance = toLooseNumber(metricsRes?.balance);
          const fallbackEquity = toLooseNumber(metricsRes?.equity);
          if (accountBalance == null && fallbackBalance != null) accountBalance = fallbackBalance;
          if (accountEquity == null && fallbackEquity != null) accountEquity = fallbackEquity;
        }
      } catch {
        // Keep ledger/ref-derived values on API fetch failures.
      }
    }

    const isTradeLedgerClosedTrade = (entry: any) => {
      if (!entry || typeof entry !== 'object') return false;
      if (String(entry?.broker || '').trim().toLowerCase() !== 'tradelocker') return false;
      const status = String(entry?.status || '').trim().toUpperCase();
      const positionStatus = String(entry?.positionStatus || '').trim().toUpperCase();
      const closedAtMs = Number(entry?.positionClosedAtMs || entry?.closedAtMs || 0);
      if (!(status === 'CLOSED' || positionStatus === 'CLOSED' || closedAtMs > 0)) return false;
      return entryMatchesRequestedAccount(entry);
    };

    const hasTradeLockerClosedLedgerEntries = entries.some((entry) => isTradeLedgerClosedTrade(entry));
    if (activeAccountMatchState !== 'mismatch' && !hasTradeLockerClosedLedgerEntries && tradeLockerApi?.getOrdersHistory) {
      try {
        const historyRes = await tradeLockerApi.getOrdersHistory();
        const historyOrders = historyRes?.ok && Array.isArray(historyRes.orders) ? historyRes.orders : [];
        if (historyOrders.length > 0) {
          const seenKeys = new Set<string>();
          for (const entry of entries) {
            const id = String(entry?.brokerOrderId || entry?.orderId || entry?.id || '').trim();
            if (id) seenKeys.add(id.toUpperCase());
          }
          const derivedEntries = historyOrders
            .map((order: any) => {
              const orderId = String(order?.id || '').trim();
              if (!orderId) return null;
              if (seenKeys.has(orderId.toUpperCase())) return null;
              const side = String(order?.side || '').trim().toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
              const createdAtMs =
                toEpochMs(order?.createdAt) ||
                toEpochMs(order?.filledAt) ||
                toEpochMs(order?.closedAt) ||
                Date.now();
              const closedAtMs =
                toEpochMs(order?.closedAt) ||
                toEpochMs(order?.filledAt) ||
                createdAtMs;
              const realizedPnl = readHistoryPnl(order);
              return {
                id: `tradelocker_history_${orderId}`,
                brokerOrderId: orderId,
                orderId,
                kind: 'trade',
                broker: 'tradelocker',
                symbol: order?.symbol ? String(order.symbol) : null,
                action: side,
                side,
                orderType: order?.type ? String(order.type) : null,
                qty: toLooseNumber(order?.qty),
                brokerQty: toLooseNumber(order?.qty),
                qtyNormalized: toLooseNumber(order?.qty),
                entryPrice: toLooseNumber(order?.price),
                brokerEntryPrice: toLooseNumber(order?.price),
                brokerClosePrice: toLooseNumber(order?.stopPrice),
                stopLoss: toLooseNumber(order?.stopLoss),
                takeProfit: toLooseNumber(order?.takeProfit),
                status: 'CLOSED',
                positionStatus: 'CLOSED',
                createdAtMs,
                updatedAtMs: closedAtMs,
                brokerOpenTimeMs: createdAtMs,
                positionOpenedAtMs: createdAtMs,
                positionClosedAtMs: closedAtMs,
                closedAtMs,
                realizedPnl: realizedPnl ?? 0,
                positionClosedPnl: realizedPnl ?? 0,
                realizedPnlSource: realizedPnl != null ? 'tradelocker_orders_history' : 'tradelocker_orders_history_unavailable',
                env: activeEnv || null,
                server: activeServer || null,
                accountId: activeAccountId ?? null,
                accNum: activeAccNum ?? null,
                accountKey: activeAccountKey || null
              };
            })
            .filter(Boolean);
          if (derivedEntries.length > 0) {
            entries = [...entries, ...derivedEntries];
          }
        }
      } catch {
        // Broker history fallback is best effort; calendar still works off ledger entries.
      }
    }

    return buildCalendarPnlSnapshot({
      entries,
      monthKey: input?.monthKey || null,
      timezone,
      accountBalance,
      accountEquity,
      symbol: input?.symbol || null,
      agentId: input?.agentId || null,
      broker: input?.broker || null,
      accountKey: requestedAccountKeyRaw || null,
      accountId: requestedAccountId ?? null,
      accNum: requestedAccNum ?? null
    });
  }, []);

  const resolveCalendarSignalEventType = useCallback((status: SignalEntry['status'], outcome?: string | null) => {
    const raw = String(status || '').toUpperCase();
    if (raw === 'PROPOSED') return 'signal_proposed';
    if (raw === 'SUBMITTING' || raw === 'PENDING') return 'signal_submitting';
    if (raw === 'EXECUTED') return 'signal_executed';
    if (raw === 'REJECTED') return 'signal_rejected';
    if (raw === 'EXPIRED') return 'signal_expired';
    if (raw === 'WIN' || raw === 'LOSS') return 'signal_outcome_resolved';
    if (raw === 'FAILED') return 'signal_failed';
    if (outcome) return 'signal_outcome_resolved';
    return 'signal_update';
  }, []);

  const upsertSignalHistory = useCallback(async (
    entry: SignalEntry,
    patch?: Partial<SignalHistoryEntry>
  ) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const outcome = patch?.outcome ?? resolveSignalOutcome(entry.status);
    const score = patch?.score ?? (
      outcome === 'WIN' || outcome === 'LOSS'
        ? computeSignalOutcomeScore(entry, outcome)
        : null
    );
    const executedAtMs = patch?.executedAtMs ?? entry.executedAtMs ?? null;
    const resolvedAtMs = patch?.resolvedAtMs ?? entry.resolvedAtMs ?? null;
    const startAtMs = executedAtMs ?? entry.createdAtMs ?? null;
    const durationMs =
      patch?.durationMs != null
        ? patch.durationMs
        : (Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(resolvedAtMs))
            ? Math.max(0, Number(resolvedAtMs) - Number(startAtMs))
            : null);
    const barsToOutcome = patch?.barsToOutcome ?? null;
    const resolvedOutcomeEnvelope = buildResolvedOutcomeEnvelope({
      signalId: String(entry.id),
      status: patch?.status ?? entry.status ?? null,
      outcome: outcome ?? null,
      createdAtMs: entry.createdAtMs,
      executedAtMs,
      resolvedAtMs,
      executionBroker: patch?.executionBroker ?? entry.executionBroker ?? null,
      executionMode: patch?.executionMode ?? entry.executionMode ?? null,
      source: patch?.executionBroker === 'shadow' || patch?.executionMode === 'shadow'
        ? 'shadow'
        : undefined
    });
    const attribution = buildSignalAttributionRecord({
      signalId: String(entry.id),
      status: patch?.status ?? entry.status ?? null,
      outcome: outcome ?? null,
      createdAtMs: entry.createdAtMs,
      executedAtMs,
      resolvedAtMs,
      executionBroker: patch?.executionBroker ?? entry.executionBroker ?? null,
      executionMode: patch?.executionMode ?? entry.executionMode ?? null,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      exitPrice: patch?.exitPrice ?? null,
      score
    });

    const payload: SignalHistoryEntry = {
      id: String(entry.id),
      signalId: String(entry.id),
      agentId: entry.agentId ?? null,
      agentName: entry.agentName ?? null,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      action: entry.action,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      probability: entry.probability,
      strategyMode: entry.strategyMode ?? null,
      reason: entry.reason ?? null,
      executionSource: entry.executionSource ?? null,
      executionBroker: entry.executionBroker ?? null,
      executionMode: entry.executionMode ?? null,
      status: patch?.status ?? entry.status ?? null,
      outcome,
      score,
      executedAtMs,
      resolvedAtMs,
      durationMs,
      barsToOutcome,
      exitPrice: patch?.exitPrice ?? null,
      runId: entry.runId ?? null,
      ledgerId: patch?.ledgerId ?? entry.executionLedgerId ?? null,
      orderId: patch?.orderId ?? entry.executionOrderId ?? null,
      positionId: patch?.positionId ?? entry.executionPositionId ?? null,
      newsSnapshot: entry.newsSnapshot ?? null,
      outcomeSource: resolvedOutcomeEnvelope?.source ?? null,
      decisionOutcome: resolvedOutcomeEnvelope?.decisionOutcome ?? null,
      executionOutcome: resolvedOutcomeEnvelope?.executionOutcome ?? null,
      resolvedOutcomeEnvelope: resolvedOutcomeEnvelope ?? null,
      attribution: attribution ?? null
    };

    const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
    const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(entry.probability)}%` : '';
    const scoreLabel = score != null ? `${score.toFixed(2)}R` : '';
    const summaryParts = [
      outcome || entry.status || 'EXECUTED',
      entry.action,
      entry.symbol,
      tfLabel,
      probLabel,
      scoreLabel
    ].filter(Boolean);
    const summary = summaryParts.join(' ');

    const tags = [
      entry.symbol,
      entry.timeframe || '',
      entry.strategyMode ? `mode:${entry.strategyMode}` : '',
      entry.agentId ? `agent:${entry.agentId}` : '',
      outcome ? `outcome:${String(outcome).toLowerCase()}` : '',
      entry.executionSource ? `source:${entry.executionSource}` : '',
      entry.executionBroker ? `broker:${entry.executionBroker}` : '',
      entry.executionMode ? `exec:${entry.executionMode}` : '',
      resolvedOutcomeEnvelope?.decisionOutcome ? `decision:${String(resolvedOutcomeEnvelope.decisionOutcome).toLowerCase()}` : '',
      resolvedOutcomeEnvelope?.executionOutcome ? `execution:${String(resolvedOutcomeEnvelope.executionOutcome).toLowerCase()}` : '',
      entry.newsSnapshot?.impactLevel ? `news:${entry.newsSnapshot.impactLevel}` : '',
      entry.newsSnapshot?.trumpNews ? 'trump_news' : ''
    ].filter(Boolean);

    const symbolKey = normalizeSymbolKey(entry.symbol);
    const tfKey = entry.timeframe ? normalizeTimeframeKey(entry.timeframe) : '';

    await ledger.upsertAgentMemory({
      key: `signal_history:${entry.id}`,
      familyKey: symbolKey ? `signal_history:${symbolKey}:${tfKey}` : undefined,
      agentId: entry.agentId ?? null,
      scope: 'shared',
      category: 'signal',
      subcategory: 'history',
      kind: 'signal_history',
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      summary,
      payload,
      tags,
      source: 'signal_panel'
    });

    const eventType = resolveCalendarSignalEventType(payload.status || entry.status, outcome || null);
    const endAtMs = resolvedAtMs ?? entry.resolvedAtMs ?? null;
    void upsertCalendarEvent({
      id: entry.id,
      type: eventType,
      title: summary,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      broker: entry.executionBroker ?? null,
      agentId: entry.agentId ?? null,
      outcome: outcome || null,
      rMultiple: score ?? null,
      startAtMs,
      endAtMs,
      durationMs,
      status: payload.status ?? entry.status ?? null,
      signalId: entry.id,
      metadata: {
        executionSource: entry.executionSource ?? null,
        executionMode: entry.executionMode ?? null
      },
      source: 'signal_panel'
    });
    if (outcome === 'WIN' || outcome === 'LOSS') {
      void upsertCalendarEvent({
        id: entry.id,
        type: 'lesson_candidate',
        title: `Lesson candidate: ${summary}`,
        symbol: entry.symbol,
        timeframe: entry.timeframe ?? null,
        agentId: entry.agentId ?? null,
        outcome: outcome || null,
        rMultiple: score ?? null,
        startAtMs,
        endAtMs,
        durationMs,
        status: outcome || null,
        signalId: entry.id,
        metadata: {
          executionSource: entry.executionSource ?? null,
          executionMode: entry.executionMode ?? null
        },
        source: 'academy'
      });
    }

    setSignalHistory((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.signalId === entry.id);
      if (idx >= 0) {
        next[idx] = { ...next[idx], ...payload };
      } else {
        next.unshift(payload);
      }
      return next;
    });
  }, [computeSignalOutcomeScore, formatTimeframeLabel, resolveCalendarSignalEventType, resolveSignalOutcome, upsertCalendarEvent]);

  const upsertSignalReview = useCallback(async (entry: SignalEntry, input: {
    outcome: 'WIN' | 'LOSS';
    score?: number | null;
    exitPrice?: number | null;
    resolvedAtMs?: number | null;
    durationMs?: number | null;
    barsToOutcome?: number | null;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const score = input.score != null ? input.score : computeSignalOutcomeScore(entry, input.outcome);
    const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
    const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(Number(entry.probability))}%` : '';
    const scoreLabel = Number.isFinite(Number(score)) ? `${Number(score).toFixed(2)}R` : '';
    const summaryParts = [
      input.outcome,
      entry.action,
      entry.symbol,
      tfLabel,
      probLabel,
      scoreLabel
    ].filter(Boolean);
    const summary = summaryParts.join(' ');

    const payload = {
      signalId: entry.id,
      outcome: input.outcome,
      score,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      action: entry.action,
      probability: entry.probability ?? null,
      strategyMode: entry.strategyMode ?? null,
      reason: entry.reason ?? null,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      exitPrice: input.exitPrice ?? null,
      executedAtMs: entry.executedAtMs ?? null,
      resolvedAtMs: input.resolvedAtMs ?? entry.resolvedAtMs ?? null,
      durationMs: input.durationMs ?? null,
      barsToOutcome: input.barsToOutcome ?? null,
      agentId: entry.agentId ?? null,
      agentName: entry.agentName ?? null,
      executionSource: entry.executionSource ?? null,
      runId: entry.runId ?? null,
      newsSnapshot: entry.newsSnapshot ?? null
    };

    const tags = [
      entry.symbol,
      entry.timeframe || '',
      entry.strategyMode ? `mode:${entry.strategyMode}` : '',
      entry.agentId ? `agent:${entry.agentId}` : '',
      `outcome:${String(input.outcome).toLowerCase()}`
    ].filter(Boolean);

    const symbolKey = normalizeSymbolKey(entry.symbol);
    const tfKey = entry.timeframe ? normalizeTimeframeKey(entry.timeframe) : '';

    await ledger.upsertAgentMemory({
      key: `signal_review:${entry.id}`,
      familyKey: symbolKey ? `signal_review:${symbolKey}:${tfKey}` : undefined,
      agentId: entry.agentId ?? null,
      scope: 'shared',
      category: 'signal',
      subcategory: 'review',
      kind: 'signal_review',
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      summary,
      payload,
      tags,
      source: 'signal_panel'
    });

    const startAtMs = payload.executedAtMs ?? entry.executedAtMs ?? entry.createdAtMs ?? null;
    const endAtMs = payload.resolvedAtMs ?? entry.resolvedAtMs ?? null;
    const durationMs =
      input.durationMs != null
        ? input.durationMs
        : (Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(endAtMs))
            ? Math.max(0, Number(endAtMs) - Number(startAtMs))
            : null);
    void upsertCalendarEvent({
      id: entry.id,
      type: 'signal_outcome_resolved',
      title: summary,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      broker: entry.executionBroker ?? null,
      agentId: entry.agentId ?? null,
      outcome: input.outcome,
      rMultiple: score ?? null,
      startAtMs,
      endAtMs,
      durationMs,
      status: input.outcome,
      signalId: entry.id,
      metadata: {
        executionSource: entry.executionSource ?? null,
        executionMode: entry.executionMode ?? null
      },
      source: 'signal_panel'
    });
    void upsertCalendarEvent({
      id: entry.id,
      type: 'lesson_candidate',
      title: `Lesson candidate: ${summary}`,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      agentId: entry.agentId ?? null,
      outcome: input.outcome,
      rMultiple: score ?? null,
      startAtMs,
      endAtMs,
      durationMs,
      status: input.outcome,
      signalId: entry.id,
      metadata: {
        executionSource: entry.executionSource ?? null,
        executionMode: entry.executionMode ?? null
      },
      source: 'academy'
    });
  }, [computeSignalOutcomeScore, formatTimeframeLabel, upsertCalendarEvent]);

  const normalizeAcademyCaseMemory = useCallback((memory: any): AcademyCase | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const caseId = String(payload.id || payload.caseId || payload.signalId || rawKey.replace(/^academy_case:/, '') || '').trim();
    if (!caseId) return null;
    const actionRaw = String(payload.action || '').trim().toUpperCase();
    const action = actionRaw === 'SELL' ? 'SELL' : 'BUY';
    const entryPrice = Number(payload.entryPrice);
    const stopLoss = Number(payload.stopLoss);
    const takeProfit = Number(payload.takeProfit);
    const createdAtMs = Number.isFinite(Number(payload.createdAtMs)) ? Number(payload.createdAtMs) : null;
    const executedAtMs = Number.isFinite(Number(payload.executedAtMs)) ? Number(payload.executedAtMs) : null;
    const resolvedAtMs = Number.isFinite(Number(payload.resolvedAtMs)) ? Number(payload.resolvedAtMs) : null;
    const durationMs = Number.isFinite(Number(payload.durationMs))
      ? Number(payload.durationMs)
      : (Number.isFinite(Number(resolvedAtMs)) && Number.isFinite(Number(executedAtMs ?? createdAtMs))
          ? Math.max(0, Number(resolvedAtMs) - Number(executedAtMs ?? createdAtMs))
          : null);
    const resolvedOutcomeEnvelope = payload.resolvedOutcomeEnvelope && typeof payload.resolvedOutcomeEnvelope === 'object'
      ? payload.resolvedOutcomeEnvelope
      : buildResolvedOutcomeEnvelope({
          signalId: caseId,
          status: payload.status != null ? String(payload.status) : null,
          outcome: payload.outcome != null ? String(payload.outcome) : null,
          createdAtMs,
          executedAtMs,
          resolvedAtMs,
          executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
          executionMode: payload.executionMode != null ? String(payload.executionMode) : null
        });
    const attribution = payload.attribution && typeof payload.attribution === 'object'
      ? payload.attribution
      : buildSignalAttributionRecord({
          signalId: caseId,
          status: payload.status != null ? String(payload.status) : null,
          outcome: payload.outcome != null ? String(payload.outcome) : null,
          createdAtMs,
          executedAtMs,
          resolvedAtMs,
          executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
          executionMode: payload.executionMode != null ? String(payload.executionMode) : null,
          entryPrice,
          stopLoss,
          takeProfit,
          exitPrice: Number.isFinite(Number(payload.exitPrice)) ? Number(payload.exitPrice) : null,
          score: Number.isFinite(Number(payload.score)) ? Number(payload.score) : null
        });

    return {
      id: caseId,
      signalId: payload.signalId != null ? String(payload.signalId) : caseId,
      agentId: payload.agentId != null ? String(payload.agentId) : null,
      agentName: payload.agentName != null ? String(payload.agentName) : null,
      symbol: String(payload.symbol || memory.symbol || '').trim(),
      timeframe: payload.timeframe != null ? String(payload.timeframe) : (memory.timeframe != null ? String(memory.timeframe) : null),
      action,
      entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
      stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
      takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
      probability: Number.isFinite(Number(payload.probability)) ? Number(payload.probability) : null,
      strategyMode: payload.strategyMode != null ? String(payload.strategyMode) : null,
      reason: payload.reason != null ? String(payload.reason) : null,
      executionSource: payload.executionSource != null ? String(payload.executionSource) : null,
      executionBroker: payload.executionBroker != null ? String(payload.executionBroker) : null,
      executionMode: payload.executionMode != null ? String(payload.executionMode) : null,
      status: payload.status != null ? String(payload.status) as AcademyCase['status'] : null,
      outcome: payload.outcome != null ? String(payload.outcome) as AcademyCase['outcome'] : null,
      score: Number.isFinite(Number(payload.score)) ? Number(payload.score) : null,
      createdAtMs,
      executedAtMs,
      resolvedAtMs,
      durationMs,
      barsToOutcome: Number.isFinite(Number(payload.barsToOutcome)) ? Number(payload.barsToOutcome) : null,
      exitPrice: Number.isFinite(Number(payload.exitPrice)) ? Number(payload.exitPrice) : null,
      runId: payload.runId != null ? String(payload.runId) : null,
      ledgerId: payload.ledgerId != null ? String(payload.ledgerId) : null,
      orderId: payload.orderId != null ? String(payload.orderId) : null,
      positionId: payload.positionId != null ? String(payload.positionId) : null,
      brokerSnapshot: payload.brokerSnapshot && typeof payload.brokerSnapshot === 'object' ? payload.brokerSnapshot as Record<string, any> : null,
      snapshot: payload.snapshot && typeof payload.snapshot === 'object' ? payload.snapshot as AcademyCaseSnapshot : null,
      telemetry: Array.isArray(payload.telemetry) ? payload.telemetry as AcademyCaseEvent[] : [],
      analysis: payload.analysis && typeof payload.analysis === 'object' ? payload.analysis as Record<string, any> : null,
      decisionOutcome: payload.decisionOutcome != null
        ? String(payload.decisionOutcome) as AcademyCase['decisionOutcome']
        : (resolvedOutcomeEnvelope?.decisionOutcome ?? null),
      executionOutcome: payload.executionOutcome != null
        ? String(payload.executionOutcome) as AcademyCase['executionOutcome']
        : (resolvedOutcomeEnvelope?.executionOutcome ?? null),
      resolvedOutcomeEnvelope: resolvedOutcomeEnvelope ?? null,
      attribution: attribution ?? null,
      source: payload.source != null
        ? String(payload.source)
        : (memory.source != null ? String(memory.source) : null)
    };
  }, []);

  const normalizeAcademyLessonMemory = useCallback((memory: any): AcademyLesson | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const lessonId = String(payload.id || payload.lessonId || rawKey.replace(/^academy_lesson:/, '') || '').trim();
    const title = String(payload.title || memory.summary || '').trim();
    if (!lessonId || !title) return null;
    const appliesToRaw = payload.appliesTo && typeof payload.appliesTo === 'object' ? payload.appliesTo as Record<string, any> : null;
    const outcomeRaw = String(payload.outcome || '').trim().toUpperCase();
    const outcome =
      outcomeRaw === 'WIN' ||
      outcomeRaw === 'LOSS' ||
      outcomeRaw === 'EXPIRED' ||
      outcomeRaw === 'REJECTED' ||
      outcomeRaw === 'FAILED'
        ? outcomeRaw
        : null;
    const scoreRaw = payload.score ?? payload.rMultiple ?? payload.r ?? null;
    const score = Number.isFinite(Number(scoreRaw)) ? Number(scoreRaw) : null;
    return {
      id: lessonId,
      title,
      summary: payload.summary != null ? String(payload.summary) : null,
      appliesTo: appliesToRaw
        ? {
            symbol: appliesToRaw.symbol != null ? String(appliesToRaw.symbol) : null,
            session: appliesToRaw.session != null ? String(appliesToRaw.session) : null,
            strategyMode: appliesToRaw.strategyMode != null ? String(appliesToRaw.strategyMode) : null,
            timeframe: appliesToRaw.timeframe != null ? String(appliesToRaw.timeframe) : null,
            broker: appliesToRaw.broker != null ? String(appliesToRaw.broker) : null,
            executionMode: appliesToRaw.executionMode != null ? String(appliesToRaw.executionMode) : null
          }
        : null,
      triggerConditions: Array.isArray(payload.triggerConditions) ? payload.triggerConditions.map((c: any) => String(c)) : null,
      recommendedAction: payload.recommendedAction != null ? String(payload.recommendedAction) : null,
      confidence: Number.isFinite(Number(payload.confidence)) ? Number(payload.confidence) : null,
      evidenceCaseIds: Array.isArray(payload.evidenceCaseIds) ? payload.evidenceCaseIds.map((id: any) => String(id)) : null,
      agentId: payload.agentId != null ? String(payload.agentId) : null,
      agentName: payload.agentName != null ? String(payload.agentName) : null,
      outcome: outcome as AcademyLesson['outcome'],
      score,
      category: payload.category != null ? String(payload.category) : null,
      tags: Array.isArray(payload.tags) ? payload.tags.map((tag: any) => String(tag)) : null,
      createdAtMs: Number.isFinite(Number(payload.createdAtMs)) ? Number(payload.createdAtMs) : null,
      updatedAtMs: Number.isFinite(Number(payload.updatedAtMs)) ? Number(payload.updatedAtMs) : null,
      source: payload.source != null ? String(payload.source) : null
    };
  }, []);

  const normalizeAcademySymbolLearningMemory = useCallback((memory: any): AcademySymbolLearning | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const symbol = String(payload.symbol || memory.symbol || '').trim();
    if (!symbol) return null;
    const learningId = String(payload.id || payload.learningId || rawKey.replace(/^academy_symbol_learning:/, '') || symbol).trim();
    const winsRaw = Number(payload.wins);
    const lossesRaw = Number(payload.losses);
    const wins = Number.isFinite(winsRaw) ? Math.max(0, Math.floor(winsRaw)) : 0;
    const losses = Number.isFinite(lossesRaw) ? Math.max(0, Math.floor(lossesRaw)) : 0;
    const total = wins + losses;
    const winRateRaw = Number(payload.winRate);
    const avgScoreRaw = Number(payload.avgScore);
    let winRate = Number.isFinite(winRateRaw) ? winRateRaw : (total > 0 ? wins / total : null);
    if (winRate != null && winRate > 1) winRate = winRate / 100;
    const avgScore = Number.isFinite(avgScoreRaw) ? avgScoreRaw : null;
    const updatedAtMsRaw = Number(payload.updatedAtMs ?? memory.updatedAtMs);
    return {
      id: learningId || symbol,
      symbol,
      summary: payload.summary != null ? String(payload.summary) : null,
      wins,
      losses,
      winRate,
      avgScore,
      bestConditions: Array.isArray(payload.bestConditions) ? payload.bestConditions.map((c: any) => String(c)) : null,
      failurePatterns: Array.isArray(payload.failurePatterns) ? payload.failurePatterns.map((c: any) => String(c)) : null,
      recommendedAdjustments: Array.isArray(payload.recommendedAdjustments) ? payload.recommendedAdjustments.map((c: any) => String(c)) : null,
      evidenceCaseIds: Array.isArray(payload.evidenceCaseIds) ? payload.evidenceCaseIds.map((id: any) => String(id)) : null,
      updatedAtMs: Number.isFinite(updatedAtMsRaw) ? updatedAtMsRaw : null,
      source: payload.source != null
        ? String(payload.source)
        : (memory.source != null ? String(memory.source) : null)
    };
  }, []);

  const normalizeCalendarRuleMemory = useCallback((memory: any): CalendarRule | null => {
    if (!memory || typeof memory !== 'object') return null;
    const payload = memory.payload && typeof memory.payload === 'object' ? memory.payload as Record<string, any> : {};
    const rawKey = String(memory.key || memory.id || '').trim();
    const id = String(payload.id || rawKey.replace(/^calendar_rule:/, '') || '').trim();
    if (!id) return null;
    const days = Array.isArray(payload.daysOfWeek)
      ? payload.daysOfWeek.map((d: any) => Number(d)).filter((d: any) => Number.isFinite(d) && d >= 0 && d <= 6)
      : [];
    const typeRaw = String(payload.type || '').trim().toLowerCase();
    const type = typeRaw === 'blackout' ? 'blackout' : 'auto_window';
    return {
      id,
      title: String(payload.title || memory.summary || id).trim(),
      type,
      daysOfWeek: days.length > 0 ? days : [1, 2, 3, 4, 5],
      startTimeLocal: String(payload.startTimeLocal || '08:30'),
      endTimeLocal: String(payload.endTimeLocal || '11:30'),
      timezone: String(payload.timezone || 'UTC'),
      enabled: payload.enabled !== false,
      appliesTo: payload.appliesTo && typeof payload.appliesTo === 'object' ? payload.appliesTo : null,
      createdAtMs: Number.isFinite(Number(payload.createdAtMs)) ? Number(payload.createdAtMs) : null,
      updatedAtMs: Number.isFinite(Number(payload.updatedAtMs ?? memory.updatedAtMs)) ? Number(payload.updatedAtMs ?? memory.updatedAtMs) : null
    };
  }, []);

  const refreshCalendarRules = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Calendar rules unavailable.' };
    try {
      const res = await ledger.listAgentMemory({ limit: 500, kind: 'calendar_rule' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load calendar rules.' };
      }
      const entries = res.memories.map(normalizeCalendarRuleMemory).filter(Boolean) as CalendarRule[];
      entries.sort((a, b) => (Number(b.updatedAtMs || 0) - Number(a.updatedAtMs || 0)));
      setCalendarRules(entries);
      setCalendarRulesUpdatedAtMs(Date.now());
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load calendar rules.' };
    }
  }, [normalizeCalendarRuleMemory]);

  const upsertCalendarRule = useCallback(async (rule: CalendarRule) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return { ok: false as const, error: 'Calendar rules unavailable.' };
    const id = String(rule.id || '').trim();
    if (!id) return { ok: false as const, error: 'Rule id is required.' };
    const now = Date.now();
    const payload = {
      ...rule,
      createdAtMs: rule.createdAtMs ?? now,
      updatedAtMs: now
    };
    await ledger.upsertAgentMemory({
      key: `calendar_rule:${id}`,
      scope: 'global',
      category: 'calendar',
      subcategory: 'rule',
      kind: 'calendar_rule',
      summary: rule.title || id,
      payload,
      tags: ['calendar_rule', rule.type].filter(Boolean),
      source: 'calendar'
    });
    setCalendarRules((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.id === id);
      if (idx >= 0) next[idx] = { ...next[idx], ...payload };
      else next.unshift(payload as CalendarRule);
      return next;
    });
    setCalendarRulesUpdatedAtMs(Date.now());
    return { ok: true as const };
  }, []);

  const toggleCalendarRule = useCallback(async (id: string, enabled: boolean) => {
    const existing = calendarRulesRef.current.find((item) => item.id === id);
    if (!existing) return { ok: false as const, error: 'Rule not found.' };
    return upsertCalendarRule({ ...existing, enabled });
  }, [upsertCalendarRule]);

  useEffect(() => {
    void syncEconomicCalendar({ force: false, reason: 'boot' });
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadCalendarControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createCalendarController({
        intervalMs: 30 * 60 * 1000,
        backgroundIntervalMs: 90 * 60 * 1000,
        tick: async () => {
          await syncEconomicCalendar({ force: false, reason: 'poll' });
        }
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [syncEconomicCalendar]);

  const runCalendarBackfill = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory || !ledger?.upsertAgentMemory) {
      return { ok: false as const, error: 'Calendar storage unavailable.' };
    }
    if (calendarBackfillRef.current) return { ok: true as const, skipped: true };
    let alreadyRan = false;
    try {
      alreadyRan = localStorage.getItem(CALENDAR_BACKFILL_STORAGE_KEY) === '1';
    } catch {
      alreadyRan = false;
    }
    if (alreadyRan) return { ok: true as const, skipped: true };
    calendarBackfillRef.current = true;

    const limit = 2000;
    const [signalEntriesRes, signalHistoryRes, academyLessonRes, academyLearningRes] = await Promise.all([
      ledger.listAgentMemory({ limit, kind: 'signal_entry' }),
      ledger.listAgentMemory({ limit, kind: 'signal_history' }),
      ledger.listAgentMemory({ limit, kind: 'academy_lesson' }),
      ledger.listAgentMemory({ limit, kind: 'academy_symbol_learning' })
    ]);

    if (signalEntriesRes?.ok && Array.isArray(signalEntriesRes.memories)) {
      for (const memory of signalEntriesRes.memories) {
        const entry = normalizeSignalEntryMemory(memory);
        if (!entry) continue;
        if (entry.status !== 'PROPOSED' && entry.status !== 'SUBMITTING' && entry.status !== 'PENDING') continue;
        const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
        const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(Number(entry.probability))}%` : '';
        const summary = [entry.status || 'PROPOSED', entry.action, entry.symbol, tfLabel, probLabel].filter(Boolean).join(' ');
        void upsertCalendarEvent({
          id: entry.id,
          type: resolveCalendarSignalEventType(entry.status, null),
          title: summary,
          symbol: entry.symbol,
          timeframe: entry.timeframe ?? null,
          broker: entry.executionBroker ?? null,
          agentId: entry.agentId ?? null,
          startAtMs: entry.createdAtMs ?? memory.createdAtMs ?? memory.updatedAtMs ?? null,
          status: entry.status ?? null,
          signalId: entry.id,
          metadata: {
            executionSource: entry.executionSource ?? null,
            executionMode: entry.executionMode ?? null
          },
          source: 'signal_panel'
        });
      }
    }

    if (signalHistoryRes?.ok && Array.isArray(signalHistoryRes.memories)) {
      for (const memory of signalHistoryRes.memories) {
        const entry = normalizeSignalHistoryMemory(memory);
        if (!entry) continue;
        const outcome = entry.outcome || entry.status || 'EXECUTED';
        const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
        const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(Number(entry.probability))}%` : '';
        const scoreLabel = entry.score != null ? `${Number(entry.score).toFixed(2)}R` : '';
        const summary = [outcome, entry.action, entry.symbol, tfLabel, probLabel, scoreLabel].filter(Boolean).join(' ');
        const startAtMs = entry.executedAtMs ?? entry.createdAtMs ?? memory.createdAtMs ?? memory.updatedAtMs ?? null;
        const endAtMs =
          entry.resolvedAtMs ??
          (Number.isFinite(Number(entry.durationMs)) && Number.isFinite(Number(startAtMs))
            ? Number(startAtMs) + Number(entry.durationMs)
            : null);
        const durationMs =
          entry.durationMs != null
            ? entry.durationMs
            : (Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(endAtMs))
                ? Math.max(0, Number(endAtMs) - Number(startAtMs))
                : null);
        void upsertCalendarEvent({
          id: entry.signalId,
          type: resolveCalendarSignalEventType(String(entry.status || ''), entry.outcome || null),
          title: summary,
          symbol: entry.symbol,
          timeframe: entry.timeframe ?? null,
          broker: entry.executionBroker ?? null,
          agentId: entry.agentId ?? null,
          outcome: entry.outcome ?? null,
          rMultiple: entry.score ?? null,
          startAtMs,
          endAtMs,
          durationMs,
          status: entry.status ?? null,
          signalId: entry.signalId,
          metadata: {
            executionSource: entry.executionSource ?? null,
            executionMode: entry.executionMode ?? null
          },
          source: 'signal_panel'
        });
      }
    }

    if (academyLessonRes?.ok && Array.isArray(academyLessonRes.memories)) {
      for (const memory of academyLessonRes.memories) {
        const lesson = normalizeAcademyLessonMemory(memory);
        if (!lesson) continue;
        void upsertCalendarEvent({
          id: lesson.id,
          type: 'lesson_created',
          title: lesson.summary || lesson.title,
          symbol: lesson.appliesTo?.symbol || null,
          timeframe: lesson.appliesTo?.timeframe || null,
          agentId: lesson.agentId ?? null,
          startAtMs: lesson.createdAtMs ?? memory.createdAtMs ?? memory.updatedAtMs ?? null,
          status: 'created',
          lessonId: lesson.id,
          metadata: lesson.appliesTo ? { appliesTo: lesson.appliesTo } : null,
          source: lesson.source || 'academy'
        });
      }
    }

    if (academyLearningRes?.ok && Array.isArray(academyLearningRes.memories)) {
      for (const memory of academyLearningRes.memories) {
        const learning = normalizeAcademySymbolLearningMemory(memory);
        if (!learning) continue;
        void upsertCalendarEvent({
          id: learning.id,
          type: 'symbol_learning_updated',
          title: learning.summary || `${learning.symbol} learning`,
          symbol: learning.symbol,
          startAtMs: learning.updatedAtMs ?? memory.updatedAtMs ?? null,
          status: 'updated',
          metadata: {
            wins: learning.wins,
            losses: learning.losses,
            winRate: learning.winRate,
            avgScore: learning.avgScore
          },
          source: learning.source || 'academy_analyst'
        });
      }
    }

    try {
      localStorage.setItem(CALENDAR_BACKFILL_STORAGE_KEY, '1');
    } catch {
      // ignore storage failures
    }

    return { ok: true as const };
  }, [
    formatTimeframeLabel,
    normalizeAcademyLessonMemory,
    normalizeAcademySymbolLearningMemory,
    normalizeSignalEntryMemory,
    normalizeSignalHistoryMemory,
    resolveCalendarSignalEventType,
    upsertCalendarEvent
  ]);

  const formatAcademyLessonLine = useCallback((lesson: AcademyLesson) => {
    const scope = lesson.appliesTo || {};
    const tf = scope.timeframe ? formatTimeframeLabel(scope.timeframe) : '';
    const parts = [
      scope.symbol,
      tf,
      scope.session,
      scope.strategyMode,
      scope.broker,
      scope.executionMode
    ].filter(Boolean);
    const scopeLabel = parts.length > 0 ? parts.join(' ') : '';
    const conditions = Array.isArray(lesson.triggerConditions) && lesson.triggerConditions.length > 0
      ? lesson.triggerConditions.join('; ')
      : '';
    const action = lesson.recommendedAction ? String(lesson.recommendedAction) : '';
    const conf = Number.isFinite(Number(lesson.confidence)) ? `${Math.round(Number(lesson.confidence) * 100)}%` : '';
    const head = [lesson.title, scopeLabel ? `(${scopeLabel})` : '', conf ? `[${conf}]` : ''].filter(Boolean).join(' ');
    const tail = [conditions, action].filter(Boolean).join(' -> ');
    return tail ? `${head} - ${tail}` : head;
  }, [formatTimeframeLabel]);

  const buildAcademyLessonContextString = useCallback((entries: AcademyLesson[], limit: number) => {
    const list = Array.isArray(entries) ? entries : [];
    const capped = list.slice(0, Math.max(1, limit));
    if (capped.length === 0) return '';
    return ['ACADEMY LESSONS', ...capped.map(formatAcademyLessonLine)].join('\n');
  }, [formatAcademyLessonLine]);

  const buildAcademyLessonContextFor = useCallback((opts: {
    symbol?: string | null;
    timeframe?: string | null;
    strategyMode?: string | null;
    agentId?: string | null;
    agentName?: string | null;
    limit?: number;
  }) => {
    if (!academyAutoApplyEnabled) return '';
    const lessons = Array.isArray(academyLessonsRef.current) ? academyLessonsRef.current : [];
    if (lessons.length === 0) return '';
    const symbolKey = opts.symbol ? normalizeSymbolKey(opts.symbol) : '';
    const tfKey = opts.timeframe ? normalizeTimeframeKey(opts.timeframe) : '';
    const strategyKey = opts.strategyMode ? String(opts.strategyMode).trim().toLowerCase() : '';
    const agentId = opts.agentId ? String(opts.agentId).trim() : '';
    const agentName = opts.agentName ? String(opts.agentName).trim() : '';
    const casesById = new Map((academyCasesRef.current || []).map((entry) => [entry.id, entry]));
    const now = Date.now();
    const filtered = lessons.filter((lesson) => {
      if (!lesson) return false;
      const scope = lesson.appliesTo || {};
      if (symbolKey) {
        const lessonSymbolKey = scope.symbol ? normalizeSymbolKey(scope.symbol) : '';
        if (lessonSymbolKey && lessonSymbolKey !== symbolKey) return false;
      }
      if (tfKey) {
        const lessonTfKey = scope.timeframe ? normalizeTimeframeKey(scope.timeframe) : '';
        if (lessonTfKey && lessonTfKey !== tfKey) return false;
      }
      if (strategyKey) {
        const lessonStrategy = scope.strategyMode ? String(scope.strategyMode).trim().toLowerCase() : '';
        if (lessonStrategy && lessonStrategy !== strategyKey) return false;
      }
      if (agentId || agentName) {
        const lessonAgentId = lesson.agentId ? String(lesson.agentId).trim() : '';
        const lessonAgentName = lesson.agentName ? String(lesson.agentName).trim() : '';
        if (lessonAgentId || lessonAgentName) {
          if (agentId && lessonAgentId && lessonAgentId !== agentId) return false;
          if (agentName && lessonAgentName && lessonAgentName !== agentName) return false;
        } else {
          const evidence = Array.isArray(lesson.evidenceCaseIds) ? lesson.evidenceCaseIds : [];
          if (evidence.length === 0) return true;
          const matchesEvidence = evidence.some((id) => {
            const entry = casesById.get(id);
            if (!entry) return false;
            if (agentId && entry.agentId && String(entry.agentId) === agentId) return true;
            if (agentName && entry.agentName && String(entry.agentName) === agentName) return true;
            return false;
          });
          if (!matchesEvidence) return false;
        }
      }
      return true;
    });

    if (filtered.length === 0) return '';
    const scored = filtered.map((lesson) => {
      const updatedAt = Number(lesson.updatedAtMs || lesson.createdAtMs || 0);
      const ageMs = updatedAt > 0 ? Math.max(0, now - updatedAt) : 0;
      const recencyScore = updatedAt > 0 ? 1 / (1 + ageMs / (7 * 24 * 60 * 60_000)) : 0;
      const confidence = Number.isFinite(Number(lesson.confidence)) ? Number(lesson.confidence) : 0;
      return { lesson, score: confidence + recencyScore };
    });
    scored.sort((a, b) => b.score - a.score);
    const limit = Number.isFinite(Number(opts.limit)) ? Math.max(1, Math.min(20, Math.floor(Number(opts.limit)))) : academyLessonLimit;
    const capped = scored.slice(0, limit).map((entry) => entry.lesson);
    return ['ACADEMY LESSONS', ...capped.map(formatAcademyLessonLine)].join('\n');
  }, [
    academyAutoApplyEnabled,
    academyLessonLimit,
    formatAcademyLessonLine,
    normalizeSymbolKey,
    normalizeTimeframeKey
  ]);

  const buildAcademySymbolLearningContextFor = useCallback((symbol?: string | null) => {
    if (!academyAutoApplyEnabled) return '';
    const symbolKey = symbol ? normalizeSymbolKey(symbol) : '';
    if (!symbolKey) return '';
    const learnings = academySymbolLearningsRef.current || [];
    const match = learnings.find((entry) => normalizeSymbolKey(entry.symbol) === symbolKey);
    if (!match) return '';
    const winRate = match.winRate != null
      ? Math.round(match.winRate * 100)
      : (match.wins + match.losses > 0 ? Math.round((match.wins / (match.wins + match.losses)) * 100) : null);
    const lines = [
      `SYMBOL LEARNING ${match.symbol}`,
      `Wins ${match.wins} / Losses ${match.losses}${winRate != null ? ` | Win ${winRate}%` : ''}${match.avgScore != null ? ` | Avg ${match.avgScore.toFixed(2)}R` : ''}`
    ];
    if (match.bestConditions && match.bestConditions.length > 0) {
      lines.push(`Best: ${match.bestConditions.slice(0, 3).join(' | ')}`);
    }
    if (match.failurePatterns && match.failurePatterns.length > 0) {
      lines.push(`Failures: ${match.failurePatterns.slice(0, 3).join(' | ')}`);
    }
    if (match.recommendedAdjustments && match.recommendedAdjustments.length > 0) {
      lines.push(`Adjust: ${match.recommendedAdjustments.slice(0, 3).join(' | ')}`);
    }
    return lines.join('\n');
  }, [academyAutoApplyEnabled, normalizeSymbolKey]);

  const buildAgentAcademyOverlay = useCallback((agent: Agent) => {
    if (!agent) return '';
    const focus = agentFocusById.get(agent.id) || (agent.name ? agentFocusById.get(`name:${agent.name}`) : null);
    const symbol = focus?.symbol || null;
    const timeframe = focus?.timeframe || null;
    const strategy = focus?.strategyMode || null;
    const lessons = buildAcademyLessonContextFor({
      symbol,
      timeframe,
      strategyMode: strategy,
      agentId: agent.id,
      agentName: agent.name,
      limit: Math.max(3, Math.min(academyLessonLimit, 8))
    });
    const learning = buildAcademySymbolLearningContextFor(symbol);
    return [lessons, learning].filter(Boolean).join('\n\n');
  }, [
    academyLessonLimit,
    agentFocusById,
    buildAcademyLessonContextFor,
    buildAcademySymbolLearningContextFor
  ]);

  const applyAcademyUpdatesToAgents = useCallback(() => {
    if (!readAgentAcademyUpdatesEnabled()) return;
    const updater = updateAgentRef.current;
    if (!updater) return;
    const now = Date.now();
    if (now - (agentInstructionUpdateAtRef.current || 0) < 30_000) return;
    agentInstructionUpdateAtRef.current = now;
    const agentsNow = agentsRef.current || [];
    for (const agent of agentsNow) {
      if (!agent) continue;
      const base = agentBaseInstructionRef.current.get(agent.id) ?? agent.systemInstruction ?? '';
      const cleanBase = base.split(ACADEMY_AGENT_UPDATE_MARKER)[0].trim();
      const overlay = buildAgentAcademyOverlay(agent);
      if (!overlay) continue;
      const nextInstruction = [cleanBase, `${ACADEMY_AGENT_UPDATE_MARKER}${overlay}`].filter(Boolean).join('\n\n').trim();
      if (nextInstruction && nextInstruction !== agent.systemInstruction) {
        updater({ ...agent, systemInstruction: nextInstruction });
        agentBaseInstructionRef.current.set(agent.id, cleanBase);
        agentAcademyOverlayRef.current.set(agent.id, overlay);
      }
    }
  }, [buildAgentAcademyOverlay]);

  const isSignalPanelAcademyCase = useCallback((entry: AcademyCase | null | undefined) => {
    if (!entry) return false;
    const source = String(entry.source || '').trim().toLowerCase();
    if (source) return source === 'signal_panel';
    return !!entry.signalId;
  }, []);

  const refreshAcademyCases = useCallback(async (opts?: { force?: boolean; limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Academy memory unavailable.' };
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(50, Math.min(2000, Math.floor(Number(opts?.limit)))) : 500;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'academy_case' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load Academy cases.' };
      }
      const entries = res.memories.map(normalizeAcademyCaseMemory).filter(Boolean) as AcademyCase[];
      entries.sort((a, b) => {
        const aTime = a.resolvedAtMs ?? a.executedAtMs ?? a.createdAtMs ?? 0;
        const bTime = b.resolvedAtMs ?? b.executedAtMs ?? b.createdAtMs ?? 0;
        return bTime - aTime;
      });
      setAcademyCases(entries);
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load Academy cases.' };
    }
  }, [normalizeAcademyCaseMemory]);

  const refreshAcademyLessons = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Academy lessons unavailable.' };
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(10, Math.min(500, Math.floor(Number(opts?.limit)))) : 120;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'academy_lesson' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load Academy lessons.' };
      }
      const entries = res.memories.map(normalizeAcademyLessonMemory).filter(Boolean) as AcademyLesson[];
      entries.sort((a, b) => (Number(b.updatedAtMs || b.createdAtMs || 0) - Number(a.updatedAtMs || a.createdAtMs || 0)));
      setAcademyLessons(entries);
      setAcademyLessonsUpdatedAtMs(Date.now());
      academyLessonContextRef.current = buildAcademyLessonContextString(entries, academyLessonLimit);
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load Academy lessons.' };
    }
  }, [academyLessonLimit, buildAcademyLessonContextString, normalizeAcademyLessonMemory]);

  const refreshAcademySymbolLearnings = useCallback(async (opts?: { limit?: number }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return { ok: false as const, error: 'Academy symbol learning unavailable.' };
    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(20, Math.min(500, Math.floor(Number(opts?.limit)))) : 120;
    try {
      const res = await ledger.listAgentMemory({ limit, kind: 'academy_symbol_learning' });
      if (!res?.ok || !Array.isArray(res.memories)) {
        return { ok: false as const, error: res?.error ? String(res.error) : 'Failed to load Academy symbol learning.' };
      }
      const entries = res.memories.map(normalizeAcademySymbolLearningMemory).filter(Boolean) as AcademySymbolLearning[];
      entries.sort((a, b) => (Number(b.updatedAtMs || 0) - Number(a.updatedAtMs || 0)));
      setAcademySymbolLearnings(entries);
      setAcademySymbolLearningsUpdatedAtMs(Date.now());
      return { ok: true as const };
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Failed to load Academy symbol learning.' };
    }
  }, [normalizeAcademySymbolLearningMemory]);

  useEffect(() => {
    void runCalendarBackfill();
  }, [runCalendarBackfill]);

  useEffect(() => {
    void refreshCalendarRules();
  }, [refreshCalendarRules]);

  useEffect(() => {
    void refreshAcademyCases({ force: true });
    void refreshAcademyLessons();
    void refreshAcademySymbolLearnings();
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadAcademyControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createAcademyController({
        intervalMs: 30_000,
        tick: async () => {
          await Promise.all([
            refreshAcademyCases({ force: true }),
            refreshAcademyLessons(),
            refreshAcademySymbolLearnings()
          ]);
        }
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [refreshAcademyCases, refreshAcademyLessons, refreshAcademySymbolLearnings]);

  useEffect(() => {
    applyAcademyUpdatesToAgents();
  }, [academyLessons, academySymbolLearnings, signalHistory, applyAcademyUpdatesToAgents]);

  const buildAcademyExportPayload = useCallback(() => {
    return {
      exportedAt: new Date().toISOString(),
      caseCount: academyCasesRef.current.length,
      lessonCount: academyLessonsRef.current.length,
      symbolLearningCount: academySymbolLearningsRef.current.length,
      cases: academyCasesRef.current,
      lessons: academyLessonsRef.current,
      symbolLearnings: academySymbolLearningsRef.current
    };
  }, []);

  const persistAcademyExport = useCallback(async () => {
    const saver = window.glass?.saveUserFile;
    if (!saver) return { ok: false as const, error: 'File save unavailable.' };
    const payload = JSON.stringify(buildAcademyExportPayload(), null, 2);
    let encoded = '';
    try {
      encoded = btoa(unescape(encodeURIComponent(payload)));
    } catch {
      encoded = btoa(payload);
    }
    return saver({
      data: encoded,
      mimeType: 'application/json',
      subdir: 'academy',
      prefix: 'academy_export'
    });
  }, [buildAcademyExportPayload]);

  const scheduleAcademyExport = useCallback((opts?: { force?: boolean }) => {
    if (!academyAutoExportEnabled) return;
    const now = Date.now();
    const cooldownMs = 10_000;
    const notBefore = academyExportNotBeforeRef.current || 0;
    if (!opts?.force && now < notBefore) return;
    academyExportNotBeforeRef.current = now + cooldownMs;
    deferMs(() => {
      void persistAcademyExport();
    }, 250);
  }, [academyAutoExportEnabled, persistAcademyExport]);

  const upsertAcademyCase = useCallback(async (input: {
    entry: SignalEntry;
    patch?: Partial<AcademyCase>;
    snapshot?: AcademyCaseSnapshot | null;
    brokerSnapshot?: Record<string, any> | null;
    event?: { id?: string; type: string; atMs?: number; payload?: Record<string, any> | null };
    source?: string;
  }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const entry = input.entry;
    const caseId = String(entry.id || '').trim();
    if (!caseId) return;
    const key = `academy_case:${caseId}`;
    let prevPayload: any = null;

    if (ledger?.getAgentMemory) {
      try {
        const res = await ledger.getAgentMemory({ key });
        if (res?.ok && res.memory?.payload && typeof res.memory.payload === 'object') {
          prevPayload = res.memory.payload;
        }
      } catch {
        // ignore
      }
    } else {
      const existing = academyCasesRef.current.find((item) => item.id === caseId);
      if (existing) prevPayload = existing;
    }

    const now = Date.now();
    const patch = input.patch || {};
    const outcome = patch.outcome ?? resolveSignalOutcome(entry.status);
    const score = patch.score ?? (
      outcome === 'WIN' || outcome === 'LOSS'
        ? computeSignalOutcomeScore(entry, outcome)
        : null
    );
    const executedAtMs = patch.executedAtMs ?? entry.executedAtMs ?? prevPayload?.executedAtMs ?? null;
    const resolvedAtMs = patch.resolvedAtMs ?? entry.resolvedAtMs ?? prevPayload?.resolvedAtMs ?? null;
    const startAtMs = executedAtMs ?? entry.createdAtMs ?? prevPayload?.createdAtMs ?? null;
    const durationMs =
      patch.durationMs != null
        ? patch.durationMs
        : (Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(resolvedAtMs))
            ? Math.max(0, Number(resolvedAtMs) - Number(startAtMs))
            : null);
    const barsToOutcome = patch.barsToOutcome ?? prevPayload?.barsToOutcome ?? null;
    const resolvedOutcomeEnvelope = buildResolvedOutcomeEnvelope({
      signalId: caseId,
      status: patch.status ?? entry.status ?? null,
      outcome: outcome ?? null,
      createdAtMs: patch.createdAtMs ?? entry.createdAtMs ?? prevPayload?.createdAtMs ?? null,
      executedAtMs,
      resolvedAtMs,
      executionBroker: patch.executionBroker ?? entry.executionBroker ?? prevPayload?.executionBroker ?? null,
      executionMode: patch.executionMode ?? entry.executionMode ?? prevPayload?.executionMode ?? null
    });
    const attribution = buildSignalAttributionRecord({
      signalId: caseId,
      status: patch.status ?? entry.status ?? null,
      outcome: outcome ?? null,
      createdAtMs: patch.createdAtMs ?? entry.createdAtMs ?? prevPayload?.createdAtMs ?? null,
      executedAtMs,
      resolvedAtMs,
      executionBroker: patch.executionBroker ?? entry.executionBroker ?? prevPayload?.executionBroker ?? null,
      executionMode: patch.executionMode ?? entry.executionMode ?? prevPayload?.executionMode ?? null,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      exitPrice: Number.isFinite(Number(patch.exitPrice))
        ? Number(patch.exitPrice)
        : (Number.isFinite(Number(prevPayload?.exitPrice)) ? Number(prevPayload.exitPrice) : null),
      score
    });

    const snapshot =
      input.snapshot !== undefined
        ? input.snapshot
        : (prevPayload?.snapshot ? prevPayload.snapshot as AcademyCaseSnapshot : null);
    const brokerSnapshot =
      input.brokerSnapshot !== undefined
        ? input.brokerSnapshot
        : (prevPayload?.brokerSnapshot ? prevPayload.brokerSnapshot as Record<string, any> : null);

    const telemetry: AcademyCaseEvent[] = Array.isArray(prevPayload?.telemetry)
      ? [...prevPayload.telemetry]
      : [];
    const analysis = patch.analysis ?? (prevPayload?.analysis ? prevPayload.analysis : null);

    if (input.event && input.event.type) {
      const atMs = input.event.atMs != null ? input.event.atMs : now;
      const id = input.event.id ? String(input.event.id) : `${input.event.type}:${atMs}`;
      if (!telemetry.some((evt) => String(evt?.id || '') === id)) {
        telemetry.push({ id, type: input.event.type, atMs, payload: input.event.payload ?? null });
      }
    }

    const payload: AcademyCase = {
      id: caseId,
      signalId: entry.id,
      agentId: entry.agentId ?? null,
      agentName: entry.agentName ?? null,
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      action: entry.action,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      probability: entry.probability ?? null,
      strategyMode: entry.strategyMode ?? null,
      reason: entry.reason ?? null,
      executionSource: entry.executionSource ?? null,
      executionBroker: entry.executionBroker ?? null,
      executionMode: entry.executionMode ?? null,
      status: (patch.status ?? entry.status ?? null) as AcademyCase['status'],
      outcome: outcome ?? null,
      score,
      createdAtMs: patch.createdAtMs ?? entry.createdAtMs ?? prevPayload?.createdAtMs ?? null,
      executedAtMs,
      resolvedAtMs,
      durationMs,
      barsToOutcome,
      exitPrice: patch.exitPrice ?? prevPayload?.exitPrice ?? null,
      runId: entry.runId ?? null,
      ledgerId: patch.ledgerId ?? entry.executionLedgerId ?? prevPayload?.ledgerId ?? null,
      orderId: patch.orderId ?? entry.executionOrderId ?? prevPayload?.orderId ?? null,
      positionId: patch.positionId ?? entry.executionPositionId ?? prevPayload?.positionId ?? null,
      brokerSnapshot,
      snapshot,
      telemetry,
      analysis,
      decisionOutcome: resolvedOutcomeEnvelope?.decisionOutcome ?? null,
      executionOutcome: resolvedOutcomeEnvelope?.executionOutcome ?? null,
      resolvedOutcomeEnvelope: resolvedOutcomeEnvelope ?? null,
      attribution: attribution ?? null,
      source: input.source || 'academy'
    };

    const tfLabel = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
    const probLabel = Number.isFinite(Number(entry.probability)) ? `${Math.round(entry.probability)}%` : '';
    const scoreLabel = score != null ? `${score.toFixed(2)}R` : '';
    const summaryParts = [
      payload.outcome || payload.status || 'PROPOSED',
      payload.action,
      payload.symbol,
      tfLabel,
      probLabel,
      scoreLabel
    ].filter(Boolean);
    const summary = summaryParts.join(' ');

    const tags = [
      entry.symbol,
      entry.timeframe || '',
      entry.strategyMode ? `mode:${entry.strategyMode}` : '',
      entry.agentId ? `agent:${entry.agentId}` : '',
      payload.outcome ? `outcome:${String(payload.outcome).toLowerCase()}` : '',
      entry.executionSource ? `source:${entry.executionSource}` : '',
      entry.executionBroker ? `broker:${entry.executionBroker}` : '',
      entry.executionMode ? `exec:${entry.executionMode}` : '',
      resolvedOutcomeEnvelope?.decisionOutcome ? `decision:${String(resolvedOutcomeEnvelope.decisionOutcome).toLowerCase()}` : '',
      resolvedOutcomeEnvelope?.executionOutcome ? `execution:${String(resolvedOutcomeEnvelope.executionOutcome).toLowerCase()}` : ''
    ].filter(Boolean);

    const symbolKey = normalizeSymbolKey(entry.symbol);
    const tfKey = entry.timeframe ? normalizeTimeframeKey(entry.timeframe) : '';

    await ledger.upsertAgentMemory({
      key,
      familyKey: symbolKey ? `academy_case:${symbolKey}:${tfKey}` : undefined,
      agentId: entry.agentId ?? null,
      scope: 'shared',
      category: 'academy',
      subcategory: 'case',
      kind: 'academy_case',
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      summary,
      payload,
      tags,
      source: input.source || 'academy'
    });

    setAcademyCases((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.id === caseId);
      if (idx >= 0) next[idx] = { ...next[idx], ...payload };
      else next.unshift(payload);
      return next;
    });

    scheduleAcademyExport();
    return payload;
  }, [academyAutoExportEnabled, computeSignalOutcomeScore, formatTimeframeLabel, normalizeSymbolKey, normalizeTimeframeKey, resolveSignalOutcome, scheduleAcademyExport]);

  const upsertAcademyLesson = useCallback(async (lesson: AcademyLesson) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const id = String(lesson.id || '').trim();
    if (!id || !lesson.title) return;
    const key = `academy_lesson:${id}`;
    const now = Date.now();
    const payload = {
      ...lesson,
      updatedAtMs: lesson.updatedAtMs ?? now,
      createdAtMs: lesson.createdAtMs ?? now
    };
    const tags = [
      lesson.appliesTo?.symbol || '',
      lesson.appliesTo?.timeframe || '',
      lesson.appliesTo?.strategyMode ? `mode:${lesson.appliesTo.strategyMode}` : '',
      lesson.appliesTo?.session ? `session:${lesson.appliesTo.session}` : '',
      lesson.appliesTo?.broker ? `broker:${lesson.appliesTo.broker}` : '',
      lesson.appliesTo?.executionMode ? `exec:${lesson.appliesTo.executionMode}` : '',
      lesson.agentId ? `agent:${lesson.agentId}` : '',
      lesson.agentName ? `agent_name:${lesson.agentName}` : '',
      lesson.outcome ? `outcome:${String(lesson.outcome).toLowerCase()}` : '',
      lesson.category ? `category:${lesson.category}` : '',
      'academy_lesson'
    ].filter(Boolean);
    const extraTags = Array.isArray(lesson.tags)
      ? lesson.tags.map((tag) => String(tag)).filter(Boolean)
      : [];
    const mergedTags = extraTags.length > 0 ? Array.from(new Set([...tags, ...extraTags])) : tags;

    await ledger.upsertAgentMemory({
      key,
      agentId: lesson.agentId ?? null,
      scope: 'shared',
      category: 'academy',
      subcategory: 'lesson',
      kind: 'academy_lesson',
      symbol: lesson.appliesTo?.symbol || undefined,
      timeframe: lesson.appliesTo?.timeframe || undefined,
      summary: lesson.summary || lesson.title,
      payload,
      tags: mergedTags,
      source: lesson.source || 'academy'
    });

    void upsertCalendarEvent({
      id,
      type: 'lesson_created',
      title: lesson.summary || lesson.title,
      symbol: lesson.appliesTo?.symbol || null,
      timeframe: lesson.appliesTo?.timeframe || null,
      agentId: lesson.agentId ?? null,
      outcome: lesson.outcome ?? null,
      rMultiple: lesson.score ?? null,
      startAtMs: payload.createdAtMs ?? Date.now(),
      status: 'created',
      lessonId: id,
      metadata: lesson.appliesTo ? { appliesTo: lesson.appliesTo } : null,
      source: lesson.source || 'academy'
    });

    setAcademyLessons((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.id === id);
      if (idx >= 0) next[idx] = { ...next[idx], ...lesson, updatedAtMs: payload.updatedAtMs };
      else next.unshift({ ...lesson, updatedAtMs: payload.updatedAtMs });
      return next;
    });
    setAcademyLessonsUpdatedAtMs(Date.now());
    const nextLessons = [{ ...lesson, updatedAtMs: payload.updatedAtMs }, ...academyLessonsRef.current.filter((item) => item.id !== id)];
    academyLessonContextRef.current = buildAcademyLessonContextString(nextLessons, academyLessonLimit);

    scheduleAcademyExport();
  }, [academyLessonLimit, buildAcademyLessonContextString, scheduleAcademyExport, upsertCalendarEvent]);

  const upsertAcademySymbolLearning = useCallback(async (learning: AcademySymbolLearning) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const symbol = String(learning.symbol || '').trim();
    if (!symbol) return;
    const symbolKey = normalizeSymbolKey(symbol) || symbol.toLowerCase();
    const key = `academy_symbol_learning:${symbolKey}`;
    const now = Date.now();
    const winsRaw = Number(learning.wins);
    const lossesRaw = Number(learning.losses);
    const wins = Number.isFinite(winsRaw) ? Math.max(0, Math.floor(winsRaw)) : 0;
    const losses = Number.isFinite(lossesRaw) ? Math.max(0, Math.floor(lossesRaw)) : 0;
    const total = wins + losses;
    const winRateRaw = Number(learning.winRate);
    const avgScoreRaw = Number(learning.avgScore);
    let winRate = Number.isFinite(winRateRaw) ? winRateRaw : (total > 0 ? wins / total : null);
    if (winRate != null && winRate > 1) winRate = winRate / 100;
    const avgScore = Number.isFinite(avgScoreRaw) ? avgScoreRaw : null;
    const payload: AcademySymbolLearning = {
      ...learning,
      id: learning.id || `academy_symbol_${symbolKey}`,
      symbol,
      wins,
      losses,
      winRate,
      avgScore,
      updatedAtMs: learning.updatedAtMs ?? now
    };
    const summary = payload.summary || `${symbol} learning`;
    const tags = [symbol, 'academy_symbol_learning'].filter(Boolean);

    await ledger.upsertAgentMemory({
      key,
      scope: 'shared',
      category: 'academy',
      subcategory: 'symbol_learning',
      kind: 'academy_symbol_learning',
      symbol,
      summary,
      payload,
      tags,
      source: learning.source || 'academy_analyst'
    });

    void upsertCalendarEvent({
      id: symbolKey,
      type: 'symbol_learning_updated',
      title: summary,
      symbol,
      agentId: learning.agentId ?? null,
      startAtMs: payload.updatedAtMs ?? Date.now(),
      status: 'updated',
      metadata: {
        wins,
        losses,
        winRate,
        avgScore
      },
      source: learning.source || 'academy_analyst'
    });

    setAcademySymbolLearnings((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => normalizeSymbolKey(item.symbol) === symbolKey);
      if (idx >= 0) next[idx] = { ...next[idx], ...payload };
      else next.unshift(payload);
      return next;
    });
    setAcademySymbolLearningsUpdatedAtMs(Date.now());
    scheduleAcademyExport();
  }, [normalizeSymbolKey, scheduleAcademyExport, upsertCalendarEvent]);

  useEffect(() => {
    academyLessonContextRef.current = buildAcademyLessonContextString(
      academyLessonsRef.current,
      academyLessonLimit
    );
  }, [academyLessonLimit, buildAcademyLessonContextString]);

  const parseAcademyAnalystJson = useCallback((rawText: string) => {
    const text = String(rawText || '').trim();
    if (!text) return null;
    const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
    const candidate = fenceMatch ? fenceMatch[1] : text;
    try {
      return JSON.parse(candidate);
    } catch {
      const objMatch = candidate.match(/\{[\s\S]*\}/);
      if (objMatch) {
        try {
          return JSON.parse(objMatch[0]);
        } catch {
          return null;
        }
      }
    }
    return null;
  }, []);

  const buildAcademyCasePacket = useCallback((entry: AcademyCase) => {
    const snapshot = entry.snapshot || null;
    const snapshotPayload = snapshot?.payload || null;
    const framesRaw = Array.isArray(snapshotPayload?.frames)
      ? snapshotPayload.frames
      : Array.isArray(snapshot?.frames)
        ? snapshot.frames
        : [];
    const trimCandles = (candles: any[], limit: number) => {
      const list = Array.isArray(candles) ? candles : [];
      if (list.length <= limit) return list;
      return list.slice(list.length - limit);
    };
    const trimmedFrames = framesRaw.map((frame: any) => {
      const candles = Array.isArray(frame?.candles) ? frame.candles : [];
      return {
        tf: frame?.tf || frame?.timeframe,
        barsCount: frame?.barsCount ?? candles.length,
        lastUpdatedAtMs: frame?.lastUpdatedAtMs ?? null,
        candles: trimCandles(candles, 160)
      };
    });

    const comparables = academyCasesRef.current
      .filter((item) => item.id !== entry.id && item.symbol === entry.symbol)
      .slice(0, 4)
      .map((item) => ({
        id: item.id,
        outcome: item.outcome || item.status || null,
        score: item.score ?? null,
        strategyMode: item.strategyMode ?? null,
        timeframe: item.timeframe ?? null,
        reason: item.reason ?? null,
        createdAtMs: item.createdAtMs ?? null
      }));

    return {
      case: {
        id: entry.id,
        signalId: entry.signalId || entry.id,
        symbol: entry.symbol,
        timeframe: entry.timeframe ?? null,
        action: entry.action,
        entryPrice: entry.entryPrice,
        stopLoss: entry.stopLoss,
        takeProfit: entry.takeProfit,
        probability: entry.probability ?? null,
        strategyMode: entry.strategyMode ?? null,
        reason: entry.reason ?? null,
        status: entry.status ?? null,
        outcome: entry.outcome ?? null,
        score: entry.score ?? null,
        executionSource: entry.executionSource ?? null,
        executionBroker: entry.executionBroker ?? null,
        executionMode: entry.executionMode ?? null,
        source: entry.source ?? null,
        executedAtMs: entry.executedAtMs ?? null,
        resolvedAtMs: entry.resolvedAtMs ?? null,
        orderId: entry.orderId ?? null,
        positionId: entry.positionId ?? null
      },
      snapshot: snapshot
        ? {
            symbol: snapshot.symbol ?? entry.symbol,
            capturedAtMs: snapshot.capturedAtMs ?? null,
            reasonCode: snapshot.reasonCode ?? null,
            timeframes: snapshot.timeframes ?? null,
            frames: trimmedFrames,
            savedPath: snapshot.savedPath ?? null
          }
        : null,
      brokerSnapshot: entry.brokerSnapshot ?? null,
      telemetry: entry.telemetry ?? [],
      comparables
    };
  }, []);

  const buildAcademySymbolLearningPacket = useCallback((symbol: string, seedCase?: AcademyCase | null) => {
    const symbolKey = normalizeSymbolKey(symbol);
    if (!symbolKey) return null;
    const cases = academyCasesRef.current
      .filter((item) => item && normalizeSymbolKey(item.symbol) === symbolKey)
      .filter((item) => isSignalPanelAcademyCase(item))
      .filter((item) => item.outcome === 'WIN' || item.outcome === 'LOSS');
    if (seedCase && seedCase.id && normalizeSymbolKey(seedCase.symbol) === symbolKey) {
      if (isSignalPanelAcademyCase(seedCase) && (seedCase.outcome === 'WIN' || seedCase.outcome === 'LOSS')) {
        if (!cases.some((item) => item.id === seedCase.id)) cases.push(seedCase);
      }
    }
    cases.sort((a, b) => {
      const aTime = a.resolvedAtMs ?? a.executedAtMs ?? a.createdAtMs ?? 0;
      const bTime = b.resolvedAtMs ?? b.executedAtMs ?? b.createdAtMs ?? 0;
      return bTime - aTime;
    });

    const wins = cases.filter((item) => item.outcome === 'WIN').length;
    const losses = cases.filter((item) => item.outcome === 'LOSS').length;
    const total = wins + losses;
    const scored = cases.filter((item) => Number.isFinite(Number(item.score)));
    const avgScore = scored.length > 0
      ? scored.reduce((sum, item) => sum + Number(item.score || 0), 0) / scored.length
      : null;

    const recentCases = cases.slice(0, 14).map((item) => ({
      id: item.id,
      outcome: item.outcome || item.status || null,
      score: item.score ?? null,
      action: item.action,
      timeframe: item.timeframe ?? null,
      strategyMode: item.strategyMode ?? null,
      reason: item.reason ?? null,
      entryPrice: item.entryPrice,
      stopLoss: item.stopLoss,
      takeProfit: item.takeProfit,
      createdAtMs: item.createdAtMs ?? null,
      resolvedAtMs: item.resolvedAtMs ?? null
    }));

    return {
      symbol,
      stats: {
        wins,
        losses,
        total,
        winRate: total > 0 ? wins / total : null,
        avgScore
      },
      recentCases
    };
  }, [isSignalPanelAcademyCase, normalizeSymbolKey]);

  const runAcademyAnalyst = useCallback(async (entry: AcademyCase) => {
    if (!entry || !entry.id) return;
    const outcome = entry.outcome || entry.status || null;
    if (outcome !== 'WIN' && outcome !== 'LOSS') return;
    if (!isSignalPanelAcademyCase(entry)) return;
    const inFlight = academyAnalystInFlightRef.current;
    if (inFlight.has(entry.id)) return;
    inFlight.add(entry.id);

    const systemInstruction = [
      'You are Academy Analyst, a forensic trading performance analyst.',
      'Analyze completed signal-panel trades to extract durable lessons and symbol-level learning.',
      'Respond in JSON only with keys: caseReport, lessons, symbolLearning.',
      'caseReport should include: summary, rootCause, failureModeTag, keyConditions, improvement.',
      'lessons is an array of rule objects with: title, appliesTo, triggerConditions, recommendedAction, confidence (0-1), evidenceCaseIds.',
      'symbolLearning should include: symbol, summary, wins, losses, winRate, avgScore, bestConditions, failurePatterns, recommendedAdjustments, evidenceCaseIds.',
      'Only use wins/losses from the signal panel when forming symbolLearning.'
    ].join('\n');

    try {
      const packet = buildAcademyCasePacket(entry);
      const symbolPacket = buildAcademySymbolLearningPacket(entry.symbol, entry);
      if (!symbolPacket) return;
      const prompt = `Analyze this Academy case and symbol packet and return JSON only.\n\nCASE_PACKET_JSON:\n${JSON.stringify(packet, null, 2)}\n\nSYMBOL_PACKET_JSON:\n${JSON.stringify(symbolPacket, null, 2)}`;
      const analystAgent: Agent = {
        id: 'academy-analyst',
        name: 'Academy Analyst',
        color: 'bg-amber-500',
        type: 'openai',
        profile: 'academy',
        systemInstruction: 'Forensic analyst focused on outcome-based learning.'
      };
      const res = await sendMessageToOpenAI(
        [],
        prompt,
        systemInstruction,
        null,
        agentsRef.current || [],
        [],
        [],
        { agent: analystAgent, reasoningEffort: 'medium' }
      );
      const parsed = parseAcademyAnalystJson(res?.text || '');
      if (!parsed || typeof parsed !== 'object') return;
      const caseReport = parsed.caseReport || parsed.analysis || null;
      const lessonsRaw = Array.isArray(parsed.lessons)
        ? parsed.lessons
        : Array.isArray(parsed.lessonObjects)
          ? parsed.lessonObjects
          : [];
      const symbolLearningRaw = parsed.symbolLearning || parsed.symbolReport || null;

      if (caseReport) {
        void upsertAcademyCase({
          entry,
          patch: { analysis: { report: caseReport, generatedAtMs: Date.now() } },
          event: { type: 'academy_report', payload: { caseId: entry.id } },
          source: 'academy_analyst'
        });
      }

      for (const raw of lessonsRaw) {
        if (!raw || typeof raw !== 'object') continue;
        const title = String(raw.title || raw.name || '').trim();
        if (!title) continue;
        const lessonId = String(raw.id || `lesson_${hashStringSampled([entry.id, title].join('|'))}`);
        const appliesToRaw = raw.appliesTo && typeof raw.appliesTo === 'object' ? raw.appliesTo as Record<string, any> : {};
        const appliesTo = {
          symbol: appliesToRaw.symbol ?? entry.symbol ?? null,
          timeframe: appliesToRaw.timeframe ?? entry.timeframe ?? null,
          strategyMode: appliesToRaw.strategyMode ?? entry.strategyMode ?? null,
          session: appliesToRaw.session ?? null,
          broker: appliesToRaw.broker ?? entry.executionBroker ?? null,
          executionMode: appliesToRaw.executionMode ?? entry.executionMode ?? null
        };
        const resolvedOutcome =
          entry.outcome ??
          (entry.status === 'WIN' ||
          entry.status === 'LOSS' ||
          entry.status === 'EXPIRED' ||
          entry.status === 'REJECTED' ||
          entry.status === 'FAILED'
            ? entry.status
            : null);
        const lesson: AcademyLesson = {
          id: lessonId,
          title,
          summary: raw.summary != null ? String(raw.summary) : null,
          appliesTo,
          triggerConditions: Array.isArray(raw.triggerConditions) ? raw.triggerConditions.map((c: any) => String(c)) : null,
          recommendedAction: raw.recommendedAction != null ? String(raw.recommendedAction) : null,
          confidence: Number.isFinite(Number(raw.confidence)) ? Number(raw.confidence) : null,
          evidenceCaseIds: Array.isArray(raw.evidenceCaseIds)
            ? raw.evidenceCaseIds.map((id: any) => String(id))
            : [entry.id],
          agentId: entry.agentId ?? null,
          agentName: entry.agentName ?? null,
          outcome: resolvedOutcome,
          score: entry.score ?? null,
          category: raw.category != null ? String(raw.category) : null,
          tags: Array.isArray(raw.tags) ? raw.tags.map((tag: any) => String(tag)) : null,
          source: 'academy_analyst',
          createdAtMs: Date.now(),
          updatedAtMs: Date.now()
        };
        void upsertAcademyLesson(lesson);
      }

      if (symbolLearningRaw && typeof symbolLearningRaw === 'object') {
        const winsRaw = Number(symbolLearningRaw.wins);
        const lossesRaw = Number(symbolLearningRaw.losses);
        const wins = Number.isFinite(winsRaw) ? Math.max(0, Math.floor(winsRaw)) : symbolPacket.stats.wins;
        const losses = Number.isFinite(lossesRaw) ? Math.max(0, Math.floor(lossesRaw)) : symbolPacket.stats.losses;
        const total = wins + losses;
        const winRateRaw = Number(symbolLearningRaw.winRate);
        const avgScoreRaw = Number(symbolLearningRaw.avgScore);
        let winRate = Number.isFinite(winRateRaw)
          ? winRateRaw
          : (total > 0 ? wins / total : symbolPacket.stats.winRate ?? null);
        if (winRate != null && winRate > 1) winRate = winRate / 100;
        const avgScore = Number.isFinite(avgScoreRaw) ? avgScoreRaw : symbolPacket.stats.avgScore ?? null;
        const summaryText = String(symbolLearningRaw.summary || symbolLearningRaw.insight || '').trim();
        const symbolLearning: AcademySymbolLearning = {
          id: `academy_symbol_${normalizeSymbolKey(entry.symbol) || entry.symbol}`,
          symbol: entry.symbol,
          summary: summaryText || null,
          wins,
          losses,
          winRate,
          avgScore,
          bestConditions: Array.isArray(symbolLearningRaw.bestConditions)
            ? symbolLearningRaw.bestConditions.map((item: any) => String(item))
            : null,
          failurePatterns: Array.isArray(symbolLearningRaw.failurePatterns)
            ? symbolLearningRaw.failurePatterns.map((item: any) => String(item))
            : null,
          recommendedAdjustments: Array.isArray(symbolLearningRaw.recommendedAdjustments)
            ? symbolLearningRaw.recommendedAdjustments.map((item: any) => String(item))
            : null,
          evidenceCaseIds: Array.isArray(symbolLearningRaw.evidenceCaseIds)
            ? symbolLearningRaw.evidenceCaseIds.map((id: any) => String(id))
            : symbolPacket.recentCases.map((item) => item.id).slice(0, 8),
          updatedAtMs: Date.now(),
          source: 'academy_analyst'
        };
        void upsertAcademySymbolLearning(symbolLearning);
      } else if (symbolPacket.stats.total > 0) {
        const fallbackLearning: AcademySymbolLearning = {
          id: `academy_symbol_${normalizeSymbolKey(entry.symbol) || entry.symbol}`,
          symbol: entry.symbol,
          summary: null,
          wins: symbolPacket.stats.wins,
          losses: symbolPacket.stats.losses,
          winRate: symbolPacket.stats.winRate ?? null,
          avgScore: symbolPacket.stats.avgScore ?? null,
          bestConditions: null,
          failurePatterns: null,
          recommendedAdjustments: null,
          evidenceCaseIds: symbolPacket.recentCases.map((item) => item.id).slice(0, 8),
          updatedAtMs: Date.now(),
          source: 'academy_analyst'
        };
        void upsertAcademySymbolLearning(fallbackLearning);
      }
    } catch {
      // ignore analyst failures
    } finally {
      inFlight.delete(entry.id);
    }
  }, [
    buildAcademyCasePacket,
    buildAcademySymbolLearningPacket,
    isSignalPanelAcademyCase,
    parseAcademyAnalystJson,
    upsertAcademyCase,
    upsertAcademyLesson,
    upsertAcademySymbolLearning
  ]);

  const maybeAutoAcceptAcademyCase = useCallback((entry?: AcademyCase | null) => {
    if (!entry || !entry.id) return;
    if (!academyAutoApplyEnabled) return;
    if (!isSignalPanelAcademyCase(entry)) return;
    const outcome = entry.outcome || entry.status || null;
    if (outcome !== 'WIN' && outcome !== 'LOSS') return;
    const key = String(entry.id);
    if (academyAutoAcceptRef.current.has(key)) return;
    academyAutoAcceptRef.current.add(key);
    void upsertCalendarEvent({
      id: entry.id,
      type: 'lesson_auto_accept',
      title: `Lesson auto-accepted: ${entry.symbol} ${entry.timeframe || ''}`.trim(),
      symbol: entry.symbol,
      timeframe: entry.timeframe ?? null,
      agentId: entry.agentId ?? null,
      outcome,
      rMultiple: entry.score ?? null,
      startAtMs: Date.now(),
      status: 'accepted',
      signalId: entry.signalId ?? entry.id,
      caseId: entry.id,
      metadata: {
        source: entry.source || 'academy',
        strategyMode: entry.strategyMode ?? null
      },
      source: 'academy'
    });
    void runAcademyAnalyst(entry);
  }, [academyAutoApplyEnabled, isSignalPanelAcademyCase, runAcademyAnalyst, upsertCalendarEvent]);

  const buildSignalEntryId = useCallback((input: {
    symbol: string;
    timeframe: string;
    action: string;
    entry: number;
    stop: number;
    target: number;
    strategyMode?: string | null;
  }) => {
    const seed = [
      input.symbol,
      input.timeframe,
      input.action,
      input.entry,
      input.stop,
      input.target,
      input.strategyMode || ''
    ].join('|');
    return `signal_${hashStringSampled(seed)}`;
  }, []);

  const buildTradeProposalFromSignal = useCallback((entry: SignalEntry, agentId?: string | null) => {
    return {
      symbol: entry.symbol,
      action: entry.action,
      entryPrice: entry.entryPrice,
      stopLoss: entry.stopLoss,
      takeProfit: entry.takeProfit,
      expiresAtMs: entry.expiresAtMs ?? null,
      status: 'PENDING',
      agentId: agentId || entry.agentId || undefined,
      reason: entry.reason || 'Signal panel proposal',
      setup: {
        signalId: entry.id,
        signalType: 'signal_panel',
        timeframe: entry.timeframe || undefined,
        mode: entry.strategyMode || undefined,
        source: 'signal_panel'
      }
    };
  }, []);

  const buildSignalTicketPayload = useCallback(async (entry: SignalEntry, targetBroker: BrokerId) => {
    const symbolRaw = String(entry?.symbol || '').trim();
    if (!symbolRaw) return null;
    const linkCfg = brokerLinkConfigRef.current;
    const master = linkCfg?.masterBroker === 'tradelocker' ? 'tradelocker' : 'mt5';
    const sourceBroker: BrokerId = master;

    const mt5Adapter = createMt5Adapter();
    const tradeLockerAdapter = createTradeLockerAdapter({
      api: (window as any)?.glass?.tradelocker,
      resolveSymbol: resolveTradeLockerSymbolBestEffort
    });

    const sourceAdapter = sourceBroker === 'mt5' ? mt5Adapter : tradeLockerAdapter;
    const targetAdapter = targetBroker === 'mt5' ? mt5Adapter : tradeLockerAdapter;

    const sourceSymbol = await resolveBrokerSymbol({
      symbol: symbolRaw,
      brokerId: sourceBroker,
      config: linkCfg,
      adapter: sourceAdapter
    });
    const targetSymbol = await resolveBrokerSymbol({
      symbol: symbolRaw,
      brokerId: targetBroker,
      config: linkCfg,
      adapter: targetAdapter
    });

    const fetchQuoteForBroker = async (broker: BrokerId, symbol: string) => {
      if (!symbol) return null;
      if (broker === 'mt5') return fetchMt5Quote(symbol);
      let quote = getBrokerQuoteForSymbol(symbol);
      if (!quote) {
        const res = await fetchBrokerQuoteForSymbol(symbol, { maxAgeMs: 0 });
        quote = res.quote || null;
      }
      return quote;
    };

    const [sourceQuote, targetQuote] = await Promise.all([
      fetchQuoteForBroker(sourceBroker, sourceSymbol),
      fetchQuoteForBroker(targetBroker, targetSymbol)
    ]);

    const entryPrice = Number(entry?.entryPrice);
    const stopLoss = Number(entry?.stopLoss);
    const takeProfit = Number(entry?.takeProfit);
    const hasEntry = Number.isFinite(entryPrice);
    const hasStop = Number.isFinite(stopLoss);
    const hasTake = Number.isFinite(takeProfit);

    let adjustedEntry = hasEntry ? entryPrice : null;
    let adjustedStop = hasStop ? stopLoss : null;
    let adjustedTake = hasTake ? takeProfit : null;

    if (sourceBroker !== targetBroker && hasEntry) {
      const mode = linkCfg?.priceAdjustMode || 'pip';
      adjustedEntry = applyPriceAdjustment({ price: entryPrice, sourceQuote, targetQuote, mode });
      if (hasStop) adjustedStop = applyPriceAdjustment({ price: stopLoss, sourceQuote, targetQuote, mode });
      if (hasTake) adjustedTake = applyPriceAdjustment({ price: takeProfit, sourceQuote, targetQuote, mode });
    }

    const side = entry?.action === 'SELL' ? 'SELL' : 'BUY';
    const refPrice = getBrokerReferencePriceFromQuote(targetQuote);
    let orderType: 'market' | 'limit' | 'stop' = 'limit';
    if (Number.isFinite(Number(adjustedEntry)) && Number.isFinite(Number(refPrice))) {
      const entryNum = Number(adjustedEntry);
      const refNum = Number(refPrice);
      orderType = side === 'BUY'
        ? (entryNum > refNum ? 'stop' : 'limit')
        : (entryNum < refNum ? 'stop' : 'limit');
    }

    return {
      symbol: targetSymbol,
      side,
      type: orderType,
      entryPrice: adjustedEntry,
      stopLoss: adjustedStop,
      takeProfit: adjustedTake
    };
  }, [fetchBrokerQuoteForSymbol, getBrokerQuoteForSymbol, getBrokerReferencePriceFromQuote, resolveTradeLockerSymbolBestEffort]);

  const buildLiveTradeProposalFromSignal = useCallback(async (entry: SignalEntry, targetBroker: BrokerId) => {
    const payload = await buildSignalTicketPayload(entry, targetBroker);
    const base = buildTradeProposalFromSignal(entry, entry.agentId || null);
    if (!payload) return base;
    const symbol = String(payload.symbol || base.symbol || '').trim();
    const entryPrice = Number.isFinite(Number(payload.entryPrice)) ? Number(payload.entryPrice) : base.entryPrice;
    const stopLoss = Number.isFinite(Number(payload.stopLoss)) ? Number(payload.stopLoss) : base.stopLoss;
    const takeProfit = Number.isFinite(Number(payload.takeProfit)) ? Number(payload.takeProfit) : base.takeProfit;
    return {
      ...base,
      symbol: symbol || base.symbol,
      entryPrice,
      stopLoss,
      takeProfit
    };
  }, [buildSignalTicketPayload, buildTradeProposalFromSignal]);

  const prefillSignalTicket = useCallback(async (entry: SignalEntry, targetBroker: BrokerId) => {
    const payload = await buildSignalTicketPayload(entry, targetBroker);
    const symbol = String(payload?.symbol || entry?.symbol || '').trim();
    if (!symbol) return;
    const openPanel = openSymbolPanelRef.current;
    if (openPanel) {
      openPanel(targetBroker, symbol, entry?.timeframe || null);
    }

    const detail: Record<string, any> = {
      symbol,
      side: payload?.side || (entry?.action === 'SELL' ? 'SELL' : 'BUY'),
      type: payload?.type || 'limit',
      open: true
    };
    if (payload?.entryPrice != null && Number.isFinite(Number(payload.entryPrice))) {
      detail.price = Number(payload.entryPrice);
    } else if (Number.isFinite(Number(entry?.entryPrice))) {
      detail.price = Number(entry?.entryPrice);
    }
    if (payload?.stopLoss != null && Number.isFinite(Number(payload.stopLoss))) {
      detail.stopLoss = Number(payload.stopLoss);
    } else if (Number.isFinite(Number(entry?.stopLoss))) {
      detail.stopLoss = Number(entry?.stopLoss);
    }
    if (payload?.takeProfit != null && Number.isFinite(Number(payload.takeProfit))) {
      detail.takeProfit = Number(payload.takeProfit);
    } else if (Number.isFinite(Number(entry?.takeProfit))) {
      detail.takeProfit = Number(entry?.takeProfit);
    }

    const eventName = targetBroker === 'mt5' ? GLASS_EVENT.MT5_TICKET : GLASS_EVENT.TRADELOCKER_TICKET;
    deferMs(() => {
      window.dispatchEvent(new CustomEvent(eventName, { detail }));
    }, 120);
  }, [buildSignalTicketPayload]);

  const executeSignalTrade = useCallback(async (
    entryId: string,
    source: 'manual' | 'autopilot',
    entryOverride?: SignalEntry | null,
    opts?: {
      forceBroker?: BrokerId | null;
      executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
      proposalOverride?: TradeProposal | null;
      autoConfigOverride?: Record<string, any> | null;
    }
  ) => {
    const inFlight = signalExecutionInFlightRef.current;
    if (inFlight.has(entryId)) return;
    inFlight.add(entryId);
    let entry: SignalEntry | null = entryOverride || null;
    setSignalEntries((prev) => {
      let found = false;
      const next = prev.map((item) => {
        if (item.id !== entryId) return item;
        entry = item;
        found = true;
        if (item.status !== 'PROPOSED') return item;
        return { ...item, status: 'SUBMITTING', executionSource: source };
      });
      if (!found && entryOverride) {
        return [{ ...entryOverride, status: 'SUBMITTING', executionSource: source }, ...next];
      }
      return next;
    });
    if (!entry || entry.status !== 'PROPOSED') {
      inFlight.delete(entryId);
      return;
    }
    const proposal = opts?.proposalOverride || entry.tradeProposal || buildTradeProposalFromSignal(entry);
    const validation = validateTradeProposalBasic(proposal);
    if (!validation.ok) {
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId
            ? { ...item, status: 'FAILED', executionError: validation.error || 'Invalid trade proposal.' }
            : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: { signalId: entryId, error: validation.error || 'Invalid trade proposal.' }
      });
      void upsertAcademyCase({
        entry: { ...entry, status: 'FAILED', executionError: validation.error || 'Invalid trade proposal.' },
        patch: { status: 'FAILED' },
        event: { type: 'signal_execute_failed', payload: { signalId: entryId, error: validation.error || 'Invalid trade proposal.' } },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }
    const targetBroker: BrokerId = opts?.forceBroker
      ? (String(opts.forceBroker).toLowerCase() === 'mt5' ? 'mt5' : String(opts.forceBroker).toLowerCase() === 'sim' ? 'sim' : 'tradelocker')
      : signalExecutionTarget !== 'auto'
        ? signalExecutionTarget
        : 'tradelocker';
    const quantStartedAt = Date.now();
    const mergedAutoCfg = opts?.autoConfigOverride
      ? { ...(autoPilotConfigRef.current || {}), ...opts.autoConfigOverride }
      : (autoPilotConfigRef.current || {});
    const quantModes = {
      regime: resolveQuantGateMode(mergedAutoCfg, 'regime'),
      ensemble: resolveQuantGateMode(mergedAutoCfg, 'ensemble'),
      metaLabel: resolveQuantGateMode(mergedAutoCfg, 'metaLabel'),
      portfolioRisk: resolveQuantGateMode(mergedAutoCfg, 'portfolioRisk')
    };
    const quantWarn: string[] = [];
    const quantBlock: string[] = [];
    const modeBlocks = (mode: QuantGateMode) => mode === 'soft_block' || mode === 'hard_block';
    let regimeState: ReturnType<typeof getCachedRegimeState> | null = null;
    let ensembleDecision: ReturnType<typeof scoreEnsemble> | null = null;
    let metaLabelDecision: ReturnType<typeof evaluateMetaLabel> | null = null;
    let portfolioDecision: ReturnType<typeof evaluatePortfolioRisk> | null = null;
    try {
      const symbol = String(proposal?.symbol || entry.symbol || '').trim().toUpperCase();
      const timeframe = normalizeTimeframeKey(entry.timeframe || proposal?.setup?.timeframe || '15m') || '15m';
      const snapshots = chartEngine.getSnapshots({ barsLimit: 220, eventsLimit: 0, includeInactive: true });
      const chartSnapshot = (snapshots || []).find((item: any) => {
        const itemSymbol = String(item?.symbol || '').trim().toUpperCase();
        const itemTf = normalizeTimeframeKey(String(item?.timeframe || '')) || '';
        return itemSymbol === symbol && itemTf === timeframe;
      });
      const bars = Array.isArray(chartSnapshot?.barsTail) ? chartSnapshot.barsTail : [];
      regimeState = getCachedRegimeState({
        symbol,
        timeframe,
        bars,
        newsRiskScore: entry.newsSnapshot?.impactScore != null ? Number(entry.newsSnapshot.impactScore) / 100 : null,
        ttlMs: 20_000
      });
      if (regimeState && (regimeState.newsRisk || regimeState.highVol)) {
        const reason = `regime_risk:${regimeState.label}`;
        if (modeBlocks(quantModes.regime)) quantBlock.push(reason);
        else if (quantModes.regime === 'warn') quantWarn.push(reason);
      }

      const agentKey = String(entry.agentId || '').trim();
      const perf = agentKey
        ? agentPerformanceById.get(agentKey) || (entry.agentName ? agentPerformanceById.get(`name:${entry.agentName}`) : null)
        : null;
      ensembleDecision = scoreEnsemble({
        candidates: [
          {
            signalId: entry.id,
            agentId: entry.agentId || null,
            symbol,
            timeframe,
            recencyWinRate: perf?.winRate ?? null,
            specializationFit: perf?.trades && perf.trades >= 20 ? Math.min(1, perf.trades / 80) : 0.25,
            regimeFit: regimeState?.trend ? 0.65 : 0.55,
            driftPenalty: (agentDriftReportsRef.current || []).some((row) => row.agentId === agentKey && row.severity === 'poor')
              ? 0.6
              : (agentDriftReportsRef.current || []).some((row) => row.agentId === agentKey && row.severity === 'warn')
                ? 0.3
                : 0
          }
        ],
        minimumScore: 0.52
      });
      if (ensembleDecision.action === 'skip') {
        const reason = `ensemble_skip:${ensembleDecision.score.toFixed(3)}`;
        if (modeBlocks(quantModes.ensemble)) quantBlock.push(reason);
        else if (quantModes.ensemble === 'warn') quantWarn.push(reason);
      }

      metaLabelDecision = evaluateMetaLabel({
        signalId: entry.id,
        ensembleScore: ensembleDecision.score,
        driftSeverity: (agentDriftReportsRef.current || []).find((row) => row.agentId === agentKey && row.severity !== 'ok')?.severity || 'ok',
        regimeLabel: regimeState?.label || null
      });
      if (metaLabelDecision.decision === 'skip') {
        const reason = `meta_skip:${metaLabelDecision.confidence.toFixed(3)}`;
        if (modeBlocks(quantModes.metaLabel)) quantBlock.push(reason);
        else if (quantModes.metaLabel === 'warn') quantWarn.push(reason);
      }

      const riskPerTrade = Number(mergedAutoCfg?.riskPerTrade);
      const candidateRiskPct = Number.isFinite(riskPerTrade) && riskPerTrade > 0 ? riskPerTrade : 1;
      const openPositions = (signalEntriesRef.current || [])
        .filter((item) => item && (item.status === 'PENDING' || item.status === 'EXECUTED' || item.status === 'SUBMITTING'))
        .map((item) => ({
          symbol: String(item.symbol || ''),
          riskPct: candidateRiskPct,
          status: item.status
        }));
      portfolioDecision = evaluatePortfolioRisk({
        candidateSymbol: symbol || String(entry.symbol || ''),
        candidateRiskPct,
        openPositions,
        maxCorrelatedExposurePct: Number(mergedAutoCfg?.maxCorrelatedExposurePct || 3.5),
        maxSymbolFamilyOverlap: Number(mergedAutoCfg?.maxSymbolFamilyOverlap || 2),
        maxConcurrentRiskPct: Number(mergedAutoCfg?.maxConcurrentRiskPct || Math.max(3, candidateRiskPct * 3))
      });
      if (!portfolioDecision.allowed) {
        const reason = `portfolio_block:${portfolioDecision.reasons.join(',') || 'policy'}`;
        if (modeBlocks(quantModes.portfolioRisk)) quantBlock.push(reason);
        else if (quantModes.portfolioRisk === 'warn') quantWarn.push(reason);
      }
    } catch (err: any) {
      quantWarn.push(err?.message ? `quant_error:${String(err.message)}` : 'quant_error');
    }
    const quantElapsedMs = Date.now() - quantStartedAt;
    if (quantElapsedMs > PRE_TRADE_QUANT_LATENCY_BUDGET_MS) {
      quantWarn.push(`quant_latency_budget_exceeded:${quantElapsedMs}ms`);
      const hasBlockingMode = modeBlocks(quantModes.regime) || modeBlocks(quantModes.ensemble) || modeBlocks(quantModes.metaLabel) || modeBlocks(quantModes.portfolioRisk);
      if (hasBlockingMode) {
        quantBlock.push('quant_latency_timeout');
      }
    }
    const quantTelemetry: SignalEntry['quantTelemetry'] = {
      status: quantBlock.length > 0 ? 'block' : quantWarn.length > 0 ? 'warn' : 'pass',
      evaluatedAtMs: Date.now(),
      elapsedMs: quantElapsedMs,
      regimeLabel: regimeState?.label || null,
      regimeNewsRisk: regimeState?.newsRisk === true,
      regimeHighVol: regimeState?.highVol === true,
      ensembleAction: ensembleDecision?.action || null,
      ensembleScore: Number.isFinite(Number(ensembleDecision?.score)) ? Number(ensembleDecision?.score) : null,
      metaDecision: metaLabelDecision?.decision || null,
      metaConfidence: Number.isFinite(Number(metaLabelDecision?.confidence)) ? Number(metaLabelDecision?.confidence) : null,
      portfolioAllowed: typeof portfolioDecision?.allowed === 'boolean' ? portfolioDecision.allowed : null,
      portfolioReasons: Array.isArray(portfolioDecision?.reasons) ? portfolioDecision.reasons : null,
      warnReasons: quantWarn.length > 0 ? [...quantWarn] : null,
      blockReasons: quantBlock.length > 0 ? [...quantBlock] : null
    };
    if (quantBlock.length > 0) {
      const error = `Execution blocked by quant gate: ${quantBlock[0]}`;
      setSignalEntries((prev) =>
        prev.map((item) => (item.id === entryId ? { ...item, status: 'FAILED', executionError: error, quantTelemetry } : item))
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: {
          signalId: entryId,
          error,
          quantBlock,
          quantWarn,
          quantElapsedMs,
          regime: regimeState?.label || null,
          ensemble: ensembleDecision || null,
          metaLabel: metaLabelDecision || null,
          portfolio: portfolioDecision || null
        }
      });
      inFlight.delete(entryId);
      return;
    }
    setSignalEntries((prev) =>
      prev.map((item) => (item.id === entryId ? { ...item, quantTelemetry } : item))
    );
    if (quantWarn.length > 0) {
      addNotification('Quant Warning', quantWarn[0], 'warning');
    }
    const preTradeGate = await evaluatePreTradeHealthGate({
      proposal,
      source,
      broker: targetBroker,
      bridgeReady: startupBridgeGateRef.current.ready,
      bridgeError: startupBridgeGateRef.current.error,
      brokerConnected: targetBroker === 'tradelocker' ? tradeLockerExecutionGateRef.current.connected : true,
      upstreamBlockedUntilMs: targetBroker === 'tradelocker' ? tradeLockerExecutionGateRef.current.upstreamBlockedUntilMs : null,
      rateLimitSuppressUntilMs: brokerRateLimitSuppressUntilMs,
      fetchQuote: targetBroker === 'tradelocker' ? fetchBrokerQuoteForSymbol : undefined,
      referencePriceFromQuote: targetBroker === 'tradelocker' ? getBrokerReferencePriceFromQuote : undefined,
      maxQuoteAgeMs: 30_000,
      maxSpreadBps: Number(mergedAutoCfg?.maxSpreadBps || mergedAutoCfg?.spreadLimitBps || 30),
      maxSlippageBps: Number(mergedAutoCfg?.maxSlippageBps || 40)
    });
    if (!preTradeGate.ok) {
      const error = preTradeGate.message || 'Pre-trade health gate blocked execution.';
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId ? { ...item, status: 'FAILED', executionError: error } : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: {
          signalId: entryId,
          error,
          code: preTradeGate.code || null,
          retryAfterMs: preTradeGate.retryAfterMs ?? null,
          detail: preTradeGate.detail || null
        }
      });
      void upsertAcademyCase({
        entry: { ...entry, status: 'FAILED', executionError: error },
        patch: { status: 'FAILED' },
        event: {
          type: 'signal_execute_failed',
          payload: {
            signalId: entryId,
            error,
            code: preTradeGate.code || null,
            retryAfterMs: preTradeGate.retryAfterMs ?? null
          }
        },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }
    const exec = executeTradeRequestRef.current;
    if (typeof exec !== 'function') {
      const error = 'Execution API not ready.';
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId ? { ...item, status: 'FAILED', executionError: error } : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: { signalId: entryId, error }
      });
      void upsertAcademyCase({
        entry: { ...entry, status: 'FAILED', executionError: error },
        patch: { status: 'FAILED' },
        event: { type: 'signal_execute_failed', payload: { signalId: entryId, error } },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }
    let execOptions: Record<string, any> | undefined = {
      forceBroker: targetBroker
    };
    if (opts?.executionMode) {
      execOptions = execOptions || {};
      execOptions.executionMode = opts.executionMode;
    }
    if (opts?.autoConfigOverride) {
      execOptions = execOptions || {};
      execOptions.autoConfigOverride = opts.autoConfigOverride;
    }
    if (execOptions && Object.keys(execOptions).length === 0) {
      execOptions = undefined;
    }
    const executionAuditKey = `signal_exec:${entryId}:${String(proposal?.messageId || '').trim()}:${targetBroker}`;
    executionAuditService.noteSubmitted({
      signalId: entryId,
      dedupeKey: executionAuditKey,
      submittedAt: Date.now(),
      retryCount: 0,
      broker: targetBroker,
      source
    });
    let res: any = null;
    try {
      res = await exec(proposal, source, execOptions);
    } catch (err: any) {
      const error = err?.message ? String(err.message) : 'Execution failed.';
      executionAuditService.noteAck({
        signalId: entryId,
        dedupeKey: executionAuditKey,
        ackAt: Date.now(),
        brokerOrderId: null,
        retryCount: 1,
        broker: targetBroker
      });
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId ? { ...item, status: 'FAILED', executionError: error } : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: { signalId: entryId, error }
      });
      void upsertAcademyCase({
        entry: { ...entry, status: 'FAILED', executionError: error },
        patch: { status: 'FAILED' },
        event: { type: 'signal_execute_failed', payload: { signalId: entryId, error } },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }
    if (!res?.ok) {
      const error = res?.error || 'Execution failed.';
      executionAuditService.noteAck({
        signalId: entryId,
        dedupeKey: executionAuditKey,
        ackAt: Date.now(),
        brokerOrderId: null,
        retryCount: 1,
        broker: targetBroker
      });
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId ? { ...item, status: 'FAILED', executionError: error } : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: { signalId: entryId, error }
      });
      void upsertAcademyCase({
        entry: { ...entry, status: 'FAILED', executionError: error },
        patch: { status: 'FAILED' },
        event: { type: 'signal_execute_failed', payload: { signalId: entryId, error } },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }
    const isFilled = res?.filled === true || (res?.broker && res.broker !== 'tradelocker');
    const executedAtMs = isFilled ? Date.now() : null;
    const ledgerId = res?.ledgerId ? String(res.ledgerId) : null;
    const orderId = res?.orderId != null ? String(res.orderId) : null;
    const positionId = res?.positionId != null ? String(res.positionId) : null;
    const orderStatus = res?.orderStatus != null ? String(res.orderStatus) : null;
    const executionBroker = res?.broker != null ? String(res.broker) : null;
    const executionMode = res?.executionMode != null ? String(res.executionMode) : null;
    executionAuditService.noteAck({
      signalId: entryId,
      dedupeKey: executionAuditKey,
      ackAt: Date.now(),
      brokerOrderId: orderId,
      retryCount: 1,
      broker: executionBroker || targetBroker
    });
    const nextStatus: SignalEntry['status'] = isFilled ? 'EXECUTED' : 'PENDING';
    const nextEntry: SignalEntry = {
      ...entry,
      status: nextStatus,
      executionError: null,
      executionSource: source,
      executionBroker: executionBroker as any,
      executionMode: executionMode as any,
      executedAtMs: executedAtMs ?? entry.executedAtMs ?? null,
      executionLedgerId: ledgerId,
      executionOrderId: orderId,
      executionPositionId: positionId,
      executionOrderStatus: orderStatus
    };
    setSignalEntries((prev) =>
      prev.map((item) =>
        item.id === entryId
          ? {
              ...item,
              status: nextStatus,
              executionError: null,
              executionSource: source,
              executionBroker: executionBroker as any,
              executionMode: executionMode as any,
              executedAtMs: executedAtMs ?? item.executedAtMs ?? null,
              executionLedgerId: ledgerId,
              executionOrderId: orderId,
              executionPositionId: positionId,
              executionOrderStatus: orderStatus
            }
          : item
      )
    );
    void appendTruthEvent({
      eventType: isFilled ? 'signal_executed' : 'signal_pending',
      symbol: entry.symbol,
      payload: {
        signalId: entryId,
        source,
        agentId: entry.agentId || null,
        ledgerId,
        executedAtMs: executedAtMs ?? null,
        orderId,
        positionId,
        orderStatus,
        broker: executionBroker
      }
    });
    void upsertSignalHistory(nextEntry, {
      status: nextStatus,
      executedAtMs: executedAtMs ?? null,
      ledgerId,
      outcome: null,
      orderId,
      positionId,
      executionBroker,
      executionMode
    });
    void upsertAcademyCase({
      entry: nextEntry,
      patch: {
        status: nextStatus,
        executedAtMs: executedAtMs ?? null,
        ledgerId,
        orderId,
        positionId
      },
      brokerSnapshot: buildAcademyBrokerSnapshot(nextEntry.symbol),
      event: {
        type: nextStatus === 'PENDING' ? 'signal_pending' : 'signal_executed',
        payload: {
          signalId: entryId,
          orderId,
          positionId,
          ledgerId,
          broker: executionBroker || null
        }
      },
      source: 'signal_panel'
    });
    inFlight.delete(entryId);
  }, [
    addNotification,
    agentPerformanceById,
    appendTruthEvent,
    brokerRateLimitSuppressUntilMs,
    buildAcademyBrokerSnapshot,
    buildTradeProposalFromSignal,
    chartEngine,
    fetchBrokerQuoteForSymbol,
    getBrokerReferencePriceFromQuote,
    normalizeTimeframeKey,
    signalExecutionTarget,
    upsertAcademyCase,
    upsertSignalHistory
  ]);

  const followShadowSignal = useCallback(async (entry: SignalEntry) => {
    if (!signalShadowFollowEnabled) return;
    if (!entry || !entry.id) return;
    if (entry.shadowLedgerId) return;
    const inFlight = shadowFollowInFlightRef.current;
    if (inFlight.has(entry.id)) return;
    inFlight.add(entry.id);
    const profile = entry.agentId
      ? (shadowProfilesRef.current || []).find((item) => item.agentId === entry.agentId)
      : null;
    if (profile && profile.enabled === false) {
      inFlight.delete(entry.id);
      return;
    }
    const exec = executeTradeRequestRef.current;
    if (typeof exec !== 'function') {
      inFlight.delete(entry.id);
      return;
    }
    const proposal = entry.tradeProposal || buildTradeProposalFromSignal(entry, entry.agentId || null);
    const shadowGate = await evaluatePreTradeHealthGate({
      proposal,
      source: 'manual',
      broker: 'shadow',
      bridgeReady: startupBridgeGateRef.current.ready,
      bridgeError: startupBridgeGateRef.current.error,
      brokerConnected: true,
      rateLimitSuppressUntilMs: brokerRateLimitSuppressUntilMs
    });
    if (!shadowGate.allowed) {
      void appendTruthEvent({
        eventType: 'signal_execute_failed',
        symbol: entry.symbol,
        payload: {
          signalId: entry.id,
          error: shadowGate.message || 'Shadow follow blocked by pre-trade gate.',
          code: shadowGate.code || null
        }
      });
      inFlight.delete(entry.id);
      return;
    }
    try {
      const res: any = await exec(proposal, 'manual', { executionMode: 'shadow' });
      if (res?.ok && res?.ledgerId) {
        const ledgerId = String(res.ledgerId);
        setSignalEntries((prev) =>
          prev.map((item) => (item.id === entry.id ? { ...item, shadowLedgerId: ledgerId } : item))
        );
      }
    } catch {
      // ignore shadow follow failures
    } finally {
      inFlight.delete(entry.id);
    }
  }, [
    appendTruthEvent,
    brokerRateLimitSuppressUntilMs,
    buildTradeProposalFromSignal,
    signalShadowFollowEnabled
  ]);

  const resolveLiveEntryGate = useCallback(async (entry: SignalEntry, profile: ShadowProfile, broker: BrokerId) => {
    const proposal = await buildLiveTradeProposalFromSignal(entry, broker);
    const entryPrice = Number(proposal.entryPrice);
    if (!Number.isFinite(entryPrice) || entryPrice <= 0) {
      return { ok: false as const, reason: 'missing_entry', proposal };
    }
    const quoteRes = await fetchBrokerQuoteForSymbol(proposal.symbol, { maxAgeMs: 20_000 });
    const quote = quoteRes?.quote || null;
    const bid = Number(quote?.bid);
    const ask = Number(quote?.ask);
    const mid = Number(getBrokerReferencePriceFromQuote(quote));
    const side = proposal.action === 'SELL' ? 'SELL' : 'BUY';
    const refPrice = Number.isFinite(side === 'BUY' ? ask : bid)
      ? (side === 'BUY' ? ask : bid)
      : mid;
    if (!Number.isFinite(refPrice) || refPrice <= 0) {
      return { ok: false as const, reason: 'missing_quote', proposal };
    }
    const tolerancePct = resolveLiveEntryTolerancePct(profile);
    const distancePct = Math.abs(refPrice - entryPrice) / entryPrice * 100;
    if (distancePct > tolerancePct) {
      return { ok: false as const, reason: 'entry_too_far', proposal, distancePct, tolerancePct, refPrice };
    }
    // Anchor SL/TP to the live-side price to preserve risk/rr when within tolerance.
    const stopLoss = Number(proposal.stopLoss);
    const takeProfit = Number(proposal.takeProfit);
    const risk = Number.isFinite(entryPrice) && Number.isFinite(stopLoss) ? Math.abs(entryPrice - stopLoss) : NaN;
    const reward = Number.isFinite(entryPrice) && Number.isFinite(takeProfit) ? Math.abs(takeProfit - entryPrice) : NaN;
    const rr = Number.isFinite(risk) && risk > 0 && Number.isFinite(reward) && reward > 0 ? reward / risk : NaN;
    let adjustedEntry = refPrice;
    let adjustedStop = proposal.stopLoss;
    let adjustedTake = proposal.takeProfit;
    if (Number.isFinite(adjustedEntry) && adjustedEntry > 0 && Number.isFinite(risk) && risk > 0) {
      adjustedStop = side === 'BUY' ? adjustedEntry - risk : adjustedEntry + risk;
      if (Number.isFinite(rr) && rr > 0) {
        adjustedTake = side === 'BUY' ? adjustedEntry + risk * rr : adjustedEntry - risk * rr;
      } else if (Number.isFinite(reward) && reward > 0) {
        adjustedTake = side === 'BUY' ? adjustedEntry + reward : adjustedEntry - reward;
      }
    }
    const adjustedProposal = {
      ...proposal,
      forceOrderType: 'market' as const,
      entryPrice: Number.isFinite(adjustedEntry) && adjustedEntry > 0 ? adjustedEntry : proposal.entryPrice,
      stopLoss: adjustedStop,
      takeProfit: adjustedTake
    };
    return { ok: true as const, proposal: adjustedProposal, distancePct, tolerancePct, refPrice };
  }, [buildLiveTradeProposalFromSignal, fetchBrokerQuoteForSymbol, getBrokerReferencePriceFromQuote, resolveLiveEntryTolerancePct]);

  const followLiveSignal = useCallback(async (entry: SignalEntry, profileOverride?: ShadowProfile | null) => {
    if (!entry || !entry.id) return;
    if (entry.status !== 'PROPOSED') return;
    const profile = profileOverride
      ? profileOverride
      : entry.agentId
        ? (shadowProfilesRef.current || []).find((item) => item.agentId === entry.agentId)
        : null;
    if (!profile?.liveDeployEnabled) return;
    if (!profile.liveAccountKey) return;
    if (profile.enabled === false) return;
    const broker = profile.liveBroker === 'tradelocker' ? 'tradelocker' : 'mt5';
    const inFlight = shadowLiveDeployInFlightRef.current;
    if (inFlight.has(entry.id)) return;
    inFlight.add(entry.id);
    try {
      const gate = await resolveLiveEntryGate(entry, profile, broker);
      if (!gate.ok) return;
      const scheduleStopSync = async (proposal: TradeProposal) => {
        if (broker !== 'tradelocker') return;
        const syncInFlight = liveStopSyncInFlightRef.current;
        if (syncInFlight.has(entry.id)) return;
        syncInFlight.add(entry.id);
        try {
          const sleep = (ms: number) => sleepMs(ms);
          let updated: SignalEntry | null = null;
          for (let i = 0; i < 5; i += 1) {
            updated = (signalEntriesRef.current || []).find((item) => item.id === entry.id) || null;
            if (updated?.executionPositionId) break;
            await sleep(1200);
          }
          if (!updated || !updated.executionPositionId) return;
          const exec = executeBrokerActionRequestRef.current;
          if (!exec) return;
          const tlExec = tradeLockerExecRef.current;
          if (tlExec?.refreshSnapshot) {
            try {
              await tlExec.refreshSnapshot();
            } catch {
              // ignore snapshot refresh failures
            }
          }
          const positions = Array.isArray(tradeLockerExecRef.current?.positions)
            ? tradeLockerExecRef.current?.positions
            : [];
          const pos = positions.find((p: any) => String(p?.id || '') === String(updated.executionPositionId)) || null;
          if (!pos) return;
          const actualEntry = Number(pos?.entryPrice ?? pos?.price ?? pos?.openPrice);
          if (!Number.isFinite(actualEntry) || actualEntry <= 0) return;
          const baseEntry = Number(proposal.entryPrice);
          const baseStop = Number(proposal.stopLoss);
          const baseTake = Number(proposal.takeProfit);
          const risk = Number.isFinite(baseEntry) && Number.isFinite(baseStop) ? Math.abs(baseEntry - baseStop) : NaN;
          const reward = Number.isFinite(baseEntry) && Number.isFinite(baseTake) ? Math.abs(baseTake - baseEntry) : NaN;
          if (!Number.isFinite(risk) || risk <= 0) return;
          const rr = Number.isFinite(reward) && reward > 0 ? reward / risk : NaN;
          const side = proposal.action === 'SELL' ? 'SELL' : 'BUY';
          const nextStopRaw = side === 'BUY' ? actualEntry - risk : actualEntry + risk;
          const nextTakeRaw = Number.isFinite(rr) && rr > 0
            ? (side === 'BUY' ? actualEntry + risk * rr : actualEntry - risk * rr)
            : (Number.isFinite(reward) && reward > 0
                ? (side === 'BUY' ? actualEntry + reward : actualEntry - reward)
                : proposal.takeProfit);
          const nextStop = Number.isFinite(nextStopRaw) ? nextStopRaw : undefined;
          const nextTake = Number.isFinite(Number(nextTakeRaw)) ? Number(nextTakeRaw) : undefined;
          if (nextStop === undefined && nextTake === undefined) return;
          const currentStop = Number(pos?.stopLoss ?? pos?.sl ?? pos?.stop);
          const currentTake = Number(pos?.takeProfit ?? pos?.tp ?? pos?.take);
          const minShift = Math.max(0, (Number.isFinite(baseEntry) ? baseEntry : actualEntry) * (LIVE_STOP_SYNC_MIN_SHIFT_PCT / 100));
          const stopDiff = nextStop !== undefined && Number.isFinite(currentStop) ? Math.abs(currentStop - nextStop) : Infinity;
          const takeDiff = nextTake !== undefined && Number.isFinite(currentTake) ? Math.abs(currentTake - nextTake) : Infinity;
          if (stopDiff < minShift && takeDiff < minShift) return;
          await exec({
            type: 'MODIFY_POSITION',
            status: 'SUBMITTING',
            source: 'shadow_live',
            positionId: String(updated.executionPositionId),
            symbol: updated.symbol,
            stopLoss: nextStop,
            takeProfit: nextTake
          });
        } finally {
          syncInFlight.delete(entry.id);
        }
      };
      const autoConfigOverride = {
        ...buildLiveSizingOverride(profile, broker),
        ...buildLiveGuardrailOverride(profile)
      };
      await executeSignalTrade(entry.id, 'manual', entry, {
        forceBroker: broker,
        executionMode: 'live',
        proposalOverride: gate.proposal,
        autoConfigOverride
      });
      void scheduleStopSync(gate.proposal);
    } catch {
      // ignore live deploy failures
    } finally {
      inFlight.delete(entry.id);
    }
  }, [buildLiveGuardrailOverride, buildLiveSizingOverride, executeSignalTrade, resolveLiveEntryGate]);

  const maybeExecutePendingLiveSignals = useCallback(async (opts?: {
    agentId?: string | null;
    excludeIds?: Set<string>;
    profileOverride?: ShadowProfile | null;
  }) => {
    if (livePendingScanRef.current.running) return;
    const now = Date.now();
    if (now - livePendingScanRef.current.lastAtMs < LIVE_PENDING_EXECUTE_THROTTLE_MS) return;
    livePendingScanRef.current.running = true;
    livePendingScanRef.current.lastAtMs = now;
    try {
      const entries = Array.isArray(signalEntriesRef.current) ? signalEntriesRef.current : [];
      if (entries.length === 0) return;
      const profiles = shadowProfilesRef.current || [];
      const liveProfiles = new Map<string, ShadowProfile>();
      for (const profile of profiles) {
        if (!profile?.agentId) continue;
        if (opts?.agentId && profile.agentId !== opts.agentId) continue;
        if (!profile.liveDeployEnabled) continue;
        if (!profile.liveAccountKey) continue;
        if (profile.enabled === false) continue;
        liveProfiles.set(profile.agentId, profile);
      }
      if (opts?.profileOverride?.agentId) {
        const override = opts.profileOverride;
        const matchesAgent = !opts.agentId || override.agentId === opts.agentId;
        if (matchesAgent && override.liveDeployEnabled && override.liveAccountKey && override.enabled !== false) {
          liveProfiles.set(override.agentId, override);
        }
      }
      if (liveProfiles.size === 0) return;
      const exclude = opts?.excludeIds || new Set<string>();
      const candidates = entries.filter((entry) => {
        if (!entry || !entry.id) return false;
        if (exclude.has(entry.id)) return false;
        if (entry.status !== 'PROPOSED') return false;
        if (entry.executionBroker || entry.executionLedgerId || entry.executionOrderId) return false;
        if (entry.agentId && !liveProfiles.has(entry.agentId)) return false;
        const expiresAt = Number(entry.expiresAtMs || 0);
        if (expiresAt && expiresAt <= now) return false;
        return true;
      });
      if (candidates.length === 0) return;
      candidates.sort((a, b) => (Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0)));
      let executed = 0;
      for (const entry of candidates) {
        if (executed >= LIVE_PENDING_EXECUTE_LIMIT) break;
        const profile = entry.agentId ? liveProfiles.get(entry.agentId) : null;
        if (!profile) continue;
        await followLiveSignal(entry, profile);
        executed += 1;
      }
    } finally {
      livePendingScanRef.current.running = false;
    }
  }, [followLiveSignal]);

  useEffect(() => {
    maybeExecutePendingLiveSignalsRef.current = maybeExecutePendingLiveSignals;
  }, [maybeExecutePendingLiveSignals]);

  const buildSignalSnapshotTimeframes = useCallback((primary: string[], strategyModes: SignalStrategyMode[]) => {
    const list = Array.isArray(primary) ? primary : [];
    const modes = new Set((strategyModes || []).map((mode) => String(mode || '').trim().toLowerCase()));
    const wantScalp = modes.has('scalp');
    const wantDay = modes.has('day');
    const wantSwing = modes.has('swing');
    const out: string[] = [];
    const seen = new Set<string>();
    const push = (value: any) => {
      const normalized = normalizeTimeframeKey(String(value || '').trim());
      if (!normalized) return;
      const key = normalized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      out.push(key);
    };
    list.forEach(push);
    push('30m');
    push('1d');
    if (wantDay || wantSwing) push('1w');
    if (wantScalp) push('1m');
    return out;
  }, []);

  const snapshotPanelTimeframes = React.useMemo(() => {
    const baseTimeframes = signalTimeframes.length > 0 ? signalTimeframes : DEFAULT_SIGNAL_TIMEFRAMES;
    return buildSignalSnapshotTimeframes(baseTimeframes, signalStrategyModes);
  }, [buildSignalSnapshotTimeframes, signalStrategyModes, signalTimeframes]);

  const snapshotPanelWarmupBarsByTimeframe = React.useMemo(() => {
    return buildSignalWarmupBarsByTimeframe(snapshotPanelTimeframes);
  }, [buildSignalWarmupBarsByTimeframe, snapshotPanelTimeframes]);

  const snapshotPanelCandidates = React.useMemo(() => {
    const list: string[] = [];
    const seen = new Set<string>();
    const push = (raw: any) => {
      const sym = String(raw || '').trim();
      if (!sym) return;
      const key = normalizeSymbolKeyShared(sym) || normalizeSymbolLooseShared(sym) || sym.toUpperCase();
      if (!key || seen.has(key)) return;
      seen.add(key);
      list.push(sym);
    };
    push(snapshotPanelSymbol);
    push(symbolScopeSymbol);
    push(signalPrimarySymbol);
    signalSymbols.forEach(push);
    patternWatchSymbols.forEach(push);
    setupWatchers.forEach((watcher) => push(watcher?.symbol));
    brokerWatchSymbols.forEach(push);
    push(activeBrokerSymbol);
    push(nativeChartSymbol);
    push(backtestSymbol);
    push(activeTvParams?.symbol);
    return list;
  }, [
    activeBrokerSymbol,
    activeTvParams?.symbol,
    backtestSymbol,
    brokerWatchSymbols,
    nativeChartSymbol,
    patternWatchSymbols,
    setupWatchers,
    signalPrimarySymbol,
    signalSymbols,
    snapshotPanelSymbol,
    symbolScopeSymbol
  ]);

  const resolveSnapshotPanelSymbol = useCallback((override?: string) => {
    const raw = override || snapshotPanelSymbol || symbolScopeSymbol || signalPrimarySymbol || activeBrokerSymbol || activeTvParams?.symbol || '';
    return String(raw || '').trim();
  }, [activeBrokerSymbol, activeTvParams?.symbol, signalPrimarySymbol, snapshotPanelSymbol, symbolScopeSymbol]);

  useEffect(() => {
    if (snapshotPanelSymbol) return;
    const fallback = resolveSnapshotPanelSymbol();
    if (fallback) setSnapshotPanelSymbol(fallback);
  }, [resolveSnapshotPanelSymbol, snapshotPanelSymbol]);

  const refreshSnapshotPanelStatus = useCallback(async (override?: { symbol?: string; timeframes?: string[] }) => {
    refreshSlaMonitor.ensureTask({
      id: SNAPSHOT_SLA_TASK_ID,
      channel: 'snapshot',
      intervalMs: 2_000
    });
    refreshSlaMonitor.noteAttempt(SNAPSHOT_SLA_TASK_ID, Date.now());
    const resolvedSymbol = resolveSnapshotPanelSymbol(override?.symbol);
    const resolvedTimeframes = Array.isArray(override?.timeframes) && override.timeframes.length > 0
      ? override.timeframes
      : snapshotPanelTimeframes;
    if (!resolvedSymbol) {
      setSnapshotPanelStatus(null);
      refreshSlaMonitor.noteSkip(SNAPSHOT_SLA_TASK_ID, 'missing_symbol', Date.now());
      return;
    }
    const snapshots = chartEngine.getSnapshots({ barsLimit: CHART_CHAT_MAX_CANDLES, eventsLimit: 0, includeInactive: true });
    const payloadResult = buildChartSnapshotPayload({
      msgId: `snapshot_panel_${Date.now()}`,
      symbol: resolvedSymbol,
      timeframes: resolvedTimeframes,
      snapshots,
      maxCandles: CHART_CHAT_MAX_CANDLES,
      maxPayloadChars: CHART_CHAT_MAX_PAYLOAD_CHARS,
      capturedAtMs: Date.now(),
      imageIncluded: false
    });
    const payload = payloadResult.payload || {};
    const diagnostics = payload.diagnostics && typeof payload.diagnostics === 'object' ? payload.diagnostics : {};
    const reasonCode = diagnostics.reasonCode || null;
    const framesSummary = Array.isArray(payload.frames)
      ? payload.frames.map((frame: any) => ({
          tf: String(frame.tf || ''),
          barsCount: Number(frame.barsCount || 0) || 0,
          lastUpdatedAtMs: frame.lastUpdatedAtMs ?? null
        }))
      : [];
    const warmupBarsByTimeframe = buildSignalWarmupBarsByTimeframe(resolvedTimeframes);
    const gaps = await computeFrameGapWorker({
      frames: framesSummary,
      timeframes: resolvedTimeframes,
      minBarsByTimeframe: warmupBarsByTimeframe,
      timeoutMs: 1800
    });
    const status: SignalSnapshotStatus = {
      symbol: payload.symbol || resolvedSymbol,
      ok: !reasonCode,
      reasonCode: reasonCode || null,
      frames: framesSummary,
      missingFrames: gaps.missing,
      shortFrames: gaps.short,
      capturedAtMs: payload.capturedAt ?? null
    };
    setSnapshotPanelStatus(status);
    refreshSlaMonitor.noteRun(SNAPSHOT_SLA_TASK_ID, Date.now());
    return status;
  }, [
    buildChartSnapshotPayload,
    buildSignalWarmupBarsByTimeframe,
    chartEngine,
    resolveSnapshotPanelSymbol,
    snapshotPanelTimeframes
  ]);

  const handleSnapshotPanelSelectSymbol = useCallback((nextSymbol: string) => {
    const cleaned = String(nextSymbol || '').trim();
    if (!cleaned) return;
    setSnapshotPanelSymbol(cleaned);
    updateSymbolScope(cleaned, { timeframes: snapshotPanelTimeframes, source: 'snapshot' });
    setNativeChartSymbol(cleaned);
    setBacktestSymbol(cleaned);
    if (snapshotPanelApplyToSignals) {
      updateSignalSettings({ symbols: [cleaned] });
    }
    void chartEngine.refreshSessionsForSymbol(cleaned, snapshotPanelTimeframes, {
      force: true,
      barsBackfillByTimeframe: snapshotPanelWarmupBarsByTimeframe
    });
    void refreshSnapshotPanelStatus({ symbol: cleaned, timeframes: snapshotPanelTimeframes });
  }, [
    chartEngine,
    refreshSnapshotPanelStatus,
    setBacktestSymbol,
    setNativeChartSymbol,
    snapshotPanelApplyToSignals,
    snapshotPanelTimeframes,
    snapshotPanelWarmupBarsByTimeframe,
    updateSignalSettings,
    updateSymbolScope
  ]);

  const warmupSnapshotPanel = useCallback(async () => {
    const resolvedSymbol = resolveSnapshotPanelSymbol();
    if (!resolvedSymbol || snapshotPanelTimeframes.length === 0) return;
    const brokerApi = window.glass?.broker;
    if (brokerApi?.getActive && brokerApi?.setActive) {
      try {
        const activeRes = await brokerApi.getActive();
        const activeId = String(activeRes?.activeId || '').toLowerCase();
        if (activeId && activeId !== 'tradelocker') {
          await brokerApi.setActive('tradelocker');
        }
      } catch {
        // ignore
      }
    }
    const ensureConnect = ensureTradeLockerConnectedRef.current;
    if (ensureConnect) {
      try {
        await ensureConnect('snapshot_panel');
      } catch {
        // ignore
      }
    }
    await chartEngine.refreshSessionsForSymbol(resolvedSymbol, snapshotPanelTimeframes, {
      force: true,
      barsBackfillByTimeframe: snapshotPanelWarmupBarsByTimeframe
    });
    await refreshSnapshotPanelStatus({ symbol: resolvedSymbol, timeframes: snapshotPanelTimeframes });
  }, [
    chartEngine,
    refreshSnapshotPanelStatus,
    resolveSnapshotPanelSymbol,
    snapshotPanelTimeframes,
    snapshotPanelWarmupBarsByTimeframe
  ]);

  useEffect(() => {
    const activeTimeframes = Array.isArray(snapshotPanelTimeframes) ? snapshotPanelTimeframes : [];
    if (activeTimeframes.length === 0) return;
    const primarySymbol = resolveSnapshotPanelSymbol();
    const candidateSymbols = [primarySymbol, symbolScopeSymbol, ...signalSymbols]
      .map((entry) => String(entry || '').trim())
      .filter(Boolean);
    if (candidateSymbols.length === 0) return;
    const dedupedSymbols = Array.from(new Set(candidateSymbols)).slice(0, 4);

    const now = Date.now();
    const key = `${dedupedSymbols.join(',')}|${activeTimeframes.join(',')}`;
    const prior = snapshotStartupPrewarmRef.current;
    if (prior && prior.key === key && now - prior.atMs < 120_000) return;
    snapshotStartupPrewarmRef.current = { key, atMs: now };

    let cancelled = false;
    (async () => {
      const ensureConnect = ensureTradeLockerConnectedRef.current;
      if (ensureConnect) {
        try {
          await ensureConnect('startup_snapshot_prewarm');
        } catch {
          // ignore prewarm connect failures
        }
      }
      for (const symbol of dedupedSymbols) {
        if (cancelled) return;
        chartEngine.setActiveSessions(symbol, activeTimeframes, {
          barsBackfillByTimeframe: snapshotPanelWarmupBarsByTimeframe
        });
        await chartEngine.refreshSessionsForSymbol(symbol, activeTimeframes, {
          force: false,
          barsBackfillByTimeframe: snapshotPanelWarmupBarsByTimeframe
        });
      }
      if (cancelled) return;
      if (primarySymbol) {
        await refreshSnapshotPanelStatus({ symbol: primarySymbol, timeframes: activeTimeframes });
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [
    chartEngine,
    refreshSnapshotPanelStatus,
    resolveSnapshotPanelSymbol,
    signalSymbols,
    snapshotPanelTimeframes,
    snapshotPanelWarmupBarsByTimeframe,
    symbolScopeSymbol
  ]);

  const runSignalScan = useCallback(async (source: 'manual' | 'auto') => {
    const symbolList = signalSymbols.length > 0
      ? signalSymbols
      : [resolveChartChatSymbol()].map((entry) => String(entry || '').trim()).filter(Boolean);
    if (symbolList.length === 0) return;
    const scanAttemptAt = Date.now();
    setSignalLastAttemptAtMs(scanAttemptAt);
    const autoRefreshIntervalMs = Number.isFinite(Number(signalRefreshIntervalMs))
      ? Math.max(5_000, Math.floor(Number(signalRefreshIntervalMs)))
      : DEFAULT_SIGNAL_REFRESH_MS;
    refreshSlaMonitor.ensureTask({
      id: SIGNAL_AUTO_REFRESH_TASK_ID,
      channel: 'signal',
      intervalMs: autoRefreshIntervalMs
    });
    if (source === 'auto') {
      refreshSlaMonitor.noteAttempt(SIGNAL_AUTO_REFRESH_TASK_ID, scanAttemptAt);
    }
    const baseTimeframes = signalTimeframes.length > 0 ? signalTimeframes : DEFAULT_SIGNAL_TIMEFRAMES;
    const timeframes = buildSignalSnapshotTimeframes(baseTimeframes, signalStrategyModes);
    const warmupBarsByTimeframe = buildSignalWarmupBarsByTimeframe(timeframes);
    const probabilityMin = Math.max(1, Math.min(100, signalProbabilityThreshold));
    const probabilityMax = Math.max(probabilityMin, Math.min(100, signalProbabilityMax));
    const primarySymbol = signalPrimarySymbol || symbolList[0] || null;
    const pendingGaps = await computeFrameGapWorker({
      frames: [],
      timeframes,
      minBarsByTimeframe: warmupBarsByTimeframe,
      timeoutMs: 1200
    });
    const tlMeta = tradeLockerExecRef.current || {};
    const tlConnected = !!tlMeta.connected;
    const upstreamUntil = Number(tlMeta?.upstreamBlockedUntilMs || 0);
    if (!tlConnected || (Number.isFinite(upstreamUntil) && upstreamUntil > Date.now())) {
      const blockedByUpstream = Number.isFinite(upstreamUntil) && upstreamUntil > Date.now();
      const retrySecs = blockedByUpstream ? Math.max(1, Math.ceil((upstreamUntil - Date.now()) / 1000)) : null;
      const msg = blockedByUpstream
        ? `TradeLocker upstream unavailable. Retry in ${retrySecs}s.`
        : 'TradeLocker not connected. Waiting to run scan.';
      setSignalLastError(msg);
      setSignalSnapshotStatus(primarySymbol ? {
        symbol: primarySymbol,
        ok: false,
        reasonCode: blockedByUpstream ? 'BROKER_UPSTREAM_BACKOFF' : 'BROKER_DISCONNECTED',
        frames: [],
        missingFrames: pendingGaps.missing,
        shortFrames: pendingGaps.short
      } : null);
      appendLiveError({
        source: 'signal.scan',
        level: 'warn',
        message: msg,
        detail: {
          connected: tlConnected,
          upstreamBlockedUntilMs: Number.isFinite(upstreamUntil) ? upstreamUntil : null
        }
      });
      if (source === 'auto') {
        refreshSlaMonitor.noteSkip(
          SIGNAL_AUTO_REFRESH_TASK_ID,
          blockedByUpstream ? 'upstream_backoff' : 'broker_disconnected',
          Date.now()
        );
      }
      return;
    }
    if (signalRunning) {
      if (source === 'auto') {
        refreshSlaMonitor.noteSkip(SIGNAL_AUTO_REFRESH_TASK_ID, 'scan_in_progress', Date.now());
      }
      return;
    }
    const runId = `signal_${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;
    signalRunRef.current = { runId, canceled: false };
    setSignalRunning(true);
    setSignalLastError(null);
    setSignalLastParseError(null);
    setSignalLastParseAtMs(null);
    setSignalSnapshotStatus(primarySymbol ? {
      symbol: primarySymbol,
      ok: false,
      reasonCode: 'WARMUP_PENDING',
      frames: [],
      missingFrames: pendingGaps.missing,
      shortFrames: pendingGaps.short
    } : null);
    const scanStartedAt = Date.now();

    const brokerApi = window.glass?.broker;
    if (brokerApi?.getActive && brokerApi?.setActive) {
      try {
        const activeRes = await brokerApi.getActive();
        const activeId = String(activeRes?.activeId || '').toLowerCase();
        if (activeId && activeId !== 'tradelocker') {
          await brokerApi.setActive('tradelocker');
        }
      } catch {
        // ignore active broker set failures
      }
    }

    const newEntries: SignalEntry[] = [];
    const snapshotBundleBySymbol = new Map<string, any>();
    const snapshotMemoryBySymbol = new Map<string, any>();
    const newsSnapshotBySymbol = new Map<string, NewsSnapshot | null>();
    const parseFailures: string[] = [];
    let parsedAny = false;
    let scanCompleted = false;
    try {
      const toolRunner = executeAgentToolRequestRef.current;
      const formatToolResult = (result: AgentToolResult | null | undefined) => {
        if (!result) return '';
        if (result.text) return String(result.text).trim();
        try {
          return JSON.stringify(result.payload ?? result, null, 2);
        } catch {
          return '';
        }
      };
      const isMemoryTool = (toolAction?: AgentToolAction | null) => {
        const type = String(toolAction?.type || '').trim().toUpperCase();
        return type === 'LIST_AGENT_MEMORY' || type === 'GET_AGENT_MEMORY';
      };
      const chartAgentsNow = chartChatAgentsRef.current || [];
      const agentsNow = agentsRef.current || [];
      const mergedAgents = [...chartAgentsNow, ...agentsNow].filter(Boolean);
      const seenAgentIds = new Set<string>();
      const agentList = mergedAgents.filter((agent) => {
        const id = String(agent?.id || '').trim();
        const fallback = String(agent?.name || '').trim().toLowerCase();
        const key = id || (fallback ? `name:${fallback}` : '');
        if (!key) return false;
        if (seenAgentIds.has(key)) return false;
        seenAgentIds.add(key);
        return true;
      });
      const outcomeGateEnabled = readSignalOutcomeGateEnabled();
      const outcomeGateMaxOpen = readSignalOutcomeGateMaxOpen();
      const performanceWeightingEnabled = readSignalPerformanceWeighting();
      const resolveAgentKey = (agent: Agent) => {
        const id = String(agent?.id || '').trim();
        if (id) return id;
        const name = String(agent?.name || '').trim();
        return name ? `name:${name}` : '';
      };
      const isFinalStatus = (status?: string | null) => {
        const raw = String(status || '').trim().toUpperCase();
        return raw === 'WIN' || raw === 'LOSS' || raw === 'REJECTED' || raw === 'EXPIRED' || raw === 'FAILED';
      };

      let orderedAgents = [...agentList];
      if (performanceWeightingEnabled) {
        orderedAgents.sort((a, b) => {
          const aStats = agentPerformanceById.get(a.id) || (a.name ? agentPerformanceById.get(`name:${a.name}`) : null);
          const bStats = agentPerformanceById.get(b.id) || (b.name ? agentPerformanceById.get(`name:${b.name}`) : null);
          const aScore = aStats ? Number(aStats.totalScore || 0) : 0;
          const bScore = bStats ? Number(bStats.totalScore || 0) : 0;
          if (bScore !== aScore) return bScore - aScore;
          const aWin = aStats ? Number(aStats.winRate || 0) : 0;
          const bWin = bStats ? Number(bStats.winRate || 0) : 0;
          return bWin - aWin;
        });
      }

      let eligibleAgents = orderedAgents;
      eligibleAgents = eligibleAgents.filter((agent) => {
        const id = String(agent?.id || '').trim();
        if (!id) return true;
        return agentScanEnabledById[id] !== false;
      });
      if (eligibleAgents.length === 0) {
        const msg = 'No scan-enabled agents available. Enable at least one agent for Signal scans.';
        setSignalLastError(msg);
        appendLiveError({
          source: 'signal.scan',
          level: 'warn',
          message: msg
        });
        return;
      }
      if (outcomeGateEnabled) {
        const openCounts = new Map<string, number>();
        const entriesNow = Array.isArray(signalEntriesRef.current) ? signalEntriesRef.current : [];
        for (const entry of entriesNow) {
          if (!entry || isFinalStatus(entry.status)) continue;
          const agentId = String(entry.agentId || '').trim();
          const agentName = String(entry.agentName || '').trim();
          const key = agentId || (agentName ? `name:${agentName}` : '');
          if (!key) continue;
          openCounts.set(key, (openCounts.get(key) || 0) + 1);
        }
        eligibleAgents = eligibleAgents.filter((agent) => {
          const key = resolveAgentKey(agent);
          if (!key) return true;
          const count = openCounts.get(key) || 0;
          return count <= outcomeGateMaxOpen;
        });

        if (eligibleAgents.length === 0) {
          const msg = outcomeGateMaxOpen > 0
            ? `Outcome gate active. Waiting for agents to resolve open signals (max ${outcomeGateMaxOpen}).`
            : 'Outcome gate active. Waiting for agents to resolve open signals.';
          setSignalLastError(msg);
          appendLiveError({
            source: 'signal.scan',
            level: 'info',
            message: msg,
            detail: { outcomeGateMaxOpen }
          });
          return;
        }
      }

      const fetchSnapshotForSymbol = async (symbol: string) => {
        const [snapshotBundle, newsSnapshot] = await Promise.all([
          captureChartChatSnapshot(runId, { symbol, timeframes }),
          fetchNewsSnapshot(symbol, { force: source === 'manual' })
        ]);
        if (signalRunRef.current?.runId !== runId) return;
        snapshotBundleBySymbol.set(symbol, snapshotBundle || null);
        snapshotMemoryBySymbol.set(symbol, lastChartSnapshotMemoryRef.current || null);
        newsSnapshotBySymbol.set(symbol, newsSnapshot || null);
        const status: SignalSnapshotStatus = snapshotBundle?.status || {
          symbol,
          ok: false,
          reasonCode: 'STORE_EMPTY',
          frames: []
        };
        const gaps = await computeFrameGapWorker({
          frames: status?.frames || [],
          timeframes,
          minBarsByTimeframe: warmupBarsByTimeframe,
          timeoutMs: 1200
        });
        const statusWithGaps: SignalSnapshotStatus = {
          ...status,
          missingFrames: gaps.missing,
          shortFrames: gaps.short
        };
        if (symbol === primarySymbol) {
          setSignalSnapshotStatus(statusWithGaps);
        }
      };

      for (let i = 0; i < symbolList.length; i += SIGNAL_SNAPSHOT_PARALLELISM) {
        const batch = symbolList.slice(i, i + SIGNAL_SNAPSHOT_PARALLELISM);
        await Promise.all(batch.map((symbol) => fetchSnapshotForSymbol(symbol)));
        if (signalRunRef.current?.runId !== runId) return;
      }

      for (const symbol of symbolList) {
        const snapshotBundle = snapshotBundleBySymbol.get(symbol) || null;
        const newsSnapshot = newsSnapshotBySymbol.get(symbol) || null;

        const allowMemoryTools = signalMemoryMode === 'tool' || signalMemoryMode === 'both';
        const memoryContext = allowMemoryTools && signalMemoryMode === 'tool'
          ? ''
          : await buildSignalMemoryContext({ symbol, limit: signalMemoryLimit });
        const newsContext = buildSignalNewsContext(newsSnapshot, symbol);
        const baseSystemContext = {
          symbol,
          timeframes,
          strategyModes: signalStrategyModes,
          expiryMinutes: signalExpiryMinutes,
          thresholdMin: probabilityMin,
          thresholdMax: probabilityMax,
          memoryMode: signalMemoryMode,
          memoryContext,
          newsContext,
          includePatterns: signalIncludePatterns
        };
        const prompt = buildSignalPrompt({
          symbol,
          timeframes,
          strategyModes: signalStrategyModes,
          expiryMinutes: signalExpiryMinutes,
          allowMemoryTools
        });
        const attachments = snapshotBundle?.imageDataUrl
          ? [{ dataUrl: snapshotBundle.imageDataUrl, label: 'Native chart snapshot' }]
          : null;
        const symbolPrefix = symbolList.length > 1 ? `${symbol}:` : '';

        for (const agent of eligibleAgents) {
          try {
          const focus = agentFocusById.get(agent.id) || (agent.name ? agentFocusById.get(`name:${agent.name}`) : null);
          const focusTimeframe = focus?.timeframe || timeframes[0] || null;
          const focusStrategy = focus?.strategyMode || null;
          const lessonContext = buildAcademyLessonContextFor({
            symbol,
            timeframe: focusTimeframe,
            strategyMode: focusStrategy,
            agentId: agent.id,
            agentName: agent.name,
            limit: academyLessonLimit
          });
          const symbolLearningContext = buildAcademySymbolLearningContextFor(symbol);
          const academyContext = [lessonContext, symbolLearningContext].filter(Boolean).join('\n\n');
          const agentScorecardContext = buildAgentScorecardContext(agent);
          const systemContext = buildSignalSystemContext({
            ...baseSystemContext,
            academyContext,
            agentContext: agentScorecardContext
          });
          let res = await sendMessageToOpenAI(
            [],
            prompt,
            systemContext,
            attachments as any,
            eligibleAgents,
            [],
            [],
            { agent, reasoningEffort: 'medium' }
          );
          if (allowMemoryTools && res?.agentToolAction && isMemoryTool(res.agentToolAction)) {
            const toolResult = toolRunner
              ? await toolRunner(res.agentToolAction)
              : { ok: false, text: 'Signal memory tools unavailable.' };
            const toolText = formatToolResult(toolResult);
            const toolContext = toolText ? `SIGNAL MEMORY TOOL RESULT:\n${toolText}` : 'SIGNAL MEMORY TOOL RESULT: (empty)';
            res = await sendMessageToOpenAI(
              [],
              prompt,
              [systemContext, toolContext].filter(Boolean).join('\n\n'),
              attachments as any,
              eligibleAgents,
              [],
              [],
              { agent, reasoningEffort: 'medium' }
            );
          }
          const parsed = parseSignalPayload(res?.text || '');
          if (!parsed) {
            const label = String(agent?.name || agent?.id || 'agent').trim() || 'agent';
            parseFailures.push(symbolPrefix ? `${symbolPrefix}${label}` : label);
          } else {
            parsedAny = true;
          }
          const signalsRaw = Array.isArray(parsed) ? parsed : parsed?.signals;
          if (Array.isArray(signalsRaw)) {
            for (const item of signalsRaw) {
              const actionRaw = String(item?.action || item?.side || item?.bias || '').trim().toUpperCase();
              const action = actionRaw === 'SELL' ? 'SELL' : actionRaw === 'BUY' ? 'BUY' : '';
              if (!action) continue;
              const tfRaw = String(item?.timeframe || item?.tf || '').trim();
              const timeframe = normalizeTimeframeKey(tfRaw) || normalizeTimeframeKey(timeframes[0] || '') || '15m';
              const entryPrice = Number(item?.entry ?? item?.entryPrice);
              const stopLoss = Number(item?.stop ?? item?.stopLoss);
              const targets = Array.isArray(item?.targets) ? item.targets.map((v: any) => Number(v)).filter((v: any) => Number.isFinite(v)) : [];
              const takeProfit = Number(item?.takeProfit ?? item?.tp ?? targets[0]);
              if (!Number.isFinite(entryPrice) || !Number.isFinite(stopLoss) || !Number.isFinite(takeProfit)) continue;
              const probability = normalizeSignalProbability(item?.probability ?? item?.confidence ?? 0);
              const strategyRaw = String(item?.strategyMode || item?.strategy || '').trim().toLowerCase();
              const strategyMode =
                strategyRaw === 'scalp' || strategyRaw === 'day' || strategyRaw === 'swing'
                  ? (strategyRaw as SignalStrategyMode)
                  : null;
              if (strategyMode && signalStrategyModes.length > 0 && !signalStrategyModes.includes(strategyMode)) {
                continue;
              }
              const reason = item?.reason ? String(item.reason) : '';
              const entry: SignalEntry = {
                id: buildSignalEntryId({
                  symbol,
                  timeframe,
                  action,
                  entry: entryPrice,
                  stop: stopLoss,
                  target: takeProfit,
                  strategyMode
                }),
                symbol,
                timeframe,
                action,
                entryPrice,
                stopLoss,
                takeProfit,
                targets,
                probability,
                strategyMode,
                reason,
                status: 'PROPOSED',
                createdAtMs: Date.now(),
                expiresAtMs: Date.now() + signalExpiryMinutes * 60_000,
                agentId: agent?.id || null,
                agentName: agent?.name || null,
                executionSource: null,
                runId,
                newsSnapshot
              };
              entry.tradeProposal = buildTradeProposalFromSignal(entry, agent?.id || null);
              newEntries.push(entry);
            }
          }
          if (res?.tradeProposal) {
            const proposal = res.tradeProposal;
            if (proposal?.symbol && proposal?.entryPrice && proposal?.stopLoss && proposal?.takeProfit) {
              const modeRaw = String(proposal?.setup?.mode || '').trim().toLowerCase();
              const proposalMode =
                modeRaw === 'scalp' || modeRaw === 'day' || modeRaw === 'swing'
                  ? (modeRaw as SignalStrategyMode)
                  : null;
              const entryId = buildSignalEntryId({
                symbol: proposal.symbol,
                timeframe: timeframes[0] || '15m',
                action: proposal.action,
                entry: proposal.entryPrice,
                stop: proposal.stopLoss,
                target: proposal.takeProfit,
                strategyMode: proposalMode
              });
              const proposalSetup =
                proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
              const normalizedProposal = {
                ...proposal,
                agentId: proposal.agentId || agent?.id || null,
                reason: proposal.reason || 'Agent proposal',
                setup: {
                  ...(proposalSetup || {}),
                  signalId: entryId,
                  signalType: proposalSetup?.signalType || 'signal_panel',
                  source: proposalSetup?.source || 'signal_panel',
                  timeframe: proposalSetup?.timeframe || timeframes[0] || '15m',
                  mode: proposalSetup?.mode || proposalMode || null
                }
              };
              const entry: SignalEntry = {
                id: entryId,
                symbol: proposal.symbol,
                timeframe: timeframes[0] || '15m',
                action: proposal.action,
                entryPrice: proposal.entryPrice,
                stopLoss: proposal.stopLoss,
                takeProfit: proposal.takeProfit,
                probability: probabilityMin,
                strategyMode: proposalMode,
                reason: proposal.reason || 'Agent proposal',
                status: 'PROPOSED',
                createdAtMs: Date.now(),
                expiresAtMs: Date.now() + signalExpiryMinutes * 60_000,
                agentId: normalizedProposal.agentId || null,
                agentName: agent?.name || null,
                executionSource: null,
                runId,
                tradeProposal: normalizedProposal,
                newsSnapshot
              };
              newEntries.push(entry);
            }
          }
        } catch {
          // ignore agent failures
        }
      }
      }

      if (signalRunRef.current?.runId !== runId) return;

      if (!parsedAny && parseFailures.length > 0) {
        const label = parseFailures.slice(0, 4).join(', ');
        const suffix = parseFailures.length > 4 ? ` +${parseFailures.length - 4} more` : '';
        const msg = `No parseable signal payload from ${label}${suffix}.`;
        setSignalLastParseError(msg);
        setSignalLastParseAtMs(Date.now());
        appendLiveError({
          source: 'signal.parse',
          level: 'warn',
          message: msg,
          detail: { symbols: parseFailures }
        });
      } else if (parsedAny) {
        setSignalLastParseError(null);
        setSignalLastParseAtMs(null);
      }

      let freshEntries: SignalEntry[] = [];
      if (newEntries.length > 0) {
        const existingNow = new Set(signalEntriesRef.current.map((entry) => entry.id));
        const filteredNew = newEntries.filter((entry) => !existingNow.has(entry.id));
        freshEntries = filteredNew;
        setSignalEntries((prev) => {
          const existing = new Set(prev.map((entry) => entry.id));
          const filtered = filteredNew.filter((entry) => !existing.has(entry.id));
          return filtered.length > 0 ? [...filtered, ...prev] : prev;
        });
        for (const entry of filteredNew) {
          const snapshotBundle = snapshotBundleBySymbol.get(entry.symbol) || null;
          const snapshotMemory = snapshotMemoryBySymbol.get(entry.symbol) || null;
          const academySnapshot: AcademyCaseSnapshot | null = snapshotBundle
            ? {
                symbol: snapshotBundle.status?.symbol || entry.symbol || null,
                capturedAtMs: snapshotBundle.status?.capturedAtMs ?? null,
                imageDataUrl: snapshotBundle.imageDataUrl ?? null,
                savedPath: snapshotMemory?.savedPath ?? null,
                memoryKey: snapshotMemory?.key ?? null,
                frames: snapshotBundle.status?.frames ?? [],
                timeframes: snapshotBundle.status?.timeframes ?? timeframes,
                reasonCode: snapshotBundle.status?.reasonCode ?? null,
                payload: snapshotBundle.payload ?? null
              }
            : null;
          const brokerSnapshot = buildAcademyBrokerSnapshot(entry.symbol);
          void appendTruthEvent({
            eventType: 'signal_proposed',
            symbol: entry.symbol,
            payload: {
              signalId: entry.id,
              timeframe: entry.timeframe,
              action: entry.action,
              entryPrice: entry.entryPrice,
              stopLoss: entry.stopLoss,
              takeProfit: entry.takeProfit,
              probability: entry.probability,
              strategyMode: entry.strategyMode,
              reason: entry.reason || null,
              agentId: entry.agentId || null,
              agentName: entry.agentName || null,
              runId
            }
          });
          void upsertAcademyCase({
            entry,
            snapshot: academySnapshot,
            brokerSnapshot,
            event: {
              type: 'signal_proposed',
              payload: {
                signalId: entry.id,
                runId,
                agentId: entry.agentId || null
              }
            },
            source: 'signal_panel'
          });
        }
      }

      const autoCfg = autoPilotConfigRef.current || {};
      const allowAuto =
        signalAutoExecuteEnabled &&
        autoCfg?.enabled &&
        !autoCfg?.killSwitch &&
        !autoCfg?.requireConfirmation;
      if (allowAuto && newEntries.length > 0) {
        const minThreshold = probabilityMin;
        const maxThreshold = probabilityMax;
        const existingNow = new Set(signalEntriesRef.current.map((entry) => entry.id));
        for (const entry of newEntries) {
          if (existingNow.has(entry.id)) continue;
          const liveProfile = entry.agentId
            ? (shadowProfilesRef.current || []).find((item) => item.agentId === entry.agentId)
            : null;
          if (liveProfile?.liveDeployEnabled) continue;
          if (entry.probability >= minThreshold && entry.probability <= maxThreshold) {
            void executeSignalTrade(entry.id, 'autopilot', entry);
          }
        }
      }

      if (freshEntries.length > 0) {
        for (const entry of freshEntries) {
          if (signalShadowFollowEnabled) {
            void followShadowSignal(entry);
          }
          void followLiveSignal(entry);
        }
      }
      if (freshEntries.length > 0 || (signalEntriesRef.current || []).length > 0) {
        const excludeIds = new Set(freshEntries.map((entry) => entry.id));
        void maybeExecutePendingLiveSignals({ excludeIds });
      }
      scanCompleted = true;
    } catch (err: any) {
      const msg = err?.message ? String(err.message) : String(err || 'Signal scan failed.');
      setSignalLastError(msg);
      appendLiveError({
        source: 'signal.scan',
        level: 'error',
        message: msg,
        detail: err && typeof err === 'object' ? err : null
      });
    } finally {
      if (signalRunRef.current?.runId === runId) {
        signalRunRef.current = null;
      }
      setSignalRunning(false);
      if (scanCompleted) {
        const completedAt = Date.now();
        setSignalLastRunAtMs(completedAt);
        lastSuccessfulSignalScanAtRef.current = completedAt;
      }
      if (source === 'auto') {
        if (scanCompleted) {
          refreshSlaMonitor.noteRun(SIGNAL_AUTO_REFRESH_TASK_ID, Date.now());
        } else {
          refreshSlaMonitor.noteSkip(SIGNAL_AUTO_REFRESH_TASK_ID, 'scan_failed', Date.now());
        }
      }
      recordPerf('signalScans');
      recordPerf('signalScanLastDurationMs', Date.now() - scanStartedAt);
    }
  }, [
    appendTruthEvent,
    academyLessonLimit,
    agentScanEnabledById,
    agentFocusById,
    agentPerformanceById,
    buildAcademyBrokerSnapshot,
    buildAcademyLessonContextFor,
    buildAcademySymbolLearningContextFor,
    buildAgentScorecardContext,
    buildSignalEntryId,
    buildSignalNewsContext,
    buildSignalMemoryContext,
    buildSignalPrompt,
    buildSignalSnapshotTimeframes,
    buildSignalSystemContext,
    buildSignalWarmupBarsByTimeframe,
    buildTradeProposalFromSignal,
    captureChartChatSnapshot,
    executeSignalTrade,
    followLiveSignal,
    followShadowSignal,
    fetchNewsSnapshot,
    normalizeSignalProbability,
    parseSignalPayload,
    resolveChartChatSymbol,
    appendLiveError,
    signalAutoExecuteEnabled,
    signalExpiryMinutes,
    signalIncludePatterns,
    signalMemoryLimit,
    signalMemoryMode,
    signalProbabilityThreshold,
    signalProbabilityMax,
    signalRefreshIntervalMs,
    signalShadowFollowEnabled,
    signalRunning,
    maybeExecutePendingLiveSignals,
    recordPerf,
    signalStrategyModes,
    signalSymbols,
    signalTimeframes,
    tradeLockerExecRef,
    upsertAcademyCase,
    SIGNAL_AUTO_REFRESH_TASK_ID
  ]);

  useEffect(() => {
    signalAutoRefreshStateRef.current = {
      enabled: signalAutoRefreshEnabled,
      symbols: signalSymbols,
      running: signalRunning,
      lastRunAtMs: signalLastRunAtMs,
      sessions: signalSessions
    };
  }, [
    signalAutoRefreshEnabled,
    signalLastRunAtMs,
    signalRunning,
    signalSessions,
    signalSymbols
  ]);

  useEffect(() => {
    const ts = Number(signalLastRunAtMs || 0);
    if (Number.isFinite(ts) && ts > 0) {
      lastSuccessfulSignalScanAtRef.current = ts;
    }
  }, [signalLastRunAtMs]);

  useEffect(() => {
    runSignalScanAutoRef.current = runSignalScan;
  }, [runSignalScan]);

  useEffect(() => {
    const intervalMs = Number.isFinite(Number(signalRefreshIntervalMs))
      ? Math.max(5_000, Math.floor(Number(signalRefreshIntervalMs)))
      : DEFAULT_SIGNAL_REFRESH_MS;
    refreshSlaMonitor.ensureTask({
      id: SIGNAL_AUTO_REFRESH_TASK_ID,
      channel: 'signal',
      intervalMs
    });
    const checkEveryMs = Math.max(1_000, Math.min(10_000, Math.floor(intervalMs / 4)));
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadSignalControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createSignalController({
        taskId: SIGNAL_AUTO_REFRESH_TASK_ID,
        groupId: 'signal',
        intervalMs: checkEveryMs,
        jitterPct: 0.08,
        visibilityMode: 'always',
        priority: 'high',
        tick: async () => {
          const state = signalAutoRefreshStateRef.current;
          if (!state.enabled) return;
          if (!Array.isArray(state.symbols) || state.symbols.length === 0) return;
          if (!isSignalSessionOpen(state.sessions)) return;
          if (state.running) return;
          const now = Date.now();
          const lastRunAtMs = Number(state.lastRunAtMs || 0);
          const lastAttemptAtMs = Number(signalAutoRefreshAttemptAtRef.current || 0);
          const anchorAtMs = Math.max(lastRunAtMs, lastAttemptAtMs);
          if (anchorAtMs > 0 && now - anchorAtMs < intervalMs) return;
          signalAutoRefreshAttemptAtRef.current = now;
          await Promise.resolve(runSignalScanAutoRef.current('auto'));
        }
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [SIGNAL_AUTO_REFRESH_TASK_ID, isSignalSessionOpen, signalRefreshIntervalMs]);

  useEffect(() => {
    const nonCriticalGroups = ['signal', 'portfolio', 'native_chart', 'backtester', 'tradelocker', 'settings'];
    const dispose = runtimeScheduler.registerTask({
      id: SCHEDULER_CIRCUIT_GUARD_TASK_ID,
      groupId: 'health',
      intervalMs: 2000,
      jitterPct: 0.05,
      visibilityMode: 'always',
      priority: 'critical',
      run: () => {
        const now = Date.now();
        const sourceStates = brokerCircuitBreaker.getSourceSnapshot(now);
        const openSources = sourceStates.filter((entry) => entry.state === 'OPEN').map((entry) => entry.source);
        const bridgeDomains = getDomainReadiness();
        const bridgeHealthy =
          bridgeDomains.signal?.ready !== false &&
          bridgeDomains.snapshot?.ready !== false &&
          bridgeDomains.tradeLedger?.ready !== false;
        const shouldPause = openSources.length > 0 || !bridgeHealthy;
        if (schedulerCircuitPausedRef.current === shouldPause) return;
        schedulerCircuitPausedRef.current = shouldPause;
        for (const groupId of nonCriticalGroups) {
          if (shouldPause) runtimeScheduler.pauseGroup(groupId);
          else runtimeScheduler.resumeGroup(groupId);
        }
        void appendAuditEvent({
          eventType: 'scheduler_circuit_policy',
          level: shouldPause ? 'warn' : 'info',
          payload: {
            paused: shouldPause,
            openSources,
            bridgeHealthy
          }
        });
      }
    });
    return () => dispose();
  }, [appendAuditEvent]);

  const cancelSignalOrder = useCallback(async (entryId: string) => {
    const inFlight = signalCancelInFlightRef.current;
    if (inFlight.has(entryId)) return;
    inFlight.add(entryId);

    let target: SignalEntry | null = null;
    setSignalEntries((prev) =>
      prev.map((item) => {
        if (item.id !== entryId) return item;
        target = item;
        return { ...item };
      })
    );

    if (!target) {
      inFlight.delete(entryId);
      return;
    }
    if (target.status !== 'PENDING' && target.status !== 'SUBMITTING') {
      inFlight.delete(entryId);
      return;
    }

    const orderId = target.executionOrderId ? String(target.executionOrderId).trim() : '';
    if (!orderId || target.executionBroker !== 'tradelocker') {
      const msg = 'Pending TradeLocker order ID not available.';
      addNotification('Cancel Pending', msg, 'warning');
      setSignalEntries((prev) =>
        prev.map((item) => (item.id === entryId ? { ...item, executionError: msg } : item))
      );
      inFlight.delete(entryId);
      return;
    }

    const exec = executeBrokerActionRequestRef.current;
    if (!exec) {
      const msg = 'Broker action service unavailable.';
      addNotification('Cancel Pending', msg, 'warning');
      setSignalEntries((prev) =>
        prev.map((item) => (item.id === entryId ? { ...item, executionError: msg } : item))
      );
      inFlight.delete(entryId);
      return;
    }

    const res = await exec({
      type: 'CANCEL_ORDER',
      status: 'SUBMITTING',
      source: 'manual',
      orderId,
      symbol: target.symbol,
      reason: 'Signal cancel'
    });

    if (res?.ok || res?.duplicate) {
      const resolvedAtMs = Date.now();
      const cancelMsg = 'Cancelled pending order.';
      setSignalEntries((prev) =>
        prev.map((item) =>
          item.id === entryId
            ? {
                ...item,
                status: 'REJECTED',
                executionError: cancelMsg,
                resolvedAtMs,
                executionOrderStatus: 'CANCELLED'
              }
            : item
        )
      );
      void appendTruthEvent({
        eventType: 'signal_cancelled',
        symbol: target.symbol,
        payload: { signalId: entryId, orderId }
      });
      void upsertSignalHistory(
        {
          ...target,
          status: 'REJECTED',
          executionError: cancelMsg,
          resolvedAtMs,
          executionOrderStatus: 'CANCELLED'
        },
        {
          status: 'REJECTED',
          outcome: 'REJECTED',
          resolvedAtMs,
          orderId,
          executionBroker: target.executionBroker || 'tradelocker'
        }
      );
      void upsertAcademyCase({
        entry: {
          ...target,
          status: 'REJECTED',
          executionError: cancelMsg,
          resolvedAtMs,
          executionOrderStatus: 'CANCELLED'
        },
        patch: { status: 'REJECTED', resolvedAtMs, orderId },
        event: {
          type: 'signal_cancelled',
          payload: { signalId: entryId, orderId }
        },
        source: 'signal_panel'
      });
      inFlight.delete(entryId);
      return;
    }

    const error = res?.error ? String(res.error) : 'Failed to cancel order.';
    addNotification('Cancel Failed', error, 'error');
    setSignalEntries((prev) =>
      prev.map((item) => (item.id === entryId ? { ...item, executionError: error } : item))
    );
    void appendTruthEvent({
      eventType: 'signal_cancel_failed',
      symbol: target.symbol,
      payload: { signalId: entryId, error }
    });
    inFlight.delete(entryId);
  }, [addNotification, appendTruthEvent, upsertAcademyCase, upsertSignalHistory]);

  const rejectSignalEntry = useCallback((entryId: string, reason?: string) => {
    let target: SignalEntry | null = null;
    setSignalEntries((prev) =>
      prev.map((item) => {
        if (item.id !== entryId) return item;
        target = item;
        return { ...item, status: 'REJECTED', executionError: reason || 'Rejected by user.', resolvedAtMs: Date.now() };
      })
    );
    if (target) {
      void appendTruthEvent({
        eventType: 'signal_rejected',
        symbol: target.symbol,
        payload: { signalId: entryId, reason: reason || 'rejected' }
      });
      void upsertSignalHistory(
        { ...target, status: 'REJECTED', executionError: reason || 'Rejected by user.', resolvedAtMs: Date.now() },
        { status: 'REJECTED', outcome: 'REJECTED', resolvedAtMs: Date.now() }
      );
      void upsertAcademyCase({
        entry: { ...target, status: 'REJECTED', executionError: reason || 'Rejected by user.', resolvedAtMs: Date.now() },
        patch: { status: 'REJECTED', resolvedAtMs: Date.now() },
        event: {
          type: 'signal_rejected',
          payload: { signalId: entryId, reason: reason || 'rejected' }
        },
        source: 'signal_panel'
      });
    }
  }, [appendTruthEvent, upsertAcademyCase, upsertSignalHistory]);

  const clearSignalEntries = useCallback(async () => {
    setSignalEntries([]);
    setSignalSimulatedOutcomes({});
    simulatedOutcomeRef.current.clear();
    signalEntriesPersistedRef.current.clear();
    signalTelegramSentRef.current.clear();
    signalTelegramWarmStartRef.current = true;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory || !ledger?.deleteAgentMemory) return;
    try {
      const res = await ledger.listAgentMemory({ kind: 'signal_entry', limit: 2000 });
      if (res?.ok && Array.isArray(res.memories)) {
        for (const entry of res.memories) {
          const key = entry?.key != null ? String(entry.key) : '';
          const id = entry?.id != null ? String(entry.id) : '';
          if (!key && !id) continue;
          try {
            await ledger.deleteAgentMemory({ key: key || undefined, id: id || undefined });
          } catch {
            // ignore delete failures
          }
        }
      }
    } catch {
      // ignore ledger failures
    }
  }, []);

  const resolveSignalExpiryReason = useCallback(
    (entry: SignalEntry, autoCfg: AutoPilotStateSnapshot | null, minThreshold: number, maxThreshold: number) => {
      const autoEnabled = !!autoCfg?.enabled;
      const killSwitch = !!autoCfg?.killSwitch;
      const requireConfirmation = !!autoCfg?.requireConfirmation;
      if (entry.status === 'FAILED') {
        return { code: 'execution_failed', detail: entry.executionError || 'Execution failed.' };
      }
      if (entry.status === 'SUBMITTING' || entry.status === 'PENDING') {
        return { code: 'execution_pending', detail: 'Execution still pending.' };
      }
      if (!signalAutoExecuteEnabled) {
        return { code: 'auto_execute_disabled', detail: 'Auto execute disabled.' };
      }
      if (!autoEnabled) {
        return { code: 'autopilot_off', detail: 'Autopilot disabled.' };
      }
      if (killSwitch) {
        return { code: 'kill_switch', detail: 'Kill switch active.' };
      }
      if (requireConfirmation) {
        return { code: 'requires_confirmation', detail: 'Confirmation required.' };
      }
      if (entry.probability < minThreshold) {
        return {
          code: 'below_min_threshold',
          detail: `Probability ${Math.round(entry.probability)} below ${minThreshold}.`
        };
      }
      if (entry.probability > maxThreshold) {
        return {
          code: 'above_max_threshold',
          detail: `Probability ${Math.round(entry.probability)} above ${maxThreshold}.`
        };
      }
      return { code: 'unexecuted', detail: 'Not executed before expiry.' };
    },
    [signalAutoExecuteEnabled]
  );

  useEffect(() => {
    let stop: (() => void) | null = null;
    let cancelled = false;
    const tick = async () => {
      const now = Date.now();
      const ledger = window.glass?.tradeLedger;
      const entriesNow = Array.isArray(signalEntriesRef.current) ? signalEntriesRef.current : [];
      const needsLedger = entriesNow.some((entry) => entry?.executionLedgerId);
      const ledgerById = new Map<string, any>();
      if (needsLedger && ledger?.list) {
        try {
          const res = await ledger.list({ limit: 400 });
          if (res?.ok && Array.isArray(res.entries)) {
            for (const item of res.entries) {
              if (!item?.id) continue;
              ledgerById.set(String(item.id), item);
            }
          }
        } catch {
          // ignore ledger failures
        }
      }

      const ordersHistory = Array.isArray(tlOrdersHistoryRef.current) ? tlOrdersHistoryRef.current : [];
      const ordersHistoryById = new Map<string, any>();
      for (const ord of ordersHistory) {
        if (!ord) continue;
        const id = String(ord?.id || '').trim();
        if (id) ordersHistoryById.set(id, ord);
      }

      const normalizeStatus = (value: any) => String(value || '').trim().toUpperCase();
      const isRejectedStatus = (value: any) => {
        const s = normalizeStatus(value);
        return s.includes('REJECT') || s.includes('DENY') || s.includes('FAIL');
      };
      const isCanceledStatus = (value: any) => {
        const s = normalizeStatus(value);
        return s.includes('CANCEL') || s.includes('CANCELED') || s.includes('CANCELLED') || s.includes('EXPIRE') || s.includes('EXPIRED');
      };
      const isFilledStatus = (value: any) => {
        const s = normalizeStatus(value);
        return s.includes('FILL') || s.includes('EXECUT') || s.includes('DONE') || s.includes('COMPLETE');
      };

      const events: Array<{ eventType: string; symbol: string; payload: Record<string, any> }> = [];
      const historyUpdates: Array<{ entry: SignalEntry; patch: Partial<SignalHistoryEntry> }> = [];
      const reviewUpdates: Array<{ entry: SignalEntry; outcome: 'WIN' | 'LOSS'; score: number; exitPrice: number; resolvedAtMs: number; durationMs?: number | null; barsToOutcome?: number | null }> = [];

      setSignalEntries((prev) => {
        let changed = false;
        const next = prev.map((entry) => {
          if (!entry) return entry;
          if (entry.status === 'WIN' || entry.status === 'LOSS' || entry.status === 'EXPIRED' || entry.status === 'REJECTED') {
            return entry;
          }

          const ledgerId = entry.executionLedgerId ? String(entry.executionLedgerId) : '';
          const ledgerEntry = ledgerId ? ledgerById.get(ledgerId) : null;
          const broker = entry.executionBroker || (ledgerEntry?.broker ? String(ledgerEntry.broker) : null);

          let nextStatus: SignalEntry['status'] = entry.status;
          let executedAtMs = entry.executedAtMs ?? null;
          let resolvedAtMs = entry.resolvedAtMs ?? null;
          let executionError = entry.executionError ?? null;
          const patch: Partial<SignalEntry> = {};

          if (ledgerEntry) {
            const ledgerStatus = normalizeStatus(ledgerEntry?.status);
            const positionStatus = normalizeStatus(ledgerEntry?.positionStatus);
            const closedAtMs = Number(ledgerEntry?.positionClosedAtMs || 0);
            const isClosed = positionStatus === 'CLOSED' || ledgerStatus === 'CLOSED' || closedAtMs > 0;
            const isOpen = positionStatus === 'OPEN' || ledgerStatus === 'OPEN';
            const isAccepted = ledgerStatus === 'ACCEPTED' || ledgerStatus === 'PENDING' || ledgerStatus === 'SUBMITTING' || ledgerStatus === 'WORKING';
            const isRejected = isRejectedStatus(ledgerStatus) || isCanceledStatus(ledgerStatus);

            const ledgerOrderId = ledgerEntry?.brokerOrderId != null ? String(ledgerEntry.brokerOrderId) : null;
            const ledgerPositionId = ledgerEntry?.positionId != null ? String(ledgerEntry.positionId) : null;
            const ledgerOrderStatus = ledgerEntry?.brokerOrderStatus != null ? String(ledgerEntry.brokerOrderStatus) : null;

            if (ledgerOrderId && ledgerOrderId !== entry.executionOrderId) patch.executionOrderId = ledgerOrderId;
            if (ledgerPositionId && ledgerPositionId !== entry.executionPositionId) patch.executionPositionId = ledgerPositionId;
            if (ledgerOrderStatus && ledgerOrderStatus !== entry.executionOrderStatus) patch.executionOrderStatus = ledgerOrderStatus;
            if (!entry.executionBroker && broker) patch.executionBroker = broker as any;

            if (isClosed) {
              const realizedRaw = ledgerEntry?.realizedPnl ?? ledgerEntry?.positionClosedPnl ?? ledgerEntry?.positionClosedPnlEstimate;
              const realized = Number.isFinite(Number(realizedRaw)) ? Number(realizedRaw) : null;
              const exitRaw = ledgerEntry?.brokerClosePrice ?? ledgerEntry?.closePrice ?? ledgerEntry?.positionClosePrice;
              const exitPrice = Number.isFinite(Number(exitRaw)) ? Number(exitRaw) : null;
              const resolvedAt = closedAtMs > 0 ? closedAtMs : now;
              let outcome: 'WIN' | 'LOSS' | null = null;
              if (realized != null) {
                outcome = realized > 0 ? 'WIN' : 'LOSS';
              } else if (exitPrice != null && Number.isFinite(exitPrice)) {
                const hitTp = entry.action === 'BUY'
                  ? exitPrice >= entry.takeProfit
                  : exitPrice <= entry.takeProfit;
                const hitSl = entry.action === 'BUY'
                  ? exitPrice <= entry.stopLoss
                  : exitPrice >= entry.stopLoss;
                if (hitTp || hitSl) outcome = hitTp ? 'WIN' : 'LOSS';
              }

              if (outcome) {
                nextStatus = outcome;
                resolvedAtMs = resolvedAt;
                executionError = null;
                const score = computeSignalOutcomeScore(entry, outcome);
                const startAtMs = executedAtMs ?? entry.executedAtMs ?? entry.createdAtMs ?? null;
                const durationMs =
                  Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(resolvedAt))
                    ? Math.max(0, Number(resolvedAt) - Number(startAtMs))
                    : null;
                events.push({
                  eventType: outcome === 'WIN' ? 'signal_outcome_win' : 'signal_outcome_loss',
                  symbol: entry.symbol,
                  payload: {
                    signalId: entry.id,
                    exitPrice,
                    takeProfit: entry.takeProfit,
                    stopLoss: entry.stopLoss,
                    resolvedAtMs: resolvedAt,
                    score,
                    agentId: entry.agentId || null
                  }
                });
                historyUpdates.push({
                  entry: { ...entry, ...patch, status: nextStatus, resolvedAtMs },
                  patch: {
                    status: nextStatus,
                    outcome: nextStatus,
                    resolvedAtMs: resolvedAt,
                    exitPrice: exitPrice ?? null,
                    score,
                    durationMs
                  }
                });
                if (exitPrice != null && Number.isFinite(exitPrice)) {
                  reviewUpdates.push({
                    entry: { ...entry, ...patch, status: nextStatus, resolvedAtMs },
                    outcome,
                    score,
                    exitPrice,
                    resolvedAtMs: resolvedAt,
                    durationMs,
                    barsToOutcome: null
                  });
                }
              }
            } else if (isOpen) {
              if (nextStatus !== 'EXECUTED') {
                nextStatus = 'EXECUTED';
                executedAtMs =
                  Number(ledgerEntry?.positionOpenedAtMs || 0) ||
                  Number(ledgerEntry?.brokerAcceptedAtMs || 0) ||
                  Number(ledgerEntry?.createdAtMs || 0) ||
                  now;
                events.push({
                  eventType: 'signal_executed',
                  symbol: entry.symbol,
                  payload: {
                    signalId: entry.id,
                    executedAtMs,
                    orderId: ledgerOrderId,
                    positionId: ledgerPositionId,
                    orderStatus: ledgerOrderStatus,
                    broker
                  }
                });
                historyUpdates.push({
                  entry: { ...entry, ...patch, status: nextStatus, executedAtMs },
                  patch: { status: nextStatus, executedAtMs }
                });
              }
            } else if (isRejected) {
              if (nextStatus !== 'REJECTED') {
                nextStatus = 'REJECTED';
                resolvedAtMs = now;
                executionError = ledgerEntry?.error ? String(ledgerEntry.error) : (ledgerOrderStatus ? `Order ${ledgerOrderStatus}` : 'Order rejected.');
                events.push({
                  eventType: 'signal_rejected',
                  symbol: entry.symbol,
                  payload: {
                    signalId: entry.id,
                    orderId: ledgerOrderId,
                    orderStatus: ledgerOrderStatus,
                    broker
                  }
                });
                historyUpdates.push({
                  entry: { ...entry, ...patch, status: nextStatus, resolvedAtMs },
                  patch: { status: nextStatus, outcome: 'REJECTED', resolvedAtMs }
                });
              }
            } else if (isAccepted) {
              if (nextStatus !== 'PENDING') {
                nextStatus = 'PENDING';
                historyUpdates.push({
                  entry: { ...entry, ...patch, status: nextStatus },
                  patch: { status: nextStatus }
                });
              }
            }
          } else {
            const orderId = entry.executionOrderId ? String(entry.executionOrderId) : '';
            const historyMatch = orderId ? ordersHistoryById.get(orderId) : null;
            const history = historyMatch || null;
            if (history) {
              const historyStatus = normalizeStatus(history?.status);
              const orderStatus = history?.status != null ? String(history.status) : null;
              if (orderStatus && orderStatus !== entry.executionOrderStatus) patch.executionOrderStatus = orderStatus;
              if (history?.id && String(history.id) !== entry.executionOrderId) patch.executionOrderId = String(history.id);
              if (!entry.executionBroker) patch.executionBroker = 'tradelocker' as any;

              if (isFilledStatus(historyStatus)) {
                if (nextStatus !== 'EXECUTED') {
                  nextStatus = 'EXECUTED';
                  const filledAtMs = history?.filledAt ? Date.parse(String(history.filledAt)) : NaN;
                  executedAtMs = Number.isFinite(filledAtMs) ? filledAtMs : now;
                  events.push({
                    eventType: 'signal_executed',
                    symbol: entry.symbol,
                    payload: {
                      signalId: entry.id,
                      executedAtMs,
                      orderId: patch.executionOrderId || entry.executionOrderId || null,
                      orderStatus: orderStatus || null,
                      broker: 'tradelocker'
                    }
                  });
                  historyUpdates.push({
                    entry: { ...entry, ...patch, status: nextStatus, executedAtMs },
                    patch: { status: nextStatus, executedAtMs }
                  });
                }
              } else if (isRejectedStatus(historyStatus) || isCanceledStatus(historyStatus)) {
                if (nextStatus !== 'REJECTED') {
                  nextStatus = 'REJECTED';
                  resolvedAtMs = now;
                  executionError = orderStatus ? `Order ${orderStatus}` : 'Order rejected.';
                  events.push({
                    eventType: 'signal_rejected',
                    symbol: entry.symbol,
                    payload: {
                      signalId: entry.id,
                      orderId: patch.executionOrderId || entry.executionOrderId || null,
                      orderStatus: orderStatus || null,
                      broker: 'tradelocker'
                    }
                  });
                  historyUpdates.push({
                    entry: { ...entry, ...patch, status: nextStatus, resolvedAtMs },
                    patch: { status: nextStatus, outcome: 'REJECTED', resolvedAtMs }
                  });
                }
              }
            }
          }

          const entryChanged =
            Object.keys(patch).length > 0 ||
            nextStatus !== entry.status ||
            executedAtMs !== entry.executedAtMs ||
            resolvedAtMs !== entry.resolvedAtMs ||
            executionError !== entry.executionError;
          if (!entryChanged) return entry;
          changed = true;
          return {
            ...entry,
            ...patch,
            status: nextStatus,
            executedAtMs,
            resolvedAtMs,
            executionError
          };
        });
        return changed ? next : prev;
      });

      for (const evt of events) {
        void appendTruthEvent({
          eventType: evt.eventType,
          symbol: evt.symbol,
          payload: evt.payload
        });
      }
      for (const update of historyUpdates) {
        void upsertSignalHistory(update.entry, update.patch);
      }
      for (const review of reviewUpdates) {
        void upsertSignalReview(review.entry, {
          outcome: review.outcome,
          score: review.score,
          exitPrice: review.exitPrice,
          resolvedAtMs: review.resolvedAtMs,
          durationMs: review.durationMs ?? null,
          barsToOutcome: review.barsToOutcome ?? null
        });
      }
      for (const update of historyUpdates) {
        const status = String(update.patch.status || update.entry.status || '').toUpperCase();
        const eventType =
          status === 'EXECUTED'
            ? 'signal_executed'
            : status === 'PENDING'
              ? 'signal_pending'
              : status === 'REJECTED'
                ? 'signal_rejected'
                : status === 'EXPIRED'
                  ? 'signal_expired'
                  : '';
        await upsertAcademyCase({
          entry: update.entry,
          patch: update.patch as any,
          event: eventType ? { type: eventType, payload: { signalId: update.entry.id, status } } : undefined,
          source: 'signal_panel'
        });
      }
      for (const review of reviewUpdates) {
        const payload = await upsertAcademyCase({
          entry: review.entry,
          patch: {
            status: review.outcome,
            outcome: review.outcome,
            score: review.score,
            exitPrice: review.exitPrice,
            resolvedAtMs: review.resolvedAtMs,
            durationMs: review.durationMs ?? null,
            barsToOutcome: review.barsToOutcome ?? null
          },
          event: {
            type: 'signal_outcome',
            payload: {
              signalId: review.entry.id,
              outcome: review.outcome,
              score: review.score
            }
          },
          source: 'signal_panel'
        });
        if (payload) {
          void maybeAutoAcceptAcademyCase(payload);
        }
      }
    };
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 7000,
        runOnStart: true,
        onTick: () => tick()
      });
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [appendTruthEvent, computeSignalOutcomeScore, maybeAutoAcceptAcademyCase, upsertAcademyCase, upsertSignalHistory, upsertSignalReview]);

  useEffect(() => {
    let stop: (() => void) | null = null;
    let cancelled = false;
    const tick = async () => {
      if (!backgroundWatchersEnabledRef.current) return;
      const now = Date.now();
      const quotes = quotesBySymbolRef.current || {};
      const autoCfg = autoPilotConfigRef.current || null;
      const minThreshold = Math.max(1, Math.min(100, signalProbabilityThreshold));
      const maxThreshold = Math.max(minThreshold, Math.min(100, signalProbabilityMax));
      const autoState = {
        autoExecuteEnabled: signalAutoExecuteEnabled,
        enabled: !!autoCfg?.enabled,
        killSwitch: !!autoCfg?.killSwitch,
        requireConfirmation: !!autoCfg?.requireConfirmation,
        minThreshold,
        maxThreshold
      };
      const events: Array<{ eventType: string; symbol: string; payload: Record<string, any> }> = [];
      const historyUpdates: Array<{ entry: SignalEntry; patch: Partial<SignalHistoryEntry> }> = [];
      const reviewUpdates: Array<{ entry: SignalEntry; outcome: 'WIN' | 'LOSS'; score: number; exitPrice: number; resolvedAtMs: number; durationMs?: number | null; barsToOutcome?: number | null }> = [];
      setSignalEntries((prev) => {
        let changed = false;
        const next = prev.map((entry) => {
          if (!entry) return entry;
          if (entry.status === 'WIN' || entry.status === 'LOSS' || entry.status === 'EXPIRED' || entry.status === 'REJECTED') {
            return entry;
          }
          if (entry.status === 'EXECUTED') {
            if (entry.executionBroker === 'tradelocker' || entry.executionLedgerId) {
              return entry;
            }
            const directQuote = quotes[entry.symbol];
            const normalizedKey = normalizeSymbolKey(entry.symbol);
            const fallbackQuote = quotes[normalizedKey];
            const quote = directQuote || fallbackQuote;
            const bid = Number(quote?.bid ?? quote?.Bid ?? quote?.b);
            const ask = Number(quote?.ask ?? quote?.Ask ?? quote?.a);
            const mid = Number(quote?.mid ?? quote?.price ?? quote?.last ?? quote?.close);
            const exitPrice = entry.action === 'SELL'
              ? (Number.isFinite(ask) ? ask : mid)
              : (Number.isFinite(bid) ? bid : mid);
            if (!Number.isFinite(exitPrice)) return entry;
            const hitTp = entry.action === 'BUY'
              ? exitPrice >= entry.takeProfit
              : exitPrice <= entry.takeProfit;
            const hitSl = entry.action === 'BUY'
              ? exitPrice <= entry.stopLoss
              : exitPrice >= entry.stopLoss;
            if (!hitTp && !hitSl) return entry;
            const status: SignalEntry['status'] = hitTp ? 'WIN' : 'LOSS';
            const score = computeSignalOutcomeScore(entry, status === 'WIN' ? 'WIN' : 'LOSS');
            const startAtMs = entry.executedAtMs ?? entry.createdAtMs ?? null;
            const durationMs =
              Number.isFinite(Number(startAtMs))
                ? Math.max(0, now - Number(startAtMs))
                : null;
            changed = true;
            events.push({
              eventType: hitTp ? 'signal_outcome_win' : 'signal_outcome_loss',
              symbol: entry.symbol,
              payload: {
                signalId: entry.id,
                exitPrice,
                takeProfit: entry.takeProfit,
                stopLoss: entry.stopLoss,
                resolvedAtMs: now,
                score,
                agentId: entry.agentId || null
              }
            });
            historyUpdates.push({
              entry: { ...entry, status, resolvedAtMs: now },
              patch: {
                status,
                outcome: status,
                resolvedAtMs: now,
                exitPrice,
                score,
                durationMs
              }
            });
            reviewUpdates.push({
              entry: { ...entry, status, resolvedAtMs: now },
              outcome: status === 'WIN' ? 'WIN' : 'LOSS',
              score,
              exitPrice,
              resolvedAtMs: now,
              durationMs,
              barsToOutcome: null
            });
            return {
              ...entry,
              status,
              executionError: null,
              resolvedAtMs: now
            };
          }
          const expiresAt = entry.expiresAtMs || null;
          if (entry.status === 'PENDING') return entry;
          if (expiresAt && now >= expiresAt) {
            const reason = resolveSignalExpiryReason(entry, autoCfg, minThreshold, maxThreshold);
            changed = true;
            events.push({
              eventType: 'signal_expired',
              symbol: entry.symbol,
              payload: {
                signalId: entry.id,
                reason: reason.code,
                detail: reason.detail,
                expiredAtMs: now,
                expiresAtMs: expiresAt,
                createdAtMs: entry.createdAtMs,
                statusAtExpiry: entry.status,
                probability: entry.probability,
                runId: entry.runId || null,
                autoState
              }
            });
            historyUpdates.push({
              entry: { ...entry, status: 'EXPIRED', resolvedAtMs: now },
              patch: {
                status: 'EXPIRED',
                outcome: 'EXPIRED',
                resolvedAtMs: now,
                durationMs: Math.max(0, now - entry.createdAtMs)
              }
            });
            return {
              ...entry,
              status: 'EXPIRED',
              executionError: entry.executionError || `Expired (${reason.code}).`,
              resolvedAtMs: now
            };
          }
          return entry;
        });
        return changed ? next : prev;
      });
      for (const evt of events) {
        void appendTruthEvent({
          eventType: evt.eventType,
          symbol: evt.symbol,
          payload: evt.payload
        });
      }
      for (const update of historyUpdates) {
        void upsertSignalHistory(update.entry, update.patch);
      }
      for (const review of reviewUpdates) {
        void upsertSignalReview(review.entry, {
          outcome: review.outcome,
          score: review.score,
          exitPrice: review.exitPrice,
          resolvedAtMs: review.resolvedAtMs,
          durationMs: review.durationMs ?? null,
          barsToOutcome: review.barsToOutcome ?? null
        });
      }
      for (const update of historyUpdates) {
        const status = String(update.patch.status || update.entry.status || '').toUpperCase();
        const eventType =
          status === 'EXECUTED'
            ? 'signal_executed'
            : status === 'PENDING'
              ? 'signal_pending'
              : status === 'REJECTED'
                ? 'signal_rejected'
                : status === 'EXPIRED'
                  ? 'signal_expired'
                  : '';
        await upsertAcademyCase({
          entry: update.entry,
          patch: update.patch as any,
          event: eventType ? { type: eventType, payload: { signalId: update.entry.id, status } } : undefined,
          source: 'signal_panel'
        });
      }
      for (const review of reviewUpdates) {
        const payload = await upsertAcademyCase({
          entry: review.entry,
          patch: {
            status: review.outcome,
            outcome: review.outcome,
            score: review.score,
            exitPrice: review.exitPrice,
            resolvedAtMs: review.resolvedAtMs,
            durationMs: review.durationMs ?? null,
            barsToOutcome: review.barsToOutcome ?? null
          },
          event: {
            type: 'signal_outcome',
            payload: {
              signalId: review.entry.id,
              outcome: review.outcome,
              score: review.score
            }
          },
          source: 'signal_panel'
        });
        if (payload) {
          void maybeAutoAcceptAcademyCase(payload);
        }
      }
    };
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 5000,
        onTick: () => tick()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [
    appendTruthEvent,
    computeSignalOutcomeScore,
    resolveSignalExpiryReason,
    signalAutoExecuteEnabled,
    signalProbabilityThreshold,
    signalProbabilityMax,
    upsertAcademyCase,
    maybeAutoAcceptAcademyCase,
    upsertSignalHistory,
    upsertSignalReview
  ]);

  useEffect(() => {
    let stop: (() => void) | null = null;
    let cancelled = false;
    const tick = async () => {
      if (!backgroundWatchersEnabledRef.current) return;
      const now = Date.now();
      const entries = Array.isArray(signalEntriesRef.current) ? signalEntriesRef.current : [];
      if (entries.length === 0) return;

      const removeIds = new Set<string>();
      for (const entry of entries) {
        if (!entry) continue;
        if (entry.executionBroker || entry.executionLedgerId || entry.executionOrderId) {
          simulatedOutcomeRef.current.delete(entry.id);
          removeIds.add(entry.id);
          continue;
        }
        if (entry.status === 'EXECUTED' || entry.status === 'PENDING' || entry.status === 'SUBMITTING' || entry.status === 'WIN' || entry.status === 'LOSS') {
          simulatedOutcomeRef.current.delete(entry.id);
          removeIds.add(entry.id);
        }
      }

      const pending = entries.filter((entry) => {
        if (!entry) return false;
        if (entry.status === 'WIN' || entry.status === 'LOSS' || entry.status === 'EXPIRED' || entry.status === 'REJECTED' || entry.status === 'FAILED') return false;
        if (entry.status === 'EXECUTED' || entry.status === 'PENDING' || entry.status === 'SUBMITTING') return false;
        if (entry.executionBroker || entry.executionLedgerId || entry.executionOrderId) return false;
        const cached = simulatedOutcomeRef.current.get(entry.id);
        if (cached && cached.createdAtMs === entry.createdAtMs) return false;
        return true;
      });
      if (pending.length === 0) return;

      const needsBySymbol = new Map<string, { timeframes: Set<string>; maxLookaheadMs: number }>();
      for (const entry of pending) {
        const symbol = String(entry.symbol || '').trim();
        if (!symbol) continue;
        const record = needsBySymbol.get(symbol) || { timeframes: new Set<string>(), maxLookaheadMs: 0 };
        record.timeframes.add('1m');
        const fallback = normalizeTimeframeKey(entry.timeframe || '');
        if (fallback && fallback !== '1m') record.timeframes.add(fallback);
        const expiryAtMs = Number.isFinite(Number(entry.expiresAtMs))
          ? Number(entry.expiresAtMs)
          : (entry.createdAtMs + signalExpiryMinutes * 60_000);
        const lookaheadMs = Math.max(0, expiryAtMs - entry.createdAtMs);
        if (lookaheadMs > record.maxLookaheadMs) record.maxLookaheadMs = lookaheadMs;
        needsBySymbol.set(symbol, record);
      }

      const refreshes: Array<Promise<any>> = [];
      for (const [symbol, needs] of needsBySymbol.entries()) {
        const timeframes = Array.from(needs.timeframes);
        if (timeframes.length === 0) continue;
        const barsBackfillByTimeframe = buildSimWarmupBarsByTimeframe(timeframes, needs.maxLookaheadMs);
        refreshes.push(
          chartEngine.refreshSessionsForSymbol(symbol, timeframes, { force: false, barsBackfillByTimeframe }).catch(() => null)
        );
      }
      if (refreshes.length > 0) {
        await Promise.all(refreshes);
      }

      const snapshots = chartEngine.getSnapshots({ barsLimit: 600, eventsLimit: 0, includeInactive: true });
      const snapshotByKey = new Map<string, any>();
      for (const snap of snapshots) {
        if (!snap) continue;
        const symbolKey = normalizeSymbolKey(snap.symbol);
        const tfKey = normalizeTimeframeKey(snap.timeframe);
        if (!symbolKey || !tfKey) continue;
        const key = `${symbolKey}::${tfKey}`;
        const existing = snapshotByKey.get(key);
        if (!existing || Number(snap.updatedAtMs || 0) > Number(existing.updatedAtMs || 0)) {
          snapshotByKey.set(key, snap);
        }
      }

      const events: Array<{ eventType: string; symbol: string; payload: Record<string, any> }> = [];
      const historyUpdates: Array<{ entry: SignalEntry; patch: Partial<SignalHistoryEntry> }> = [];
      const reviewUpdates: Array<{ entry: SignalEntry; outcome: 'WIN' | 'LOSS'; score: number; exitPrice: number; resolvedAtMs: number; durationMs?: number | null; barsToOutcome?: number | null }> = [];
      const academyUpdates: Array<{ entry: SignalEntry; patch: Partial<AcademyCase>; event: { type: string; payload: Record<string, any> } }> = [];

      const outcomeUpdates: Record<string, {
        outcome: 'WIN' | 'LOSS' | 'EXPIRED';
        resolvedAtMs: number;
        exitPrice?: number | null;
        timeframe?: string;
        barsToOutcome?: number | null;
        durationMs?: number | null;
      }> = {};

      for (const entry of pending) {
        const cached = simulatedOutcomeRef.current.get(entry.id);
        if (cached && cached.createdAtMs === entry.createdAtMs) continue;
        const symbolKey = normalizeSymbolKey(entry.symbol);
        if (!symbolKey) continue;

        const fallback = normalizeTimeframeKey(entry.timeframe || '');
        const primaryKey = `${symbolKey}::1m`;
        const fallbackKey = fallback ? `${symbolKey}::${fallback}` : '';
        let snap = snapshotByKey.get(primaryKey) || null;
        let timeframeUsed = '1m';
        if (!snap || !Array.isArray(snap.barsTail) || snap.barsTail.length < 2) {
          if (fallbackKey) {
            const fallbackSnap = snapshotByKey.get(fallbackKey) || null;
            if (fallbackSnap && Array.isArray(fallbackSnap.barsTail) && fallbackSnap.barsTail.length > 0) {
              snap = fallbackSnap;
              timeframeUsed = fallback || timeframeUsed;
            }
          }
        }
        const expiryAtMs = Number.isFinite(Number(entry.expiresAtMs))
          ? Number(entry.expiresAtMs)
          : (entry.createdAtMs + signalExpiryMinutes * 60_000);
        if (!snap || !Array.isArray(snap.barsTail) || snap.barsTail.length === 0) {
          if (now >= expiryAtMs) {
            simulatedOutcomeRef.current.set(entry.id, {
              createdAtMs: entry.createdAtMs,
              outcome: 'EXPIRED',
              resolvedAtMs: expiryAtMs,
              exitPrice: null,
              timeframe: timeframeUsed,
              barsToOutcome: null,
              durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
            });
            outcomeUpdates[entry.id] = {
              outcome: 'EXPIRED',
              resolvedAtMs: expiryAtMs,
              exitPrice: null,
              timeframe: timeframeUsed,
              barsToOutcome: null,
              durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
            };
            const simEntry = {
              ...entry,
              executionBroker: entry.executionBroker ?? 'sim',
              executionMode: entry.executionMode ?? 'simulated'
            };
            events.push({
              eventType: 'signal_outcome_simulated',
              symbol: entry.symbol,
              payload: {
                signalId: entry.id,
                outcome: 'EXPIRED',
                resolvedAtMs: expiryAtMs,
                timeframe: timeframeUsed,
                durationMs: Math.max(0, expiryAtMs - entry.createdAtMs),
                source: 'simulated',
                reason: 'no_data'
              }
            });
            historyUpdates.push({
              entry: simEntry,
              patch: {
                status: 'EXPIRED',
                outcome: 'EXPIRED',
                resolvedAtMs: expiryAtMs,
                durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
              }
            });
            academyUpdates.push({
              entry: simEntry,
              patch: {
                status: 'EXPIRED',
                outcome: 'EXPIRED',
                resolvedAtMs: expiryAtMs,
                durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
              },
              event: {
                type: 'signal_outcome_simulated',
                payload: {
                  signalId: entry.id,
                  outcome: 'EXPIRED',
                  timeframe: timeframeUsed,
                  durationMs: Math.max(0, expiryAtMs - entry.createdAtMs),
                  source: 'simulated',
                  reason: 'no_data'
                }
              }
            });
          }
          continue;
        }
        const resMs = resolutionToMs(timeframeUsed) || 60_000;
        const firstBarStart = Number(snap.barsTail[0]?.t ?? 0) || 0;
        if (firstBarStart && entry.createdAtMs < (firstBarStart - resMs)) continue;
        const windowEndMs = Math.min(now, expiryAtMs);
        const sim = resolveSimulatedOutcomeFromBars(entry, snap.barsTail, timeframeUsed, windowEndMs);

        if (sim) {
          const score = computeSignalOutcomeScore(entry, sim.outcome);
          simulatedOutcomeRef.current.set(entry.id, {
            createdAtMs: entry.createdAtMs,
            outcome: sim.outcome,
            resolvedAtMs: sim.resolvedAtMs,
            exitPrice: sim.exitPrice,
            timeframe: timeframeUsed,
            barsToOutcome: sim.barsToOutcome ?? null,
            durationMs: sim.durationMs ?? null
          });
          outcomeUpdates[entry.id] = {
            outcome: sim.outcome,
            resolvedAtMs: sim.resolvedAtMs,
            exitPrice: sim.exitPrice,
            timeframe: timeframeUsed,
            barsToOutcome: sim.barsToOutcome ?? null,
            durationMs: sim.durationMs ?? null
          };
          const simEntry = {
            ...entry,
            executionBroker: entry.executionBroker ?? 'sim',
            executionMode: entry.executionMode ?? 'simulated'
          };
          events.push({
            eventType: 'signal_outcome_simulated',
            symbol: entry.symbol,
            payload: {
              signalId: entry.id,
              outcome: sim.outcome,
              exitPrice: sim.exitPrice,
              resolvedAtMs: sim.resolvedAtMs,
              timeframe: timeframeUsed,
              barsToOutcome: sim.barsToOutcome ?? null,
              durationMs: sim.durationMs ?? null,
              source: 'simulated'
            }
          });
          historyUpdates.push({
            entry: simEntry,
            patch: {
              status: sim.outcome,
              outcome: sim.outcome,
              resolvedAtMs: sim.resolvedAtMs,
              exitPrice: sim.exitPrice,
              score,
              durationMs: sim.durationMs ?? null,
              barsToOutcome: sim.barsToOutcome ?? null
            }
          });
          reviewUpdates.push({
            entry: simEntry,
            outcome: sim.outcome,
            score,
            exitPrice: sim.exitPrice,
            resolvedAtMs: sim.resolvedAtMs,
            durationMs: sim.durationMs ?? null,
            barsToOutcome: sim.barsToOutcome ?? null
          });
          academyUpdates.push({
            entry: simEntry,
            patch: {
              status: sim.outcome,
              outcome: sim.outcome,
              score,
              exitPrice: sim.exitPrice,
              resolvedAtMs: sim.resolvedAtMs,
              durationMs: sim.durationMs ?? null,
              barsToOutcome: sim.barsToOutcome ?? null
            },
            event: {
              type: 'signal_outcome_simulated',
              payload: {
                signalId: entry.id,
                outcome: sim.outcome,
                timeframe: timeframeUsed,
                barsToOutcome: sim.barsToOutcome ?? null,
                durationMs: sim.durationMs ?? null,
                source: 'simulated'
              }
            }
          });
          continue;
        }

        if (now < expiryAtMs) continue;
        const lastBar = snap.barsTail[snap.barsTail.length - 1];
        const lastBarEndMs = (Number(lastBar?.t ?? 0) || 0) + resMs;
        if (lastBarEndMs < expiryAtMs) continue;

        simulatedOutcomeRef.current.set(entry.id, {
          createdAtMs: entry.createdAtMs,
          outcome: 'EXPIRED',
          resolvedAtMs: expiryAtMs,
          exitPrice: null,
          timeframe: timeframeUsed,
          barsToOutcome: null,
          durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
        });
        outcomeUpdates[entry.id] = {
          outcome: 'EXPIRED',
          resolvedAtMs: expiryAtMs,
          exitPrice: null,
          timeframe: timeframeUsed,
          barsToOutcome: null,
          durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
        };
        const simEntry = {
          ...entry,
          executionBroker: entry.executionBroker ?? 'sim',
          executionMode: entry.executionMode ?? 'simulated'
        };
        events.push({
          eventType: 'signal_outcome_simulated',
          symbol: entry.symbol,
          payload: {
            signalId: entry.id,
            outcome: 'EXPIRED',
            resolvedAtMs: expiryAtMs,
            timeframe: timeframeUsed,
            durationMs: Math.max(0, expiryAtMs - entry.createdAtMs),
            source: 'simulated'
          }
        });
        historyUpdates.push({
          entry: simEntry,
          patch: {
            status: 'EXPIRED',
            outcome: 'EXPIRED',
            resolvedAtMs: expiryAtMs,
            durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
          }
        });
        academyUpdates.push({
          entry: simEntry,
          patch: {
            status: 'EXPIRED',
            outcome: 'EXPIRED',
            resolvedAtMs: expiryAtMs,
            durationMs: Math.max(0, expiryAtMs - entry.createdAtMs)
          },
          event: {
            type: 'signal_outcome_simulated',
            payload: {
              signalId: entry.id,
              outcome: 'EXPIRED',
              timeframe: timeframeUsed,
              durationMs: Math.max(0, expiryAtMs - entry.createdAtMs),
              source: 'simulated'
            }
          }
        });
      }

      for (const evt of events) {
        void appendTruthEvent({
          eventType: evt.eventType,
          symbol: evt.symbol,
          payload: evt.payload
        });
      }
      for (const update of historyUpdates) {
        void upsertSignalHistory(update.entry, update.patch);
      }
      for (const review of reviewUpdates) {
        void upsertSignalReview(review.entry, {
          outcome: review.outcome,
          score: review.score,
          exitPrice: review.exitPrice,
          resolvedAtMs: review.resolvedAtMs,
          durationMs: review.durationMs ?? null,
          barsToOutcome: review.barsToOutcome ?? null
        });
      }
      for (const update of academyUpdates) {
        const payload = await upsertAcademyCase({
          entry: update.entry,
          patch: update.patch as any,
          event: update.event,
          source: 'signal_panel'
        });
        const outcome = String(update.patch?.outcome || update.patch?.status || '').toUpperCase();
        if (payload && (outcome === 'WIN' || outcome === 'LOSS')) {
          void maybeAutoAcceptAcademyCase(payload);
        }
      }

      if (removeIds.size > 0 || Object.keys(outcomeUpdates).length > 0) {
        setSignalSimulatedOutcomes((prev) => {
          let next = prev;
          if (removeIds.size > 0) {
            next = { ...next };
            removeIds.forEach((id) => {
              if (next[id]) delete next[id];
            });
          }
          if (Object.keys(outcomeUpdates).length > 0) {
            next = { ...next, ...outcomeUpdates };
          }
          return next;
        });
      }
    };
    let inFlight = false;
    let pending = false;
    let lastAt = 0;
    const trigger = () => {
      const now = Date.now();
      if (inFlight) {
        pending = true;
        return;
      }
      if (now - lastAt < 1500) {
        pending = true;
        return;
      }
      inFlight = true;
      lastAt = now;
      Promise.resolve()
        .then(() => tick())
        .finally(() => {
          inFlight = false;
          if (pending) {
            pending = false;
            trigger();
          }
        });
    };
    signalOutcomeTriggerRef.current = trigger;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 7000,
        onTick: () => trigger()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
      if (signalOutcomeTriggerRef.current === trigger) {
        signalOutcomeTriggerRef.current = null;
      }
    };
  }, [
    appendTruthEvent,
    buildSimWarmupBarsByTimeframe,
    chartEngine,
    computeSignalOutcomeScore,
    resolveSimulatedOutcomeFromBars,
    signalExpiryMinutes,
    setSignalSimulatedOutcomes,
    upsertAcademyCase,
    maybeAutoAcceptAcademyCase,
    upsertSignalHistory,
    upsertSignalReview
  ]);

  const handleAgentRequest = useCallback((event: { phase: string; correlationId: string; meta?: Record<string, any>; error?: string }) => {
    const meta = event?.meta && typeof event.meta === 'object' ? event.meta : {};
    if (meta.channel !== 'chart') return;
    const payload = {
      msgId: event.correlationId,
      symbol: meta.symbol || null,
      modelHint: meta.modelHint || null,
      hasImage: meta.hasImage === true,
      hasFrames: meta.hasFrames === true,
      payloadChars: meta.payloadChars || null,
      agentId: meta.agentId || null,
      mode: meta.mode || null
    };
    if (event.phase === 'send') {
      logChartChatEvent('OUTBOUND_AGENT_CALL', payload);
    } else if (event.phase === 'response') {
      logChartChatEvent('OUTBOUND_AGENT_RESPONSE', payload);
    } else if (event.phase === 'error') {
      logChartChatEvent('OUTBOUND_AGENT_CALL_ERROR', { ...payload, error: event.error || null });
    }
  }, [logChartChatEvent]);

  const applyOrQueueBacktestOptimization = useCallback((payload: BacktesterOptimizationApply) => {
    if (!payload) return false;
    const handler = backtesterRef.current?.applyOptimization;
    if (handler) {
      handler(payload);
      return true;
    }
    pendingBacktestApplyRef.current = payload;
    return false;
  }, []);

  const findWatcherForLibraryEntry = useCallback((entry: SetupLibraryEntry) => {
    if (!entry) return null;
    const libraryKey = String(entry.configKey || entry.key || '').trim();
    const symbolKey = normalizeSymbolKey(entry.symbol);
    const timeframeKey = normalizeTimeframeKey(entry.timeframe);
    const strategyKey = String(entry.strategy || '').trim().toUpperCase();
    const paramsKey = buildParamsKey(entry.params || {});
    const watchers = setupWatchersRef.current || [];
    for (const watcher of watchers) {
      if (!watcher) continue;
      if (libraryKey && watcher.libraryKey && watcher.libraryKey === libraryKey) return watcher;
      if (symbolKey && normalizeSymbolKey(watcher.symbol) !== symbolKey) continue;
      if (timeframeKey && normalizeTimeframeKey(watcher.timeframe) !== timeframeKey) continue;
      if (strategyKey && String(watcher.strategy || '').toUpperCase() !== strategyKey) continue;
      const watcherParamsKey = buildParamsKey(watcher.params || {});
      if (paramsKey && watcherParamsKey !== paramsKey) continue;
      return watcher;
    }
    return null;
  }, []);

  const findWatcherForProfile = useCallback((profile: WatchProfile) => {
    if (!profile) return null;
    const profileId = String(profile.profileId || '').trim();
    const symbolKey = normalizeSymbolKey(profile.symbol);
    const timeframeKey = normalizeTimeframeKey(profile.timeframe);
    const strategyKey = String(profile.strategy || '').trim().toUpperCase();
    const paramsKey = buildParamsKey(profile.params || {});
    const watchers = setupWatchersRef.current || [];
    for (const watcher of watchers) {
      if (!watcher) continue;
      if (profileId && watcher.profileId && watcher.profileId === profileId) return watcher;
      if (symbolKey && normalizeSymbolKey(watcher.symbol) !== symbolKey) continue;
      if (timeframeKey && normalizeTimeframeKey(watcher.timeframe) !== timeframeKey) continue;
      if (strategyKey && String(watcher.strategy || '').toUpperCase() !== strategyKey) continue;
      const watcherParamsKey = buildParamsKey(watcher.params || {});
      if (paramsKey && watcherParamsKey !== paramsKey) continue;
      return watcher;
    }
    return null;
  }, []);

  const ensureWatcherFromLibraryEntry = useCallback((entry: SetupLibraryEntry, opts?: { mode?: SetupWatcher['mode']; enabled?: boolean; regime?: SetupWatcher['regime']; source?: string | null }) => {
    if (!entry) return null;
    const existing = findWatcherForLibraryEntry(entry);
    const nextLibraryKey = entry.configKey || entry.key || null;
    const nextRegime = opts?.regime ? normalizeSetupRegimeGate(opts.regime) : undefined;
    const nextStats = {
      total: entry.stats?.total ?? null,
      winRate: entry.stats?.winRate ?? null,
      expectancy: entry.stats?.expectancy ?? null,
      profitFactor: entry.stats?.profitFactor ?? null,
      netR: entry.performance?.netR ?? null,
      maxDrawdown: entry.performance?.maxDrawdown ?? null
    };
    if (existing) {
      const patch: Partial<SetupWatcher> = {};
      if (nextLibraryKey && existing.libraryKey !== nextLibraryKey) patch.libraryKey = nextLibraryKey;
      if (nextRegime && existing.regime !== nextRegime) patch.regime = nextRegime;
      if (existing.libraryTier !== entry.tier) patch.libraryTier = entry.tier;
      if (existing.libraryScore !== entry.score) patch.libraryScore = entry.score;
      if (existing.libraryWinRateTier !== entry.winRateTier) patch.libraryWinRateTier = entry.winRateTier;
      if (JSON.stringify(existing.libraryStats || {}) !== JSON.stringify(nextStats)) {
        patch.libraryStats = nextStats;
      }
      if (Object.keys(patch).length > 0) {
        const nextWatcher = { ...existing, ...patch };
        updateSetupWatcher(existing.id, patch);
        void appendAuditEvent({
          eventType: 'setup_library_watcher_sync',
          symbol: entry.symbol,
          payload: {
            watcherId: existing.id,
            libraryKey: nextLibraryKey,
            tier: entry.tier,
            winRateTier: entry.winRateTier,
            score: entry.score
          }
        });
        void persistPromotionEvent({
          eventType: 'setup_watcher_sync',
          source: opts?.source || entry.source || 'setup_library',
          watcher: nextWatcher,
          library: entry,
          meta: { updatedFields: Object.keys(patch) }
        });
      }
      return existing;
    }

    const created = addSetupWatcher({
      symbol: entry.symbol,
      timeframe: entry.timeframe,
      strategy: entry.strategy,
      params: entry.params || {},
      mode: opts?.mode || 'suggest',
      enabled: opts?.enabled !== false,
      regime: nextRegime,
      library: entry
    });
    if (created) {
      void appendAuditEvent({
        eventType: 'setup_library_watcher_create',
        symbol: entry.symbol,
        payload: {
          watcherId: created.id,
          libraryKey: nextLibraryKey,
          tier: entry.tier,
          winRateTier: entry.winRateTier,
          score: entry.score
        }
      });
    }
    return created;
  }, [addSetupWatcher, appendAuditEvent, findWatcherForLibraryEntry, persistPromotionEvent, updateSetupWatcher]);

  const persistSetupLibraryFromOptimization = useCallback(async (result: any, opts?: { timeFilter?: any; source?: string }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory || !ledger?.getAgentMemory) {
      return { ok: false, error: 'Setup library unavailable.' };
    }
    if (!result?.ok || !result.bestConfig) {
      return { ok: false, error: 'Optimization result missing best config.' };
    }

    const built = buildSetupLibraryEntry({
      symbol: result.symbol,
      timeframe: result.timeframe,
      strategy: result.strategy,
      params: result.bestConfig.params || {},
      stats: result.bestConfig.stats || {},
      performance: result.bestConfig.performance || {},
      runId: result.runId || null,
      rangeDays: result.rangeDays || null,
      timeFilter: opts?.timeFilter || null,
      stabilityScore: result?.walkForward?.summary?.stabilityScore ?? null,
      source: opts?.source || 'optimizer',
      minTrades: 20
    });

    if (!built.score.eligible) {
      return { ok: true, skipped: true, reason: built.score.reasons.join(' ') };
    }

    const tierKey = buildSetupLibraryTierKey(
      result.symbol,
      result.timeframe,
      result.strategy,
      built.entry.tier
    );

    let existing: SetupLibraryEntry | null = null;
    try {
      const res = await ledger.getAgentMemory({ key: tierKey, touch: true });
      if (res?.ok && res.memory?.payload) {
        existing = res.memory.payload as SetupLibraryEntry;
      }
    } catch {
      // ignore
    }

    const now = Date.now();
    const tierEntry: SetupLibraryEntry = {
      ...built.entry,
      key: tierKey,
      configKey: built.entry.key,
      createdAtMs: existing?.createdAtMs ?? now,
      updatedAtMs: now
    };

    if (!shouldReplaceLibraryEntry(existing, tierEntry)) {
      return { ok: true, updated: false, entry: tierEntry };
    }

    const summary = `${tierEntry.symbol} ${tierEntry.timeframe} ${tierEntry.strategy}\n${built.summary} | Score ${tierEntry.score}`;
    const tags = [
      tierEntry.symbol,
      tierEntry.timeframe,
      tierEntry.strategy,
      'setup',
      'library',
      `tier:${tierEntry.tier}`,
      tierEntry.winRateTier
    ];

    await ledger.upsertAgentMemory({
      key: tierKey,
      familyKey: `setup_library:${tierEntry.symbol}:${tierEntry.timeframe}:${tierEntry.strategy}`,
      scope: 'shared',
      category: 'setup',
      subcategory: 'library',
      kind: 'setup_library',
      symbol: tierEntry.symbol,
      timeframe: tierEntry.timeframe,
      summary,
      payload: tierEntry,
      source: opts?.source || 'optimizer',
      tags
    });

    return { ok: true, updated: true, entry: tierEntry };
  }, []);

  const saveSetupLibraryFromOptimization = useCallback(async (
    result: any,
    opts?: { timeFilter?: any; source?: string; createWatcher?: boolean; watcherMode?: SetupWatcher['mode']; watcherEnabled?: boolean }
  ) => {
    const saved = await persistSetupLibraryFromOptimization(result, opts);
    if (saved?.ok && !saved?.skipped) {
      if (saved.entry && opts?.createWatcher !== false) {
        ensureWatcherFromLibraryEntry(saved.entry, {
          mode: opts?.watcherMode || 'suggest',
          enabled: opts?.watcherEnabled !== false,
          source: opts?.source || 'optimizer'
        });
      }
      void refreshSetupLibrary();
    }
    return saved;
  }, [ensureWatcherFromLibraryEntry, persistSetupLibraryFromOptimization, refreshSetupLibrary]);

  const sendBacktestSetupToWatchlist = useCallback((payload: { strategy: string; params: Record<string, any>; symbol?: string; timeframe?: string; mode?: SetupWatcher['mode'] }) => {
    if (!payload) return null;
    const strategy = normalizeSetupStrategyName(payload.strategy);
    const symbol = String(payload.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    const timeframe = String(payload.timeframe || '').trim();
    if (!strategy || !symbol || !timeframe) return null;
    const params = payload.params && typeof payload.params === 'object' ? payload.params : {};
    const mode = payload.mode || 'suggest';
    return addSetupWatcher({
      symbol,
      timeframe,
      strategy: strategy as SetupWatcher['strategy'],
      params,
      mode,
      enabled: true
    });
  }, [activeBrokerSymbol, activeTvParams?.symbol, addSetupWatcher, symbolScopeSymbol]);

  const createWatchProfileFromOptimization = useCallback(async (payload: {
    strategy: string;
    params: Record<string, any>;
    symbol?: string;
    timeframe?: string;
    objectivePresetId?: string | null;
    objectivePresetName?: string | null;
    baselineRunId?: string | null;
    optimizerSessionId?: string | null;
    regimeConstraint?: { mode: 'require' | 'exclude'; keys: string[] } | null;
    mode?: SetupWatcher['mode'];
    enabled?: boolean;
  }) => {
    if (!payload) return null;
    const strategy = normalizeSetupStrategyName(payload.strategy);
    const symbol = String(payload.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    const timeframe = String(payload.timeframe || '').trim();
    if (!strategy || !symbol || !timeframe) return null;
    const params = payload.params && typeof payload.params === 'object' ? payload.params : {};
    let paramsHash = '';
    try {
      const paramsKey = buildParamsKey(params);
      paramsHash = hashStringSampled(paramsKey || JSON.stringify(params));
    } catch {
      paramsHash = '';
    }
    const profileKey = [strategy, symbol, timeframe, paramsHash, payload.optimizerSessionId || ''].join(':');
    const profileId = `profile_${hashStringSampled(profileKey)}`;
    const now = Date.now();
    const existing = watchProfilesRef.current.find((item) => item.profileId === profileId);
    const profile: WatchProfile = {
      profileId,
      symbol,
      timeframe,
      strategy: strategy as WatchProfile['strategy'],
      params,
      regimeConstraint: payload.regimeConstraint || existing?.regimeConstraint || null,
      paramsHash,
      objectivePresetId: payload.objectivePresetId || null,
      objectivePresetName: payload.objectivePresetName || null,
      baselineRunId: payload.baselineRunId || null,
      optimizerSessionId: payload.optimizerSessionId || null,
      createdAtMs: existing?.createdAtMs ?? now,
      updatedAtMs: now,
      source: 'optimizer'
    };
    await upsertWatchProfile(profile);

    const profileAction = existing ? 'updated' : 'created';
    const presetLabel = payload.objectivePresetName || payload.objectivePresetId || null;
    const existingWatcher = findWatcherForProfile(profile);
    if (existingWatcher) {
      updateSetupWatcher(existingWatcher.id, {
        profileId: profile.profileId,
        profileLabel: presetLabel,
        profileObjectivePreset: payload.objectivePresetId || payload.objectivePresetName || null,
        profileSessionId: payload.optimizerSessionId || null,
        profileBaselineRunId: payload.baselineRunId || null,
        profileParamsHash: paramsHash
      });
      const linkedWatcher = {
        ...existingWatcher,
        profileId: profile.profileId,
        profileParamsHash: paramsHash
      };
      void persistPromotionEvent({
        eventType: 'watch_profile',
        source: 'optimizer',
        profile,
        watcher: linkedWatcher,
        meta: { profileAction, watcherAction: 'linked' }
      });
      return profile;
    }

    const createdWatcher = addSetupWatcher({
      symbol,
      timeframe,
      strategy: strategy as SetupWatcher['strategy'],
      params,
      mode: payload.mode || 'suggest',
      enabled: payload.enabled !== false,
      profileId: profile.profileId,
      profileLabel: presetLabel,
      profileObjectivePreset: payload.objectivePresetId || payload.objectivePresetName || null,
      profileSessionId: payload.optimizerSessionId || null,
      profileBaselineRunId: payload.baselineRunId || null,
      profileParamsHash: paramsHash
    });
    void persistPromotionEvent({
      eventType: 'watch_profile',
      source: 'optimizer',
      profile,
      watcher: createdWatcher,
      meta: { profileAction, watcherAction: createdWatcher ? 'created' : 'none' }
    });
    return profile;
  }, [activeBrokerSymbol, activeTvParams?.symbol, addSetupWatcher, findWatcherForProfile, persistPromotionEvent, symbolScopeSymbol, updateSetupWatcher, upsertWatchProfile]);

  const flushPendingBacktestApply = useCallback(() => {
    const payload = pendingBacktestApplyRef.current;
    if (!payload) return false;
    const handler = backtesterRef.current?.applyOptimization;
    if (!handler) return false;
    pendingBacktestApplyRef.current = null;
    handler(payload);
    return true;
  }, []);

  useEffect(() => {
    const focus = backtesterRef.current?.getSummary?.();
    const symbol = String(focus?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    const timeframe = String(focus?.timeframe || '').trim();
    void refreshAgentMemory({ symbol, timeframe, limit: 6 });
  }, [activeBrokerSymbol, activeTvParams?.symbol, refreshAgentMemory, symbolScopeSymbol]);

  useEffect(() => {
    void refreshSetupLibrary();
  }, [refreshSetupLibrary]);

  useEffect(() => {
    void refreshTaskPlaybooks().then(() => {
      void ensureDefaultTaskPlaybook();
    });
    void refreshPlaybookRuns();
  }, [ensureDefaultTaskPlaybook, refreshPlaybookRuns, refreshTaskPlaybooks]);

  useEffect(() => {
    void refreshWatchProfiles();
  }, [refreshWatchProfiles]);

  useEffect(() => {
    void refreshSetupSignals();
  }, [refreshSetupSignals]);

  useEffect(() => {
    void refreshActionFlows();
  }, [refreshActionFlows]);

  useEffect(() => {
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 60_000,
        onTick: () => {
          if (!backgroundWatchersEnabledRef.current) return;
          const focus = backtesterRef.current?.getSummary?.();
          const symbol = String(focus?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
          const timeframe = String(focus?.timeframe || '').trim();
          void refreshAgentMemory({ symbol, timeframe, limit: 6 });
        }
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [activeBrokerSymbol, activeTvParams?.symbol, refreshAgentMemory, symbolScopeSymbol]);

  const executeAgentToolRequest = useCallback(async (
    action: AgentToolAction,
    onProgress?: (update: Partial<AgentToolAction>) => void
  ): Promise<AgentToolResult> => {
    if (!action || !action.type) {
      return { ok: false, text: 'Tool request missing type.' };
    }

    const symbol = action.symbol ? String(action.symbol).trim() : '';
    const payloadSource =
      action.payload && typeof action.payload === 'object'
        ? String((action.payload as Record<string, any>).source || '').trim()
        : '';
    const actionSource = String(action.source || '').trim();
    const effectiveSource = actionSource || payloadSource || (action.reason ? String(action.reason).trim() : '') || 'agent_tool';
    const toolId = action.messageId ? String(action.messageId).trim() : `tool_${Date.now()}_${Math.random().toString(16).slice(2, 6)}`;
    const toolStartedAtMs = Date.now();
    const trimToolText = (text: string) => {
      const raw = String(text || '').trim();
      if (raw.length <= 240) return raw;
      return `${raw.slice(0, 236)}...`;
    };
    const payloadDedupeKey =
      action.payload && typeof action.payload === 'object'
        ? String(((action.payload as Record<string, any>).dedupeKey ?? (action.payload as Record<string, any>).idempotencyKey ?? '') || '').trim()
        : '';
    const effectiveDedupeKey = action.dedupeKey ? String(action.dedupeKey).trim() : payloadDedupeKey;
    if (effectiveDedupeKey) {
      const now = Date.now();
      const map = agentToolDedupeRef.current;
      for (const [key, atMs] of map.entries()) {
        if (now - atMs > AGENT_TOOL_DEDUPE_WINDOW_MS) map.delete(key);
      }
      const prevAtMs = map.get(effectiveDedupeKey);
      if (prevAtMs && now - prevAtMs < AGENT_TOOL_DEDUPE_WINDOW_MS) {
        void appendAuditEvent({
          eventType: 'agent_tool_deduped',
          toolId,
          symbol: symbol || null,
          correlationId: action.correlationId || null,
          payload: {
            type: action.type,
            dedupeKey: effectiveDedupeKey,
            previousAtMs: prevAtMs
          }
        });
        return {
          ok: true,
          text: 'Tool request deduped.',
          payload: { deduped: true, dedupeKey: effectiveDedupeKey, previousAtMs: prevAtMs }
        };
      }
      map.set(effectiveDedupeKey, now);
    }
    void appendAuditEvent({
      eventType: 'agent_tool_start',
      toolId,
      symbol: symbol || null,
      correlationId: action.correlationId || null,
      payload: {
        type: action.type,
        timeframe: action.timeframe || null,
        strategy: action.strategy || null
      }
    });
    const finalizeToolResult = (result: AgentToolResult, meta?: Record<string, any>) => {
      if (meta && typeof meta === 'object') {
        const payload = result.payload && typeof result.payload === 'object' ? { ...(result.payload as Record<string, any>) } : {};
        for (const [key, value] of Object.entries(meta)) {
          if (payload[key] == null) payload[key] = value;
        }
        result.payload = payload;
      }
      const runId = result?.payload?.runId || null;
      void appendAuditEvent({
        eventType: result.ok ? 'agent_tool_ok' : 'agent_tool_failed',
        toolId,
        symbol: symbol || null,
        runId,
        correlationId: action.correlationId || null,
        payload: {
          type: action.type,
          ok: result.ok,
          text: trimToolText(result.text || '')
        }
      });
      if (action.type !== 'RUN_ACTION_CATALOG') {
        void recordActionTraceRef.current?.({
          actionId: `tool:${action.type}`,
          payload: action.payload && typeof action.payload === 'object' ? action.payload : {},
          source: effectiveSource,
          symbol: action.symbol || null,
          timeframe: action.timeframe || null,
          strategy: action.strategy || null,
          agentId: action.agentId || null,
          agentName: action.agentName || null,
          messageId: action.messageId || null,
          correlationId: action.correlationId || null,
          runId,
          kind: 'tool',
          startedAtMs: toolStartedAtMs
        }, {
          ok: result.ok,
          error: result.text || null,
          code: (result.payload && typeof result.payload === 'object' && typeof (result.payload as any).detail === 'string')
            ? String((result.payload as any).detail)
            : null,
          data: result.payload ?? null
        });
      }
      return result;
    };

    const formatAge = (ms: number | null | undefined) => {
      if (!Number.isFinite(Number(ms)) || Number(ms) <= 0) return '';
      const delta = Math.max(0, Date.now() - Number(ms));
      const seconds = Math.max(1, Math.floor(delta / 1000));
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      return `${hours}h ago`;
    };

    const normalizeSetupStrategy = (value: any) => {
      return normalizeSetupStrategyName(value);
    };

    const normalizeSetupMode = (value: any) => {
      const raw = String(value || '').trim().toLowerCase();
      if (!raw) return '';
      if (raw === 'live' || raw === 'paper' || raw === 'suggest') return raw;
      return '';
    };

    const normalizeSetupRegime = (value: any) => {
      const raw = String(value || '').trim().toLowerCase();
      if (!raw) return '';
      if (raw === 'trend' || raw === 'range' || raw === 'breakout') return raw;
      if (raw.includes('any') || raw.includes('all') || raw.includes('none')) return 'any';
      return '';
    };

    const normalizeSetupTimeframe = (value: any) => {
      const raw = String(value || '').trim();
      if (!raw) return '';
      const match = raw.match(/^(\d+)\s*([a-zA-Z]+)$/);
      if (!match) return raw;
      const amount = match[1];
      const unit = match[2].toLowerCase();
      if (unit === 'h' || unit === 'd') return `${amount}${unit.toUpperCase()}`;
      if (unit === 'm') return `${amount}m`;
      return raw;
    };

    const resolveOptimizerWinner = async (input: {
      winnerId?: string;
      sessionId?: string;
      round?: number | null;
      symbol?: string;
      timeframe?: string;
      strategy?: string;
      limit?: number;
    }) => {
      const ledger = window.glass?.tradeLedger;
      if (!ledger?.getOptimizerWinner && !ledger?.listOptimizerWinners && !ledger?.getOptimizerWinnerBySessionRound) {
        return { ok: false, error: 'Optimizer winners unavailable.' };
      }

      const winnerId = String(input.winnerId || '').trim();
      const sessionId = String(input.sessionId || '').trim();
      const round = Number.isFinite(Number(input.round)) ? Math.max(1, Math.floor(Number(input.round))) : null;
      let winner: any = null;
      let winners: any[] = [];

      if (winnerId && ledger?.getOptimizerWinner) {
        const res = await ledger.getOptimizerWinner({ id: winnerId });
        if (res?.ok && res.winner) winner = res.winner;
      }

      if (!winner && sessionId && round && ledger?.getOptimizerWinnerBySessionRound) {
        const res = await ledger.getOptimizerWinnerBySessionRound({ sessionId, round });
        if (res?.ok && res.winner) winner = res.winner;
      }

      if (!winner && ledger?.listOptimizerWinners) {
        const listRes = await ledger.listOptimizerWinners({
          limit: Number.isFinite(Number(input.limit)) ? Math.max(1, Math.floor(Number(input.limit))) : 1,
          sessionId: sessionId || undefined,
          symbol: input.symbol || undefined,
          timeframe: input.timeframe || undefined,
          strategy: input.strategy || undefined,
          round: round || undefined
        });
        if (listRes?.ok && Array.isArray(listRes.winners) && listRes.winners.length > 0) {
          winners = listRes.winners;
          winner = winners[0];
        }
      }

      if (!winner) {
        return { ok: false, error: 'Optimizer winner not found.' };
      }

      return { ok: true, winner, winners };
    };

    const resolveResearchSession = async (filters: { sessionId?: string; symbol?: string; timeframe?: string }) => {
      const sessionId = filters.sessionId ? String(filters.sessionId).trim() : '';
      if (sessionId) {
        const session = await getResearchStatus(sessionId);
        if (session) return session;
      }
      const symbolFilter = filters.symbol ? normalizeSymbolKey(filters.symbol) : '';
      const timeframeFilter = filters.timeframe ? normalizeSetupTimeframe(filters.timeframe) : '';
      const ledger = window.glass?.tradeLedger;
      if (!ledger?.listResearchSessions) return null;
      try {
        const res = await ledger.listResearchSessions({
          limit: 5,
          symbol: symbolFilter || undefined,
          timeframe: timeframeFilter || undefined
        });
        if (!res?.ok || !Array.isArray(res.sessions) || res.sessions.length === 0) return null;
        return res.sessions[0] || null;
      } catch {
        return null;
      }
    };

    const matchesSetupWatcher = (
      watcher: SetupWatcher,
      filters: { symbol?: string; timeframe?: string; strategy?: string; mode?: string; enabled?: boolean }
    ) => {
      if (!watcher) return false;
      const symbolFilter = filters.symbol ? normalizeSymbolKey(filters.symbol) : '';
      if (symbolFilter) {
        const watcherSymbol = normalizeSymbolKey(watcher.symbol);
        if (!watcherSymbol || watcherSymbol !== symbolFilter) return false;
      }
      const timeframeFilter = filters.timeframe ? normalizeSetupTimeframe(filters.timeframe) : '';
      if (timeframeFilter) {
        const watcherTf = normalizeSetupTimeframe(watcher.timeframe);
        if (!watcherTf || watcherTf !== timeframeFilter) return false;
      }
      const strategyFilter = filters.strategy ? normalizeSetupStrategy(filters.strategy) : '';
      if (strategyFilter && String(watcher.strategy).toUpperCase() !== strategyFilter) return false;
      const modeFilter = filters.mode ? normalizeSetupMode(filters.mode) : '';
      if (modeFilter && watcher.mode !== modeFilter) return false;
      if (typeof filters.enabled === 'boolean' && watcher.enabled !== filters.enabled) return false;
      return true;
    };

    if (action.type === 'RUN_ACTION_CATALOG') {
      let payload = action.payload && typeof action.payload === 'object' ? action.payload : {};
      const requestedActionId = String(action.actionId || payload.actionId || '').trim();
      const forceAction = payload.forceAction === true;
      const preferFlow = payload.preferFlow === true;
      const sequenceRaw = payload.steps || payload.actions || payload.sequence || null;
      const sequenceSteps = normalizeActionSequenceSteps(sequenceRaw);
      const flowIntentRaw = payload.intentKey || payload.flowIntentKey || payload.intent || null;
      let flowIntentKey =
        typeof flowIntentRaw === 'string' && flowIntentRaw.trim().startsWith('intent_')
          ? flowIntentRaw.trim()
          : (typeof payload.intentKey === 'string' ? payload.intentKey.trim() : '');
      if (!flowIntentKey && typeof payload.intent === 'string') {
        const intentText = payload.intent.trim();
        if (intentText) flowIntentKey = `intent_${hashStringSampled(intentText, 512)}`;
      }

      let actionId = requestedActionId;
      if (!actionId && sequenceSteps.length === 1) {
        actionId = sequenceSteps[0].actionId;
        if (sequenceSteps[0].payload && typeof sequenceSteps[0].payload === 'object') {
          payload = { ...payload, ...sequenceSteps[0].payload };
        }
      }
      if (!forceAction && flowIntentKey && (preferFlow || !requestedActionId || requestedActionId === 'playbook.run')) {
        actionId = 'action_flow.run';
        payload.intentKey = flowIntentKey;
      }
      if (sequenceSteps.length > 1) {
        const playbook = buildActionSequencePlaybook({
          steps: sequenceSteps,
          intentLabel: payload.intentLabel || payload.intent || payload.reason || null
        });
        if (!playbook) {
          return finalizeToolResult({ ok: false, text: 'Action sequence missing valid steps.' });
        }
        const enqueueRun = enqueuePlaybookRunRef.current;
        if (!enqueueRun) {
          return finalizeToolResult({ ok: false, text: 'Playbook runner unavailable.' });
        }
        const res = enqueueRun({
          playbook,
          symbol: payload.symbol || action.symbol || undefined,
          timeframe: payload.timeframe || action.timeframe || undefined,
          timeframes: Array.isArray(payload.timeframes) ? payload.timeframes : undefined,
          strategy: payload.strategy || action.strategy || undefined,
          mode: payload.mode || action.mode || undefined,
          source: payload.source || effectiveSource,
          reason: payload.reason || payload.intent || 'action_sequence'
        });
        if (!res.ok) {
          return finalizeToolResult({ ok: false, text: res.error || 'Failed to start action sequence.' });
        }
        try {
          const flowDebugEnabled = localStorage.getItem('glass_action_flow_debug') === '1';
          if (flowDebugEnabled) {
            addNotification(
              'Action Sequence Queued',
              `Queued ${sequenceSteps.length} steps via playbook.`,
              'info'
            );
          }
        } catch {
          // ignore localStorage errors
        }
        return finalizeToolResult({
          ok: true,
          text: 'Action sequence queued via playbook.',
          payload: { runId: res.runId, queued: res.queued, actionId: 'playbook.run' }
        });
      }
      if (!actionId) {
        return finalizeToolResult({ ok: false, text: 'Action catalog request missing actionId.' });
      }
      const enqueueAction = enqueueCatalogActionRef.current;
      if (!enqueueAction) {
        return finalizeToolResult({ ok: false, text: 'Action catalog queue unavailable.' });
      }
      const res = enqueueAction({
        actionId,
        payload,
        symbol: action.symbol || undefined,
        timeframe: action.timeframe || undefined,
        strategy: action.strategy || undefined,
        mode: action.mode || undefined,
        source: effectiveSource,
        dedupeKey: effectiveDedupeKey || undefined,
        correlationId: action.correlationId || null
      });
      if (!res.ok) {
        return finalizeToolResult({ ok: false, text: res.error || 'Failed to enqueue action.' });
      }
      return finalizeToolResult({
        ok: true,
        text: 'Action queued via task tree.',
        payload: { runId: res.runId, queued: res.queued, actionId }
      });
    }

    if (action.type === 'GET_SYSTEM_STATE') {
      const detail = action.detail === 'full' ? 'full' : 'summary';
      const maxItemsRaw = Number(action.maxItems);
      const maxItems = Number.isFinite(maxItemsRaw)
        ? Math.max(1, Math.min(50, Math.floor(maxItemsRaw)))
        : detail === 'full'
          ? 8
          : 4;

      const capturedAtMs = Date.now();
      const healthBuilder = buildHealthSnapshotRef.current;
      const health = healthSnapshotRef.current || healthSnapshot || (healthBuilder ? healthBuilder() : null);
      const sidebarState = sidebarStateRef.current || { isOpen: false, mode: 'chat' as SidebarMode };
      const tabsNow = Array.isArray(tabsRef.current) ? tabsRef.current : tabs;
      const activeId = String(activeTabIdRef.current || '').trim();
      const activeTabNow = activeId ? tabsNow.find((t) => t.id === activeId) : null;
      const tabItems = detail === 'full'
        ? tabsNow.slice(0, maxItems).map((t) => ({
            id: String(t.id),
            title: t.title ?? null,
            url: t.url ?? null,
            isWatched: t.isWatched ?? null,
            aiPinned: t.aiPinned ?? null,
            aiLabel: t.aiLabel ?? null
          }))
        : undefined;
      const watchedTabs = tabsNow.filter((t) => t && t.isWatched).length;
      const pinnedTabs = tabsNow.filter((t) => t && t.aiPinned).length;

      const watchers = setupWatchersRef.current || [];
      const signals = setupSignalsRef.current || [];
      const profiles = watchProfilesRef.current || [];
      const chatMeta = chatStateRef.current || {};
      const agentsNow = agentsRef.current || [];

      const watchersList = detail === 'full'
        ? watchers.slice(0, maxItems).map((w) => ({
            id: w.id,
            symbol: w.symbol,
            timeframe: w.timeframe,
            strategy: w.strategy,
            mode: w.mode,
            enabled: w.enabled,
            profileId: w.profileId ?? null,
            paramsHash: w.profileParamsHash ?? null,
            lastSignalType: w.lastSignalType ?? null,
            lastSignalAtMs: w.lastSignalAtMs ?? null,
            regime: w.regime ?? null
          }))
        : undefined;
      const signalsList = detail === 'full'
        ? signals.slice(0, maxItems).map((s) => ({
            id: s.id,
            profileId: s.profileId ?? null,
            symbol: s.symbol,
            timeframe: s.timeframe,
            ts: s.ts,
            strength: s.strength,
            signalType: s.payload.signalType,
            status: s.payload.status,
            side: s.payload.side
          }))
        : undefined;
      const profilesList = detail === 'full'
        ? profiles.slice(0, maxItems).map((p) => ({
            profileId: p.profileId,
            symbol: p.symbol,
            timeframe: p.timeframe,
            strategy: p.strategy,
            paramsHash: p.paramsHash ?? null,
            objectivePresetName: p.objectivePresetName ?? null,
            optimizerSessionId: p.optimizerSessionId ?? null,
            createdAtMs: p.createdAtMs,
            updatedAtMs: p.updatedAtMs
          }))
        : undefined;

      const setupLibraryItems = detail === 'full'
        ? setupLibraryEntries.slice(0, maxItems).map((entry) => ({
            key: entry.key,
            symbol: entry.symbol,
            timeframe: entry.timeframe,
            strategy: entry.strategy,
            score: entry.score,
            tier: entry.tier,
            winRate: entry.stats?.winRate ?? null,
            expectancy: entry.stats?.expectancy ?? null,
            profitFactor: entry.stats?.profitFactor ?? null,
            netR: entry.performance?.netR ?? null,
            maxDrawdown: entry.performance?.maxDrawdown ?? null,
            rangeDays: entry.rangeDays ?? null,
            source: entry.source ?? null,
            updatedAtMs: entry.updatedAtMs ?? null
          }))
        : undefined;
      const setupLibraryTierCounts: Record<string, number> = {};
      for (const entry of setupLibraryEntries) {
        if (!entry?.tier) continue;
        const tier = String(entry.tier);
        setupLibraryTierCounts[tier] = (setupLibraryTierCounts[tier] || 0) + 1;
      }

      const regimeSnapshots = setupRegimesRef.current || {};
      const regimeSnapshotList = detail === 'full'
        ? Object.values(regimeSnapshots).slice(0, maxItems).map((snapshot) => ({
            symbol: snapshot?.symbol ?? null,
            timeframe: snapshot?.timeframe ?? null,
            label: snapshot?.label ?? null,
            trendStrength: snapshot?.trendStrength ?? null,
            volatilityPct: snapshot?.volatilityPct ?? null,
            atr: snapshot?.atr ?? null,
            close: snapshot?.close ?? null,
            emaFast: snapshot?.emaFast ?? null,
            emaSlow: snapshot?.emaSlow ?? null,
            updatedAtMs: snapshot?.updatedAtMs ?? null
          }))
        : undefined;
      const regimeBlocks = setupRegimeBlocks || {};
      const regimeBlockEntries = Object.entries(regimeBlocks).map(([watcherId, block]) => ({
        watcherId,
        blocked: !!block?.blocked,
        currentRegimeKey: block?.currentRegimeKey ?? null,
        requiredKeys: Array.isArray(block?.requiredKeys) ? block.requiredKeys : [],
        mode: block?.mode ?? null
      }));
      const blockedByRegime = regimeBlockEntries.filter((entry) => entry.blocked).length;

      const agentsList = detail === 'full'
        ? agentsNow.slice(0, maxItems).map((agent) => ({
            id: agent.id,
            name: agent.name,
            type: agent.type,
            voice: agent.voice ?? null,
            capabilities: agent.capabilities ?? null
          }))
        : undefined;

      const tlMeta = tradeLockerExecRef.current || {};
      const tlMetrics = tlMeta.accountMetrics && typeof tlMeta.accountMetrics === 'object' ? tlMeta.accountMetrics : null;
      const positions = Array.isArray(tlMeta.positions) ? tlMeta.positions : [];
      const orders = Array.isArray(tlMeta.orders) ? tlMeta.orders : [];
      const positionItems = detail === 'full'
        ? positions.slice(0, maxItems).map((p) => ({
            id: p.id,
            symbol: p.symbol,
            type: p.type,
            size: p.size,
            entryPrice: p.entryPrice,
            stopLoss: p.stopLoss,
            takeProfit: p.takeProfit,
            pnl: p.pnl,
            status: p.status
          }))
        : undefined;
      const orderItems = detail === 'full'
        ? orders.slice(0, maxItems).map((o) => ({
            id: o.id,
            symbol: o.symbol,
            side: o.side,
            type: o.type,
            qty: o.qty,
            price: o.price,
            stopLoss: o.stopLoss,
            takeProfit: o.takeProfit,
            status: o.status
          }))
        : undefined;
      const mt5Spec = mt5AccountSpecRef.current || mt5AccountSpec || null;
      const mt5Balance = Number(mt5Spec?.balance);
      const mt5Equity = Number(mt5Spec?.equity);
      const simPositionsList = Array.isArray(simPositions) ? simPositions : [];
      let simFloatingPnlTotal = 0;
      let simPnlCount = 0;
      for (const pos of simPositionsList) {
        const pnl = Number(pos?.pnl);
        if (!Number.isFinite(pnl)) continue;
        simFloatingPnlTotal += pnl;
        simPnlCount += 1;
      }
      const simFloatingPnl = simPnlCount > 0 ? simFloatingPnlTotal : null;

      const nativeMeta = nativeChartRef.current?.getMeta ? nativeChartRef.current.getMeta() : null;
      const chartSessionsNow = Array.isArray(chartSessions.sessions) ? chartSessions.sessions : [];
      const chartSessionsList = detail === 'full'
        ? chartSessionsNow.slice(0, maxItems).map((s) => ({
            id: s.id,
            symbol: s.symbol,
            watchEnabled: s.watchEnabled,
            views: s.views,
            updatedAtMs: s.updatedAtMs
          }))
        : undefined;
      const chartSessionsWatched = chartSessionsNow.filter((s) => s && s.watchEnabled !== false).length;

      const taskTree = taskTreeRef.current as any;
      const taskTreeQueueDepth = Number.isFinite(Number(taskTree?.queue?.length)) ? Number(taskTree.queue.length) : null;
      const taskTreeProcessing = typeof taskTree?.processing === 'boolean' ? taskTree.processing : null;
      const taskTreeMaxQueue = Number.isFinite(Number(taskTree?.maxQueue)) ? Number(taskTree.maxQueue) : null;
      const taskTreeDedupeWindowMs = Number.isFinite(Number(taskTree?.dedupeWindowMs)) ? Number(taskTree.dedupeWindowMs) : null;
      const actionTaskTree = actionTaskTreeRef.current as any;
      const actionTaskTreeQueueDepth = Number.isFinite(Number(actionTaskTree?.queue?.length)) ? Number(actionTaskTree.queue.length) : null;
      const actionTaskTreeProcessing = typeof actionTaskTree?.processing === 'boolean' ? actionTaskTree.processing : null;
      const actionTaskTreeMaxQueue = Number.isFinite(Number(actionTaskTree?.maxQueue)) ? Number(actionTaskTree.maxQueue) : null;
      const actionTaskTreeDedupeWindowMs = Number.isFinite(Number(actionTaskTree?.dedupeWindowMs)) ? Number(actionTaskTree.dedupeWindowMs) : null;

      const ledger = window.glass?.tradeLedger;
      let ledgerStats: any = null;
      let ledgerRecentEntries: Array<any> | undefined;
      let taskTreeEvents: Array<{
        eventType: string;
        runId?: string | null;
        step?: string | null;
        status?: string | null;
        note?: string | null;
        error?: string | null;
        symbol?: string | null;
        createdAtMs?: number | null;
      }> | undefined;
      let taskTreeLastRun: { runId?: string | null; status?: string | null; lastEventType?: string | null; lastEventAtMs?: number | null } | null = null;
      let taskTreeRuns: Array<any> | undefined;
      let actionTaskTreeEvents: Array<{
        eventType: string;
        runId?: string | null;
        step?: string | null;
        status?: string | null;
        note?: string | null;
        error?: string | null;
        symbol?: string | null;
        createdAtMs?: number | null;
      }> | undefined;
      let actionTaskTreeLastRun: { runId?: string | null; status?: string | null; lastEventType?: string | null; lastEventAtMs?: number | null } | null = null;
      let actionTaskTreeRuns: Array<any> | undefined;
      if (ledger?.stats) {
        try {
          const res = await ledger.stats();
          if (res?.ok) {
            ledgerStats = {
              path: res.path ?? null,
              entriesCount: res.entriesCount ?? null,
              memoriesCount: res.memoriesCount ?? null,
              agentMemoryCount: res.agentMemoryCount ?? null,
              optimizerCacheCount: res.optimizerCacheCount ?? null,
              experimentCount: res.experimentCount ?? null,
              researchSessionCount: res.researchSessionCount ?? null,
              researchStepCount: res.researchStepCount ?? null,
              stateVersion: res.stateVersion ?? null,
              persistedVersion: res.persistedVersion ?? null,
              pendingWrites: res.pendingWrites ?? null,
              persistDelayMs: res.persistDelayMs ?? null,
              inFlight: res.inFlight ?? null,
              lastDirtyAtMs: res.lastDirtyAtMs ?? null,
              lastPersistAtMs: res.lastPersistAtMs ?? null,
              lastError: res.lastError ?? null
            };
          }
        } catch {
          ledgerStats = ledgerStats || null;
        }
      }
      if (detail === 'full' && ledger?.list) {
        try {
          const listLimit = Math.min(150, Math.max(30, maxItems * 5));
          const listRes = await ledger.list({ limit: listLimit });
          if (listRes?.ok && Array.isArray(listRes.entries)) {
            const entries = listRes.entries as any[];
            ledgerRecentEntries = entries
              .filter((entry: any) => entry && String(entry.kind || '').toLowerCase() !== 'audit_event')
              .slice(0, maxItems)
              .map((entry: any) => ({
                id: String(entry.id || ''),
                kind: entry.kind != null ? String(entry.kind) : null,
                status: entry.status != null ? String(entry.status) : null,
                symbol: entry.symbol != null ? String(entry.symbol) : null,
                action: entry.action != null ? String(entry.action) : null,
                executionMode: entry.executionMode != null ? String(entry.executionMode) : null,
                executionId: entry.executionId != null ? String(entry.executionId) : null,
                runId: entry.runId != null ? String(entry.runId) : null,
                decisionId: entry.decisionId != null ? String(entry.decisionId) : null,
                createdAtMs: Number(entry.createdAtMs) || null,
                updatedAtMs: Number(entry.updatedAtMs) || null
              }));

            const taskEntries = entries.filter((entry: any) => {
              if (!entry || String(entry.kind || '').toLowerCase() !== 'audit_event') return false;
              const eventType = String(entry.eventType || '').toLowerCase();
              return eventType.startsWith('task_tree_');
            });
            const actionEntries = taskEntries.filter((entry: any) => entry?.payload?.taskType === 'action');
            const coreEntries = taskEntries.filter((entry: any) => entry?.payload?.taskType !== 'action');
            taskTreeEvents = coreEntries.slice(0, maxItems).map((entry: any) => ({
              eventType: String(entry.eventType || ''),
              runId: entry.runId != null ? String(entry.runId) : null,
              step: entry.payload?.step != null ? String(entry.payload.step) : null,
              status: entry.payload?.status != null ? String(entry.payload.status) : null,
              note: entry.payload?.note != null ? String(entry.payload.note) : null,
              error: entry.payload?.error != null ? String(entry.payload.error) : null,
              symbol: entry.symbol != null ? String(entry.symbol) : null,
              createdAtMs: Number(entry.createdAtMs) || null
            }));
            if (taskTreeEvents.length > 0) {
              const latest = taskTreeEvents[0];
              taskTreeLastRun = {
                runId: latest.runId ?? null,
                status: latest.status ?? null,
                lastEventType: latest.eventType ?? null,
                lastEventAtMs: latest.createdAtMs ?? null
              };
            }

            const persistEntries = coreEntries.filter((entry: any) => String(entry.eventType || '') === 'task_tree_persist');
            if (persistEntries.length > 0) {
              taskTreeRuns = persistEntries.slice(0, maxItems).map((entry: any) => {
                const summary = entry.payload || {};
                const steps = Array.isArray(summary.steps) ? summary.steps : [];
                return {
                  runId: String(summary.runId || entry.runId || ''),
                  status: summary.status != null ? String(summary.status) : null,
                  createdAtMs: Number(summary.createdAtMs) || null,
                  finishedAtMs: Number(summary.finishedAtMs) || null,
                  context: summary.context && typeof summary.context === 'object'
                    ? {
                        source: summary.context.source != null ? String(summary.context.source) : null,
                        symbol: summary.context.symbol != null ? String(summary.context.symbol) : null,
                        timeframe: summary.context.timeframe != null ? String(summary.context.timeframe) : null,
                        strategy: summary.context.strategy != null ? String(summary.context.strategy) : null,
                        watcherId: summary.context.watcherId != null ? String(summary.context.watcherId) : null,
                        mode: summary.context.mode != null ? String(summary.context.mode) : null
                      }
                    : null,
                  steps: steps.slice(0, 50).map((step: any) => ({
                    step: String(step.step || ''),
                    status: String(step.status || ''),
                    startedAtMs: Number(step.startedAtMs) || null,
                    finishedAtMs: Number(step.finishedAtMs) || null,
                    attempts: Number.isFinite(Number(step.attempts)) ? Number(step.attempts) : null,
                    retryCount: Number.isFinite(Number(step.retryCount)) ? Number(step.retryCount) : null,
                    error: step.error != null ? String(step.error) : null,
                    note: step.note != null ? String(step.note) : null
                  }))
                };
              });
            }

            actionTaskTreeEvents = actionEntries.slice(0, maxItems).map((entry: any) => ({
              eventType: String(entry.eventType || ''),
              runId: entry.runId != null ? String(entry.runId) : null,
              step: entry.payload?.step != null ? String(entry.payload.step) : null,
              status: entry.payload?.status != null ? String(entry.payload.status) : null,
              note: entry.payload?.note != null ? String(entry.payload.note) : null,
              error: entry.payload?.error != null ? String(entry.payload.error) : null,
              symbol: entry.symbol != null ? String(entry.symbol) : null,
              createdAtMs: Number(entry.createdAtMs) || null
            }));
            if (actionTaskTreeEvents.length > 0) {
              const latest = actionTaskTreeEvents[0];
              actionTaskTreeLastRun = {
                runId: latest.runId ?? null,
                status: latest.status ?? null,
                lastEventType: latest.eventType ?? null,
                lastEventAtMs: latest.createdAtMs ?? null
              };
            }

            const actionPersistEntries = actionEntries.filter((entry: any) => String(entry.eventType || '') === 'task_tree_persist');
            if (actionPersistEntries.length > 0) {
              actionTaskTreeRuns = actionPersistEntries.slice(0, maxItems).map((entry: any) => {
                const summary = entry.payload || {};
                const steps = Array.isArray(summary.steps) ? summary.steps : [];
                return {
                  runId: String(summary.runId || entry.runId || ''),
                  status: summary.status != null ? String(summary.status) : null,
                  createdAtMs: Number(summary.createdAtMs) || null,
                  finishedAtMs: Number(summary.finishedAtMs) || null,
                  context: summary.context && typeof summary.context === 'object'
                    ? {
                        source: summary.context.source != null ? String(summary.context.source) : null,
                        symbol: summary.context.symbol != null ? String(summary.context.symbol) : null,
                        timeframe: summary.context.timeframe != null ? String(summary.context.timeframe) : null,
                        strategy: summary.context.strategy != null ? String(summary.context.strategy) : null,
                        watcherId: summary.context.watcherId != null ? String(summary.context.watcherId) : null,
                        mode: summary.context.mode != null ? String(summary.context.mode) : null
                      }
                    : null,
                  steps: steps.slice(0, 50).map((step: any) => ({
                    step: String(step.step || ''),
                    status: String(step.status || ''),
                    startedAtMs: Number(step.startedAtMs) || null,
                    finishedAtMs: Number(step.finishedAtMs) || null,
                    attempts: Number.isFinite(Number(step.attempts)) ? Number(step.attempts) : null,
                    retryCount: Number.isFinite(Number(step.retryCount)) ? Number(step.retryCount) : null,
                    error: step.error != null ? String(step.error) : null,
                    note: step.note != null ? String(step.note) : null
                  }))
                };
              });
            }
          }
        } catch {
          ledgerRecentEntries = ledgerRecentEntries || undefined;
          taskTreeEvents = taskTreeEvents || undefined;
          taskTreeLastRun = taskTreeLastRun || null;
          taskTreeRuns = taskTreeRuns || undefined;
        }
      }
      const lastTradeEntry = (ledgerRecentEntries || []).find((entry) => entry?.kind === 'trade') || null;
      const lastTradeBlock = lastTradeBlockRef.current || null;

      const playbookStatus = playbookStatusByWatcher || {};
      const playbookKeys = Object.keys(playbookStatus);
      const watchersWithPlaybook = watchers.filter((w) => w?.playbook && w.playbook.enabled !== false).length;
      const taskTreeResumes = taskTreeResumeEntries
        .slice(0, detail === 'full' ? maxItems : 2)
        .map((entry) => ({
          taskType: entry.taskType,
          runId: String(entry.runId || ''),
          status: entry.status ?? null,
          createdAtMs: entry.createdAtMs ?? null,
          updatedAtMs: entry.updatedAtMs ?? null,
          queueDepth: entry.queueDepth ?? null,
          blocked: entry.blocked ?? null,
          blockedReason: entry.blockedReason ?? null,
          requiresConfirmation: entry.requiresConfirmation ?? null,
          context: entry.context ?? null,
          lastStep: entry.lastStep ?? null
        }));

      const autoCfg = autoPilotConfigRef.current || null;
      const effectiveAuto = autoCfg ? resolveAutoPilotPolicy(autoCfg).effective : null;
      const telegramRaw = autoCfg?.telegram || null;
      const telegramChatId = telegramRaw?.chatId ? String(telegramRaw.chatId).trim() : '';
      const telegramSuffix = telegramChatId ? telegramChatId.slice(-4) : '';
      const effectiveAllowedStrategies = Array.isArray(effectiveAuto?.allowedStrategies)
        ? effectiveAuto?.allowedStrategies
        : null;
      const effectiveAllowedTimeframes = Array.isArray(effectiveAuto?.allowedTimeframes)
        ? effectiveAuto?.allowedTimeframes
        : null;
      const backtestSummary = backtesterRef.current?.getSummary?.() || null;
      const persistenceHealth = getPersistenceHealthSnapshot();

      const snapshot: SystemStateSnapshot = {
        capturedAtMs,
        detail,
        health,
        truth: {
          projection: truthProjectionRef.current || truthProjection || null,
          updatedAtMs: truthProjectionUpdatedAtRef.current || null
        },
        sidebar: {
          isOpen: sidebarState.isOpen,
          mode: sidebarState.mode
        },
        chat: {
          isThinking: chatMeta.isThinking ?? null,
          replyMode: chatMeta.replyMode ?? null,
          isLive: chatMeta.isLive ?? null,
          chartChatIsLive: chatMeta.chartChatIsLive ?? null,
          chartChatThinking: chatMeta.chartChatThinking ?? null,
          liveMode: chatMeta.liveMode ?? null,
          messagesCount: chatMeta.messagesCount ?? null,
          lastMessageAtMs: chatMeta.lastMessageAtMs ?? null,
          chartChatMessagesCount: chatMeta.chartChatMessagesCount ?? null,
          chartChatLastMessageAtMs: chatMeta.chartChatLastMessageAtMs ?? null,
          activeAgentId: chatMeta.activeAgentId ?? null,
          agentsCount: chatMeta.agentsCount ?? agentsNow.length,
          sessionBias: chatMeta.sessionBias ?? null,
          autoTabVisionEnabled: chatMeta.autoTabVisionEnabled ?? null,
          chartWatchEnabled: chatMeta.chartWatchEnabled ?? null,
          chartWatchMode: chatMeta.chartWatchMode ?? null,
          chartWatchSnoozedUntilMs: chatMeta.chartWatchSnoozedUntilMs ?? null,
          postTradeReviewEnabled: chatMeta.postTradeReviewEnabled ?? null,
          postTradeReviewAgentId: chatMeta.postTradeReviewAgentId ?? null,
          chartWatchLeadAgentId: chatMeta.chartWatchLeadAgentId ?? null
        },
        agents: agentsList,
        tabs: {
          activeTabId: activeId || null,
          activeTab: activeTabNow
            ? {
                id: String(activeTabNow.id),
                title: activeTabNow.title ?? null,
                url: activeTabNow.url ?? null,
                isWatched: activeTabNow.isWatched ?? null,
                aiPinned: activeTabNow.aiPinned ?? null,
                aiLabel: activeTabNow.aiLabel ?? null
              }
            : null,
          items: tabItems,
          total: tabsNow.length,
          watched: watchedTabs,
          pinned: pinnedTabs
        },
        symbolScope: symbolScope
          ? {
              symbol: symbolScope.symbol,
              timeframes: symbolScope.timeframes,
              updatedAtMs: symbolScope.updatedAtMs,
              source: symbolScope.source ?? null
            }
          : null,
        tradelocker: {
          status: tlMeta.status ?? null,
          env: tlMeta.env ?? null,
          server: tlMeta.server ?? null,
          accountId: tlMeta.accountId ?? null,
          accNum: tlMeta.accNum ?? null,
          tradingEnabled: !!tlMeta.tradingEnabled,
          autoPilotEnabled: tlMeta.autoPilotEnabled ?? null,
          defaultOrderQty: tlMeta.defaultOrderQty ?? null,
          defaultOrderType: tlMeta.defaultOrderType ?? null,
          balance: tlMetrics?.balance ?? null,
          equity: tlMetrics?.equity ?? null,
          currency: tlMetrics?.currency ?? null,
          marginUsed: tlMetrics?.marginUsed ?? null,
          marginFree: tlMetrics?.marginFree ?? null,
          marginLevel: tlMetrics?.marginLevel ?? null,
          openGrossPnl: tlMetrics?.openGrossPnl ?? null,
          openNetPnl: tlMetrics?.openNetPnl ?? null,
          accountMetricsUpdatedAtMs: tlMeta.accountMetricsUpdatedAtMs ?? null,
          watchSymbols: Array.isArray(brokerWatchSymbols) ? brokerWatchSymbols.slice(0, maxItems) : null,
          positionsCount: positions.length,
          ordersCount: orders.length,
          openPositionsCount: tlMeta.openPositionsCount ?? positions.length,
          openOrdersCount: tlMeta.openOrdersCount ?? orders.length,
          positions: positionItems,
          orders: orderItems,
          streamStatus: tlMeta.streamStatus ?? null,
          streamError: tlMeta.streamError ?? null,
          streamUpdatedAtMs: tlMeta.streamUpdatedAtMs ?? null,
          lastError: tlMeta.lastError || null,
          quotesUpdatedAtMs: tlMeta.quotesUpdatedAtMs ?? null,
          quotesError: tlMeta.quotesError ?? null,
          quotesBySymbolCount: tlMeta.quotesBySymbol ? Object.keys(tlMeta.quotesBySymbol).length : null,
          snapshotUpdatedAtMs: tlMeta.snapshotUpdatedAtMs ?? null,
          rateLimitSuppressUntilMs: brokerRateLimitSuppressUntilMs || null
        },
        mt5: {
          bridgeAvailable: mt5BridgeAvailable ?? null,
          accountKey: mt5Spec?.accountKey ?? null,
          balance: Number.isFinite(mt5Balance) ? mt5Balance : null,
          equity: Number.isFinite(mt5Equity) ? mt5Equity : null,
          currency: mt5Spec?.currency ?? null,
          netting: mt5Spec?.netting ?? null,
          updatedAtMs: mt5Spec?.updatedAtMs ?? null,
          positionsCount: mt5PositionsCount ?? null,
          ordersCount: mt5OrdersCount ?? null,
          positionsUpdatedAtMs: mt5PositionsUpdatedAtMs ?? null,
          ordersUpdatedAtMs: mt5OrdersUpdatedAtMs ?? null,
          lastError: mt5SnapshotError ?? null
        },
        sim: {
          available: simAvailable ?? null,
          balance: Number.isFinite(Number(simBalance)) ? Number(simBalance) : null,
          equity: Number.isFinite(Number(simEquity)) ? Number(simEquity) : null,
          positionsCount: simPositionsList.length,
          floatingPnl: simFloatingPnl,
          updatedAtMs: simUpdatedAtMs ?? null
        },
        autopilot: {
          enabled: effectiveAuto?.enabled ?? autoCfg?.enabled ?? null,
          mode: effectiveAuto?.mode ?? autoCfg?.mode ?? null,
          policyMode: effectiveAuto?.mode ?? null,
          killSwitch: effectiveAuto?.killSwitch ?? autoCfg?.killSwitch ?? null,
          executionMode: effectiveAuto?.executionMode ?? autoCfg?.executionMode ?? null,
          decisionMode: autoCfg?.decisionMode ?? null,
          decisionAgentId: autoCfg?.decisionAgentId ?? null,
          decisionReasoningEffort: autoCfg?.decisionReasoningEffort ?? null,
          maxAgentCommandsPerMinute: autoCfg?.maxAgentCommandsPerMinute ?? null,
          riskPerTrade: effectiveAuto?.riskPerTrade ?? null,
          maxDailyLoss: effectiveAuto?.maxDailyLoss ?? null,
          maxOpenPositions: effectiveAuto?.maxOpenPositions ?? null,
          requireConfirmation: effectiveAuto?.requireConfirmation ?? null,
          spreadLimitModel: effectiveAuto?.spreadLimitModel ?? null,
          spreadLimitPct: effectiveAuto?.spreadLimitPct ?? null,
          spreadLimitAtrMult: effectiveAuto?.spreadLimitAtrMult ?? null,
          stopModel: effectiveAuto?.stopModel ?? null,
          stopPercent: effectiveAuto?.stopPercent ?? null,
          stopAtrMult: effectiveAuto?.stopAtrMult ?? null,
          defaultRR: effectiveAuto?.defaultRR ?? null,
          lotSize: effectiveAuto?.lotSize ?? null,
          maxOrdersPerMinute: effectiveAuto?.maxOrdersPerMinute ?? null,
          maxConsecutiveLosses: effectiveAuto?.maxConsecutiveLosses ?? null,
          perSymbolMaxPositions: effectiveAuto?.perSymbolMaxPositions ?? null,
          perSymbolMaxLot: effectiveAuto?.perSymbolMaxLot ?? null,
          allowedStrategies: effectiveAllowedStrategies ?? null,
          allowedTimeframes: effectiveAllowedTimeframes ?? null,
          symbolCapsRaw: autoCfg?.symbolCapsRaw ?? null,
          symbolAllowlistRaw: autoCfg?.symbolAllowlistRaw ?? null,
          symbolGroupMapRaw: autoCfg?.symbolGroupMapRaw ?? null,
          groupCapsRaw: autoCfg?.groupCapsRaw ?? null,
          driftActionWarn: autoCfg?.driftActionWarn ?? null,
          driftActionPoor: autoCfg?.driftActionPoor ?? null,
          driftActionCooldownHours: autoCfg?.driftActionCooldownHours ?? null,
          driftAutoRetest: autoCfg?.driftAutoRetest ?? null,
          driftRetestCooldownHours: autoCfg?.driftRetestCooldownHours ?? null,
          driftRetestRangeDays: autoCfg?.driftRetestRangeDays ?? null,
          driftRetestMaxCombos: autoCfg?.driftRetestMaxCombos ?? null,
          telegram: telegramRaw
            ? {
                connected: !!telegramRaw.connected,
                hasToken: !!String(telegramRaw.botToken || '').trim(),
                chatIdSuffix: telegramSuffix || null
              }
            : null
        },
        shadow: {
          stats: shadowTradeStatsRef.current ?? shadowTradeStats ?? null,
          compare: shadowTradeCompareRef.current ?? shadowTradeCompare ?? null
        },
        watchers: {
          total: watchers.length,
          enabled: watchers.filter((w) => w && w.enabled !== false).length,
          live: watchers.filter((w) => w && w.mode === 'live').length,
          paper: watchers.filter((w) => w && w.mode === 'paper').length,
          suggest: watchers.filter((w) => w && w.mode === 'suggest').length,
          profiles: profiles.length,
          signals: signals.length,
          lastEvalAtMs: setupWatcherLastEvalAtRef.current ?? null,
          lastSignalAtMs: setupWatcherLastSignalAtRef.current ?? null,
          blockedByRegime,
          items: watchersList,
          signalsList,
          profilesList
        },
        regimes: {
          total: Object.keys(regimeSnapshots).length,
          blocked: blockedByRegime,
          blocks: detail === 'full' ? regimeBlockEntries.slice(0, maxItems) : undefined,
          snapshots: regimeSnapshotList
        },
        setupLibrary: {
          total: setupLibraryEntries.length,
          updatedAtMs: setupLibraryUpdatedAtMs ?? null,
          error: setupLibraryError ?? null,
          tiers: Object.keys(setupLibraryTierCounts).length > 0 ? setupLibraryTierCounts : null,
          items: setupLibraryItems
        },
        chart: {
          nativeSymbol: nativeMeta?.symbol ?? null,
          nativeTimeframe: nativeMeta?.frames?.[0]?.resolution ?? null,
          chartSessions: chartSessionsNow.length,
          chartSessionsWatched,
          sessions: chartSessionsList
        },
        taskTree: {
          updatedAtMs: taskTreeUpdatedAtRef.current ?? null,
          queueDepth: taskTreeQueueDepth,
          processing: taskTreeProcessing,
          maxQueue: taskTreeMaxQueue,
          dedupeWindowMs: taskTreeDedupeWindowMs,
          resumes: taskTreeResumes,
          lastRun: taskTreeLastRun,
          recentEvents: taskTreeEvents,
          runs: taskTreeRuns,
          action: {
            updatedAtMs: taskTreeUpdatedAtRef.current ?? null,
            queueDepth: actionTaskTreeQueueDepth,
            processing: actionTaskTreeProcessing,
            maxQueue: actionTaskTreeMaxQueue,
            dedupeWindowMs: actionTaskTreeDedupeWindowMs,
            lastRun: actionTaskTreeLastRun,
            recentEvents: actionTaskTreeEvents,
            runs: actionTaskTreeRuns,
            activeStepConfig: actionTaskActiveStepRef.current
              ? {
                  runId: actionTaskActiveStepRef.current.runId ?? null,
                  actionId: actionTaskActiveStepRef.current.actionId ?? null,
                  maxRetries: actionTaskActiveStepRef.current.maxRetries ?? null,
                  retryDelayMs: actionTaskActiveStepRef.current.retryDelayMs ?? null,
                  timeoutMs: actionTaskActiveStepRef.current.timeoutMs ?? null
                }
              : null
          }
        },
        taskPlaybooks: {
          total: (taskPlaybooksRef.current || []).length,
          updatedAtMs: taskPlaybookUpdatedAtMs ?? null,
          activeRun: taskPlaybookActiveRunRef.current ?? null,
          recentRuns: detail === 'full' ? (taskPlaybookRunsRef.current || []).slice(0, maxItems) : undefined,
          library: detail === 'full'
            ? (taskPlaybooksRef.current || []).slice(0, maxItems).map((p) => ({
                id: p.id,
                name: p.name,
                version: p.version ?? null,
                defaultMode: p.defaultMode ?? null,
                symbol: p.symbol ?? null,
                timeframes: p.timeframes ?? null,
                strategy: p.strategy ?? null
              }))
            : undefined
        },
        execution: {
          playbookRunning: playbookRunningRef.current || false,
          playbookLastRunAtMs: playbookLastRunAtRef.current || null,
          lossStreak: lossStreakState
            ? {
                streak: lossStreakState.streak ?? null,
                lastClosedAtMs: lossStreakState.lastClosedAtMs ?? null,
                updatedAtMs: lossStreakState.updatedAtMs ?? null,
                accountKey: lossStreakState.accountKey ?? null
              }
            : null,
          lastTrade: lastTradeEntry
            ? {
                id: lastTradeEntry.id,
                status: lastTradeEntry.status ?? null,
                symbol: lastTradeEntry.symbol ?? null,
                action: lastTradeEntry.action ?? null,
                executionMode: lastTradeEntry.executionMode ?? null,
                executionId: lastTradeEntry.executionId ?? null,
                createdAtMs: lastTradeEntry.createdAtMs ?? null,
                updatedAtMs: lastTradeEntry.updatedAtMs ?? null
              }
            : null,
          lastTradeBlock: lastTradeBlock || null,
          shadow: shadowTradeStatsRef.current ?? shadowTradeStats ?? null
        },
        playbooks: {
          watchersWithPlaybook,
          activeCount: playbookKeys.length,
          byWatcher: detail === 'full' ? playbookStatus : undefined
        },
        ledger: {
          stats: ledgerStats,
          recentEntries: ledgerRecentEntries
        },
        persistence: {
          overallOk: persistenceHealth.overallOk,
          updatedAtMs: persistenceHealth.updatedAtMs,
          domains: persistenceHealth.domains
        },
        performance: {
          summary: setupPerformanceSummary ?? null,
          updatedAtMs: setupPerformanceUpdatedAtMs ?? null,
          error: setupPerformanceError ?? null,
          byWatcherCount: Object.keys(setupPerformanceByWatcher || {}).length,
          byLibraryCount: Object.keys(setupPerformanceByLibrary || {}).length,
          byModeCount: Object.keys(setupPerformanceByMode || {}).length,
          bySymbolCount: Object.keys(setupPerformanceBySymbol || {}).length
        },
        backtester: {
          symbol: backtestSummary?.symbol ?? null,
          timeframe: backtestSummary?.timeframe ?? null,
          rangeDays: backtestSummary?.rangeDays ?? null,
          bars: backtestSummary?.bars ?? null,
          stats: detail === 'full' ? backtestSummary?.stats ?? null : undefined,
          performance: detail === 'full' ? backtestSummary?.performance ?? null : undefined,
          validation: detail === 'full' ? backtestSummary?.validation ?? null : undefined,
          walkForward: detail === 'full' ? backtestSummary?.walkForward ?? null : undefined,
          updatedAtMs: backtestSummary?.updatedAtMs ?? null
        }
      };

      const lines = [
        `System snapshot (${detail})`,
        `Sidebar: ${sidebarState.isOpen ? 'open' : 'closed'} | Mode ${sidebarState.mode}`,
        `Tabs: ${tabsNow.length} total | Watched ${watchedTabs} | Pinned ${pinnedTabs}`,
        `TradeLocker: ${tlMeta.status || 'unknown'}${tlMeta.env ? ` (${String(tlMeta.env).toUpperCase()})` : ''}${tlMeta.accNum != null ? ` #${tlMeta.accNum}` : ''}`,
        `Positions ${positions.length} | Orders ${orders.length} | Stream ${tlMeta.streamStatus || 'unknown'}`,
        `AutoPilot: ${effectiveAuto?.enabled ? 'ENABLED' : 'DISABLED'} | Mode ${effectiveAuto?.mode || '--'} | Kill ${effectiveAuto?.killSwitch ? 'ON' : 'off'}`,
        lastTradeBlock && (lastTradeBlock.reason || lastTradeBlock.code)
          ? `Last trade block: ${lastTradeBlock.reason || lastTradeBlock.code}${lastTradeBlock.symbol ? ` (${lastTradeBlock.symbol})` : ''}`
          : null,
        `Watchers: ${watchers.filter((w) => w && w.enabled !== false).length}/${watchers.length} enabled | Signals ${signals.length} | Profiles ${profiles.length}`,
        symbolScopeSymbol ? `Symbol scope: ${symbolScopeSymbol} | TF ${symbolScopeTimeframesLabel || '4H/1H/15M'}` : 'Symbol scope: --',
        nativeMeta?.symbol ? `Native chart: ${nativeMeta.symbol} (${nativeMeta.frames?.length || 0} frames)` : 'Native chart: --',
        taskTreeUpdatedAtRef.current ? `Task tree updated ${formatAge(taskTreeUpdatedAtRef.current)}` : 'Task tree: --',
        actionTaskTreeQueueDepth != null
          ? `Action tasks queued: ${actionTaskTreeQueueDepth}`
          : 'Action tasks queued: --',
        ledgerStats
          ? `Ledger: ${ledgerStats.entriesCount ?? 0} entries | ${ledgerStats.agentMemoryCount ?? 0} agent memories`
          : 'Ledger: --',
        backtestSummary?.symbol
          ? `Backtester: ${backtestSummary.symbol} ${backtestSummary.timeframe || ''} (${backtestSummary.rangeDays || 0}d)`
          : 'Backtester: --'
      ];

      return finalizeToolResult({
        ok: true,
        text: lines.filter(Boolean).join('\n'),
        payload: snapshot
      });
    }

    if (action.type === 'GET_APP_SNAPSHOT') {
      const capture = window.glass?.captureNativeSnapshot;
      if (!capture) {
        return finalizeToolResult({ ok: false, text: 'Native snapshot capture unavailable.' }, { detail: 'capture_unavailable' });
      }
      const options = {
        format: action.format,
        quality: action.quality,
        width: action.width,
        height: action.height
      };
      const result = await capture(options);
      if (!result) {
        const err = window.glass?.getLastCaptureError?.() || 'Capture failed.';
        return finalizeToolResult({ ok: false, text: err }, { detail: 'capture_failed' });
      }
      const dataUrl = `data:${result.mimeType || 'image/jpeg'};base64,${result.data}`;
      let savedPath: string | null = null;
      if (action.save) {
        try {
          const saver = window.glass?.saveUserFile;
          if (saver) {
            const label = action.label ? String(action.label).trim() : '';
            const prefix = label ? `app_snapshot_${label}` : 'app_snapshot';
            const saved = await saver({ dataUrl, subdir: 'app-snapshots', prefix });
            if (saved?.ok && saved.path) {
              savedPath = String(saved.path);
            }
          }
        } catch {
          // ignore save failures
        }
      }
      const message = savedPath ? 'App snapshot captured and saved.' : 'App snapshot captured.';
      return finalizeToolResult(
        {
          ok: true,
          text: message,
          imageDataUrl: dataUrl,
          payload: { savedPath }
        },
        { detail: savedPath ? 'capture_saved' : 'capture_only' }
      );
    }

    if (action.type === 'GET_NATIVE_CHART_SNAPSHOT') {
      const requestedSymbol =
        String(action.symbol || '').trim() ||
        String(symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
      const requestedTimeframe = String(action.timeframe || '').trim();

      const ensureConnect = ensureTradeLockerConnectedRef.current;
      if (ensureConnect) {
        try {
          await ensureConnect('native_chart_snapshot');
        } catch {
          // ignore
        }
      }

      if (!nativeChartMounted) {
        setNativeChartMounted(true);
      }

      const sleep = (ms: number) => sleepMs(ms);
      const maxWaitMs = 3500;
      const startedAt = Date.now();
      let snapshot: string | null = null;
      let meta: NativeChartMeta | null = null;

      while (Date.now() - startedAt < maxWaitMs) {
        const chart = nativeChartRef.current;
        if (chart?.focusSymbol && requestedSymbol) {
          chart.focusSymbol(requestedSymbol, requestedTimeframe, { revealSetups: false });
        } else if (chart?.ensureFrameActive && requestedTimeframe) {
          chart.ensureFrameActive(requestedTimeframe);
        }
          snapshot = chart?.captureSnapshot ? chart.captureSnapshot() : null;
          if (snapshot) {
            meta = chart?.getMeta ? chart.getMeta() : null;
            lastNativeChartSnapshotRef.current = { dataUrl: snapshot, meta, capturedAtMs: Date.now() };
            const snapshotSymbol = requestedSymbol || meta?.symbol || null;
            const snapshotTimeframe = requestedTimeframe || null;
            void persistChartSnapshotMemory({
              imageDataUrl: snapshot,
              meta,
              symbol: snapshotSymbol,
              timeframe: snapshotTimeframe,
              source: 'setup_signal'
            });
            break;
          }
        await sleep(350);
      }

      if (!snapshot) {
        const cached = lastNativeChartSnapshotRef.current;
        if (cached?.dataUrl) {
          const cachedAge = cached.capturedAtMs ? formatAge(cached.capturedAtMs) : '';
          const cachedMeta = cached.meta || null;
          return finalizeToolResult(
            {
              ok: true,
              text: `Native chart snapshot unavailable. Using last snapshot${cachedAge ? ` from ${cachedAge}` : ''}.`,
              imageDataUrl: cached.dataUrl,
              payload: cachedMeta || undefined
            },
            { detail: 'snapshot_cached', symbol: cachedMeta?.symbol || requestedSymbol || null, frames: cachedMeta?.frames?.length ?? null }
          );
        }
        return finalizeToolResult(
          {
            ok: true,
            text: 'Native chart snapshot unavailable. Proceed with broker quotes/bars; visuals are optional.',
            payload: { unavailable: true, symbol: requestedSymbol || null }
          },
          { detail: 'snapshot_unavailable', symbol: requestedSymbol || null }
        );
      }

      const frames = meta?.frames || [];
      const frameLines = frames.length
        ? frames.map((frame) => {
            const age = frame.updatedAtMs ? formatAge(frame.updatedAtMs) : '';
            const details = [
              frame.label || frame.resolution,
              `${frame.bars || 0} bars`,
              age ? `updated ${age}` : ''
            ].filter(Boolean).join(' | ');
            return `- ${details}`;
          })
        : [];
      const updatedLabel = meta?.updatedAtMs ? formatAge(meta.updatedAtMs) : '';
      const lines = [
        `Native chart snapshot captured${meta?.symbol ? ` for ${meta.symbol}` : ''}.`,
        updatedLabel ? `Last update: ${updatedLabel}` : '',
        frameLines.length ? `Frames:\n${frameLines.join('\n')}` : ''
      ].filter(Boolean);
      return finalizeToolResult(
        {
          ok: true,
          text: lines.join('\n'),
          imageDataUrl: snapshot,
          payload: meta || undefined
        },
        { symbol: meta?.symbol || null, frames: frames.length }
      );
    }

    if (action.type === 'GET_BACKTEST_SUMMARY') {
      const summary = backtesterRef.current?.getSummary?.();
      if (!summary) {
        return finalizeToolResult(
          { ok: false, text: 'Backtester summary unavailable. Open the Backtester panel and load history first.' },
          { detail: 'summary_unavailable' }
        );
      }
      const fmtPct = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
      };
      const fmtR = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
      };
      const fmtNum = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? num.toFixed(2) : '--';
      };

      const stats = summary.stats || ({} as any);
      const perf = summary.performance || ({} as any);
      const validation = summary.validation && (summary.validation as any).enabled ? summary.validation : null;
      const walkForward = summary.walkForward && (summary.walkForward as any).enabled ? summary.walkForward : null;

      const lines = [
        'Backtest summary',
        `Symbol: ${summary.symbol}`,
        `Timeframe: ${summary.timeframe}`,
        `Range: last ${summary.rangeDays}d`,
        `Bars: ${summary.bars}`,
        `Trades: ${stats.total ?? 0} | Win rate: ${fmtPct(stats.winRate)} | Expectancy: ${fmtR(stats.expectancy)} | PF: ${fmtNum(stats.profitFactor)}`,
        `Net R: ${fmtR(perf.netR)} | Max DD: ${fmtR(perf.maxDrawdown)}${perf.maxDrawdownPct != null ? ` (${fmtPct(perf.maxDrawdownPct)})` : ''}`,
        summary.updatedAtMs ? `Updated: ${formatAge(summary.updatedAtMs)}` : ''
      ].filter(Boolean);

      if (validation) {
        const v = validation as any;
        const train = v.train || {};
        const test = v.test || {};
        lines.push(
          `Validation: ${v.mode === 'last_days' ? `last ${v.lastDays}d` : `${v.splitPercent}% split`}`,
          `Train WR ${fmtPct(train.winRate)} Exp ${fmtR(train.expectancy)} PF ${fmtNum(train.profitFactor)} Net ${fmtR(train.netR)}`,
          `Test WR ${fmtPct(test.winRate)} Exp ${fmtR(test.expectancy)} PF ${fmtNum(test.profitFactor)} Net ${fmtR(test.netR)}`
        );
      }
      if (walkForward) {
        const wf = walkForward as any;
        lines.push(
          `Walk-forward: ${wf.trainDays}d/${wf.testDays}d step ${wf.stepDays}d (folds ${wf.folds})`,
          `Avg Test Net ${fmtR(wf.avgNetR)} Exp ${fmtR(wf.avgExpectancy)} WR ${fmtPct(wf.avgWinRate)} PF ${fmtNum(wf.avgProfitFactor)}`,
          `Positive folds: ${fmtPct(wf.positiveNetPct)}`
        );
      }

      return finalizeToolResult(
        { ok: true, text: lines.join('\n'), payload: summary },
        { symbol: summary.symbol, timeframe: summary.timeframe, trades: stats.total ?? 0 }
      );
    }

    if (action.type === 'GET_BACKTEST_TRAINING_PACK') {
      const totalPack = backtesterRef.current?.getTrainingPack?.({ limit: 0 });
      const totalEpisodes = totalPack?.meta?.totalEpisodes ?? totalPack?.episodes?.length ?? 0;
      const limitRaw = Number(action.limit ?? action.maxEpisodes);
      const limitDefault = 200;
      const limit = Number.isFinite(limitRaw)
        ? Math.max(0, Math.min(400, Math.floor(limitRaw)))
        : limitDefault;
      const offsetRaw = Number(action.offset);
      const offset = Number.isFinite(offsetRaw)
        ? Math.max(0, Math.min(Math.max(0, totalEpisodes - 1), Math.floor(offsetRaw)))
        : Math.max(0, totalEpisodes - Math.max(1, limit));

      const pack = backtesterRef.current?.getTrainingPack?.({ offset, limit });
      if (!pack) {
        return finalizeToolResult(
          { ok: false, text: 'Backtest training pack unavailable. Open the Backtester panel and load history first.' },
          { detail: 'training_pack_unavailable' }
        );
      }
      const chunkEpisodes = Array.isArray(pack.episodes) ? pack.episodes : [];
      const total = Number.isFinite(Number(pack.meta?.totalEpisodes))
        ? Number(pack.meta?.totalEpisodes)
        : totalEpisodes;
      const start = Number.isFinite(Number(pack.meta?.offset)) ? Number(pack.meta?.offset) : offset;
      const nextOffset = pack.meta?.nextOffset ?? null;

      const maxText = 12000;
      let json = '';
      try {
        json = JSON.stringify(pack, null, 2);
      } catch {
        json = '';
      }
      const truncated = json.length > maxText;
      const jsonBlock = json
        ? `${json.slice(0, truncated ? maxText : json.length)}${truncated ? '\n...truncated...' : ''}`
        : '';
      const header = `Backtest training pack (${pack.meta?.symbol || 'Symbol'} ${pack.meta?.timeframe || ''})`;
      const hint = truncated
        ? 'JSON truncated for chat. Request fewer episodes or smaller limits if needed.'
        : '';
      const nextHint = nextOffset != null ? `Next offset: ${nextOffset}` : 'End of pack.';
      const textParts = [
        header,
        pack.meta
          ? `Episodes: ${pack.meta.totalEpisodes ?? chunkEpisodes.length} | Offset ${start} | Limit ${pack.meta.limit ?? limit} | Returned ${chunkEpisodes.length}`
          : '',
        nextHint,
        hint,
        jsonBlock ? `JSON:\n${jsonBlock}` : 'JSON unavailable.'
      ].filter(Boolean);
      return finalizeToolResult(
        { ok: true, text: textParts.join('\n'), payload: pack },
        { symbol: pack.meta?.symbol || null, timeframe: pack.meta?.timeframe || null, episodes: chunkEpisodes.length, offset: start }
      );
    }

      if (action.type === 'RUN_BACKTEST_OPTIMIZATION') {
        const rawStrategy = resolveToolStrategy(action);
        const allowedStrategies = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
        if (!rawStrategy || !allowedStrategies.has(rawStrategy)) {
          return finalizeToolResult({
            ok: false,
            text: 'Backtest optimization requires a supported strategy (range breakout, break + retest, FVG retrace, trend pullback, mean reversion).'
          });
        }

        const summary = backtesterRef.current?.getSummary?.();
        const symbolsRaw = Array.isArray(action.symbols) ? action.symbols : [];
      const symbolList = symbolsRaw.length > 0
        ? symbolsRaw.map((s) => String(s || '').trim()).filter(Boolean)
        : symbol ? [symbol] : [];
      if (symbolList.length === 0) {
        return finalizeToolResult({ ok: false, text: 'Backtest optimization requires at least one symbol.' });
      }
      if (symbolList.length > 0) {
        setBacktestSymbol(symbolList[0]);
      }

      const timeframesRaw = Array.isArray(action.timeframes) ? action.timeframes : [];
      const timeframeList = timeframesRaw.length > 0
        ? timeframesRaw.map((tf) => String(tf || '').trim()).filter(Boolean)
        : action.timeframe ? [String(action.timeframe).trim()] : [''];

        const seedParams = resolveStrategyParams(action);
        const seededGrid = seedParams ? buildParamGridFromParams(seedParams) : {};
        const rawParamGrid =
          action.paramGrid && typeof action.paramGrid === 'object'
            ? action.paramGrid
            : {};
        const baseParamGrid = { ...seededGrid, ...rawParamGrid };
      const timeFilter =
        action.timeFilter && typeof action.timeFilter === 'object'
          ? action.timeFilter
          : undefined;
      const usePreset = action.usePreset === true || !baseParamGrid || Object.keys(baseParamGrid).length === 0;
      const presetKeyRaw = action.presetKey ? String(action.presetKey).trim() : '';
      const executionPreset = normalizeExecutionPresetKey(action.executionPreset ?? action.realityPreset);
      const execution = resolveExecutionConfig(action.execution, summary?.execution, executionPreset);
      const executionLine = formatExecutionSummary(execution, executionPreset);
      const validationLine = formatValidationSummary(action.validation);

      const ledger = window.glass?.tradeLedger;
      const messageId = String(action.messageId || '').trim();
      let cancelToken = messageId ? backtestOptimizationCancelRef.current.get(messageId) : undefined;
      if (messageId && !cancelToken) {
        cancelToken = { cancelled: false };
        backtestOptimizationCancelRef.current.set(messageId, cancelToken);
      }

      const totalRuns = Math.max(1, symbolList.length * timeframeList.length);
      let runIndex = 0;
      const batchResults: Array<{ symbol: string; timeframe: string; result: any }> = [];

      const formatPct = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
      };
      const formatR = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
      };
      const formatPf = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? num.toFixed(2) : '--';
      };
      const formatParams = (params: Record<string, any>) => {
        const order =
          rawStrategy === 'BREAK_RETEST'
            ? ['lookbackBars', 'atrPeriod', 'atrMult', 'rr', 'cooldownBars', 'breakoutMode', 'bufferAtrMult', 'retestBars', 'retestBufferAtrMult', 'retestConfirm']
            : rawStrategy === 'FVG_RETRACE'
            ? ['atrPeriod', 'atrMult', 'rr', 'maxWaitBars', 'entryMode', 'minGapAtrMult']
            : rawStrategy === 'TREND_PULLBACK'
              ? ['fastEma', 'slowEma', 'pullbackEma', 'confirmMode', 'minTrendBars', 'atrPeriod', 'atrMult', 'rr', 'cooldownBars']
              : rawStrategy === 'MEAN_REVERSION'
                ? ['smaPeriod', 'atrPeriod', 'bandAtrMult', 'stopAtrMult', 'rr', 'cooldownBars', 'useRsiFilter', 'rsiPeriod', 'rsiOversold', 'rsiOverbought']
                : ['lookbackBars', 'atrPeriod', 'atrMult', 'rr', 'cooldownBars', 'breakoutMode', 'bufferAtrMult'];

        const entries = Object.entries(params || {})
          .filter(([key, value]) => key !== 'enabled' && value != null)
          .sort((a, b) => {
            const aIdx = order.indexOf(a[0]);
            const bIdx = order.indexOf(b[0]);
            if (aIdx === -1 && bIdx === -1) return a[0].localeCompare(b[0]);
            if (aIdx === -1) return 1;
            if (bIdx === -1) return -1;
            return aIdx - bIdx;
          })
          .map(([key, value]) => `${key} ${value}`);
        return entries.join(', ');
      };

      const loadPresetGrid = async (symbolKey: string, timeframeKey: string) => {
        if (!ledger?.getAgentMemory) return null;
        const safeTf = timeframeKey || '15m';
        const defaultKey = `backtest_preset:${symbolKey}:${rawStrategy}:${safeTf}`;
        const key = presetKeyRaw || defaultKey;
        try {
          let res = await ledger.getAgentMemory({ key, touch: true });
          if (!res?.ok && !presetKeyRaw) {
            const fallbackKey = `backtest_preset:${symbolKey}:${rawStrategy}`;
            res = await ledger.getAgentMemory({ key: fallbackKey, touch: true });
          }
          if (res?.ok && res.memory?.payload?.paramGrid) {
            return { key: res.memory.key || key, grid: res.memory.payload.paramGrid };
          }
        } catch {
          // ignore
        }
        return null;
      };

      const savePresetGrid = async (symbolKey: string, timeframeKey: string, grid: Record<string, any>) => {
        if (!ledger?.upsertAgentMemory) return;
        const safeTf = timeframeKey || '15m';
        const keyBase = presetKeyRaw || `backtest_preset:${symbolKey}:${rawStrategy}:${safeTf}`;
        const key = totalRuns > 1 && presetKeyRaw ? `${keyBase}:${symbolKey}:${safeTf}` : keyBase;
        const summary = `Preset ${symbolKey} ${safeTf} ${rawStrategy}`;
        try {
          await ledger.upsertAgentMemory({
            key,
            familyKey: `backtest_preset:${symbolKey}:${rawStrategy}`,
            kind: 'backtest_preset',
            symbol: symbolKey,
            timeframe: safeTf,
            summary,
            payload: {
              strategy: rawStrategy,
              timeframe: safeTf,
              rangeDays: action.rangeDays,
              timeFilter,
              paramGrid: grid
            },
            source: 'agent',
            tags: [symbolKey, safeTf, rawStrategy, 'backtest', 'preset']
          });
        } catch {
          // ignore
        }
      };

      for (const symbolKey of symbolList) {
        for (const tfRaw of timeframeList) {
          runIndex += 1;
          const timeframeKey = String(tfRaw || '').trim();
          const runLabel = `Run ${runIndex}/${totalRuns}: ${symbolKey} ${timeframeKey || '15m'}`;

          if (cancelToken?.cancelled) {
            break;
          }

          let paramGrid: Record<string, any> | null =
            baseParamGrid && Object.keys(baseParamGrid).length > 0 ? baseParamGrid : null;

          if (usePreset) {
            const preset = await loadPresetGrid(symbolKey, timeframeKey);
            if (preset?.grid) {
              paramGrid = preset.grid;
            }
          }

          if (!paramGrid || Object.keys(paramGrid).length === 0) {
            const fallbackGrid = buildDefaultOptimizationGrid(rawStrategy);
            if (fallbackGrid && Object.keys(fallbackGrid).length > 0) {
              paramGrid = fallbackGrid;
            }
          }

          if (!paramGrid || Object.keys(paramGrid).length === 0) {
            return finalizeToolResult({
              ok: false,
              text: 'Backtest optimization requires a paramGrid or a saved preset.'
            });
          }

          if (baseParamGrid && Object.keys(baseParamGrid).length > 0) {
            await savePresetGrid(symbolKey, timeframeKey, baseParamGrid);
          }

          let result: any;
            const history = await loadBacktestOptimizationHistory({
              symbol: symbolKey,
              strategy: rawStrategy as any,
              timeframe: timeframeKey || undefined,
              rangeDays: action.rangeDays,
              maxCombos: action.maxCombos,
              timeFilter,
              paramGrid,
              execution
            });

          if (!history.ok) {
            result = {
              ok: false,
              schemaVersion: 1,
              runId: history.runId,
              symbol: symbolKey,
              strategy: rawStrategy,
              timeframe: history.timeframe || timeframeKey || '',
              rangeDays: history.rangeDays || action.rangeDays || 0,
              bars: 0,
              combosTested: 0,
              combosRequested: 0,
              truncated: false,
              ranAtMs: history.startedAtMs,
              elapsedMs: Date.now() - history.startedAtMs,
              error: history.error || 'Backtest optimization failed.'
            };
            } else {
              try {
                const baseRequest =
                  history.request || {
                    symbol: symbolKey,
                    strategy: rawStrategy as any,
                    timeframe: timeframeKey || undefined,
                    rangeDays: action.rangeDays,
                    maxCombos: action.maxCombos,
                    timeFilter,
                    paramGrid
                  };
                result = await runBacktestOptimizationWorker(
                  {
                    request: {
                      ...baseRequest,
                      execution: execution ?? (baseRequest as any).execution
                    },
                    bars: history.bars,
                    history: history.history,
                    runId: history.runId,
                    startedAtMs: history.startedAtMs
                  },
                {
                  shouldCancel: () => !!cancelToken?.cancelled,
                  onProgress: (progress) => {
                    if (!onProgress) return;
                    const pct = progress.total > 0
                      ? Math.min(1, Math.max(0, progress.done / progress.total))
                      : 0;
                    const overall = totalRuns > 0
                      ? (runIndex - 1 + pct) / totalRuns
                      : pct;
                    onProgress({
                      progressPct: Math.round(overall * 100),
                      progressDone: progress.done,
                      progressTotal: progress.total,
                      progressLabel: `${runLabel} | ${progress.done}/${progress.total} combos`
                    });
                  }
                }
              );
            } catch {
                result = await runBacktestOptimization(
                  {
                    symbol: symbolKey,
                    strategy: rawStrategy as any,
                    timeframe: timeframeKey || undefined,
                    rangeDays: action.rangeDays,
                    maxCombos: action.maxCombos,
                    timeFilter,
                    paramGrid,
                    execution: execution ?? (history.request as any)?.execution
                  },
                  {
                    shouldCancel: () => !!cancelToken?.cancelled,
                    onProgress: (progress) => {
                    if (!onProgress) return;
                    const pct = progress.total > 0
                      ? Math.min(1, Math.max(0, progress.done / progress.total))
                      : 0;
                    const overall = totalRuns > 0
                      ? (runIndex - 1 + pct) / totalRuns
                      : pct;
                    onProgress({
                      progressPct: Math.round(overall * 100),
                      progressDone: progress.done,
                      progressTotal: progress.total,
                      progressLabel: `${runLabel} | ${progress.done}/${progress.total} combos`
                    });
                  }
                }
              );
            }
          }

          batchResults.push({ symbol: symbolKey, timeframe: timeframeKey || result.timeframe, result });
          if (!result.ok || result.cancelled) {
            break;
          }
        }

        if (cancelToken?.cancelled) break;
      }

      if (messageId) {
        backtestOptimizationCancelRef.current.delete(messageId);
      }

      const isBatch = batchResults.length > 1;
      const lines: string[] = [];
      if (isBatch) {
        lines.push(`Backtest optimization batch (${rawStrategy})`);
        lines.push(executionLine);
        lines.push(validationLine);
      }

      for (const entry of batchResults) {
        const result = entry.result;
        if (!result?.ok) {
          lines.push(`${entry.symbol} ${entry.timeframe || ''}: ${result?.error || 'Failed'}`);
          continue;
        }

        const header = `${entry.symbol} ${result.timeframe} ${result.rangeDays}d`;
        const comboLine = `Combos ${result.combosTested}${result.truncated ? ' (truncated)' : ''} | Bars ${result.bars} | Time ${Math.max(0, Math.round(result.elapsedMs))}ms`;
        const top = (result.topConfigs || [])[0];
        const topLine = top
          ? `${formatParams(top.params)} | Net ${formatR(top.performance?.netR)} | WR ${formatPct(top.stats?.winRate)} | PF ${formatPf(top.stats?.profitFactor)} | Trades ${top.stats?.total ?? 0}`
          : 'No configs returned.';
        lines.push(isBatch ? `${header} :: ${topLine}` : `Backtest optimization (${header} ${rawStrategy})`);
        if (!isBatch) {
          const filterLine =
            timeFilter && (timeFilter.startHour != null || timeFilter.endHour != null)
              ? `Session filter: ${timeFilter.startHour ?? '--'}-${timeFilter.endHour ?? '--'} ${timeFilter.timezone || 'utc'}`
              : '';
          lines.push(executionLine);
          lines.push(validationLine);
          lines.push(filterLine);
          lines.push(comboLine);
          lines.push(topLine);
        }

        try {
          const ledger = window.glass?.tradeLedger;
          if (ledger?.upsertAgentMemory) {
            const memoryKey = `backtest_opt:${result.symbol}:${result.timeframe}:${result.strategy}`;
            const familyKey = `backtest_opt:${result.symbol}:${result.timeframe}`;
            const runId = result.runId || `opt_${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;
            const runKey = `backtest_opt_run:${result.symbol}:${result.timeframe}:${result.strategy}:${runId}`;
            const summary = `${header} ${rawStrategy}\n${executionLine}\n${topLine}`;
              const payload = {
                schemaVersion: result.schemaVersion ?? 1,
                runId,
                strategy: result.strategy,
                rangeDays: result.rangeDays,
                timeFilter,
                execution,
                combosTested: result.combosTested,
                combosRequested: result.combosRequested,
                truncated: result.truncated,
                cancelled: result.cancelled,
              bestConfig: result.bestConfig,
              topConfigs: result.topConfigs,
              history: result.history || null
            };
            await ledger.upsertAgentMemory({
              key: memoryKey,
              familyKey,
              kind: 'backtest_optimization',
              symbol: result.symbol,
              timeframe: result.timeframe,
              summary,
              payload,
              source: 'agent',
              tags: [result.symbol, result.timeframe, result.strategy, 'backtest', 'optimization']
            });
            await ledger.upsertAgentMemory({
              key: runKey,
              familyKey,
              kind: 'backtest_optimization_run',
              symbol: result.symbol,
              timeframe: result.timeframe,
              summary: `Run ${runId} | ${summary}`,
              payload,
              source: 'agent',
              tags: [result.symbol, result.timeframe, result.strategy, 'backtest', 'optimization', 'run', runId]
            });
            await saveSetupLibraryFromOptimization(result, { timeFilter, source: 'agent' });
          }
        } catch {
          // ignore memory persistence errors
        }
      }

      if (batchResults.length === 0) {
        return finalizeToolResult({ ok: false, text: 'Backtest optimization failed to run.' });
      }

      if (!isBatch) {
        const single = batchResults[0]?.result;
        if (single?.ok && single.bestConfig) {
          try {
            applyOrQueueBacktestOptimization({
              strategy: rawStrategy,
              params: single.bestConfig.params,
              timeframe: single.timeframe,
              rangeDays: single.rangeDays,
              symbol: single.symbol
            });
          } catch {
            // ignore apply errors
          }
        }
      }

        return finalizeToolResult(
          { ok: true, text: lines.filter(Boolean).join('\n'), payload: batchResults.map((b) => b.result) },
          { symbol: symbolList[0] || null, timeframe: timeframeList[0] || null }
        );
      }

      if (action.type === 'START_BACKTEST_OPTIMIZER') {
        const rawStrategy = resolveToolStrategy(action);
        const allowedStrategies = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
        if (!rawStrategy || !allowedStrategies.has(rawStrategy)) {
          return finalizeToolResult({
            ok: false,
            text: 'Backtest optimizer requires a supported strategy (range breakout, break + retest, FVG retrace, trend pullback, mean reversion).'
          });
        }

        const summary = backtesterRef.current?.getSummary?.();
        const symbol =
          String(action.symbol || '').trim() ||
          String(summary?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
        if (!symbol) {
          return finalizeToolResult({ ok: false, text: 'Backtest optimizer requires a symbol.' });
        }
        const timeframe =
          String(action.timeframe || '').trim() ||
          String(summary?.timeframe || '').trim();
        if (!timeframe) {
          return finalizeToolResult({ ok: false, text: 'Backtest optimizer requires a timeframe.' });
        }
        setBacktestSymbol(symbol);

        const timeFilter =
          action.timeFilter && typeof action.timeFilter === 'object'
            ? action.timeFilter
            : undefined;
        const executionPreset = normalizeExecutionPresetKey(action.executionPreset ?? action.realityPreset);
        const execution = resolveExecutionConfig(action.execution, summary?.execution, executionPreset);
        const validation = resolveOptimizationValidation(action.validation, summary);
        const rangeDays = Number.isFinite(Number(action.rangeDays))
          ? Math.max(1, Math.floor(Number(action.rangeDays)))
          : Number.isFinite(Number(summary?.rangeDays))
            ? Math.max(1, Math.floor(Number(summary?.rangeDays)))
            : 90;
        const maxCombos = Number.isFinite(Number(action.maxCombos))
          ? Math.max(1, Math.floor(Number(action.maxCombos)))
          : Number.isFinite(Number(action.budget))
            ? Math.max(1, Math.floor(Number(action.budget)))
            : 200;

        const seedParams = resolveStrategyParams(action);
        const seededGrid = seedParams ? buildParamGridFromParams(seedParams) : null;
        let paramGrid =
          action.paramGrid && typeof action.paramGrid === 'object'
            ? action.paramGrid
            : null;
        if (seededGrid && Object.keys(seededGrid).length > 0) {
          paramGrid = paramGrid && Object.keys(paramGrid).length > 0 ? { ...seededGrid, ...paramGrid } : seededGrid;
        }
        const presetKeyRaw = action.searchSpacePreset ? String(action.searchSpacePreset).trim() : '';
        const ledger = window.glass?.tradeLedger;

        const loadPresetGrid = async () => {
          if (!ledger?.getAgentMemory) return null;
          const safeTf = timeframe || '15m';
          const defaultKey = `backtest_preset:${symbol}:${rawStrategy}:${safeTf}`;
          const key = presetKeyRaw || defaultKey;
          try {
            let res = await ledger.getAgentMemory({ key, touch: true });
            if (!res?.ok && !presetKeyRaw) {
              const fallbackKey = `backtest_preset:${symbol}:${rawStrategy}`;
              res = await ledger.getAgentMemory({ key: fallbackKey, touch: true });
            }
            if (res?.ok && res.memory?.payload?.paramGrid) {
              return { key: res.memory.key || key, grid: res.memory.payload.paramGrid };
            }
          } catch {
            // ignore
          }
          return null;
        };

        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const preset = await loadPresetGrid();
          if (preset?.grid) {
            paramGrid = preset.grid;
          }
        }

        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const fallbackGrid = buildDefaultOptimizationGrid(rawStrategy);
          if (fallbackGrid && Object.keys(fallbackGrid).length > 0) {
            paramGrid = fallbackGrid;
          }
        }

        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          return finalizeToolResult({ ok: false, text: 'Backtest optimizer requires a paramGrid or saved preset.' });
        }

        const session = await startOptimizationSession(
          {
            baselineRunId: action.baselineRunId,
            symbol,
            timeframe,
            strategy: rawStrategy as any,
            rangeDays,
            paramGrid,
              timeFilter,
              objective: action.objective && typeof action.objective === 'object' ? action.objective : undefined,
              objectivePreset: action.objectivePreset ? String(action.objectivePreset).trim() : undefined,
              validation,
              execution,
              maxCombos
            },
          {
            onProgress: (progress) => {
              onProgress?.({
                progressPct: progress.pct,
                progressDone: progress.done,
                progressTotal: progress.total,
                progressLabel: progress.label
              });
            }
          }
        );

        const executionLine = formatExecutionSummary(execution, executionPreset);
        const validationLine = formatValidationSummary(validation);
        const lines = [
          `Optimizer session ${session.sessionId} started for ${symbol} ${timeframe}.`,
          executionLine,
          validationLine
        ].filter(Boolean);
        return finalizeToolResult(
          {
            ok: true,
            text: lines.join('\n'),
            payload: session
          },
          { symbol, timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'GET_BACKTEST_OPTIMIZER_STATUS') {
        const summary = backtesterRef.current?.getSummary?.();
        const sessionId = action.sessionId ? String(action.sessionId).trim() : '';
        let session = sessionId ? await getOptimizerStatus(sessionId) : null;
        if (!session) {
          session = await getLatestOptimizerSession({
            symbol: action.symbol || summary?.symbol,
            timeframe: action.timeframe || summary?.timeframe,
            baselineRunId: action.baselineRunId
          });
        }

        if (!session) {
          return finalizeToolResult({ ok: false, text: 'Optimizer session not found.' });
        }

        const progress = session.progress;
        const progressLine = progress
          ? `Progress: ${progress.done}/${progress.total} (${progress.pct}%)`
          : 'Progress: --';
        const lines = [
          `Optimizer session ${session.sessionId}`,
          `Status: ${session.status}`,
          progressLine,
          session.error ? `Error: ${session.error}` : ''
        ].filter(Boolean);

        return finalizeToolResult(
          { ok: true, text: lines.join('\n'), payload: session },
          { symbol: session.symbol, timeframe: session.timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'GET_BACKTEST_OPTIMIZER_RESULTS') {
        const summary = backtesterRef.current?.getSummary?.();
        let sessionId = action.sessionId ? String(action.sessionId).trim() : '';
        let session = sessionId ? await getOptimizerStatus(sessionId) : null;
        if (!sessionId) {
          session = await getLatestOptimizerSession({
            symbol: action.symbol || summary?.symbol,
            timeframe: action.timeframe || summary?.timeframe,
            baselineRunId: action.baselineRunId
          });
          sessionId = session?.sessionId || '';
        }
        if (!sessionId) {
          return finalizeToolResult({ ok: false, text: 'Optimizer results not found (no session id).' });
        }

        const results = await getOptimizerResults(sessionId);
        if (!results) {
          return finalizeToolResult({ ok: false, text: 'Optimizer results unavailable yet.' });
        }

        const fmtPct = (value: any) => {
          const num = Number(value);
          return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
        };
        const fmtNum = (value: any, digits = 2) => {
          const num = Number(value);
          return Number.isFinite(num) ? num.toFixed(digits) : '--';
        };
        const fmtParams = (params: Record<string, any> | undefined | null) => {
          if (!params) return '--';
          const entries = Object.entries(params)
            .filter(([_, value]) => value != null)
            .sort(([a], [b]) => a.localeCompare(b))
            .slice(0, 10)
            .map(([key, value]) => `${key} ${value}`);
          return entries.length ? entries.join(', ') : '--';
        };
        const fmtDiagnostics = (diag: any) => {
          if (!diag) return '';
          const winStreak = diag.winStreaks && diag.winStreaks[0] ? `${diag.winStreaks[0].length}x(${diag.winStreaks[0].count})` : '--';
          const lossStreak = diag.lossStreaks && diag.lossStreaks[0] ? `${diag.lossStreaks[0].length}x(${diag.lossStreaks[0].count})` : '--';
          const lossHour = diag.lossByHour && diag.lossByHour[0] ? `H${diag.lossByHour[0].hour}` : '--';
          const lossDay = diag.lossByDay && diag.lossByDay[0] ? `D${diag.lossByDay[0].day}` : '--';
          const payoff = Number.isFinite(Number(diag.payoffRatio)) ? Number(diag.payoffRatio).toFixed(2) : '--';
          return `Diagnostics: W ${winStreak} / L ${lossStreak} | Loss hour ${lossHour} | Loss day ${lossDay} | Payoff ${payoff}`;
        };

        const recommended = results.recommended;
        const candidate = recommended || results.topCandidates[0];
        const lines = [
          `Optimizer results ${session?.symbol || ''} ${session?.timeframe || ''}`.trim(),
          candidate
            ? `Recommended: WR ${fmtPct(candidate.test.winRate)} | DD ${fmtNum(candidate.test.maxDrawdown)} | Net ${fmtNum(candidate.test.netR)}R | PF ${fmtNum(candidate.test.profitFactor)} | Trades ${candidate.test.tradeCount}`
            : 'Recommended: --',
          candidate ? `Params: ${fmtParams(candidate.params)}` : '',
          results.recommendedDiagnostics ? fmtDiagnostics(results.recommendedDiagnostics) : '',
          `Pareto: ${results.pareto.length} | Evaluated ${results.evaluated}/${results.totalCombos}`,
          results.warnings.length ? `Warnings: ${results.warnings.join(' ')}` : ''
        ].filter(Boolean);

        return finalizeToolResult(
          { ok: true, text: lines.join('\n'), payload: results },
          { symbol: session?.symbol || action.symbol || null, timeframe: session?.timeframe || action.timeframe || null, sessionId }
        );
      }

      if (action.type === 'GET_OPTIMIZER_WINNER_PARAMS') {
        const resolve = await resolveOptimizerWinner({
          winnerId: action.winnerId,
          sessionId: action.sessionId,
          round: action.round,
          symbol: action.symbol,
          timeframe: action.timeframe,
          strategy: action.strategy,
          limit: action.limit
        });

        if (!resolve.ok) {
          const detail = resolve.error === 'Optimizer winners unavailable.' ? 'optimizer_winners_unavailable' : 'optimizer_winner_not_found';
          return finalizeToolResult(
            { ok: false, text: resolve.error || 'Optimizer winner not found.' },
            { detail }
          );
        }

        const winner = resolve.winner;
        const winners = resolve.winners || [];

        const params = winner.params && typeof winner.params === 'object' ? winner.params : null;
        if (!params) {
          return finalizeToolResult(
            { ok: false, text: 'Optimizer winner params unavailable.' },
            { detail: 'optimizer_winner_params_missing', winnerId: winner.id || null }
          );
        }

        let paramsHash = String(winner.paramsHash || '');
        if (!paramsHash) {
          try {
            const paramsKey = buildParamsKey(params);
            paramsHash = hashStringSampled(paramsKey || JSON.stringify(params));
          } catch {
            paramsHash = '';
          }
        }

        const fmtPct = (value: any) => {
          const num = Number(value);
          return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
        };
        const fmtNum = (value: any, digits = 2) => {
          const num = Number(value);
          return Number.isFinite(num) ? num.toFixed(digits) : '--';
        };
        const metrics = winner.metrics || {};
        const metricsLine = [
          `WR ${fmtPct(metrics.winRate)}`,
          `DD ${fmtNum(metrics.maxDrawdown)}`,
          `Net ${fmtNum(metrics.netR)}R`,
          `PF ${fmtNum(metrics.profitFactor)}`,
          `Trades ${metrics.tradeCount ?? '--'}`
        ].join(' | ');
        const paramsLines = Object.entries(params)
          .filter(([key, value]) => value != null)
          .sort(([a], [b]) => a.localeCompare(b))
          .map(([key, value]) => `- ${key}: ${value}`);

        const headerParts = [
          `Optimizer winner ${winner.id || ''}`.trim(),
          winner.sessionId ? `Session ${winner.sessionId}` : '',
          winner.round ? `Round ${winner.round}` : ''
        ].filter(Boolean);
        const lines = [
          headerParts.join(' | '),
          winner.symbol || action.symbol ? `Symbol ${winner.symbol || action.symbol}` : '',
          winner.timeframe || action.timeframe ? `TF ${winner.timeframe || action.timeframe}` : '',
          winner.strategy || action.strategy ? `Strategy ${winner.strategy || action.strategy}` : '',
          paramsHash ? `Params hash ${paramsHash}` : '',
          metricsLine,
          'Params:',
          paramsLines.length ? paramsLines.join('\n') : '--'
        ].filter(Boolean);

        const includeHumanReadable = typeof action.includeHumanReadable === 'boolean' ? action.includeHumanReadable : false;
        const humanReadable = includeHumanReadable
          ? [
              `Symbol: ${winner.symbol || action.symbol || '--'}`,
              `Timeframe: ${winner.timeframe || action.timeframe || '--'}`,
              `Strategy: ${winner.strategy || action.strategy || '--'}`,
              `Round: ${winner.round ?? action.round ?? '--'}`,
              `Session: ${winner.sessionId || action.sessionId || '--'}`,
              '',
              'Params:',
              paramsLines.length ? paramsLines.join('\n') : '--',
              '',
              `Metrics: ${metricsLine}`
            ].join('\n')
          : null;

        return finalizeToolResult(
          {
            ok: true,
            text: lines.join('\n'),
            payload: {
              winner: { ...winner, paramsHash: paramsHash || winner.paramsHash || null },
              winners,
              humanReadable
            }
          },
          { symbol: winner.symbol || action.symbol || null, timeframe: winner.timeframe || action.timeframe || null, sessionId: winner.sessionId || action.sessionId || null, winnerId: winner.id || null }
        );
      }

      if (action.type === 'SAVE_OPTIMIZER_WINNER_PRESET') {
        const resolve = await resolveOptimizerWinner({
          winnerId: action.winnerId,
          sessionId: action.sessionId,
          round: action.round,
          symbol: action.symbol,
          timeframe: action.timeframe,
          strategy: action.strategy,
          limit: action.limit
        });

        const winner = resolve.ok ? resolve.winner : null;
        const params = winner?.params && typeof winner.params === 'object'
          ? winner.params
          : action.params && typeof action.params === 'object'
            ? action.params
            : null;

        if (!params || Object.keys(params).length === 0) {
          return finalizeToolResult(
            { ok: false, text: resolve.ok ? 'Optimizer winner params unavailable.' : (resolve.error || 'Optimizer winner not found.') },
            { detail: resolve.ok ? 'optimizer_winner_params_missing' : 'optimizer_winner_not_found' }
          );
        }

        const wantsLibrary = (() => {
          const presetKey = String(action.presetKey || '').trim().toLowerCase();
          if (presetKey.startsWith('setup_library:')) return true;
          const tags = Array.isArray(action.tags) ? action.tags.map((tag) => String(tag).toLowerCase()) : [];
          return tags.includes('setup_library') || tags.includes('setup-library') || tags.includes('setup library');
        })();
        const symbol = String(winner?.symbol || action.symbol || '').trim();
        const timeframe = String(winner?.timeframe || action.timeframe || '').trim();
        const strategy = normalizeSetupStrategy(winner?.strategy || action.strategy);
        if (!symbol || !timeframe || !strategy) {
          return finalizeToolResult(
            { ok: false, text: 'Preset save requires symbol/timeframe/strategy.' },
            { detail: 'preset_missing_fields' }
          );
        }

        if (wantsLibrary && !winner) {
          return finalizeToolResult(
            { ok: false, text: 'Setup library saves require an optimizer winner (sessionId+round or winnerId).' },
            { detail: 'setup_library_requires_winner' }
          );
        }

        const ledger = window.glass?.tradeLedger;
        if (!ledger?.upsertAgentMemory) {
          return finalizeToolResult(
            { ok: false, text: 'Preset storage unavailable (ledger missing).' },
            { detail: 'preset_storage_unavailable' }
          );
        }

        const paramsHash = (() => {
          try {
            const key = buildParamsKey(params);
            return hashStringSampled(key || JSON.stringify(params));
          } catch {
            return '';
          }
        })();
        const grid = buildParamGridFromParams(params);
        const safeSymbol = normalizeSymbolKey(symbol);
        const safeTf = normalizeTimeframeKey(timeframe) || timeframe;
        const safeStrategy = String(strategy || '').trim().toUpperCase();
        const rawName = String(action.presetName || '').trim();
        const slug = rawName
          ? rawName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-+|-+$)/g, '').slice(0, 32)
          : '';
        const baseKey = `backtest_preset:${safeSymbol}:${safeStrategy}:${safeTf}`;
        const key = action.presetKey
          ? String(action.presetKey)
          : slug
            ? `${baseKey}:${slug}`
            : baseKey;
        const summary = `Preset ${symbol} ${safeTf} ${safeStrategy}${rawName ? ` | ${rawName}` : ''}`;

        if (wantsLibrary && winner) {
          const metrics = winner.metrics || {};
          const built = buildSetupLibraryEntry({
            symbol: safeSymbol,
            timeframe: safeTf,
            strategy: safeStrategy as any,
            params,
            stats: {
              total: metrics.tradeCount ?? null,
              winRate: metrics.winRate ?? null,
              expectancy: metrics.expectancy ?? null,
              profitFactor: metrics.profitFactor ?? null
            },
            performance: {
              netR: metrics.netR ?? null,
              maxDrawdown: metrics.maxDrawdown ?? null
            },
            runId: winner.sessionId ? String(winner.sessionId) : winner.id ? String(winner.id) : null,
            rangeDays: action.rangeDays ?? null,
            timeFilter: action.timeFilter ?? null,
            stabilityScore: metrics.stabilityScore ?? null,
            source: 'optimizer_winner',
            minTrades: 1
          });

          const tierKey = buildSetupLibraryTierKey(
            built.entry.symbol,
            built.entry.timeframe,
            built.entry.strategy,
            built.entry.tier
          );

          let existing: SetupLibraryEntry | null = null;
          try {
            const res = await ledger.getAgentMemory({ key: tierKey, touch: true });
            if (res?.ok && res.memory?.payload) {
              existing = res.memory.payload as SetupLibraryEntry;
            }
          } catch {
            // ignore lookup failures
          }

          const now = Date.now();
          const entry: SetupLibraryEntry = {
            ...built.entry,
            key: built.entry.key,
            configKey: built.entry.key,
            createdAtMs: existing?.createdAtMs ?? now,
            updatedAtMs: now
          };

          if (shouldReplaceLibraryEntry(existing, entry)) {
            const summaryLine = `${entry.symbol} ${entry.timeframe} ${entry.strategy}\n${built.summary} | Score ${entry.score}`;
            const tags = [
              entry.symbol,
              entry.timeframe,
              entry.strategy,
              'setup',
              'library',
              `tier:${entry.tier}`,
              entry.winRateTier,
              ...(Array.isArray(action.tags) ? action.tags : [])
            ].filter(Boolean);

            try {
              await ledger.upsertAgentMemory({
                key: tierKey,
                familyKey: `setup_library:${entry.symbol}:${entry.timeframe}:${entry.strategy}`,
                scope: 'shared',
                category: 'setup',
                subcategory: 'library',
                kind: 'setup_library',
                symbol: entry.symbol,
                timeframe: entry.timeframe,
                summary: summaryLine,
                payload: entry,
                source: 'optimizer_winner',
                tags
              });
            } catch {
              return finalizeToolResult(
                { ok: false, text: 'Failed to save to setup library.' },
                { detail: 'setup_library_save_failed' }
              );
            }
          }

          void refreshSetupLibrary();
          return finalizeToolResult(
            {
              ok: true,
              text: `Saved setup library entry ${entry.key}.`,
              payload: {
                key: entry.key,
                symbol: entry.symbol,
                timeframe: entry.timeframe,
                strategy: entry.strategy,
                paramsHash: paramsHash || null
              }
            },
            { symbol: entry.symbol, timeframe: entry.timeframe, detail: 'setup_library_saved', presetKey: entry.key }
          );
        }

        try {
          await ledger.upsertAgentMemory({
            key,
            familyKey: `backtest_preset:${safeSymbol}:${safeStrategy}`,
            kind: 'backtest_preset',
            symbol: safeSymbol,
            timeframe: safeTf,
            summary,
            payload: {
              strategy: safeStrategy,
              timeframe: safeTf,
              paramGrid: grid,
              params,
              paramsHash: paramsHash || null,
              winnerId: winner?.id ? String(winner.id) : action.winnerId ? String(action.winnerId) : null,
              optimizerSessionId: winner?.sessionId ? String(winner.sessionId) : action.sessionId ? String(action.sessionId) : null,
              optimizerRound: winner?.round ?? action.round ?? null,
              presetName: rawName || null
            },
            source: 'agent',
            tags: [
              safeSymbol,
              safeTf,
              safeStrategy,
              'backtest',
              'preset',
              ...(Array.isArray(action.tags) ? action.tags : [])
            ].filter(Boolean)
          });
        } catch {
          return finalizeToolResult(
            { ok: false, text: 'Failed to save preset.' },
            { detail: 'preset_save_failed' }
          );
        }

        return finalizeToolResult(
          {
            ok: true,
            text: `Saved preset ${key}.`,
            payload: {
              key,
              symbol: safeSymbol,
              timeframe: safeTf,
              strategy: safeStrategy,
              paramsHash: paramsHash || null
            }
          },
          { symbol, timeframe, detail: 'preset_saved', presetKey: key }
        );
      }

      if (action.type === 'PROPOSE_BACKTEST_OPTIMIZATION_REFINEMENT') {
        const summary = backtesterRef.current?.getSummary?.();
        const result = await proposeOptimizationRefinement({
          sessionId: action.sessionId,
          baselineRunId: action.baselineRunId,
          symbol: action.symbol || summary?.symbol,
          timeframe: action.timeframe || summary?.timeframe
        });

        if (!result.ok || !result.proposal) {
          return finalizeToolResult(
            { ok: false, text: result.error || 'Optimizer refinement unavailable.' },
            { detail: 'refinement_unavailable' }
          );
        }

        const proposal = result.proposal;
        const paramGrid = proposal.paramGrid || {};
        const gridKeys = Object.keys(paramGrid);
        const fmtParams = (params: Record<string, any> | null | undefined) => {
          if (!params) return '--';
          const entries = Object.entries(params)
            .filter(([_, value]) => value != null)
            .sort(([a], [b]) => a.localeCompare(b))
            .slice(0, 10)
            .map(([key, value]) => `${key} ${value}`);
          return entries.length ? entries.join(', ') : '--';
        };
        const fmtGrid = () => {
          if (gridKeys.length === 0) return '--';
          return gridKeys
            .slice(0, 10)
            .map((key) => {
              const value = (paramGrid as any)[key];
              const count = Array.isArray(value) ? value.length : value != null ? 1 : 0;
              return `${key}(${count})`;
            })
            .join(', ');
        };
        const rationaleLines = Array.isArray(proposal.rationale)
          ? proposal.rationale.map((line) => `- ${line}`)
          : [];
        const lines = [
          `Refinement proposal for ${proposal.symbol} ${proposal.timeframe}`.trim(),
          `Objective preset: ${proposal.objectivePreset}`,
          `Param grid: ${fmtGrid()}`,
          proposal.baseParams ? `Base params: ${fmtParams(proposal.baseParams)}` : '',
          rationaleLines.length ? `Rationale:\n${rationaleLines.join('\n')}` : ''
        ].filter(Boolean);

        return finalizeToolResult(
          { ok: true, text: lines.join('\n'), payload: proposal },
          { symbol: proposal.symbol, timeframe: proposal.timeframe, detail: 'refinement_proposed' }
        );
      }

      if (action.type === 'RUN_BACKTEST_OPTIMIZATION_CHAIN') {
        const rawStrategy = resolveToolStrategy(action);
        const allowedStrategies = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
        if (!rawStrategy || !allowedStrategies.has(rawStrategy)) {
          return finalizeToolResult({
            ok: false,
            text: 'Optimization chain requires a supported strategy (range breakout, break + retest, FVG retrace, trend pullback, mean reversion).'
          });
        }

        const summary = backtesterRef.current?.getSummary?.();
        const symbol =
          String(action.symbol || '').trim() ||
          String(summary?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
        if (!symbol) {
          return finalizeToolResult({ ok: false, text: 'Optimization chain requires a symbol.' });
        }
        const timeframe =
          String(action.timeframe || '').trim() ||
          String(summary?.timeframe || '').trim();
        if (!timeframe) {
          return finalizeToolResult({ ok: false, text: 'Optimization chain requires a timeframe.' });
        }

        setBacktestSymbol(symbol);

        const timeFilter =
          action.timeFilter && typeof action.timeFilter === 'object'
            ? action.timeFilter
            : undefined;
        const rangeDays = Number.isFinite(Number(action.rangeDays))
          ? Math.max(1, Math.floor(Number(action.rangeDays)))
          : Number.isFinite(Number(summary?.rangeDays))
            ? Math.max(1, Math.floor(Number(summary?.rangeDays)))
            : 90;
        const maxCombos = Number.isFinite(Number(action.maxCombos))
          ? Math.max(1, Math.floor(Number(action.maxCombos)))
          : Number.isFinite(Number(action.budget))
            ? Math.max(1, Math.floor(Number(action.budget)))
            : 200;

        const objectivePreset = action.objectivePreset ? String(action.objectivePreset).trim() : undefined;
        const objective = action.objective && typeof action.objective === 'object' ? action.objective : undefined;
        const executionPreset = normalizeExecutionPresetKey(action.executionPreset ?? action.realityPreset);
        const execution = resolveExecutionConfig(action.execution, summary?.execution, executionPreset);
        const validation = resolveOptimizationValidation(action.validation, summary);

        const presetKeyRaw = action.searchSpacePreset ? String(action.searchSpacePreset).trim() : '';
        const ledger = window.glass?.tradeLedger;
        const loadPresetGrid = async () => {
          if (!ledger?.getAgentMemory) return null;
          const safeTf = timeframe || '15m';
          const defaultKey = `backtest_preset:${symbol}:${rawStrategy}:${safeTf}`;
          const key = presetKeyRaw || defaultKey;
          try {
            let res = await ledger.getAgentMemory({ key, touch: true });
            if (!res?.ok && !presetKeyRaw) {
              const fallbackKey = `backtest_preset:${symbol}:${rawStrategy}`;
              res = await ledger.getAgentMemory({ key: fallbackKey, touch: true });
            }
            if (res?.ok && res.memory?.payload?.paramGrid) {
              return { key: res.memory.key || key, grid: res.memory.payload.paramGrid };
            }
          } catch {
            // ignore
          }
          return null;
        };

        const seedParams = resolveStrategyParams(action);
        const seededGrid = seedParams ? buildParamGridFromParams(seedParams) : null;
        let paramGrid: Record<string, any> | null =
          action.paramGrid && typeof action.paramGrid === 'object'
            ? action.paramGrid
            : null;
        if (seededGrid && Object.keys(seededGrid).length > 0) {
          paramGrid = paramGrid && Object.keys(paramGrid).length > 0 ? { ...seededGrid, ...paramGrid } : seededGrid;
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const preset = await loadPresetGrid();
          if (preset?.grid) paramGrid = preset.grid;
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const fallbackGrid = buildDefaultOptimizationGrid(rawStrategy);
          if (fallbackGrid && Object.keys(fallbackGrid).length > 0) {
            paramGrid = fallbackGrid;
          }
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          return finalizeToolResult({ ok: false, text: 'Optimization chain requires a paramGrid or saved preset.' });
        }

        const sleep = (ms: number) => sleepMs(ms);
        const waitForCompletion = async (sessionId: string, label: string) => {
          const startedAt = Date.now();
          const timeoutMs = 240_000;
          let lastSession = await getOptimizerStatus(sessionId);
          while (Date.now() - startedAt < timeoutMs) {
            if (lastSession && lastSession.status !== 'running') break;
            await sleep(2000);
            lastSession = await getOptimizerStatus(sessionId);
            if (lastSession?.progress) {
              onProgress?.({
                progressPct: lastSession.progress.pct,
                progressDone: lastSession.progress.done,
                progressTotal: lastSession.progress.total,
                progressLabel: `${label}${lastSession.progress.label ? ` ${lastSession.progress.label}` : ''}`.trim()
              });
            }
          }
          return lastSession;
        };

        const fmtPct = (value: any) => {
          const num = Number(value);
          return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
        };
        const fmtNum = (value: any, digits = 2) => {
          const num = Number(value);
          return Number.isFinite(num) ? num.toFixed(digits) : '--';
        };
        const formatCandidateLine = (label: string, candidate: any) => {
          if (!candidate?.test) return `${label}: --`;
          return `${label}: WR ${fmtPct(candidate.test.winRate)} | DD ${fmtNum(candidate.test.maxDrawdown)} | Net ${fmtNum(candidate.test.netR)}R | PF ${fmtNum(candidate.test.profitFactor)} | Trades ${candidate.test.tradeCount}`;
        };
        const buildWinnerMetrics = (candidate: any) => {
          const test = candidate?.test || {};
          return {
            winRate: test.winRate ?? null,
            profitFactor: test.profitFactor ?? null,
            expectancy: test.expectancy ?? null,
            maxDrawdown: test.maxDrawdown ?? null,
            edgeMargin: test.edgeMargin ?? null,
            tradeCount: test.tradeCount ?? null,
            netR: test.netR ?? null,
            score: candidate?.score ?? null,
            penalties: {
              penalty: candidate?.penalty ?? null,
              stabilityPenalty: candidate?.stabilityPenalty ?? null
            }
          };
        };
        const buildWinnerRecord = (candidate: any, sessionId: string, round: number) => {
          if (!candidate?.params) return null;
          let paramsHash = String(candidate.paramsHash || '');
          if (!paramsHash) {
            try {
              const paramsKey = buildParamsKey(candidate.params || {});
              paramsHash = hashStringSampled(paramsKey || JSON.stringify(candidate.params));
            } catch {
              paramsHash = '';
            }
          }
          const id = `winner_${sessionId}_${round}_${paramsHash || 'params'}`;
          return {
            id,
            sessionId,
            round,
            symbol,
            timeframe,
            strategy: rawStrategy,
            params: candidate.params,
            paramsHash: paramsHash || null,
            metrics: buildWinnerMetrics(candidate),
            createdAtMs: Date.now()
          };
        };
        const persistWinner = async (winner: any) => {
          const ledger = window.glass?.tradeLedger;
          if (!winner || !ledger?.createOptimizerWinner) return false;
          try {
            const res = await ledger.createOptimizerWinner(winner);
            return !!res?.ok;
          } catch {
            return false;
          }
        };
        const normalizeGridValues = (value: any) => {
          if (Array.isArray(value)) return value;
          if (value == null) return [];
          return [value];
        };
        const trimGridValues = (value: any) => {
          const arr = normalizeGridValues(value);
          return arr.slice(0, 12);
        };
        const diffGrid = (before: Record<string, any>, after: Record<string, any>) => {
          const keys = Array.from(new Set([...Object.keys(before || {}), ...Object.keys(after || {})]));
          const changes: Array<{ key: string; before: any[]; after: any[] }> = [];
          for (const key of keys) {
            const beforeVals = trimGridValues((before || {})[key]);
            const afterVals = trimGridValues((after || {})[key]);
            if (JSON.stringify(beforeVals) === JSON.stringify(afterVals)) continue;
            changes.push({ key, before: beforeVals, after: afterVals });
          }
          return changes;
        };
        const decideExperiment = (candidate: any, objective: any) => {
          if (!candidate?.test) return 'investigate';
          if (!objective || typeof objective !== 'object') return 'investigate';
          const failures: string[] = [];
          const minTradeCount = Number.isFinite(Number(objective.minTradeCount)) ? Number(objective.minTradeCount) : null;
          const maxDrawdown = Number.isFinite(Number(objective.maxDrawdown)) ? Number(objective.maxDrawdown) : null;
          const minProfitFactor = Number.isFinite(Number(objective.minProfitFactor)) ? Number(objective.minProfitFactor) : null;
          const minExpectancy = Number.isFinite(Number(objective.minExpectancy)) ? Number(objective.minExpectancy) : null;
          const minEdgeMargin = Number.isFinite(Number(objective.minEdgeMargin)) ? Number(objective.minEdgeMargin) : null;

          if (minTradeCount != null && candidate.test.tradeCount < minTradeCount) failures.push('trades');
          if (maxDrawdown != null && candidate.test.maxDrawdown > maxDrawdown) failures.push('drawdown');
          if (minProfitFactor != null && (candidate.test.profitFactor == null || candidate.test.profitFactor < minProfitFactor)) failures.push('profitFactor');
          if (minExpectancy != null && (candidate.test.expectancy == null || candidate.test.expectancy < minExpectancy)) failures.push('expectancy');
          if (minEdgeMargin != null && (candidate.test.edgeMargin == null || candidate.test.edgeMargin < minEdgeMargin)) failures.push('edgeMargin');

          return failures.length > 0 ? 'reject' : 'adopt';
        };

        const sessionOne = await startOptimizationSession(
          {
            baselineRunId: action.baselineRunId,
            symbol,
            timeframe,
            strategy: rawStrategy as any,
            rangeDays,
            paramGrid: paramGrid as any,
              timeFilter,
              objective,
              objectivePreset,
              validation,
              execution,
              maxCombos
            },
          {
            onProgress: (progress) => {
              onProgress?.({
                progressPct: progress.pct,
                progressDone: progress.done,
                progressTotal: progress.total,
                progressLabel: `Round 1/2 ${progress.label || ''}`.trim()
              });
            }
          }
        );

        const completedOne = await waitForCompletion(sessionOne.sessionId, 'Round 1/2');
        if (!completedOne || completedOne.status === 'running') {
          return finalizeToolResult(
            { ok: false, text: `Round 1 still running (session ${sessionOne.sessionId}). Try again shortly.` },
            { sessionId: sessionOne.sessionId }
          );
        }
        if (completedOne.status === 'failed') {
          return finalizeToolResult(
            { ok: false, text: completedOne.error || 'Round 1 optimization failed.' },
            { sessionId: sessionOne.sessionId }
          );
        }

        const roundOneResults = await getOptimizerResults(sessionOne.sessionId);
        if (!roundOneResults) {
          return finalizeToolResult(
            { ok: false, text: 'Round 1 results unavailable.' },
            { sessionId: sessionOne.sessionId }
          );
        }

        const roundsRequested = Number.isFinite(Number(action.rounds)) ? Number(action.rounds) : 2;
        const executionLine = formatExecutionSummary(execution, executionPreset);
        const validationLine = formatValidationSummary(validation);
        if (roundsRequested <= 1) {
          const candidate = roundOneResults.recommended || roundOneResults.topCandidates[0];
          const round1Winner = buildWinnerRecord(candidate, sessionOne.sessionId, 1);
          if (round1Winner) {
            await persistWinner(round1Winner);
          }
          const lines = [
            `Optimization chain complete (1 round)`,
            executionLine,
            validationLine,
            `Round 1 session: ${sessionOne.sessionId}`,
            formatCandidateLine('Round 1 best', candidate)
          ].filter(Boolean);
          return finalizeToolResult(
            {
              ok: true,
              text: lines.join('\n'),
              payload: {
                round1: roundOneResults,
                session1: sessionOne,
                round1Winner,
                round1WinnerId: round1Winner?.id || null,
                winnersAvailable: Boolean(round1Winner?.params)
              }
            },
            { symbol, timeframe, sessionId: sessionOne.sessionId }
          );
        }

        const refinement = await proposeOptimizationRefinement({
          sessionId: sessionOne.sessionId,
          baselineRunId: action.baselineRunId,
          symbol,
          timeframe
        });

        if (!refinement.ok || !refinement.proposal) {
          return finalizeToolResult(
            { ok: false, text: refinement.error || 'Refinement proposal unavailable for round 2.' },
            { sessionId: sessionOne.sessionId }
          );
        }

        const refinedGrid = refinement.proposal.paramGrid && Object.keys(refinement.proposal.paramGrid).length > 0
          ? refinement.proposal.paramGrid
          : paramGrid;
        const gridChanges = diffGrid(paramGrid || {}, refinedGrid || {});

          const sessionTwo = await startOptimizationSession(
            {
              baselineRunId: action.baselineRunId,
              symbol,
              timeframe,
              strategy: rawStrategy as any,
              rangeDays,
              paramGrid: refinedGrid as any,
              timeFilter,
              objective,
              objectivePreset: refinement.proposal.objectivePreset || objectivePreset,
              validation,
              execution,
              maxCombos
            },
          {
            onProgress: (progress) => {
              onProgress?.({
                progressPct: progress.pct,
                progressDone: progress.done,
                progressTotal: progress.total,
                progressLabel: `Round 2/2 ${progress.label || ''}`.trim()
              });
            }
          }
        );

        const completedTwo = await waitForCompletion(sessionTwo.sessionId, 'Round 2/2');
        if (!completedTwo || completedTwo.status === 'running') {
          return finalizeToolResult(
            { ok: false, text: `Round 2 still running (session ${sessionTwo.sessionId}). Try again shortly.` },
            { sessionId: sessionTwo.sessionId }
          );
        }
        if (completedTwo.status === 'failed') {
          return finalizeToolResult(
            { ok: false, text: completedTwo.error || 'Round 2 optimization failed.' },
            { sessionId: sessionTwo.sessionId }
          );
        }

        const roundTwoResults = await getOptimizerResults(sessionTwo.sessionId);
        if (!roundTwoResults) {
          return finalizeToolResult(
            { ok: false, text: 'Round 2 results unavailable.' },
            { sessionId: sessionTwo.sessionId }
          );
        }

        const candidateOne = roundOneResults.recommended || roundOneResults.topCandidates[0];
        const candidateTwo = roundTwoResults.recommended || roundTwoResults.topCandidates[0];
        const round1Winner = buildWinnerRecord(candidateOne, sessionOne.sessionId, 1);
        const round2Winner = buildWinnerRecord(candidateTwo, sessionTwo.sessionId, 2);
        if (round1Winner) await persistWinner(round1Winner);
        if (round2Winner) await persistWinner(round2Winner);
        const rationale = refinement.proposal.rationale || [];
        const rationaleText = rationale.length ? `Refinement rationale:\n- ${rationale.join('\n- ')}` : '';
        const lines = [
          'Optimization chain complete (2 rounds)',
          executionLine,
          validationLine,
          `Round 1 session: ${sessionOne.sessionId}`,
          formatCandidateLine('Round 1 best', candidateOne),
          `Round 2 session: ${sessionTwo.sessionId}`,
          formatCandidateLine('Round 2 best', candidateTwo),
          rationaleText
        ].filter(Boolean);

        let experimentId: string | null = null;
        const ledgerForExperiment = window.glass?.tradeLedger;
        if (ledgerForExperiment?.createExperimentNote) {
          const now = Date.now();
          const hypothesisRaw = String(action.hypothesis || action.reason || '').trim();
          const hypothesis = hypothesisRaw
            ? hypothesisRaw
            : rationale.length > 0
              ? `Refine params: ${rationale[0]}`
              : 'Refine parameters based on round 1 diagnostics.';
          const decision = decideExperiment(candidateTwo, objective);
          const objectivePresetResolved = refinement.proposal.objectivePreset || objectivePreset || null;
          const summaryLine = candidateTwo?.test
            ? `WR ${fmtPct(candidateTwo.test.winRate)} | DD ${fmtNum(candidateTwo.test.maxDrawdown)} | Net ${fmtNum(candidateTwo.test.netR)}R | PF ${fmtNum(candidateTwo.test.profitFactor)} | Trades ${candidateTwo.test.tradeCount}`
            : 'No candidate metrics available.';

          const refinementDiff = {
            objectivePreset: {
              from: objectivePreset || null,
              to: objectivePresetResolved
            },
            gridChanges
          };

          const resultSummary = {
            round1: {
              sessionId: sessionOne.sessionId,
              candidate: candidateOne,
              metrics: candidateOne?.test || null,
              penalty: candidateOne?.penalty ?? null,
              stabilityPenalty: candidateOne?.stabilityPenalty ?? null
            },
            round2: {
              sessionId: sessionTwo.sessionId,
              candidate: candidateTwo,
              metrics: candidateTwo?.test || null,
              penalty: candidateTwo?.penalty ?? null,
              stabilityPenalty: candidateTwo?.stabilityPenalty ?? null
            },
            diagnostics: roundTwoResults?.recommendedDiagnostics || null,
            rangeDays,
            timeFilter: timeFilter || null
          };

          try {
            const noteRes = await ledgerForExperiment.createExperimentNote({
              id: `exp_${now}_${Math.random().toString(16).slice(2, 8)}`,
              createdAtMs: now,
              updatedAtMs: now,
              symbol,
              timeframe,
              strategy: rawStrategy,
              baselineRunId: action.baselineRunId || null,
              round1SessionId: sessionOne.sessionId,
              round2SessionId: sessionTwo.sessionId,
              objectivePreset: objectivePresetResolved,
              summary: summaryLine,
              hypothesis,
              refinementDiff,
              resultSummary,
              decision,
              recommendedParams: candidateTwo?.params || null,
              recommendedMetrics: candidateTwo?.test || null,
              rangeDays,
              tags: [symbol, timeframe, rawStrategy, 'experiment'].filter(Boolean),
              source: 'optimizer_chain'
            });
            if (noteRes?.ok && noteRes.note?.id) experimentId = String(noteRes.note.id);
          } catch {
            // ignore experiment persistence failures
          }
        }

        return finalizeToolResult(
          {
            ok: true,
            text: lines.join('\n'),
            payload: {
              round1: roundOneResults,
              round2: roundTwoResults,
              proposal: refinement.proposal,
              session1: sessionOne,
              session2: sessionTwo,
              round1Winner,
              round2Winner,
              round1WinnerId: round1Winner?.id || null,
              round2WinnerId: round2Winner?.id || null,
              winnersAvailable: Boolean(round1Winner?.params || round2Winner?.params),
              experimentId
            }
          },
          { symbol, timeframe, sessionId: sessionTwo.sessionId, experimentId }
        );
      }

      if (action.type === 'START_RESEARCH_AUTOPILOT') {
        const rawStrategy = resolveToolStrategy(action);
        const allowedStrategies = new Set(['RANGE_BREAKOUT', 'BREAK_RETEST', 'FVG_RETRACE', 'TREND_PULLBACK', 'MEAN_REVERSION']);
        if (!rawStrategy || !allowedStrategies.has(rawStrategy)) {
          return finalizeToolResult({
            ok: false,
            text: 'Research autopilot requires a supported strategy (range breakout, break + retest, FVG retrace, trend pullback, mean reversion).'
          });
        }

        const summary = backtesterRef.current?.getSummary?.();
        const symbol =
          String(action.symbol || '').trim() ||
          String(summary?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
        if (!symbol) {
          return finalizeToolResult({ ok: false, text: 'Research autopilot requires a symbol.' });
        }
        const timeframe =
          String(action.timeframe || '').trim() ||
          String(summary?.timeframe || '').trim();
        if (!timeframe) {
          return finalizeToolResult({ ok: false, text: 'Research autopilot requires a timeframe.' });
        }

        setBacktestSymbol(symbol);

        const timeFilter =
          action.timeFilter && typeof action.timeFilter === 'object'
            ? action.timeFilter
            : undefined;
        const rangeDays = Number.isFinite(Number(action.rangeDays))
          ? Math.max(1, Math.floor(Number(action.rangeDays)))
          : Number.isFinite(Number(summary?.rangeDays))
            ? Math.max(1, Math.floor(Number(summary?.rangeDays)))
            : 90;
        const maxCombos = Number.isFinite(Number(action.maxCombos))
          ? Math.max(1, Math.floor(Number(action.maxCombos)))
          : Number.isFinite(Number(action.budget))
            ? Math.max(1, Math.floor(Number(action.budget)))
            : 200;

        const maxExperiments = Number.isFinite(Number(action.maxExperiments))
          ? Math.max(1, Math.floor(Number(action.maxExperiments)))
          : 3;
        const maxRuntimeSec = Number.isFinite(Number(action.maxRuntimeSec))
          ? Math.max(60, Math.floor(Number(action.maxRuntimeSec)))
          : undefined;
        const plateauLimit = Number.isFinite(Number(action.plateauLimit))
          ? Math.max(1, Math.floor(Number(action.plateauLimit)))
          : undefined;

        const objectivePreset = action.objectivePreset ? String(action.objectivePreset).trim() : undefined;
        const objective = action.objective && typeof action.objective === 'object' ? action.objective : undefined;
        const validation = action.validation && typeof action.validation === 'object' ? action.validation : undefined;
        const robustness = action.robustness && typeof action.robustness === 'object' ? action.robustness : undefined;
        const execution = action.execution && typeof action.execution === 'object' ? action.execution : undefined;
        const targetRegimeKey = action.targetRegimeKey ? String(action.targetRegimeKey).trim() : undefined;
        const minTargetRegimeSamples = Number.isFinite(Number(action.minTargetRegimeSamples))
          ? Math.max(1, Math.floor(Number(action.minTargetRegimeSamples)))
          : undefined;

        const presetKeyRaw = action.searchSpacePreset ? String(action.searchSpacePreset).trim() : '';
        const ledger = window.glass?.tradeLedger;
        const loadPresetGrid = async () => {
          if (!ledger?.getAgentMemory) return null;
          const safeTf = timeframe || '15m';
          const defaultKey = `backtest_preset:${symbol}:${rawStrategy}:${safeTf}`;
          const key = presetKeyRaw || defaultKey;
          try {
            let res = await ledger.getAgentMemory({ key, touch: true });
            if (!res?.ok && !presetKeyRaw) {
              const fallbackKey = `backtest_preset:${symbol}:${rawStrategy}`;
              res = await ledger.getAgentMemory({ key: fallbackKey, touch: true });
            }
            if (res?.ok && res.memory?.payload?.paramGrid) {
              return { key: res.memory.key || key, grid: res.memory.payload.paramGrid };
            }
          } catch {
            // ignore
          }
          return null;
        };

        const seedParams = resolveStrategyParams(action);
        const seededGrid = seedParams ? buildParamGridFromParams(seedParams) : null;
        let paramGrid: Record<string, any> | null =
          action.paramGrid && typeof action.paramGrid === 'object'
            ? action.paramGrid
            : null;
        if (seededGrid && Object.keys(seededGrid).length > 0) {
          paramGrid = paramGrid && Object.keys(paramGrid).length > 0 ? { ...seededGrid, ...paramGrid } : seededGrid;
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const preset = await loadPresetGrid();
          if (preset?.grid) paramGrid = preset.grid;
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          const fallbackGrid = buildDefaultOptimizationGrid(rawStrategy);
          if (fallbackGrid && Object.keys(fallbackGrid).length > 0) {
            paramGrid = fallbackGrid;
          }
        }
        if (!paramGrid || Object.keys(paramGrid).length === 0) {
          return finalizeToolResult({ ok: false, text: 'Research autopilot requires a paramGrid or saved preset.' });
        }

        const session = await startResearchSession({
          symbol,
          timeframe,
          strategy: rawStrategy as any,
          rangeDays,
          maxCombos,
          maxExperiments,
          maxRuntimeSec,
          plateauLimit,
          paramGrid: paramGrid as any,
          searchSpacePreset: presetKeyRaw || undefined,
          objectivePreset,
          objective,
          validation,
          timeFilter,
          execution,
          robustness,
          targetRegimeKey,
          minTargetRegimeSamples
        });

        return finalizeToolResult(
          {
            ok: true,
            text: `Research autopilot session ${session.sessionId} started for ${symbol} ${timeframe}.`,
            payload: session
          },
          { symbol, timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'GET_RESEARCH_AUTOPILOT_STATUS') {
        const summary = backtesterRef.current?.getSummary?.();
        const session = await resolveResearchSession({
          sessionId: action.sessionId,
          symbol: action.symbol || summary?.symbol,
          timeframe: action.timeframe || summary?.timeframe
        });
        if (!session) {
          return finalizeToolResult({ ok: false, text: 'Research session not found.' });
        }
        const stats = session.stats || ({} as any);
        const bestScore =
          stats.bestScore != null && Number.isFinite(Number(stats.bestScore))
            ? Number(stats.bestScore).toFixed(3)
            : '--';
        const lines = [
          `Research autopilot ${session.sessionId}`,
          `Status: ${session.status}`,
          `Experiments: ${stats.experimentsRun ?? 0}/${stats.experimentsPlanned ?? '--'}`,
          `Best score: ${bestScore}`,
          stats.lastError ? `Last error: ${stats.lastError}` : ''
        ].filter(Boolean);
        return finalizeToolResult(
          { ok: true, text: lines.join('\n'), payload: session },
          { symbol: session.symbol, timeframe: session.timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'GET_RESEARCH_AUTOPILOT_RESULTS') {
        const summary = backtesterRef.current?.getSummary?.();
        const session = await resolveResearchSession({
          sessionId: action.sessionId,
          symbol: action.symbol || summary?.symbol,
          timeframe: action.timeframe || summary?.timeframe
        });
        if (!session) {
          return finalizeToolResult({ ok: false, text: 'Research session not found.' });
        }
        const results = await getResearchResults(session.sessionId);
        const steps = Array.isArray(results?.steps) ? results.steps : [];
        const lastStep = steps.length > 0 ? steps[steps.length - 1] : null;
        const stats = session.stats || ({} as any);
        const lastStepLine = lastStep
          ? `Last step: ${String(lastStep.kind || 'step')} ${lastStep.createdAtMs ? `(${formatAge(lastStep.createdAtMs)})` : ''}`
          : 'Last step: --';
        const lines = [
          `Research results ${session.sessionId}`,
          `Status: ${session.status}`,
          `Experiments: ${stats.experimentsRun ?? 0}/${stats.experimentsPlanned ?? '--'}`,
          `Best experiment: ${stats.bestExperimentId || '--'}`,
          lastStepLine
        ].filter(Boolean);
        return finalizeToolResult(
          { ok: true, text: lines.join('\n'), payload: results },
          { symbol: session.symbol, timeframe: session.timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'STOP_RESEARCH_AUTOPILOT') {
        const summary = backtesterRef.current?.getSummary?.();
        const session = await resolveResearchSession({
          sessionId: action.sessionId,
          symbol: action.symbol || summary?.symbol,
          timeframe: action.timeframe || summary?.timeframe
        });
        if (!session) {
          return finalizeToolResult({ ok: false, text: 'Research session not found.' });
        }
        const stopped = await stopResearchSession(session.sessionId);
        const status = stopped?.status || 'stopped';
        return finalizeToolResult(
          { ok: true, text: `Research autopilot ${session.sessionId} ${status}.`, payload: stopped || session },
          { symbol: session.symbol, timeframe: session.timeframe, sessionId: session.sessionId }
        );
      }

      if (action.type === 'GET_BROKER_QUOTE') {
        const symbol =
          String(action.symbol || '').trim() ||
          String(symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
        if (!symbol) {
        return finalizeToolResult(
          { ok: false, text: 'No symbol available for broker quote.' },
          { detail: 'missing_symbol' }
        );
      }
      let resolvedSymbol = symbol;
      let quote = getBrokerQuoteForSymbol(symbol);
      if (!quote) {
        try {
          const resolved = await resolveTradeLockerSymbolBestEffort(symbol);
          if (resolved) resolvedSymbol = resolved;
        } catch {
          // ignore resolve failure
        }
        if (resolvedSymbol !== symbol) {
          quote = getBrokerQuoteForSymbol(resolvedSymbol);
        }
      }
      if (!quote) {
        const quoteRes = await fetchBrokerQuoteForSymbol(resolvedSymbol, { maxAgeMs: 0 });
        quote = quoteRes.quote;
      }
      if (!quote) {
        return finalizeToolResult(
          { ok: false, text: `No broker quote available for ${resolvedSymbol || symbol}.` },
          { symbol: resolvedSymbol || symbol, detail: 'quote_missing' }
        );
      }
      const bid = formatBrokerPrice(quote.bid);
      const ask = formatBrokerPrice(quote.ask);
      const mid = formatBrokerPrice(quote.mid ?? quote.last);
      const spread = formatBrokerPrice(quote.spread);
      const age = formatAge(Number(quote.fetchedAtMs ?? quote.timestampMs ?? 0));
      const parts = [
        `${resolvedSymbol || symbol} broker quote`,
        bid ? `Bid ${bid}` : '',
        ask ? `Ask ${ask}` : '',
        mid ? `Mid ${mid}` : '',
        spread ? `Spread ${spread}` : '',
        age ? `Updated ${age}` : ''
      ].filter(Boolean);
      return finalizeToolResult(
        { ok: true, text: parts.join(' | '), payload: quote },
        { symbol: resolvedSymbol || symbol, spread: quote.spread ?? null }
      );
    }

    if (action.type === 'GET_AGENT_MEMORY') {
      const ledger = window.glass?.tradeLedger;
      if (!ledger?.getAgentMemory && !ledger?.listAgentMemory) {
        return finalizeToolResult(
          { ok: false, text: 'Agent memory unavailable.' },
          { detail: 'memory_unavailable' }
        );
      }

      const key = String(action.memoryKey || '').trim();
      const id = String(action.memoryId || '').trim();
      let entry: any = null;

      if (ledger?.getAgentMemory && (key || id)) {
        const res = await ledger.getAgentMemory({ key: key || undefined, id: id || undefined, touch: true });
        if (res?.ok && res.memory) entry = res.memory;
      }

      if (!entry && ledger?.listAgentMemory) {
        const res = await ledger.listAgentMemory({
          symbol: action.symbol || undefined,
          timeframe: action.timeframe || undefined,
          kind: action.kind || undefined,
          tags: action.tags && action.tags.length > 0 ? action.tags : undefined,
          limit: 1
        });
        if (res?.ok && Array.isArray(res.memories) && res.memories.length > 0) {
          entry = res.memories[0];
        }
      }

      if (!entry) {
        return finalizeToolResult(
          { ok: false, text: 'Agent memory not found.' },
          { detail: 'memory_not_found' }
        );
      }

      const summary = String(entry.summary || '').trim();
      const meta = [entry.kind, entry.symbol, entry.timeframe].filter(Boolean).join(' ');
      const age = formatAge(entry.updatedAtMs || entry.createdAtMs || null);
      const tags = Array.isArray(entry.tags) && entry.tags.length > 0 ? `Tags: ${entry.tags.join(', ')}` : '';
      const keyLine = entry.key ? `Key: ${entry.key}` : '';
      let payloadText = '';
      try {
        payloadText = entry.payload ? JSON.stringify(entry.payload, null, 2) : '';
      } catch {
        payloadText = '';
      }
      const maxPayload = 8000;
      const payloadBlock = payloadText
        ? `Payload:\n${payloadText.slice(0, maxPayload)}${payloadText.length > maxPayload ? '\n...truncated...' : ''}`
        : '';
      const lines = [
        'Agent memory',
        meta ? `Meta: ${meta}` : '',
        age ? `Updated: ${age}` : '',
        keyLine,
        tags,
        summary ? `Summary:\n${summary}` : 'Summary: (none)',
        payloadBlock
      ].filter(Boolean);
      return finalizeToolResult(
        { ok: true, text: lines.join('\n'), payload: entry },
        { key: entry.key || null, kind: entry.kind || null }
      );
    }

    if (action.type === 'LIST_AGENT_MEMORY') {
      const ledger = window.glass?.tradeLedger;
      if (!ledger?.listAgentMemory) {
        return finalizeToolResult(
          { ok: false, text: 'Agent memory unavailable.' },
          { detail: 'memory_unavailable' }
        );
      }

      const limit = Number.isFinite(Number(action.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(action.limit)))) : 10;
      const res = await ledger.listAgentMemory({
        symbol: action.symbol || undefined,
        timeframe: action.timeframe || undefined,
        kind: action.kind || undefined,
        tags: action.tags && action.tags.length > 0 ? action.tags : undefined,
        limit
      });
      if (!res?.ok) {
        return finalizeToolResult(
          { ok: false, text: res?.error ? String(res.error) : 'Failed to load agent memory list.' },
          { detail: 'memory_list_failed' }
        );
      }
      const memories = Array.isArray(res.memories) ? res.memories : [];
      if (memories.length === 0) {
        return finalizeToolResult(
          { ok: true, text: 'No agent memories found for the requested filters.', payload: [] },
          { count: 0 }
        );
      }

      const fmtPct = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
      };
      const fmtR = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
      };
      const fmtNum = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? num.toFixed(2) : '--';
      };

      const lines = memories.map((entry: any) => {
        const meta = [entry.kind, entry.symbol, entry.timeframe].filter(Boolean).join(' ');
        const age = formatAge(entry.updatedAtMs || entry.createdAtMs || null);
        const summary = String(entry.summary || '').trim();
        const summaryLine = summary ? summary.split('\n')[0] : '';
        const stats = entry.payload?.stats || {};
        const perf = entry.payload?.performance || {};
        const statsLabel =
          stats && (stats.total != null || stats.winRate != null || stats.expectancy != null || stats.profitFactor != null || perf.netR != null)
            ? `Trades ${stats.total ?? '--'} WR ${fmtPct(stats.winRate)} Exp ${fmtR(stats.expectancy)} PF ${fmtNum(stats.profitFactor)} Net ${fmtR(perf.netR)}`
            : '';
        const snapshotPathRaw = entry.kind === 'chart_snapshot' ? String(entry.payload?.savedPath || '') : '';
        const snapshotFile = snapshotPathRaw
          ? `File ${(snapshotPathRaw.split(/[\\/]/).pop() || snapshotPathRaw).trim()}`
          : '';
        const key = entry.key ? `Key ${entry.key}` : '';
        const parts = [meta, age ? `Updated ${age}` : '', statsLabel, summaryLine, snapshotFile, key].filter(Boolean);
        return `- ${parts.join(' | ')}`;
      });

      const headerParts = [
        'Agent memory list',
        action.symbol ? `Symbol ${action.symbol}` : '',
        action.timeframe ? `TF ${action.timeframe}` : '',
        action.kind ? `Kind ${action.kind}` : '',
        action.tags && action.tags.length > 0 ? `Tags ${action.tags.join(',')}` : '',
        `Returned ${memories.length}`
      ].filter(Boolean);

      return finalizeToolResult(
        { ok: true, text: `${headerParts.join(' | ')}\n${lines.join('\n')}`, payload: memories },
          { count: memories.length }
        );
      }

    if (action.type === 'CODEBASE_LIST_FILES') {
      const codebase = window.glass?.codebase;
      if (!codebase?.listFiles) {
        return finalizeToolResult({ ok: false, text: 'Codebase tools unavailable.' }, { detail: 'codebase_unavailable' });
      }
      const limitRaw = Number(action.maxResults ?? action.limit);
      const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(200000, Math.floor(limitRaw))) : 1000;
      const displayLimit = Math.min(limit, 400);
      const includeAll = action.includeAll !== false;
      const res = await codebase.listFiles({
        root: action.root || '.',
        extensions: action.extensions && action.extensions.length > 0 ? action.extensions : undefined,
        maxResults: limit,
        includeAll
      });
      if (!res?.ok) {
        return finalizeToolResult(
          { ok: false, text: res?.error ? String(res.error) : 'Failed to list codebase files.' },
          { detail: 'codebase_list_failed' }
        );
      }
      const files = Array.isArray(res.files) ? res.files : [];
      if (files.length === 0) {
        return finalizeToolResult({ ok: true, text: 'No codebase files found.', payload: res }, { count: 0 });
      }
      const lines = files.slice(0, displayLimit).map((file) => `- ${file}`);
      const header = `Codebase files (${files.length}${res.truncated ? '+' : ''})`;
      return finalizeToolResult({ ok: true, text: `${header}\n${lines.join('\n')}`, payload: res }, { count: files.length });
    }

    if (action.type === 'CODEBASE_SEARCH') {
      const codebase = window.glass?.codebase;
      if (!codebase?.search) {
        return finalizeToolResult({ ok: false, text: 'Codebase tools unavailable.' }, { detail: 'codebase_unavailable' });
      }
      const query = String(action.query || '').trim();
      if (!query) {
        return finalizeToolResult({ ok: false, text: 'Codebase search requires a query.' }, { detail: 'missing_query' });
      }
      const limitRaw = Number(action.maxResults ?? action.limit);
      const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(5000, Math.floor(limitRaw))) : 200;
      const displayLimit = Math.min(limit, 200);
      const includeAll = action.includeAll !== false;
      const res = await codebase.search({
        query,
        regex: action.regex === true,
        caseSensitive: action.caseSensitive === true,
        contextLines: Number.isFinite(Number(action.contextLines)) ? Number(action.contextLines) : undefined,
        maxResults: limit,
        root: action.root || '.',
        extensions: action.extensions && action.extensions.length > 0 ? action.extensions : undefined,
        includeAll,
        maxFileBytes: Number.isFinite(Number(action.maxFileBytes)) ? Number(action.maxFileBytes) : undefined,
        maxFileResults: Number.isFinite(Number(action.maxFileResults)) ? Number(action.maxFileResults) : undefined
      });
      if (!res?.ok) {
        return finalizeToolResult(
          { ok: false, text: res?.error ? String(res.error) : 'Codebase search failed.' },
          { detail: 'codebase_search_failed' }
        );
      }
      const matches = Array.isArray(res.matches) ? res.matches : [];
      if (matches.length === 0) {
        return finalizeToolResult(
          { ok: true, text: 'No codebase matches found for the query.', payload: res },
          { count: 0 }
        );
      }
      const lines = matches.slice(0, displayLimit).map((match: any) => {
        const path = String(match.path || '').trim();
        const line = Number(match.line || 0);
        const column = Number(match.column || 0);
        const label = `${path}:${line || 1}:${column || 1}`;
        const preview = String(match.preview || '').trim();
        if (!preview || !preview.includes('\n')) return `- ${label} ${preview}`;
        const block = preview.split('\n').map((row) => `  ${row}`).join('\n');
        return `- ${label}\n${block}`;
      });
      const header = `Codebase search "${query}" (${matches.length}${res.truncated ? '+' : ''})`;
      return finalizeToolResult({ ok: true, text: `${header}\n${lines.join('\n')}`, payload: res }, { count: matches.length });
    }

    if (action.type === 'CODEBASE_READ_FILE') {
      const codebase = window.glass?.codebase;
      if (!codebase?.readFile) {
        return finalizeToolResult({ ok: false, text: 'Codebase tools unavailable.' }, { detail: 'codebase_unavailable' });
      }
      const relPath = String(action.path || '').trim();
      if (!relPath) {
        return finalizeToolResult({ ok: false, text: 'File path is required.' }, { detail: 'missing_path' });
      }
      const res = await codebase.readFile({
        path: relPath,
        startLine: Number.isFinite(Number(action.startLine)) ? Number(action.startLine) : undefined,
        endLine: Number.isFinite(Number(action.endLine)) ? Number(action.endLine) : undefined,
        maxLines: Number.isFinite(Number(action.maxLines ?? action.maxResults)) ? Number(action.maxLines ?? action.maxResults) : undefined,
        fullFile: action.fullFile === true,
        root: action.root || '.'
      });
      if (!res?.ok) {
        return finalizeToolResult(
          { ok: false, text: res?.error ? String(res.error) : 'Failed to read file.' },
          { detail: 'codebase_read_failed' }
        );
      }
      const header = `${res.path || relPath} L${res.startLine || 1}-L${res.endLine || 1} of ${res.totalLines || '--'}`;
      const content = res.content ? String(res.content) : '';
      const body = content ? `\n\`\`\`\n${content}\n\`\`\`` : '\n(no content)';
      return finalizeToolResult({ ok: true, text: `${header}${body}`, payload: res }, { path: relPath });
    }

    if (action.type === 'CODEBASE_TRACE_DATAFLOW') {
      const codebase = window.glass?.codebase;
      if (!codebase?.traceDataflow) {
        return finalizeToolResult({ ok: false, text: 'Codebase tools unavailable.' }, { detail: 'codebase_unavailable' });
      }
      const source = String(action.flowSource || '').trim();
      const sink = String(action.flowSink || '').trim();
      if (!source && !sink) {
        return finalizeToolResult(
          { ok: false, text: 'Trace requires a source or sink.' },
          { detail: 'missing_flow_terms' }
        );
      }
      const limitRaw = Number(action.maxResults ?? action.limit);
      const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(2000, Math.floor(limitRaw))) : 200;
      const includeAll = action.includeAll !== false;
      const res = await codebase.traceDataflow({
        source: source || undefined,
        sink: sink || undefined,
        maxResults: limit,
        root: action.root || '.',
        extensions: action.extensions && action.extensions.length > 0 ? action.extensions : undefined,
        includeAll
      });
      if (!res?.ok) {
        return finalizeToolResult(
          { ok: false, text: res?.error ? String(res.error) : 'Failed to trace data flow.' },
          { detail: 'codebase_trace_failed' }
        );
      }
      const sourceMatches = Array.isArray(res.sourceMatches) ? res.sourceMatches : [];
      const sinkMatches = Array.isArray(res.sinkMatches) ? res.sinkMatches : [];
      const overlap = Array.isArray(res.overlap) ? res.overlap : [];
      const lines: string[] = ['Codebase dataflow trace'];
      if (source) lines.push(`Source: ${source} (${sourceMatches.length}${res.truncated ? '+' : ''} matches)`);
      if (sink) lines.push(`Sink: ${sink} (${sinkMatches.length}${res.truncated ? '+' : ''} matches)`);
      if (overlap.length > 0) {
        lines.push('Files with both source and sink references:');
        lines.push(...overlap.slice(0, 12).map((file: string) => `- ${file}`));
      }
      if (lines.length === 1) lines.push('No matching references found.');
      return finalizeToolResult({ ok: true, text: lines.join('\n'), payload: res }, { count: overlap.length });
    }

    if (action.type === 'LIST_SETUP_WATCHERS') {
      const limit = Number.isFinite(Number(action.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(action.limit)))) : 10;
      const filters = {
        symbol: action.symbol || undefined,
        timeframe: action.timeframe || undefined,
        strategy: action.strategy || undefined,
        mode: action.mode || undefined,
        enabled: typeof action.enabled === 'boolean' ? action.enabled : undefined
      };
      const watchers = (setupWatchersRef.current || []).filter((watcher) => matchesSetupWatcher(watcher, filters));
      if (watchers.length === 0) {
        return finalizeToolResult(
          { ok: true, text: 'No setup watchers matched the requested filters.', payload: [] },
          { count: 0 }
        );
      }
      const limited = watchers.slice(0, limit);
      const lines = limited.map((watcher) => {
        const updated = formatAge(watcher.updatedAtMs || watcher.createdAtMs || null);
        const lastSignal = watcher.lastSignalType ? `last ${watcher.lastSignalType}` : 'last none';
        const parts = [
          watcher.id,
          watcher.symbol,
          watcher.timeframe,
          watcher.strategy,
          watcher.enabled ? 'on' : 'off',
          watcher.mode ? `mode ${watcher.mode}` : '',
          lastSignal,
          updated ? `updated ${updated}` : ''
        ].filter(Boolean);
        return `- ${parts.join(' | ')}`;
      });
      const header = [
        'Setup watchers',
        action.symbol ? `Symbol ${action.symbol}` : '',
        action.timeframe ? `TF ${action.timeframe}` : '',
        action.strategy ? `Strategy ${action.strategy}` : '',
        typeof action.enabled === 'boolean' ? `Enabled ${action.enabled ? 'yes' : 'no'}` : '',
        `Returned ${limited.length}/${watchers.length}`
      ].filter(Boolean).join(' | ');
      return finalizeToolResult(
        { ok: true, text: `${header}\n${lines.join('\n')}`, payload: limited },
        { count: watchers.length }
      );
    }

    if (action.type === 'LIST_SETUP_LIBRARY') {
      const limit = Number.isFinite(Number(action.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(action.limit)))) : 10;
      const symbolFilter = action.symbol ? normalizeSymbolKey(action.symbol) : '';
      const timeframeFilter = action.timeframe ? normalizeTimeframeKey(action.timeframe) : '';
      const strategyFilter = action.strategy ? String(action.strategy).trim().toUpperCase() : '';
      const tierRaw = action.libraryTier ? String(action.libraryTier).trim().toUpperCase() : '';
      const winRateRaw = action.winRateTier ? String(action.winRateTier).trim().toUpperCase() : '';
      const allowedTier = new Set(['S', 'A', 'B', 'C', 'D']);
      const allowedWin = new Set(['WR70', 'WR60', 'WR50', 'WR40', 'WR30']);
      const tierFilter = tierRaw && allowedTier.has(tierRaw) ? tierRaw : '';
      const winRateFilter = winRateRaw && allowedWin.has(winRateRaw) ? winRateRaw : '';

      let entries = setupLibraryRef.current || [];
      if (entries.length === 0) {
        await refreshSetupLibrary({
          symbol: action.symbol || undefined,
          timeframe: action.timeframe || undefined,
          strategy: action.strategy || undefined,
          limit: Math.max(50, limit)
        });
        entries = setupLibraryRef.current || [];
      }

      const filtered = entries.filter((entry) => {
        if (!entry) return false;
        if (symbolFilter && normalizeSymbolKey(entry.symbol) !== symbolFilter) return false;
        if (timeframeFilter && normalizeTimeframeKey(entry.timeframe) !== timeframeFilter) return false;
        if (strategyFilter && String(entry.strategy).toUpperCase() !== strategyFilter) return false;
        if (tierFilter && String(entry.tier).toUpperCase() !== tierFilter) return false;
        if (winRateFilter && String(entry.winRateTier).toUpperCase() !== winRateFilter) return false;
        return true;
      }).sort((a, b) => (b.score ?? 0) - (a.score ?? 0));

      if (filtered.length === 0) {
        return finalizeToolResult(
          { ok: true, text: 'No setup library entries matched the requested filters.', payload: [] },
          { count: 0 }
        );
      }

      const fmtPct = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${(num * 100).toFixed(1)}%` : '--';
      };
      const fmtR = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? `${num.toFixed(2)}R` : '--';
      };
      const fmtNum = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? num.toFixed(2) : '--';
      };

      const limited = filtered.slice(0, limit);
      const lines = limited.map((entry) => {
        const stats = entry.stats || {};
        const perf = entry.performance || {};
        const keyLabel = entry.key ? `Key ${entry.key}` : '';
        const cfgLabel = entry.configKey ? `Cfg ${entry.configKey}` : '';
        const parts = [
          entry.symbol,
          entry.timeframe,
          entry.strategy,
          entry.tier,
          entry.winRateTier,
          `Score ${entry.score}`,
          `WR ${fmtPct(stats.winRate)}`,
          `PF ${fmtNum(stats.profitFactor)}`,
          `Net ${fmtR(perf.netR)}`,
          keyLabel,
          cfgLabel
        ].filter(Boolean);
        return `- ${parts.join(' | ')}`;
      });

      const header = [
        'Setup library',
        action.symbol ? `Symbol ${action.symbol}` : '',
        action.timeframe ? `TF ${action.timeframe}` : '',
        action.strategy ? `Strategy ${action.strategy}` : '',
        tierFilter ? `Tier ${tierFilter}` : '',
        winRateFilter ? `Win ${winRateFilter}` : '',
        `Returned ${limited.length}/${filtered.length}`
      ].filter(Boolean).join(' | ');

      return finalizeToolResult(
        { ok: true, text: `${header}\n${lines.join('\n')}`, payload: limited },
        { count: filtered.length }
      );
    }

    if (action.type === 'CREATE_WATCHER_FROM_LIBRARY') {
      const libraryKey = String(action.libraryKey || action.memoryKey || '').trim();
      const symbolFilter = action.symbol ? normalizeSymbolKey(action.symbol) : '';
      const timeframeFilter = action.timeframe ? normalizeTimeframeKey(action.timeframe) : '';
      const strategyFilter = action.strategy ? String(action.strategy).trim().toUpperCase() : '';
      const tierRaw = action.libraryTier ? String(action.libraryTier).trim().toUpperCase() : '';
      const winRateRaw = action.winRateTier ? String(action.winRateTier).trim().toUpperCase() : '';
      const allowedTier = new Set(['S', 'A', 'B', 'C', 'D']);
      const allowedWin = new Set(['WR70', 'WR60', 'WR50', 'WR40', 'WR30']);
      const tierFilter = tierRaw && allowedTier.has(tierRaw) ? tierRaw : '';
      const winRateFilter = winRateRaw && allowedWin.has(winRateRaw) ? winRateRaw : '';

      let entries = setupLibraryRef.current || [];
      if (entries.length === 0) {
        await refreshSetupLibrary({
          symbol: action.symbol || undefined,
          timeframe: action.timeframe || undefined,
          strategy: action.strategy || undefined,
          limit: 200
        });
        entries = setupLibraryRef.current || [];
      }

      const matches = entries.filter((entry) => {
        if (!entry) return false;
        if (libraryKey) {
          return entry.key === libraryKey || entry.configKey === libraryKey;
        }
        if (symbolFilter && normalizeSymbolKey(entry.symbol) !== symbolFilter) return false;
        if (timeframeFilter && normalizeTimeframeKey(entry.timeframe) !== timeframeFilter) return false;
        if (strategyFilter && String(entry.strategy).toUpperCase() !== strategyFilter) return false;
        if (tierFilter && String(entry.tier).toUpperCase() !== tierFilter) return false;
        if (winRateFilter && String(entry.winRateTier).toUpperCase() !== winRateFilter) return false;
        return true;
      }).sort((a, b) => (b.score ?? 0) - (a.score ?? 0));

      if (matches.length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'No setup library entry matched the request.' },
          { detail: 'library_not_found' }
        );
      }

      const entry = matches[0];
      const mode = normalizeSetupMode(action.mode) || 'suggest';
      const regime = normalizeSetupRegime(action.regime);
      const enabled = typeof action.enabled === 'boolean' ? action.enabled : true;
      const promotionSource = action.source ? String(action.source).trim() : 'setup_library';
      const watcher = ensureWatcherFromLibraryEntry(entry, {
        mode: mode as SetupWatcher['mode'],
        enabled,
        regime: regime ? (regime as SetupWatcher['regime']) : undefined,
        source: promotionSource
      });
      if (!watcher) {
        return finalizeToolResult(
          { ok: false, text: 'Failed to create watcher from setup library entry.' },
          { detail: 'watcher_create_failed' }
        );
      }
      const summary = `${watcher.symbol} ${watcher.timeframe} ${watcher.strategy} (${watcher.mode})`;
      return finalizeToolResult(
        { ok: true, text: `Setup library watcher ready: ${summary}`, payload: watcher },
        { watcherId: watcher.id }
      );
    }

    if (action.type === 'CREATE_SETUP_WATCHER') {
      const winnerRequested = Boolean(action.winnerId || (action.sessionId && action.round));
      const resolvedWinner = winnerRequested
        ? await resolveOptimizerWinner({
            winnerId: action.winnerId,
            sessionId: action.sessionId,
            round: action.round,
            symbol: action.symbol,
            timeframe: action.timeframe,
            strategy: action.strategy,
            limit: action.limit
          })
        : null;

      if (winnerRequested && (!resolvedWinner || !resolvedWinner.ok)) {
        return finalizeToolResult(
          { ok: false, text: resolvedWinner?.error || 'Optimizer winner not found.' },
          { detail: 'watcher_winner_not_found' }
        );
      }

      const winner = resolvedWinner?.ok ? resolvedWinner.winner : null;
      const symbol = String(winner?.symbol || action.symbol || '').trim();
      const timeframe = String(winner?.timeframe || action.timeframe || '').trim();
      const strategy = normalizeSetupStrategy(winner?.strategy || action.strategy);
      if (!symbol || !timeframe || !strategy) {
        return finalizeToolResult(
          { ok: false, text: 'Missing symbol/timeframe/strategy for setup watcher.' },
          { detail: 'watcher_missing_fields' }
        );
      }
      const mode = normalizeSetupMode(action.mode) || 'suggest';
      const regime = normalizeSetupRegime(action.regime);
      const enabled = typeof action.enabled === 'boolean' ? action.enabled : true;
      const paramsFromAction = action.params && typeof action.params === 'object' ? action.params : {};
      const params = winner?.params && typeof winner.params === 'object' ? winner.params : paramsFromAction;
      if (!params || Object.keys(params).length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'Setup watcher requires params or an optimizer winner reference.' },
          { detail: 'watcher_missing_params' }
        );
      }
      const playbook = normalizeExecutionPlaybook(action.playbook || null);
      let paramsHash = '';
      try {
        const paramsKey = buildParamsKey(params);
        paramsHash = hashStringSampled(paramsKey || JSON.stringify(params));
      } catch {
        paramsHash = '';
      }
      const optimizerSessionId = winner?.sessionId ? String(winner.sessionId) : action.sessionId ? String(action.sessionId).trim() : null;
      const optimizerRound = Number.isFinite(Number(winner?.round))
        ? Math.max(1, Math.floor(Number(winner.round)))
        : Number.isFinite(Number(action.round))
          ? Math.max(1, Math.floor(Number(action.round)))
          : null;
      const optimizerWinnerId = winner?.id ? String(winner.id) : action.winnerId ? String(action.winnerId).trim() : null;
      const watcher = addSetupWatcher({
        symbol,
        timeframe,
        strategy: strategy as SetupWatcher['strategy'],
        params,
        playbook,
        mode: mode as SetupWatcher['mode'],
        enabled,
        regime: regime ? (regime as SetupWatcher['regime']) : undefined,
        optimizerSessionId,
        optimizerRound,
        optimizerWinnerId,
        profileParamsHash: paramsHash || null
      });
      const summary = `${watcher.symbol} ${watcher.timeframe} ${watcher.strategy} (${watcher.mode})`;
      return finalizeToolResult(
        {
          ok: true,
          text: `Created setup watcher ${watcher.id}: ${summary}`,
          payload: {
            ...watcher,
            optimizerWinnerId: optimizerWinnerId || watcher.optimizerWinnerId || null,
            optimizerSessionId: optimizerSessionId || watcher.optimizerSessionId || null,
            optimizerRound: optimizerRound ?? watcher.optimizerRound ?? null
          }
        },
        { watcherId: watcher.id }
      );
    }

    if (action.type === 'UPDATE_SETUP_WATCHER') {
      const watcherId = String(action.watcherId || '').trim();
      const filters = watcherId
        ? null
        : {
            symbol: action.symbol || undefined,
            timeframe: action.timeframe || undefined,
            strategy: action.strategy || undefined,
            mode: action.mode || undefined,
            enabled: typeof action.enabled === 'boolean' ? action.enabled : undefined
          };
      const targets = watcherId
        ? (setupWatchersRef.current || []).filter((watcher) => watcher.id === watcherId)
        : (setupWatchersRef.current || []).filter((watcher) => matchesSetupWatcher(watcher, filters || {}));
      if (targets.length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'No setup watchers matched the update request.' },
          { detail: 'watcher_not_found' }
        );
      }
      const patch: Partial<SetupWatcher> = {};
      if (watcherId) {
        if (action.symbol) patch.symbol = String(action.symbol).trim();
        if (action.timeframe) patch.timeframe = String(action.timeframe).trim();
        const strategy = normalizeSetupStrategy(action.strategy);
        if (strategy) patch.strategy = strategy as SetupWatcher['strategy'];
      }
      const mode = normalizeSetupMode(action.mode);
      if (mode) patch.mode = mode as SetupWatcher['mode'];
      const regime = normalizeSetupRegime(action.regime);
      if (regime) patch.regime = regime as SetupWatcher['regime'];
      if (typeof action.enabled === 'boolean') patch.enabled = action.enabled;
      if (action.params && typeof action.params === 'object') patch.params = action.params;
      if (action.playbook != null) patch.playbook = action.playbook;
      if (Object.keys(patch).length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'No valid watcher fields provided to update.' },
          { detail: 'watcher_no_patch' }
        );
      }
      targets.forEach((watcher) => updateSetupWatcher(watcher.id, patch));
      return finalizeToolResult(
        { ok: true, text: `Updated ${targets.length} setup watcher${targets.length === 1 ? '' : 's'}.`, payload: targets.map((w) => ({ id: w.id })) },
        { count: targets.length }
      );
    }

    if (action.type === 'DELETE_SETUP_WATCHER') {
      const watcherId = String(action.watcherId || '').trim();
      const filters = watcherId
        ? null
        : {
            symbol: action.symbol || undefined,
            timeframe: action.timeframe || undefined,
            strategy: action.strategy || undefined,
            mode: action.mode || undefined
          };
      const targets = watcherId
        ? (setupWatchersRef.current || []).filter((watcher) => watcher.id === watcherId)
        : (setupWatchersRef.current || []).filter((watcher) => matchesSetupWatcher(watcher, filters || {}));
      if (targets.length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'No setup watchers matched the delete request.' },
          { detail: 'watcher_not_found' }
        );
      }
      targets.forEach((watcher) => removeSetupWatcher(watcher.id));
      return finalizeToolResult(
        { ok: true, text: `Deleted ${targets.length} setup watcher${targets.length === 1 ? '' : 's'}.`, payload: targets.map((w) => ({ id: w.id })) },
        { count: targets.length }
      );
    }

    if (action.type === 'GET_SETUP_SIGNALS') {
      const limit = Number.isFinite(Number(action.limit)) ? Math.max(1, Math.min(50, Math.floor(Number(action.limit)))) : 10;
      const sinceMs = Number.isFinite(Number(action.sinceMs)) ? Number(action.sinceMs) : null;
      const watcherId = String(action.watcherId || '').trim();
      const symbolFilter = action.symbol ? normalizeSymbolKey(action.symbol) : '';
      const timeframeFilter = action.timeframe ? normalizeSetupTimeframe(action.timeframe) : '';
      const strategyFilter = normalizeSetupStrategy(action.strategy);

      const signals = (setupSignalsRef.current || []).filter((signal) => {
        if (!signal) return false;
        if (sinceMs != null && (signal.ts || 0) < sinceMs) return false;
        if (watcherId && signal.payload?.watcherId !== watcherId) return false;
        if (symbolFilter) {
          const sigSymbol = normalizeSymbolKey(signal.symbol);
          if (!sigSymbol || sigSymbol !== symbolFilter) return false;
        }
        if (timeframeFilter) {
          const sigTf = normalizeSetupTimeframe(signal.timeframe);
          if (!sigTf || sigTf !== timeframeFilter) return false;
        }
        if (strategyFilter && String(signal.payload?.strategy || '').toUpperCase() !== strategyFilter) return false;
        return true;
      }).sort((a, b) => (b.ts || 0) - (a.ts || 0));

      if (signals.length === 0) {
        return finalizeToolResult(
          { ok: true, text: 'No setup signals found for the requested filters.', payload: [] },
          { count: 0 }
        );
      }

      const limited = signals.slice(0, limit);
      const lines = limited.map((signal) => {
        const age = formatAge(signal.ts || null);
        const details = signal.payload?.details || null;
        const entry = formatBrokerPrice(details?.entryPrice);
        const stop = formatBrokerPrice(details?.stopLoss);
        const tp = formatBrokerPrice(details?.takeProfit);
        const status = signal.payload?.status || signal.payload?.signalType || '';
        const strengthPct = Number.isFinite(Number(signal.strength)) ? Math.round(Number(signal.strength) * 100) : null;
        const priceParts = [
          entry ? `entry ${entry}` : '',
          stop ? `sl ${stop}` : '',
          tp ? `tp ${tp}` : ''
        ].filter(Boolean).join(' ');
        const parts = [
          status,
          signal.payload?.side ? signal.payload.side : '',
          signal.symbol,
          signal.timeframe,
          signal.payload?.strategy,
          age ? `${age} ago` : '',
          strengthPct != null ? `${strengthPct}%` : ''
        ].filter(Boolean).join(' ');
        return `- ${parts}${priceParts ? ` | ${priceParts}` : ''}`;
      });
      const header = [
        'Setup signals',
        action.symbol ? `Symbol ${action.symbol}` : '',
        action.timeframe ? `TF ${action.timeframe}` : '',
        action.strategy ? `Strategy ${action.strategy}` : '',
        watcherId ? `Watcher ${watcherId}` : '',
        `Returned ${limited.length}/${signals.length}`
      ].filter(Boolean).join(' | ');

      return finalizeToolResult(
        { ok: true, text: `${header}\n${lines.join('\n')}`, payload: limited },
        { count: signals.length }
      );
    }

    if (action.type === 'EXPLAIN_SETUP_SIGNAL') {
      const signalId = String(action.signalId || '').trim();
      const profileId = String(action.profileId || '').trim();
      const watcherId = String(action.watcherId || '').trim();
      const symbolFilter = action.symbol ? normalizeSymbolKey(action.symbol) : '';
      const timeframeFilter = action.timeframe ? normalizeSetupTimeframe(action.timeframe) : '';

      let candidateSignals = setupSignalsRef.current || [];
      if (
        candidateSignals.length === 0 ||
        signalId ||
        profileId ||
        watcherId ||
        symbolFilter ||
        timeframeFilter
      ) {
        const refreshed = await refreshSetupSignals({
          symbol: action.symbol ? String(action.symbol) : undefined,
          timeframe: action.timeframe ? String(action.timeframe) : undefined,
          limit: 200
        });
        if (refreshed.length > 0) candidateSignals = refreshed;
      }

      const matches = candidateSignals.filter((signal) => {
        if (!signal) return false;
        if (signalId && signal.id !== signalId) return false;
        if (profileId && signal.profileId !== profileId) return false;
        if (watcherId && signal.payload?.watcherId !== watcherId) return false;
        if (symbolFilter && normalizeSymbolKey(signal.symbol) !== symbolFilter) return false;
        if (timeframeFilter && normalizeSetupTimeframe(signal.timeframe) !== timeframeFilter) return false;
        return true;
      }).sort((a, b) => (b.ts || 0) - (a.ts || 0));

      if (matches.length === 0) {
        return finalizeToolResult(
          { ok: false, text: 'No setup signal found to explain for the requested filters.' },
          { detail: 'setup_signal_missing' }
        );
      }

      const signal = matches[0];
      const details = signal.payload?.details && typeof signal.payload.details === 'object'
        ? signal.payload.details
        : {};
      const side = signal.payload?.side ? String(signal.payload.side).toUpperCase() : '';
      const age = formatAge(signal.ts || null);

      const toNumber = (value: any) => {
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
      };
      const entryNum = toNumber(details?.entryPrice);
      const stopNum = toNumber(details?.stopLoss);
      const tpNum = toNumber(details?.takeProfit);
      const entry = formatBrokerPrice(entryNum);
      const stop = formatBrokerPrice(stopNum);
      const tp = formatBrokerPrice(tpNum);

      let rr: number | null = null;
      if (entryNum != null && stopNum != null && tpNum != null) {
        const risk = side === 'SELL' ? stopNum - entryNum : entryNum - stopNum;
        const reward = side === 'SELL' ? entryNum - tpNum : tpNum - entryNum;
        if (risk > 0 && reward > 0) rr = reward / risk;
      }

      const evidence =
        signal.payload?.evidence ||
        buildEvidenceCardFromSignal({
          strategy: signal.payload?.strategy,
          signalType: signal.payload?.signalType,
          side: side === 'BUY' || side === 'SELL' ? side : null,
          details,
          reasonCodes,
          strength: signal.strength,
          regime: details?.regime ? String(details.regime) : null,
          createdAtMs: signal.ts || Date.now()
        });

      const captureSnapshot = async (symbolLabel: string, timeframeLabel: string) => {
        if (!nativeChartMounted) {
          setNativeChartMounted(true);
        }
        const sleep = (ms: number) => sleepMs(ms);
        const startedAt = Date.now();
        const maxWaitMs = 3500;
        let snapshot: string | null = null;
        let meta: NativeChartMeta | null = null;

        while (Date.now() - startedAt < maxWaitMs) {
          const chart = nativeChartRef.current;
          if (chart?.focusSymbol && symbolLabel) {
            chart.focusSymbol(symbolLabel, timeframeLabel, { revealSetups: true });
          } else if (chart?.ensureFrameActive && timeframeLabel) {
            chart.ensureFrameActive(timeframeLabel);
          }
          snapshot = chart?.captureSnapshot ? chart.captureSnapshot() : null;
          if (snapshot) {
            meta = chart?.getMeta ? chart.getMeta() : null;
            lastNativeChartSnapshotRef.current = { dataUrl: snapshot, meta, capturedAtMs: Date.now() };
            void persistChartSnapshotMemory({
              imageDataUrl: snapshot,
              meta,
              symbol: meta?.symbol || requestedSymbol || null,
              timeframe: requestedTimeframe || null,
              source: effectiveSource
            });
            break;
          }
          await sleep(350);
        }

        if (!snapshot) {
          const cached = lastNativeChartSnapshotRef.current;
          if (cached?.dataUrl) {
            return {
              snapshot: cached.dataUrl,
              meta: cached.meta || null,
              cached: true,
              cachedAge: cached.capturedAtMs ? formatAge(cached.capturedAtMs) : ''
            };
          }
        }
        return { snapshot, meta, cached: false, cachedAge: '' };
      };

      const includeSnapshot =
        typeof action.includeSnapshot === 'boolean'
          ? action.includeSnapshot
          : false;

      const snapshotResult = includeSnapshot
        ? await captureSnapshot(signal.symbol, signal.timeframe)
        : { snapshot: null as string | null, meta: null as NativeChartMeta | null, cached: false, cachedAge: '' };

      const strengthPct = Number.isFinite(Number(signal.strength)) ? Math.round(Number(signal.strength) * 100) : null;
      const reasonCodes = Array.isArray(signal.reasonCodes)
        ? Array.from(new Set(signal.reasonCodes.map((item) => String(item || '').trim()).filter(Boolean)))
        : [];
      const regime = details?.regime ? String(details.regime) : '';
      const regimeMeta = details?.regimeMeta && typeof details.regimeMeta === 'object' ? details.regimeMeta : null;
      const regimeBits = [];
      if (Number.isFinite(Number(regimeMeta?.trendStrength))) {
        regimeBits.push(`trend ${Number(regimeMeta.trendStrength).toFixed(2)}`);
      }
      if (Number.isFinite(Number(regimeMeta?.volatilityPct))) {
        regimeBits.push(`vol ${Number(regimeMeta.volatilityPct).toFixed(2)}%`);
      }

      const library = details?.library && typeof details.library === 'object' ? details.library : null;
      const libraryLine = library
        ? [
            library.tier ? `tier ${library.tier}` : '',
            library.score != null ? `score ${Number(library.score).toFixed(2)}` : '',
            library.winRateTier ? `wr ${library.winRateTier}` : ''
          ].filter(Boolean).join(' ')
        : '';

      const actionStatus = signal.payload?.status || signal.payload?.signalType || 'setup_ready';
      const actionGuidance =
        actionStatus === 'entry_confirmed'
          ? 'entry confirmed; execute if risk + filters are green'
          : actionStatus === 'setup_ready'
            ? 'setup ready; wait for confirmation/entry trigger'
            : actionStatus === 'setup_detected'
              ? 'setup forming; wait for readiness or confirmation'
              : actionStatus === 'triggered'
                ? 'triggered/executed; manage risk and monitor'
                : 'invalidated; do not execute unless re-confirmed';

      const levelLine = [entry ? `entry ${entry}` : '', stop ? `sl ${stop}` : '', tp ? `tp ${tp}` : '']
        .filter(Boolean)
        .join(' | ');

      const evidenceLines = [
        evidence?.bias ? `Bias: ${evidence.bias}` : '',
        evidence?.setup ? `Setup: ${evidence.setup}` : '',
        evidence?.invalidation ? `Invalidation: ${evidence.invalidation}` : '',
        evidence?.confidence?.score != null
          ? `Confidence: ${Math.round(Number(evidence.confidence.score) * 100)}%`
          : ''
      ].filter(Boolean);

      const bullets = [
        `Strategy: ${signal.payload?.strategy || ''}${side ? ` | ${side}` : ''}${age ? ` | ${age}` : ''}`,
        `Status: ${actionStatus}`,
        strengthPct != null ? `Strength: ${strengthPct}%` : '',
        levelLine ? `Levels: ${levelLine}${rr != null ? ` | RR ${rr.toFixed(2)}` : ''}` : '',
        regime ? `Regime: ${regime}${regimeBits.length ? ` (${regimeBits.join(', ')})` : ''}` : '',
        reasonCodes.length ? `Reasons: ${reasonCodes.join(', ')}` : '',
        libraryLine ? `Library: ${libraryLine}` : '',
        ...evidenceLines,
        includeSnapshot
          ? (snapshotResult.snapshot
              ? `Chart snapshot: ${snapshotResult.cached ? `cached${snapshotResult.cachedAge ? ` (${snapshotResult.cachedAge})` : ''}` : 'captured'}` 
              : 'Chart snapshot: unavailable')
          : 'Chart snapshot: omitted (includeSnapshot=false)',
        `Action: ${actionGuidance}.`
      ].filter(Boolean);

      const header = `Setup signal ${actionStatus} for ${signal.symbol} ${signal.timeframe}.`;
      const text = [header, ...bullets.map((line) => `- ${line}`)].join('\n');

      return finalizeToolResult(
        {
          ok: true,
          text,
          imageDataUrl: includeSnapshot ? snapshotResult.snapshot || undefined : undefined,
          payload: {
            signal,
            evidence: evidence || null,
            action: {
              status: actionStatus,
              guidance: actionGuidance,
              levels: {
                entry: entryNum ?? null,
                stopLoss: stopNum ?? null,
                takeProfit: tpNum ?? null
              },
              rr: rr != null ? Number(rr.toFixed(2)) : null
            },
            snapshot: includeSnapshot
              ? {
                  imageDataUrl: snapshotResult.snapshot || null,
                  atMs: Date.now(),
                  symbol: signal.symbol,
                  timeframe: signal.timeframe
                }
              : null
          }
        },
        { detail: 'setup_signal_explained', symbol: signal.symbol, timeframe: signal.timeframe }
      );
    }

    if (action.type === 'UPDATE_AGENT_CAPABILITIES') {
      const caps = action.capabilities && typeof action.capabilities === 'object' ? action.capabilities : null;
      if (!caps) {
        return finalizeToolResult(
          { ok: false, text: 'No capability changes provided.' },
          { detail: 'capabilities_missing' }
        );
      }
      const agentId = String(action.agentId || '').trim();
      const agentName = String(action.agentName || '').trim().toLowerCase();
      const list = agentsRef.current || [];
      const target = agentId
        ? list.find((agent) => agent.id === agentId)
        : list.find((agent) => agentName && agent.name.toLowerCase() === agentName);
      if (!target) {
        return finalizeToolResult(
          { ok: false, text: 'Agent not found for capability update.' },
          { detail: 'agent_not_found' }
        );
      }
      const currentCaps = normalizeAgentCapabilities(target.capabilities);
      const merged = normalizeAgentCapabilities({ ...currentCaps, ...caps });
      const updater = updateAgentRef.current;
      if (!updater) {
        return finalizeToolResult(
          { ok: false, text: 'Agent update handler unavailable.' },
          { detail: 'agent_update_unavailable' }
        );
      }
      updater({ ...target, capabilities: merged });
      const capLine = `trade ${merged.trade ? 'on' : 'off'} | auto-exec ${merged.autoExecute ? 'on' : 'off'} | broker ${merged.broker ? 'on' : 'off'} | tools ${merged.tools ? 'on' : 'off'}`;
      void appendAuditEvent({
        eventType: 'agent_capabilities_update',
        payload: { agentId: target.id, agentName: target.name, capabilities: merged }
      });
      return finalizeToolResult(
        { ok: true, text: `Updated ${target.name} capabilities: ${capLine}.`, payload: { agentId: target.id, capabilities: merged } },
        { agentId: target.id }
      );
    }

    return finalizeToolResult(
      { ok: false, text: `Unsupported tool request: ${action.type}` },
      { detail: 'unsupported_tool' }
    );
    }, [
      activeBrokerSymbol,
      activeTab,
      activeTabId,
      activeTvParams?.symbol,
      addSetupWatcher,
      appendAuditEvent,
      applyOrQueueBacktestOptimization,
      brokerWatchSymbols,
      chartSessions.sessions,
      ensureWatcherFromLibraryEntry,
      fetchBrokerQuoteForSymbol,
      getBrokerQuoteForSymbol,
      getResearchResults,
      getResearchStatus,
      healthSnapshot,
      nativeChartMounted,
      normalizeAgentCapabilities,
      persistChartSnapshotMemory,
      playbookStatusByWatcher,
      refreshSetupLibrary,
      refreshSetupSignals,
      removeSetupWatcher,
      saveSetupLibraryFromOptimization,
      setupPerformanceByLibrary,
      setupPerformanceByMode,
      setupPerformanceBySymbol,
      setupPerformanceByWatcher,
      setupPerformanceError,
      setupPerformanceSummary,
      setupPerformanceUpdatedAtMs,
      startResearchSession,
      stopResearchSession,
      tabs,
      updateSetupWatcher
    ]);

  useEffect(() => {
    executeAgentToolRequestRef.current = executeAgentToolRequest;
  }, [executeAgentToolRequest]);

  const runActionCatalog = useCallback(async (input: { actionId: string; payload?: Record<string, any> }) => {
    const actionId = String(input.actionId || '').trim();
    if (!actionId) return { ok: false, error: 'Action id is required.' };
    const payload = input.payload && typeof input.payload === 'object' ? input.payload : {};
    return await panelConnectivityEngine.runAction({
      panel: 'app',
      request: { actionId, payload },
      source: 'catalog',
      runActionCatalog: async (request) => {
        const action: AgentToolAction = {
          type: 'RUN_ACTION_CATALOG',
          status: 'PENDING',
          actionId: request.actionId,
          payload: request.payload && typeof request.payload === 'object' ? request.payload : {},
          source: 'ui'
        };
        const res = await executeAgentToolRequest(action);
        if (!res?.ok) return { ok: false, error: res?.text || 'Action failed.', data: res?.payload ?? null };
        return { ok: true, data: res?.payload ?? null };
      }
    });
  }, [executeAgentToolRequest]);

  const requestSystemSnapshot = useCallback(async (input?: { detail?: 'summary' | 'full'; maxItems?: number }) => {
    const action: AgentToolAction = {
      type: 'GET_SYSTEM_STATE',
      status: 'PENDING',
      detail: input?.detail === 'full' ? 'full' : 'summary',
      maxItems: input?.maxItems ?? undefined,
      source: 'monitor'
    };
    return executeAgentToolRequest(action);
  }, [executeAgentToolRequest]);

  const clearSnapshotFrameCache = useCallback((opts?: { dropSessionBars?: boolean }) => {
    return chartEngine.clearPersistedFrameCache({
      dropSessionBars: opts?.dropSessionBars === true
    });
  }, [chartEngine]);

  const cancelAgentToolRequest = useCallback((messageId: string, action: AgentToolAction) => {
    if (!messageId) return;
    if (!action || action.type !== 'RUN_BACKTEST_OPTIMIZATION') return;
    const key = String(messageId).trim();
    if (!key) return;
    const existing = backtestOptimizationCancelRef.current.get(key);
    if (existing) {
      existing.cancelled = true;
    } else {
      backtestOptimizationCancelRef.current.set(key, { cancelled: true });
    }
  }, []);

  const saveOptimizerWinnerPreset = useCallback(async (payload: {
    winnerId?: string | null;
    sessionId?: string | null;
    round?: number | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    params?: Record<string, any> | null;
    presetName?: string | null;
    tags?: string[];
  }) => {
    const action: AgentToolAction = {
      type: 'SAVE_OPTIMIZER_WINNER_PRESET',
      status: 'PENDING',
      winnerId: payload.winnerId || undefined,
      sessionId: payload.sessionId || undefined,
      round: payload.round ?? undefined,
      symbol: payload.symbol || undefined,
      timeframe: payload.timeframe || undefined,
      strategy: payload.strategy || undefined,
      params: payload.params || undefined,
      presetName: payload.presetName || undefined,
      tags: payload.tags || undefined
    };
    const result = await executeAgentToolRequest(action);
    if (!result.ok) {
      throw new Error(result.text || 'Failed to save preset.');
    }
    return result;
  }, [executeAgentToolRequest]);

  useEffect(() => {
    const symbol = String(activeTvParams?.symbol || '').trim();
    if (!symbol) {
      setActiveBrokerSymbol('');
      return;
    }

    let cancelled = false;
    (async () => {
      const resolved = await resolveTradeLockerSymbolBestEffort(symbol);
      if (cancelled) return;
      setActiveBrokerSymbol(resolved || symbol);
    })();

    return () => {
      cancelled = true;
    };
  }, [activeTvParams?.symbol, resolveTradeLockerSymbolBestEffort]);

  useEffect(() => {
    const activeUrl = activeTab?.url || '';
    if (!isTradingViewUrl(activeUrl)) {
      setActiveTvPrice(null);
      setActiveTvPriceUpdatedAtMs(null);
      return;
    }

    const controls = browserControlsRef.current;
    if (!controls?.executeInTab) return;

    setActiveTvPrice(null);
    setActiveTvPriceUpdatedAtMs(null);
    tvPriceFetchAtRef.current = 0;

    let cancelled = false;
    const intervalMs = 8000;

    const poll = async () => {
      if (cancelled) return;
      const now = Date.now();
      if (now - tvPriceFetchAtRef.current < 1500) return;
      tvPriceFetchAtRef.current = now;

      let res: any = null;
      try {
        res = await controls.executeInTab(activeTabId, TRADINGVIEW_PRICE_SCRIPT);
      } catch {
        res = null;
      }
      if (cancelled) return;

      const text = res && typeof res === 'object' ? String(res.text || '').trim() : '';
      const parsed = parsePriceText(text);
      if (parsed != null) {
        setActiveTvPrice(parsed);
        setActiveTvPriceUpdatedAtMs(Date.now());
      }
    };

    let stop: (() => void) | null = null;
    void loadTradingViewPriceControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createTradingViewPriceController({
        intervalMs,
        runOnStart: true,
        tick: poll
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [activeTab?.url, activeTabId]);

  const normalizeExecutionMode = (value: any) => {
    const raw = String(value || '').trim().toLowerCase();
    if (!raw) return null;
    if (raw === 'live' || raw === 'paper' || raw === 'shadow') return raw;
    return null;
  };

  const isShadowEntry = (entry: any) => {
    const mode = String(entry?.executionMode || '').toLowerCase();
    const broker = String(entry?.broker || '').toLowerCase();
    return mode === 'shadow' || broker === 'shadow';
  };

  const isEntryClosed = (entry: any) => {
    const status = String(entry?.status || '').toUpperCase();
    const positionStatus = String(entry?.positionStatus || '').toUpperCase();
    const closedAt = Number(entry?.positionClosedAtMs || 0);
    return status === 'CLOSED' || positionStatus === 'CLOSED' || closedAt > 0;
  };

  const computeShadowR = (entry: any, exitPrice: number | null) => {
    const entryPrice = Number(entry?.shadowEntryPrice ?? entry?.entryPrice ?? entry?.brokerEntryPrice ?? entry?.plannedEntryPrice);
    const stopLoss = Number(entry?.stopLoss ?? entry?.brokerStopLoss ?? entry?.plannedStopLoss);
    if (!Number.isFinite(entryPrice) || !Number.isFinite(stopLoss) || !Number.isFinite(exitPrice)) return null;
    const risk = Math.abs(entryPrice - stopLoss);
    if (!Number.isFinite(risk) || risk <= 0) return null;
    const side = String(entry?.action || '').toUpperCase() === 'SELL' ? -1 : 1;
    const r = ((Number(exitPrice) - entryPrice) * side) / risk;
    return Number.isFinite(r) ? r : null;
  };

  const resolveShadowOutcome = (entry: any) => {
    const reason = String(entry?.shadowExitReason || entry?.exitReason || '').trim().toUpperCase();
    if (!reason) return null;
    if (reason.includes('TP')) return 'WIN';
    if (reason.includes('SL')) return 'LOSS';
    if (reason.includes('EXPIRE')) return 'EXPIRED';
    return null;
  };

  const buildShadowTradeViews = useCallback((entries: any[]): ShadowTradeView[] => {
    const agentsNow = agentsRef.current || [];
    const agentMap = new Map(agentsNow.map((agent) => [agent.id, agent]));
    const views = entries
      .filter((entry) => entry?.kind === 'trade' && isShadowEntry(entry))
      .map((entry) => {
        const agent = entry?.agentId ? agentMap.get(String(entry.agentId)) : null;
        const closedAtMs = Number(entry?.positionClosedAtMs ?? entry?.closedAtMs ?? 0) || null;
        const openedAtMs = Number(entry?.positionOpenedAtMs ?? entry?.openedAtMs ?? entry?.createdAtMs ?? 0) || null;
        const shadowExitPrice = Number(entry?.shadowExitPrice ?? entry?.closePrice ?? entry?.positionClosePrice ?? entry?.brokerClosePrice);
        const shadowR = Number.isFinite(Number(entry?.shadowR))
          ? Number(entry.shadowR)
          : computeShadowR(entry, Number.isFinite(shadowExitPrice) ? shadowExitPrice : null);
        return {
          id: String(entry.id || ''),
          signalId: entry?.setupSignalId ? String(entry.setupSignalId) : (entry?.signalId ? String(entry.signalId) : null),
          agentId: entry?.agentId ? String(entry.agentId) : null,
          agentName: agent?.name || (entry?.agentName ? String(entry.agentName) : null),
          symbol: String(entry?.symbol || '').trim(),
          action: String(entry?.action || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY',
          entryPrice: Number(entry?.shadowEntryPrice ?? entry?.entryPrice ?? entry?.brokerEntryPrice ?? entry?.plannedEntryPrice),
          stopLoss: Number(entry?.stopLoss ?? entry?.brokerStopLoss ?? entry?.plannedStopLoss),
          takeProfit: Number(entry?.takeProfit ?? entry?.brokerTakeProfit ?? entry?.plannedTakeProfit),
          openedAtMs,
          closedAtMs,
          outcome: resolveShadowOutcome(entry),
          shadowR,
          status: entry?.positionStatus || entry?.status || null,
          exitReason: entry?.shadowExitReason ? String(entry.shadowExitReason) : null
        } as ShadowTradeView;
      });
    views.sort((a, b) => {
      const aTime = a.closedAtMs ?? a.openedAtMs ?? 0;
      const bTime = b.closedAtMs ?? b.openedAtMs ?? 0;
      return bTime - aTime;
    });
    return views;
  }, [computeShadowR]);

  const buildShadowAccounts = useCallback((entries: any[]): ShadowAccountSnapshot[] => {
    const agentsNow = agentsRef.current || [];
    const profiles = shadowProfilesRef.current || [];
    const profileMap = new Map(profiles.map((profile) => [profile.agentId, profile]));
    const tradesByAgent = new Map<string, any[]>();
    const openCounts = new Map<string, number>();

    for (const entry of entries) {
      if (!isShadowEntry(entry)) continue;
      const agentId = entry?.agentId ? String(entry.agentId) : '';
      if (!agentId) continue;
      const list = tradesByAgent.get(agentId) || [];
      list.push(entry);
      tradesByAgent.set(agentId, list);
      if (!isEntryClosed(entry)) {
        openCounts.set(agentId, (openCounts.get(agentId) || 0) + 1);
      }
    }

    const knownAgents = new Set<string>(agentsNow.map((agent) => agent.id));
    for (const id of profileMap.keys()) {
      knownAgents.add(id);
    }

    const now = Date.now();
    const accounts: ShadowAccountSnapshot[] = [];

    for (const agentId of Array.from(knownAgents)) {
      const agent = agentsNow.find((item) => item.id === agentId) || null;
      const profile = normalizeShadowProfile(profileMap.get(agentId) || { agentId, agentName: agent?.name }, agent);
      if (!profile) continue;
      const trades = (tradesByAgent.get(agentId) || []).filter((entry) => isEntryClosed(entry));
      trades.sort((a, b) => {
        const aTime = Number(a?.positionClosedAtMs ?? a?.closedAtMs ?? a?.positionOpenedAtMs ?? a?.createdAtMs ?? 0);
        const bTime = Number(b?.positionClosedAtMs ?? b?.closedAtMs ?? b?.positionOpenedAtMs ?? b?.createdAtMs ?? 0);
        return aTime - bTime;
      });

      let balance = profile.startingBalance;
      let maxBalance = balance;
      let wins = 0;
      let losses = 0;
      let expires = 0;
      let netR = 0;
      let dayKey = '';
      let dayStartBalance = balance;
      let dayLowBalance = balance;
      let dailyDrawdownPct = 0;

      for (const entry of trades) {
        const closedAtMs = Number(entry?.positionClosedAtMs ?? entry?.closedAtMs ?? 0);
        const date = closedAtMs ? new Date(closedAtMs) : new Date();
        const nextDayKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        if (nextDayKey !== dayKey) {
          dayKey = nextDayKey;
          dayStartBalance = balance;
          dayLowBalance = balance;
        }

        const exitPrice = Number(entry?.shadowExitPrice ?? entry?.closePrice ?? entry?.positionClosePrice ?? entry?.brokerClosePrice);
        const shadowR = Number.isFinite(Number(entry?.shadowR))
          ? Number(entry.shadowR)
          : computeShadowR(entry, Number.isFinite(exitPrice) ? exitPrice : null);
        const r = Number.isFinite(Number(shadowR)) ? Number(shadowR) : 0;
        netR += r;

        const outcome = resolveShadowOutcome(entry);
        if (outcome === 'WIN') wins += 1;
        else if (outcome === 'LOSS') losses += 1;
        else if (outcome === 'EXPIRED') expires += 1;

        const riskAmount = balance * (profile.riskPct / 100);
        const pnl = riskAmount * r;
        balance += pnl;
        maxBalance = Math.max(maxBalance, balance);
        dayLowBalance = Math.min(dayLowBalance, balance);
        const dayDd = dayStartBalance > 0 ? ((dayStartBalance - dayLowBalance) / dayStartBalance) * 100 : 0;
        if (dayDd > dailyDrawdownPct) dailyDrawdownPct = dayDd;
      }

      const drawdownPct = maxBalance > 0 ? ((maxBalance - balance) / maxBalance) * 100 : 0;
      let displayBalance = balance;
      let displayEquity = balance;
      let displayDrawdownPct = Number.isFinite(drawdownPct) ? drawdownPct : null;
      let displayDailyDrawdownPct = Number.isFinite(dailyDrawdownPct) ? dailyDrawdownPct : null;
      let balanceSource: 'shadow' | 'live' = 'shadow';
      let openTrades = openCounts.get(agentId) || 0;

      if (profile.liveDeployEnabled) {
        const broker = profile.liveBroker === 'tradelocker' ? 'tradelocker' : 'mt5';
        const live = getLiveAccountSnapshot(broker);
        const liveBalance = Number(live?.balance);
        const liveEquity = Number(live?.equity);
        if (Number.isFinite(liveBalance) || Number.isFinite(liveEquity)) {
          if (Number.isFinite(liveBalance)) displayBalance = liveBalance;
          if (Number.isFinite(liveEquity)) displayEquity = liveEquity;
          else displayEquity = displayBalance;
          balanceSource = 'live';
          displayDrawdownPct = null;
          displayDailyDrawdownPct = null;
          maxBalance = Math.max(maxBalance, displayBalance);
        }
        if (broker === 'tradelocker' && Number.isFinite(Number(live?.openPositions))) {
          openTrades = Number(live?.openPositions);
        }
      }

      accounts.push({
        agentId,
        balance: displayBalance,
        equity: displayEquity,
        wins,
        losses,
        expires,
        netR,
        maxBalance,
        drawdownPct: displayDrawdownPct,
        dailyDrawdownPct: displayDailyDrawdownPct,
        openTrades,
        updatedAtMs: now,
        balanceSource
      });
    }

    return accounts;
  }, [computeShadowR, getLiveAccountSnapshot, normalizeShadowProfile]);

  const buildShadowTradeStats = (entries: any[]): ShadowTradeStats => {
    const stats: ShadowTradeStats = {
      openCount: 0,
      closedCount: 0,
      wins: 0,
      losses: 0,
      winRate: null,
      netR: 0,
      avgR: null,
      lastClosedAtMs: null,
      updatedAtMs: Date.now(),
      byRegime: {}
    };

    for (const entry of entries) {
      if (!isShadowEntry(entry)) continue;
      if (isEntryClosed(entry)) {
        stats.closedCount += 1;
        const exitPrice = Number(entry?.shadowExitPrice ?? entry?.closePrice ?? entry?.positionClosePrice ?? entry?.brokerClosePrice);
        const r = Number.isFinite(Number(entry?.shadowR))
          ? Number(entry.shadowR)
          : computeShadowR(entry, Number.isFinite(exitPrice) ? exitPrice : null);
        if (r != null) {
          stats.netR += r;
          if (r >= 0) stats.wins += 1;
          else stats.losses += 1;
        }
        const closedAt = Number(entry?.positionClosedAtMs || 0);
        if (closedAt > 0) stats.lastClosedAtMs = Math.max(stats.lastClosedAtMs || 0, closedAt) || stats.lastClosedAtMs;
        const regimeKey = String(entry?.shadowRegimeKey || entry?.regimeKey || '').trim();
        if (regimeKey) {
          const bucket = stats.byRegime?.[regimeKey] || {
            trades: 0,
            wins: 0,
            losses: 0,
            winRate: null,
            netR: 0,
            avgR: null
          };
          bucket.trades += 1;
          if (r != null) {
            bucket.netR += r;
            if (r >= 0) bucket.wins += 1;
            else bucket.losses += 1;
          }
          stats.byRegime = stats.byRegime || {};
          stats.byRegime[regimeKey] = bucket;
        }
      } else {
        stats.openCount += 1;
      }
    }

    if (stats.closedCount > 0) {
      stats.winRate = stats.wins / stats.closedCount;
      stats.avgR = stats.netR / stats.closedCount;
    }
    if (stats.byRegime) {
      for (const bucket of Object.values(stats.byRegime)) {
        if (bucket.trades > 0) {
          bucket.winRate = bucket.wins / bucket.trades;
          bucket.avgR = bucket.netR / bucket.trades;
        }
      }
    }
    return stats;
  };

  const computeActualR = (entry: any, exitPrice: number | null) => {
    const entryPrice = Number(
      entry?.brokerEntryPrice ?? entry?.entryPrice ?? entry?.plannedEntryPrice ?? entry?.shadowEntryPrice
    );
    const stopLoss = Number(entry?.stopLoss ?? entry?.brokerStopLoss ?? entry?.plannedStopLoss);
    if (!Number.isFinite(entryPrice) || !Number.isFinite(stopLoss) || !Number.isFinite(exitPrice)) return null;
    const risk = Math.abs(entryPrice - stopLoss);
    if (!Number.isFinite(risk) || risk <= 0) return null;
    const side = String(entry?.action || '').toUpperCase() === 'SELL' ? -1 : 1;
    const r = ((Number(exitPrice) - entryPrice) * side) / risk;
    return Number.isFinite(r) ? r : null;
  };

  const getTradeClosedAtMs = (entry: any) => {
    const closedAt = Number(entry?.positionClosedAtMs ?? entry?.closedAtMs ?? entry?.closedAt ?? 0);
    return Number.isFinite(closedAt) && closedAt > 0 ? closedAt : null;
  };

  const getTradeOpenedAtMs = (entry: any) => {
    const openedAt = Number(entry?.positionOpenedAtMs ?? entry?.openedAtMs ?? entry?.createdAtMs ?? 0);
    return Number.isFinite(openedAt) && openedAt > 0 ? openedAt : null;
  };

  const resolveTradeMatchKey = (entry: any) => {
    const setupSignalId = entry?.setupSignalId ?? entry?.signalId ?? null;
    if (setupSignalId) return `signal:${String(setupSignalId)}`;
    const decisionId = entry?.decisionId ?? null;
    if (decisionId) return `decision:${String(decisionId)}`;
    const messageId = entry?.messageId ?? null;
    if (messageId) return `message:${String(messageId)}`;
    const executionId = entry?.executionId ?? null;
    if (executionId) return `exec:${String(executionId)}`;

    const symbol = normalizeSymbolKey(String(entry?.symbol || ''));
    const action = String(entry?.action || '').toUpperCase();
    const entryPrice = Number(entry?.entryPrice ?? entry?.brokerEntryPrice ?? entry?.plannedEntryPrice);
    const openedAt = getTradeOpenedAtMs(entry);
    const bucket = openedAt ? Math.floor(openedAt / 60_000) : null;
    if (!symbol || !action || !Number.isFinite(entryPrice) || bucket == null) return '';
    return `fallback:${symbol}:${action}:${entryPrice.toFixed(4)}:${bucket}`;
  };

  const isActualEntry = (entry: any, includePaper: boolean) => {
    if (!entry || entry.kind !== 'trade') return false;
    if (isShadowEntry(entry)) return false;
    const mode = String(entry?.executionMode || '').toLowerCase();
    const broker = String(entry?.broker || '').toLowerCase();
    if (mode === 'shadow') return false;
    if (mode === 'paper' && !includePaper) return false;
    if (mode === 'live') return true;
    if (broker === 'tradelocker') return true;
    if (broker === 'sim') return includePaper;
    return includePaper && mode === 'paper';
  };

  const buildShadowTradeCompare = (
    entries: any[],
    opts?: { includePairs?: boolean; includePaper?: boolean }
  ): { summary: ShadowTradeCompareSummary; pairs: any[] } => {
    const includePaper = opts?.includePaper === true;
    const shadowMap = new Map<string, any>();
    const actualMap = new Map<string, any>();

    for (const entry of entries) {
      if (!entry || entry.kind !== 'trade') continue;
      if (!isEntryClosed(entry)) continue;
      const key = resolveTradeMatchKey(entry);
      if (!key) continue;
      const closedAt = getTradeClosedAtMs(entry) || 0;
      if (isShadowEntry(entry)) {
        const prev = shadowMap.get(key);
        const prevClosed = prev ? getTradeClosedAtMs(prev) || 0 : 0;
        if (!prev || closedAt >= prevClosed) shadowMap.set(key, entry);
        continue;
      }
      if (isActualEntry(entry, includePaper)) {
        const prev = actualMap.get(key);
        const prevClosed = prev ? getTradeClosedAtMs(prev) || 0 : 0;
        if (!prev || closedAt >= prevClosed) actualMap.set(key, entry);
      }
    }

    const summary: ShadowTradeCompareSummary = {
      matchedCount: 0,
      shadowOnlyCount: 0,
      actualOnlyCount: 0,
      shadowWinRate: null,
      actualWinRate: null,
      shadowNetR: 0,
      actualNetR: 0,
      avgDeltaR: null,
      outcomeMatchRate: null,
      updatedAtMs: Date.now(),
      byRegime: {}
    };

    const pairs: any[] = [];
    let shadowWins = 0;
    let actualWins = 0;
    let deltaSum = 0;
    let deltaCount = 0;
    let outcomeMatches = 0;
    let outcomeTotal = 0;

    for (const [key, shadowEntry] of shadowMap.entries()) {
      const actualEntry = actualMap.get(key);
      if (!actualEntry) continue;
      summary.matchedCount += 1;

      const shadowExit = Number(
        shadowEntry?.shadowExitPrice ?? shadowEntry?.closePrice ?? shadowEntry?.positionClosePrice ?? shadowEntry?.brokerClosePrice
      );
      const actualExit = Number(
        actualEntry?.brokerClosePrice ?? actualEntry?.closePrice ?? actualEntry?.positionClosePrice ?? actualEntry?.shadowExitPrice
      );
      const shadowR = Number.isFinite(Number(shadowEntry?.shadowR))
        ? Number(shadowEntry.shadowR)
        : computeShadowR(shadowEntry, Number.isFinite(shadowExit) ? shadowExit : null);
      const actualR = computeActualR(actualEntry, Number.isFinite(actualExit) ? actualExit : null);

      if (shadowR != null) {
        summary.shadowNetR += shadowR;
        if (shadowR >= 0) shadowWins += 1;
      }
      if (actualR != null) {
        summary.actualNetR += actualR;
        if (actualR >= 0) actualWins += 1;
      }
      if (shadowR != null && actualR != null) {
        deltaSum += actualR - shadowR;
        deltaCount += 1;
        const shadowOutcome = shadowR >= 0 ? 'win' : 'loss';
        const actualOutcome = actualR >= 0 ? 'win' : 'loss';
        outcomeTotal += 1;
        if (shadowOutcome === actualOutcome) outcomeMatches += 1;
      }

      const regimeKey = String(shadowEntry?.shadowRegimeKey || shadowEntry?.regimeKey || actualEntry?.regimeKey || '').trim();
      if (regimeKey) {
        const bucket =
          summary.byRegime?.[regimeKey] || {
            matchedCount: 0,
            shadowWinRate: null,
            actualWinRate: null,
            shadowNetR: 0,
            actualNetR: 0,
            avgDeltaR: null,
            outcomeMatchRate: null
          };
        bucket.matchedCount += 1;
        if (shadowR != null) bucket.shadowNetR += shadowR;
        if (actualR != null) bucket.actualNetR += actualR;
        summary.byRegime = summary.byRegime || {};
        summary.byRegime[regimeKey] = bucket;
      }

      if (opts?.includePairs) {
        pairs.push({
          key,
          symbol: shadowEntry?.symbol ?? actualEntry?.symbol ?? null,
          timeframe: shadowEntry?.setupTimeframe ?? actualEntry?.setupTimeframe ?? null,
          strategy: shadowEntry?.setupStrategy ?? actualEntry?.setupStrategy ?? null,
          setupSignalId: shadowEntry?.setupSignalId ?? actualEntry?.setupSignalId ?? null,
          decisionId: shadowEntry?.decisionId ?? actualEntry?.decisionId ?? null,
          messageId: shadowEntry?.messageId ?? actualEntry?.messageId ?? null,
          shadowId: shadowEntry?.id ?? null,
          actualId: actualEntry?.id ?? null,
          shadowR: shadowR ?? null,
          actualR: actualR ?? null,
          shadowOutcome: shadowR != null ? (shadowR >= 0 ? 'win' : 'loss') : null,
          actualOutcome: actualR != null ? (actualR >= 0 ? 'win' : 'loss') : null,
          regimeKey: regimeKey || null,
          openedAtMs: getTradeOpenedAtMs(shadowEntry) ?? getTradeOpenedAtMs(actualEntry),
          closedAtMs: getTradeClosedAtMs(shadowEntry) ?? getTradeClosedAtMs(actualEntry)
        });
      }
    }

    summary.shadowOnlyCount = Math.max(0, shadowMap.size - summary.matchedCount);
    summary.actualOnlyCount = Math.max(0, actualMap.size - summary.matchedCount);
    summary.shadowWinRate = summary.matchedCount > 0 ? shadowWins / summary.matchedCount : null;
    summary.actualWinRate = summary.matchedCount > 0 ? actualWins / summary.matchedCount : null;
    summary.avgDeltaR = deltaCount > 0 ? deltaSum / deltaCount : null;
    summary.outcomeMatchRate = outcomeTotal > 0 ? outcomeMatches / outcomeTotal : null;

    if (summary.byRegime) {
      for (const [key, bucket] of Object.entries(summary.byRegime)) {
        if (bucket.matchedCount <= 0) continue;
        const matches = pairs.filter((p) => p.regimeKey === key);
        const shadowWinsLocal = matches.filter((p) => p.shadowOutcome === 'win').length;
        const actualWinsLocal = matches.filter((p) => p.actualOutcome === 'win').length;
        const deltaLocal = matches.filter((p) => p.shadowR != null && p.actualR != null);
        const deltaSumLocal = deltaLocal.reduce((acc, p) => acc + (Number(p.actualR) - Number(p.shadowR)), 0);
        const outcomeLocal = matches.filter((p) => p.shadowOutcome && p.actualOutcome);
        const outcomeMatchesLocal = outcomeLocal.filter((p) => p.shadowOutcome === p.actualOutcome).length;
        bucket.shadowWinRate = bucket.matchedCount ? shadowWinsLocal / bucket.matchedCount : null;
        bucket.actualWinRate = bucket.matchedCount ? actualWinsLocal / bucket.matchedCount : null;
        bucket.avgDeltaR = deltaLocal.length ? deltaSumLocal / deltaLocal.length : null;
        bucket.outcomeMatchRate = outcomeLocal.length ? outcomeMatchesLocal / outcomeLocal.length : null;
      }
    }

    return { summary, pairs };
  };

  const syncShadowTradeOutcome = useCallback(async (entry: any) => {
    if (!entry || !isEntryClosed(entry)) return;
    const entryId = entry?.id ? String(entry.id) : '';
    if (!entryId) return;
    const closedAtMs = getTradeClosedAtMs(entry) || Date.now();
    const prevClosedAt = shadowOutcomeSyncedRef.current.get(entryId) || 0;
    if (prevClosedAt && prevClosedAt >= closedAtMs) return;
    shadowOutcomeSyncedRef.current.set(entryId, closedAtMs);

    const outcome = resolveShadowOutcome(entry);
    if (!outcome) return;
    const signalId = entry?.setupSignalId ? String(entry.setupSignalId) : (entry?.signalId ? String(entry.signalId) : '');
    if (!signalId) return;

    const signalEntry = (signalEntriesRef.current || []).find((item) => item.id === signalId) || null;
    const action = String(entry?.action || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
    const entryPrice = Number(entry?.entryPrice ?? entry?.shadowEntryPrice ?? entry?.brokerEntryPrice ?? entry?.plannedEntryPrice);
    const stopLoss = Number(entry?.stopLoss ?? entry?.brokerStopLoss ?? entry?.plannedStopLoss);
    const takeProfit = Number(entry?.takeProfit ?? entry?.brokerTakeProfit ?? entry?.plannedTakeProfit);
    const exitPrice = Number(entry?.shadowExitPrice ?? entry?.closePrice ?? entry?.positionClosePrice ?? entry?.brokerClosePrice);
    const shadowR = Number.isFinite(Number(entry?.shadowR))
      ? Number(entry.shadowR)
      : computeShadowR(entry, Number.isFinite(exitPrice) ? exitPrice : null);

    const baseEntry: SignalEntry = signalEntry || {
      id: signalId,
      symbol: String(entry?.symbol || '').trim(),
      timeframe: entry?.setupTimeframe != null ? String(entry.setupTimeframe) : null,
      action,
      entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
      stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
      takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
      probability: 0,
      strategyMode: entry?.setupMode != null ? String(entry.setupMode) : null,
      reason: entry?.reason != null ? String(entry.reason) : null,
      status: outcome as SignalEntry['status'],
      createdAtMs: Number(entry?.createdAtMs ?? entry?.positionOpenedAtMs ?? Date.now()),
      executedAtMs: Number(entry?.positionOpenedAtMs ?? entry?.createdAtMs ?? Date.now()),
      resolvedAtMs: closedAtMs,
      expiresAtMs: Number.isFinite(Number(entry?.expiresAtMs)) ? Number(entry.expiresAtMs) : null,
      agentId: entry?.agentId ?? null,
      agentName: entry?.agentName ?? null,
      executionSource: null,
      executionBroker: 'shadow',
      executionMode: 'shadow',
      executionLedgerId: entryId,
      shadowLedgerId: entryId,
      executionOrderId: null,
      executionPositionId: null,
      executionOrderStatus: null,
      runId: entry?.runId ?? null,
      newsSnapshot: null
    };

    const score =
      outcome === 'WIN' || outcome === 'LOSS'
        ? (Number.isFinite(Number(shadowR)) ? Number(shadowR) : computeSignalOutcomeScore(baseEntry, outcome))
        : null;
    const startAtMs = baseEntry.executedAtMs ?? baseEntry.createdAtMs ?? null;
    const durationMs =
      Number.isFinite(Number(startAtMs)) && Number.isFinite(Number(closedAtMs))
        ? Math.max(0, Number(closedAtMs) - Number(startAtMs))
        : null;

    await upsertSignalHistory(baseEntry, {
      status: outcome,
      outcome,
      resolvedAtMs: closedAtMs,
      exitPrice: Number.isFinite(exitPrice) ? exitPrice : null,
      score: score != null ? score : null,
      durationMs,
      ledgerId: entryId,
      executionBroker: 'shadow',
      executionMode: 'shadow'
    });

    if (outcome === 'WIN' || outcome === 'LOSS') {
      void upsertSignalReview(baseEntry, {
        outcome,
        score: score != null ? score : undefined,
        exitPrice: Number.isFinite(exitPrice) ? exitPrice : null,
        resolvedAtMs: closedAtMs,
        durationMs,
        barsToOutcome: null
      });
    }

    const academyPayload = await upsertAcademyCase({
      entry: { ...baseEntry, executionBroker: 'shadow', executionMode: 'shadow' },
      patch: {
        status: outcome,
        outcome,
        score: score != null ? score : null,
        exitPrice: Number.isFinite(exitPrice) ? exitPrice : null,
        resolvedAtMs: closedAtMs,
        durationMs,
        ledgerId: entryId,
        executionBroker: 'shadow',
        executionMode: 'shadow'
      },
      brokerSnapshot: buildAcademyBrokerSnapshot(baseEntry.symbol),
      event: {
        type: outcome === 'EXPIRED' ? 'signal_expired' : 'signal_outcome',
        payload: { signalId, outcome, score }
      },
      source: 'shadow_follow'
    });

    if (academyPayload && (outcome === 'WIN' || outcome === 'LOSS')) {
      void maybeAutoAcceptAcademyCase(academyPayload);
    }
  }, [buildAcademyBrokerSnapshot, computeSignalOutcomeScore, maybeAutoAcceptAcademyCase, resolveShadowOutcome, upsertAcademyCase, upsertSignalHistory, upsertSignalReview]);

  const refreshShadowTrades = useCallback(async (opts?: { force?: boolean; includeCompare?: boolean; includePaper?: boolean }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list) return { ok: false, error: 'Trade ledger unavailable.' };
    const now = Date.now();
    if (!opts?.force && now - shadowTradePollAtRef.current < 4_000) {
      return { ok: true, skipped: true };
    }
    shadowTradePollAtRef.current = now;
    const res = await ledger.list({ limit: 2000 });
    if (!res?.ok || !Array.isArray(res.entries)) return { ok: false, error: res?.error || 'Failed to load ledger.' };
    shadowLedgerCacheRef.current = { atMs: now, entries: res.entries };
    const shadowEntries = res.entries.filter((entry: any) => entry?.kind === 'trade' && isShadowEntry(entry));
    const openEntries = shadowEntries.filter((entry: any) => !isEntryClosed(entry));
    const openMap = new Map<string, any>();
    for (const entry of openEntries) {
      if (!entry?.id) continue;
      openMap.set(String(entry.id), entry);
    }
    shadowOpenTradesRef.current = openMap;
    const stats = buildShadowTradeStats(shadowEntries);
    shadowTradeStatsRef.current = stats;
    setShadowTradeStats(stats);
    const views = buildShadowTradeViews(res.entries);
    shadowTradeViewsRef.current = views;
    setShadowTradeViews(views);
    const accounts = buildShadowAccounts(shadowEntries);
    shadowAccountsRef.current = accounts;
    setShadowAccounts(accounts);
    const shouldCompare = opts?.includeCompare === true || opts?.force === true || now - shadowTradeCompareAtRef.current > 15_000;
    if (shouldCompare) {
      const compare = buildShadowTradeCompare(res.entries, { includePairs: false, includePaper: opts?.includePaper === true });
      shadowTradeCompareRef.current = compare.summary;
      shadowTradeCompareAtRef.current = now;
      setShadowTradeCompare(compare.summary);
    }
    for (const entry of shadowEntries) {
      if (!isEntryClosed(entry)) continue;
      void syncShadowTradeOutcome(entry);
    }
    return { ok: true, openEntries, stats, entries: res.entries };
  }, [buildShadowAccounts, buildShadowTradeCompare, buildShadowTradeStats, buildShadowTradeViews, syncShadowTradeOutcome]);

  useEffect(() => {
    void refreshShadowTrades({ force: true });
  }, [refreshShadowTrades]);

  useEffect(() => {
    const cached = shadowLedgerCacheRef.current?.entries;
    if (!Array.isArray(cached) || cached.length === 0) return;
    const shadowEntries = cached.filter((entry: any) => entry?.kind === 'trade' && isShadowEntry(entry));
    const accounts = buildShadowAccounts(shadowEntries);
    shadowAccountsRef.current = accounts;
    setShadowAccounts(accounts);
  }, [buildShadowAccounts, mt5AccountSpec, shadowProfiles]);

  const evaluateShadowTrades = useCallback(async () => {
    const autoCfg = autoPilotConfigRef.current;
    const executionMode = normalizeExecutionMode(autoCfg?.executionMode) || 'live';
    const shouldPoll = executionMode === 'shadow' || shadowOpenTradesRef.current.size > 0;
    if (!shouldPoll) return;

    const snapshot = await refreshShadowTrades();
    if (!snapshot?.ok) return;
    const openEntries = Array.isArray(snapshot.openEntries) ? snapshot.openEntries : [];
    if (openEntries.length === 0) return;

    const ledger = window.glass?.tradeLedger;
    if (!ledger?.update) return;

    let updated = false;
    for (const entry of openEntries) {
      const entryId = entry?.id ? String(entry.id) : '';
      if (!entryId) continue;
      const symbol = String(entry?.symbol || '').trim();
      if (!symbol) continue;

      const quoteRes = await fetchBrokerQuoteForSymbol(symbol, { maxAgeMs: 20_000 });
      const quote = quoteRes.quote;
      const bid = Number(quote?.bid ?? quote?.bidPrice);
      const ask = Number(quote?.ask ?? quote?.askPrice);
      let refPrice = Number(getBrokerReferencePriceFromQuote(quote));
      if (!Number.isFinite(refPrice)) refPrice = Number(quote?.price ?? quote?.mid);

      const side = String(entry?.action || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
      const stopLoss = Number(entry?.stopLoss ?? entry?.brokerStopLoss ?? entry?.plannedStopLoss);
      const takeProfit = Number(entry?.takeProfit ?? entry?.brokerTakeProfit ?? entry?.plannedTakeProfit);
      const exitRef = side === 'BUY'
        ? (Number.isFinite(bid) ? bid : refPrice)
        : (Number.isFinite(ask) ? ask : refPrice);
      if (!Number.isFinite(exitRef)) continue;

      const expiresAtMs = Number(entry?.expiresAtMs ?? 0);
      if (Number.isFinite(expiresAtMs) && expiresAtMs > 0 && Date.now() >= expiresAtMs) {
        const patch: any = {
          status: 'CLOSED',
          positionStatus: 'CLOSED',
          positionClosedAtMs: Date.now(),
          shadowExitPrice: exitRef,
          shadowExitReason: 'EXPIRED',
          shadowR: 0,
          executionMode: 'shadow',
          broker: 'shadow'
        };
        await ledger.update({ id: entryId, patch });
        updated = true;
        void appendAuditEvent({
          eventType: 'shadow_trade_closed',
          symbol,
          runId: entry?.runId ?? null,
          decisionId: entry?.decisionId ?? null,
          executionId: entry?.executionId ?? entryId,
          payload: {
            entryId,
            exitPrice: exitRef,
            outcome: patch.shadowExitReason,
            shadowR: 0,
            quote,
            side
          }
        });
        void syncShadowTradeOutcome({ ...entry, ...patch });
        continue;
      }

      let hit: 'tp' | 'sl' | null = null;
      if (side === 'BUY') {
        if (Number.isFinite(stopLoss) && exitRef <= stopLoss) hit = 'sl';
        if (hit == null && Number.isFinite(takeProfit) && exitRef >= takeProfit) hit = 'tp';
      } else {
        if (Number.isFinite(stopLoss) && exitRef >= stopLoss) hit = 'sl';
        if (hit == null && Number.isFinite(takeProfit) && exitRef <= takeProfit) hit = 'tp';
      }

      if (!hit) continue;

      const shadowR = computeShadowR(entry, exitRef);
      const patch: any = {
        status: 'CLOSED',
        positionStatus: 'CLOSED',
        positionClosedAtMs: Date.now(),
        shadowExitPrice: exitRef,
        shadowExitReason: hit === 'tp' ? 'TP' : 'SL',
        shadowR: shadowR != null ? shadowR : undefined,
        executionMode: 'shadow',
        broker: 'shadow'
      };
      await ledger.update({ id: entryId, patch });
      updated = true;

      void appendAuditEvent({
        eventType: 'shadow_trade_closed',
        symbol,
        runId: entry?.runId ?? null,
        decisionId: entry?.decisionId ?? null,
        executionId: entry?.executionId ?? entryId,
        payload: {
          entryId,
          exitPrice: exitRef,
          outcome: patch.shadowExitReason,
          shadowR,
          quote,
          side
        }
      });
      void syncShadowTradeOutcome({ ...entry, ...patch });
    }

    if (updated) {
      await refreshShadowTrades({ force: true });
    }
  }, [appendAuditEvent, fetchBrokerQuoteForSymbol, getBrokerReferencePriceFromQuote, normalizeExecutionMode, refreshShadowTrades, syncShadowTradeOutcome]);

  useEffect(() => {
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadShadowControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createShadowController({
        intervalMs: 5_000,
        tick: async () => {
          await evaluateShadowTrades();
          await Promise.resolve(maybeExecutePendingLiveSignalsRef.current?.());
        }
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [evaluateShadowTrades]);

  const buildAutoPilotStateSnapshot = useCallback((opts?: { now?: number }) => {
    const now = Number.isFinite(Number(opts?.now)) ? Number(opts?.now) : Date.now();
    const config = autoPilotConfigRef.current || {};
    const tlMeta = tradeLockerExecRef.current || {};
    const marketHealth = marketDataRef.current.getHealth();
    const watchers = setupWatchersRef.current || [];
    const enabledCount = watchers.filter((w) => w && w.enabled !== false).length;
    return evaluateAutoPilotState({
      enabled: !!config.enabled,
      killSwitch: !!config.killSwitch,
      brokerConnected: !!tlMeta.connected,
      brokerTradingEnabled: !!tlMeta.tradingEnabled,
      brokerAutoPilotEnabled: tlMeta.autoPilotEnabled ?? null,
      streamStatus: marketHealth.streamStatus ?? tlMeta.streamStatus ?? null,
      streamUpdatedAtMs: marketHealth.streamUpdatedAtMs ?? tlMeta.streamUpdatedAtMs ?? null,
      quotesUpdatedAtMs: marketHealth.quotesUpdatedAtMs ?? tlMeta.quotesUpdatedAtMs ?? null,
      watchersEnabledCount: enabledCount,
      now
    });
  }, []);

  const updateAutoPilotState = useCallback((opts?: { now?: number; emit?: boolean }) => {
    const next = buildAutoPilotStateSnapshot({ now: opts?.now });
    const merged = mergeAutoPilotState(autoPilotStateRef.current, next);
    const prev = autoPilotStateRef.current;
    autoPilotStateRef.current = merged;
    const changed =
      !prev ||
      prev.state !== merged.state ||
      prev.reason !== merged.reason ||
      String(prev.message || '') !== String(merged.message || '');
    if (changed && opts?.emit !== false) {
      void appendAuditEvent({
        eventType: 'autopilot_state_changed',
        level: merged.state === 'FAULTED' ? 'error' : merged.state === 'PAUSED' ? 'warn' : 'info',
        payload: {
          state: merged.state,
          reason: merged.reason || null,
          message: merged.message || null,
          updatedAtMs: merged.updatedAtMs
        }
      });
    }
    return merged;
  }, [appendAuditEvent, buildAutoPilotStateSnapshot]);

  const parseTimeToMinutes = useCallback((value: string) => {
    const raw = String(value || '').trim();
    const [hRaw, mRaw] = raw.split(':');
    const h = Number(hRaw);
    const m = Number(mRaw);
    if (!Number.isFinite(h) || !Number.isFinite(m)) return null;
    return Math.min(23, Math.max(0, Math.floor(h))) * 60 + Math.min(59, Math.max(0, Math.floor(m)));
  }, []);

  const getTimePartsInZone = useCallback((timeZone: string) => {
    try {
      const fmt = new Intl.DateTimeFormat('en-US', {
        timeZone,
        weekday: 'short',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
      const parts = fmt.formatToParts(new Date());
      const lookup: Record<string, string> = {};
      for (const part of parts) {
        lookup[part.type] = part.value;
      }
      const weekday = lookup.weekday || '';
      const hour = Number(lookup.hour);
      const minute = Number(lookup.minute);
      const dayMap: Record<string, number> = {
        Sun: 0,
        Mon: 1,
        Tue: 2,
        Wed: 3,
        Thu: 4,
        Fri: 5,
        Sat: 6
      };
      const day = dayMap[weekday] ?? new Date().getDay();
      return {
        day,
        minutes: Number.isFinite(hour) && Number.isFinite(minute) ? hour * 60 + minute : null
      };
    } catch {
      const now = new Date();
      return { day: now.getDay(), minutes: now.getHours() * 60 + now.getMinutes() };
    }
  }, []);

  const ruleMatchesTime = useCallback((rule: CalendarRule) => {
    const days = Array.isArray(rule.daysOfWeek) && rule.daysOfWeek.length > 0 ? rule.daysOfWeek : [0, 1, 2, 3, 4, 5, 6];
    const timeParts = getTimePartsInZone(rule.timezone || 'UTC');
    if (!days.includes(timeParts.day)) return false;
    const startMin = parseTimeToMinutes(rule.startTimeLocal);
    const endMin = parseTimeToMinutes(rule.endTimeLocal);
    if (startMin == null || endMin == null || timeParts.minutes == null) return false;
    if (startMin === endMin) return true;
    if (startMin < endMin) {
      return timeParts.minutes >= startMin && timeParts.minutes < endMin;
    }
    // crosses midnight
    return timeParts.minutes >= startMin || timeParts.minutes < endMin;
  }, [getTimePartsInZone, parseTimeToMinutes]);

  const ruleAppliesToTarget = useCallback((rule: CalendarRule, target: { symbol?: string | null; broker?: string | null; agentId?: string | null }) => {
    const applies = rule.appliesTo || {};
    const symbol = String(target.symbol || '').trim().toLowerCase();
    const broker = String(target.broker || '').trim().toLowerCase();
    const agentId = String(target.agentId || '').trim().toLowerCase();
    if (Array.isArray(applies.symbols) && applies.symbols.length > 0) {
      const allowed = applies.symbols.map((s) => String(s || '').trim().toLowerCase()).filter(Boolean);
      if (symbol && !allowed.includes(symbol)) return false;
    }
    if (Array.isArray(applies.brokers) && applies.brokers.length > 0) {
      const allowed = applies.brokers.map((s) => String(s || '').trim().toLowerCase()).filter(Boolean);
      if (broker && !allowed.includes(broker)) return false;
    }
    if (Array.isArray(applies.agents) && applies.agents.length > 0) {
      const allowed = applies.agents.map((s) => String(s || '').trim().toLowerCase()).filter(Boolean);
      if (agentId && !allowed.includes(agentId)) return false;
    }
    return true;
  }, []);

  const evaluateCalendarRules = useCallback((input: { symbol?: string | null; broker?: string | null; agentId?: string | null }) => {
    const rules = calendarRulesRef.current || [];
    if (rules.length === 0) return { ok: true as const };
    const enabledRules = rules.filter((rule) => rule.enabled !== false && ruleAppliesToTarget(rule, input));
    if (enabledRules.length === 0) return { ok: true as const };

    const matchingBlackout = enabledRules.find((rule) => rule.type === 'blackout' && ruleMatchesTime(rule));
    if (matchingBlackout) {
      return {
        ok: false as const,
        reason: `Calendar blackout: ${matchingBlackout.title}`,
        rule: matchingBlackout,
        blockType: 'blackout'
      };
    }

    const windows = enabledRules.filter((rule) => rule.type === 'auto_window');
    if (windows.length > 0) {
      const inWindow = windows.some((rule) => ruleMatchesTime(rule));
      if (!inWindow) {
        return {
          ok: false as const,
          reason: 'Outside allowed auto window.',
          rule: windows[0],
          blockType: 'window'
        };
      }
    }

    return { ok: true as const };
  }, [ruleAppliesToTarget, ruleMatchesTime]);

  const runPreTradeRiskGate = useCallback(async (input: {
    source: 'manual' | 'autopilot';
    broker: 'tradelocker' | 'sim' | 'shadow';
    guardrailsActive: boolean;
    effectiveAutoCfg: any;
    accountKey: string;
    openPositionsCount: number;
    equityNow: number | null;
    symbol: string;
    appendTradeAudit: (eventType: string, extra?: Record<string, any>, level?: 'info' | 'warn' | 'error', symbolOverride?: string | null) => void;
  }) => {
    const {
      source,
      broker,
      guardrailsActive,
      effectiveAutoCfg,
      accountKey,
      openPositionsCount,
      equityNow,
      symbol,
      appendTradeAudit
    } = input;

    const autoState = source === 'autopilot' ? updateAutoPilotState({ emit: true }) : null;

    if (source === 'autopilot' && String(effectiveAutoCfg?.mode || '') === 'swing') {
      const risk = Number(effectiveAutoCfg?.riskPerTrade);
      const maxOpen = Number(effectiveAutoCfg?.maxOpenPositions);
      if (Number.isFinite(risk) && risk >= 0.5 && Number.isFinite(maxOpen) && maxOpen > 3) {
        const msg = 'Swing mode 0.50% risk requires a low max-open-positions setting.';
        addNotification('AutoPilot Blocked', msg, 'warning');
        appendTradeAudit('trade_blocked', { reason: msg, broker, block: 'swing_risk_requires_low_positions' }, 'warn', symbol);
        return { ok: false as const, error: msg };
      }
    }

    let recentOrdersCount: number | null = null;
    let dailyPnl: number | null = null;
    let lossStreak: number | null = null;
    let symbolAllowed: boolean | null = null;

    if (guardrailsActive) {
      const maxOrdersPerMinute = Number(effectiveAutoCfg?.maxOrdersPerMinute);
      if (Number.isFinite(maxOrdersPerMinute) && maxOrdersPerMinute > 0) {
        try {
          const ledger = window.glass?.tradeLedger;
          if (ledger?.list) {
            const res = await ledger.list({ limit: 200 });
            if (res?.ok && Array.isArray(res.entries)) {
              const cutoff = Date.now() - 60_000;
              const recent = res.entries.filter((entry: any) => {
                if (!entry || entry.kind !== 'trade') return false;
                const createdAt = Number(entry.createdAtMs) || 0;
                if (createdAt < cutoff) return false;
                if (entry.status && String(entry.status).toUpperCase() === 'REJECTED') return false;
                return true;
              });
              recentOrdersCount = recent.length;
            }
          }
        } catch {
          // ignore ledger failures
        }
      }

      const maxDailyLoss = Number(effectiveAutoCfg?.maxDailyLoss);
      if (Number.isFinite(maxDailyLoss) && maxDailyLoss > 0 && Number.isFinite(Number(equityNow)) && Number(equityNow) > 0) {
        const dateKey = getLocalDateKey();
        const storageKey = getDailyBaselineStorageKey(accountKey, dateKey);
        const baseline = readLocalJson(storageKey);
        const equityStart = baseline && Number.isFinite(Number(baseline.equityStart)) ? Number(baseline.equityStart) : null;
        const ensuredStart = equityStart != null ? equityStart : Number(equityNow);
        if (equityStart == null) {
          writeLocalJson(storageKey, { equityStart: ensuredStart, createdAtMs: Date.now() });
        }
        dailyPnl = Number(equityNow) - ensuredStart;
      }

      const maxLossStreak = Number(effectiveAutoCfg?.maxConsecutiveLosses);
      if (Number.isFinite(maxLossStreak) && maxLossStreak > 0) {
        const streakState = readLocalJson(getLossStreakStorageKey(accountKey));
        lossStreak = streakState && Number.isFinite(Number(streakState.streak)) ? Number(streakState.streak) : 0;
      }

      const allowlist = parseSymbolAllowlistRaw(effectiveAutoCfg?.symbolAllowlistRaw);
      if (allowlist.size > 0) {
        const variants = buildSymbolKeyVariants(symbol);
        symbolAllowed = variants.some((key) => allowlist.has(key));
      }
    }

    const decision = evaluateRiskGate({
      source,
      guardrailsActive,
      autoPilotState: autoState,
      maxOrdersPerMinute: Number(effectiveAutoCfg?.maxOrdersPerMinute),
      recentOrdersCount,
      maxOpenPositions: broker === 'tradelocker' ? Number(effectiveAutoCfg?.maxOpenPositions) : null,
      openPositionsCount,
      maxDailyLoss: Number(effectiveAutoCfg?.maxDailyLoss),
      dailyPnl,
      maxConsecutiveLosses: Number(effectiveAutoCfg?.maxConsecutiveLosses),
      lossStreak,
      symbolAllowed
    });

    if (!decision.ok) {
      const msg = decision.message || 'AutoPilot is not ready to trade.';
      addNotification('AutoPilot Blocked', msg, 'warning');
      appendTradeAudit(
        'trade_blocked',
        {
          reason: msg,
          broker,
          block: decision.reasonCode || 'risk_gate',
          autoPilotState: autoState?.state || null,
          autoPilotReason: autoState?.reason || null
        },
        'warn',
        symbol
      );
      return { ok: false as const, error: msg, code: decision.reasonCode || undefined };
    }

    return { ok: true as const };
  }, [addNotification, updateAutoPilotState]);

  const executeTradeRequestDirect = useCallback(async (
      proposal: TradeProposal,
      source: 'manual' | 'autopilot',
      opts?: {
        forceBroker?: 'sim' | 'tradelocker';
        executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
        runId?: string;
        autoConfigOverride?: Record<string, any> | null;
      }
    ) => {
      const tlMeta = tradeLockerExecRef.current;
      const autoCfg = autoPilotConfigRef.current || {};
      const mergedCfg = opts?.autoConfigOverride ? { ...autoCfg, ...opts.autoConfigOverride } : autoCfg;
      const { effective: effectiveAutoCfg } = resolveAutoPilotPolicy(mergedCfg);
      const forceBroker = opts?.forceBroker;
      const executionMode =
        normalizeExecutionMode(opts?.executionMode) ||
        (source === 'autopilot' ? normalizeExecutionMode(mergedCfg?.executionMode) : null) ||
        (forceBroker === 'sim' ? 'paper' : 'live');
      const shadowMode = executionMode === 'shadow';
      const messageId = proposal.messageId ? String(proposal.messageId).trim() : '';
      const guardrailsActive = !!effectiveAutoCfg?.enabled;
      const decisionId = messageId || `dec_${Date.now()}_${Math.random().toString(16).slice(2, 6)}`;
      const runId = opts?.runId ? String(opts.runId).trim() : null;
      const appendTradeAudit = (eventType: string, extra?: Record<string, any>, level: 'info' | 'warn' | 'error' = 'info', symbolOverride?: string | null) => {
        const symbol = symbolOverride || proposal.symbol || '';
        const brokerResponseId = extra?.orderId || extra?.positionId || null;
        const executionId = extra?.executionId || extra?.ledgerId || null;
        void appendAuditEvent({
          eventType,
          level,
          symbol,
          runId: runId || null,
          decisionId,
          executionId,
          brokerResponseId,
          payload: {
            source,
            executionMode: executionMode || null,
            messageId: messageId || null,
            agentId: proposal.agentId || null,
            ...extra
          }
        });
      };
      appendTradeAudit('trade_request');

    const validationError = validateTradeProposalBasic(proposal);
    if (validationError) {
      addNotification('Invalid Trade', validationError, 'error');
      appendTradeAudit('trade_validation_failed', { error: validationError }, 'error');
      return { ok: false as const, error: validationError };
    }

    const calendarBroker = executionMode === 'shadow'
      ? 'shadow'
      : forceBroker === 'sim'
        ? 'sim'
        : forceBroker === 'tradelocker'
          ? 'tradelocker'
          : 'tradelocker';
    if (source === 'autopilot' || executionMode === 'shadow') {
      const gate = evaluateCalendarRules({
        symbol: proposal.symbol || null,
        broker: calendarBroker,
        agentId: proposal.agentId || null
      });
      if (!gate.ok) {
        const msg = gate.reason || 'Calendar rule blocked execution.';
        addNotification('Calendar Blocked', msg, 'warning');
        appendTradeAudit('trade_blocked', { reason: msg, broker: calendarBroker, block: 'calendar', rule: gate.rule?.title || null }, 'warn', proposal.symbol);
        return { ok: false as const, error: msg, code: 'calendar_blocked' };
      }
    }

    const canUseTradeLocker =
      shadowMode
        ? false
        : forceBroker === 'tradelocker'
          ? !!tlMeta?.connected && !!tlMeta?.tradingEnabled && !!window.glass?.tradelocker?.placeOrder
          : forceBroker === 'sim'
            ? false
            : !!tlMeta?.connected &&
              !!tlMeta?.tradingEnabled &&
              (source !== 'autopilot' || !!tlMeta?.autoPilotEnabled) &&
              !!window.glass?.tradelocker?.placeOrder;

    if (forceBroker === 'tradelocker' && !canUseTradeLocker) {
      const msg = 'TradeLocker is unavailable for live execution.';
      addNotification('TradeLocker Blocked', msg, 'warning');
      appendTradeAudit('trade_blocked', { reason: msg, broker: 'tradelocker', block: 'broker_unavailable' }, 'warn');
      return { ok: false as const, error: msg, broker: 'tradelocker' as const };
    }

    if (source === 'autopilot' && canUseTradeLocker && tlMeta?.connected && tlMeta?.tradingEnabled && !tlMeta?.autoPilotEnabled) {
      const msg = 'TradeLocker AutoPilot execution is disabled in Settings.';
      addNotification('AutoPilot Blocked', msg, 'warning');
      appendTradeAudit('trade_blocked', { reason: msg, broker: 'tradelocker', block: 'autopilot_disabled' }, 'warn');
      return { ok: false as const, error: msg, broker: 'tradelocker' as const };
    }

    const broker = shadowMode ? 'shadow' : forceBroker === 'tradelocker' ? 'tradelocker' : forceBroker === 'sim' ? 'sim' : (canUseTradeLocker ? 'tradelocker' : 'sim');
    const accountKey =
      broker === 'tradelocker'
        ? (resolveSnapshotSourceKey() || `${String(tlMeta?.env || '')}:${String(tlMeta?.server || '')}:${String(tlMeta?.accountId || '')}:${String(tlMeta?.accNum || '')}`)
        : broker === 'shadow' ? 'shadow' : 'sim';

    const simOpenPositions = Array.isArray(simPositions)
      ? simPositions.filter((p) => p && String(p.status || '').toUpperCase() === 'OPEN')
      : [];
    const openPositionsCount =
      broker === 'shadow'
        ? shadowOpenTradesRef.current.size
        : broker === 'tradelocker' && Number.isFinite(Number(tlMeta?.openPositionsCount))
          ? Number(tlMeta.openPositionsCount)
          : simOpenPositions.length;

    const configuredLots = Number(effectiveAutoCfg?.lotSize);
    const fallbackLots =
      broker === 'tradelocker' && Number.isFinite(Number(tlMeta?.defaultOrderQty)) ? Number(tlMeta.defaultOrderQty) : undefined;
    const defaultQty =
      Number.isFinite(configuredLots) && configuredLots > 0 ? configuredLots : fallbackLots;
    const orderTypeRaw =
      broker === 'tradelocker' ? String(tlMeta?.defaultOrderType || 'market').toLowerCase() : 'market';
    let orderType = orderTypeRaw === 'limit' ? 'limit' : orderTypeRaw === 'stop' ? 'stop' : 'market';
    let isMarketOrder = orderType === 'market';

    // Best-effort: map TradingView-style symbols (e.g. "OANDA:XAUUSD") to the broker's TradeLocker instrument symbol (e.g. "XAUUSD.R").
    const effectiveSymbol =
      broker === 'tradelocker'
        ? await resolveTradeLockerSymbolBestEffort(proposal.symbol)
        : proposal.symbol;
    const effectiveProposal = effectiveSymbol === proposal.symbol ? proposal : { ...proposal, symbol: effectiveSymbol };

    const equityNow = broker === 'tradelocker' ? Number(tlMeta?.equity) : Number(simEquity);
    const gate = await runPreTradeRiskGate({
      source,
      broker,
      guardrailsActive,
      effectiveAutoCfg,
      accountKey,
      openPositionsCount,
      equityNow: Number.isFinite(equityNow) ? equityNow : null,
      symbol: effectiveProposal.symbol,
      appendTradeAudit
    });
    if (!gate.ok) {
      return { ok: false as const, error: gate.error, broker };
    }

    let brokerQuote: any = null;
    let brokerQuoteAgeMs: number | null = null;
    if (broker === 'tradelocker' || broker === 'shadow' || (broker === 'sim' && tlMeta?.connected)) {
      const quoteRes = await fetchBrokerQuoteForSymbol(effectiveProposal.symbol, { maxAgeMs: 30_000 });
      brokerQuote = quoteRes.quote;
      brokerQuoteAgeMs = quoteRes.quoteAgeMs ?? null;
      if (!brokerQuote && broker === 'tradelocker') {
        try {
          const exec = tradeLockerExecRef.current;
          if (exec?.refreshQuotes) {
            await exec.refreshQuotes({ symbols: [effectiveProposal.symbol], maxAgeMs: 0 });
          }
          const retry = getBrokerQuoteForSymbol(effectiveProposal.symbol);
          if (retry) {
            brokerQuote = retry;
            const ts = Number(retry?.fetchedAtMs ?? retry?.timestampMs ?? 0);
            brokerQuoteAgeMs = ts > 0 ? Date.now() - ts : null;
          }
        } catch {
          // ignore quote retry failures
        }
      }
    }

    const brokerRef = getBrokerReferencePriceFromQuote(brokerQuote);
    const signalSetupMeta = proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
    const isSignalPanel = signalSetupMeta?.signalType === 'signal_panel' || signalSetupMeta?.source === 'signal_panel';
    if (broker === 'tradelocker' && isSignalPanel) {
      const entryNum = Number(effectiveProposal.entryPrice);
      const ref = Number(brokerRef);
      if (Number.isFinite(entryNum) && entryNum > 0 && Number.isFinite(ref) && ref > 0) {
        const isBuy = effectiveProposal.action === 'BUY';
        orderType = isBuy
          ? (entryNum > ref ? 'stop' : 'limit')
          : (entryNum < ref ? 'stop' : 'limit');
        isMarketOrder = orderType === 'market';
      }
    }
    const forcedOrderTypeRaw = String((effectiveProposal as any)?.forceOrderType || '').trim().toLowerCase();
    if (forcedOrderTypeRaw === 'market' || forcedOrderTypeRaw === 'limit' || forcedOrderTypeRaw === 'stop') {
      orderType = forcedOrderTypeRaw as typeof orderType;
      isMarketOrder = orderType === 'market';
    }
    const executionEntry =
      isMarketOrder && Number.isFinite(Number(brokerRef))
        ? Number(brokerRef)
        : effectiveProposal.entryPrice;
    let executionStopLoss = effectiveProposal.stopLoss;
    let executionTakeProfit = effectiveProposal.takeProfit;
    let executionAdjusted = false;

    if (isMarketOrder && Number.isFinite(Number(executionEntry))) {
      const isBuy = effectiveProposal.action === 'BUY';
      const slNum = Number(executionStopLoss);
      const tpNum = Number(executionTakeProfit);
      const slValid = Number.isFinite(slNum) && (isBuy ? slNum < Number(executionEntry) : slNum > Number(executionEntry));
      const tpValid = Number.isFinite(tpNum) && (isBuy ? tpNum > Number(executionEntry) : tpNum < Number(executionEntry));

      if (!slValid || !tpValid) {
        const rrRaw = Number(effectiveAutoCfg?.defaultRR);
        const rr = Number.isFinite(rrRaw) && rrRaw > 0 ? rrRaw : 2;
        const stopModel = String(effectiveAutoCfg?.stopModel || 'percent').toLowerCase();
        let distance: number | null = null;
        let modelUsed = '';
        if (stopModel === 'atr') {
          const atrRes = await getAtr14Cached(effectiveProposal.symbol);
          const atrMultRaw = Number(effectiveAutoCfg?.stopAtrMult);
          const atrMult = Number.isFinite(atrMultRaw) && atrMultRaw > 0 ? atrMultRaw : 1;
          if (atrRes.ok && Number.isFinite(atrRes.atr) && atrRes.atr > 0) {
            distance = atrRes.atr * atrMult;
            modelUsed = 'atr';
          }
        }
        if (!distance || !Number.isFinite(distance) || distance <= 0) {
          const pctRaw = Number(effectiveAutoCfg?.stopPercent);
          const pct = Number.isFinite(pctRaw) && pctRaw > 0 ? pctRaw : 0.2;
          distance = Number(executionEntry) * (pct / 100);
          modelUsed = 'percent';
        }
        if (Number.isFinite(distance) && distance > 0) {
          executionStopLoss = isBuy ? Number(executionEntry) - distance : Number(executionEntry) + distance;
          executionTakeProfit = isBuy ? Number(executionEntry) + distance * rr : Number(executionEntry) - distance * rr;
          executionAdjusted = true;
          addNotification('Auto SL/TP', `Adjusted ${effectiveProposal.symbol} using ${modelUsed.toUpperCase()} stops.`, 'info');
          appendTradeAudit(
            'trade_adjusted',
            {
              reason: 'Auto-fix invalid SL/TP vs broker price',
              model: modelUsed,
              rr,
              entryPrice: executionEntry,
              stopLoss: executionStopLoss,
              takeProfit: executionTakeProfit
            },
            'info',
            effectiveProposal.symbol
          );
        }
      }
    }

    const executionProposal =
      executionEntry !== effectiveProposal.entryPrice || executionAdjusted
        ? { ...effectiveProposal, entryPrice: executionEntry, stopLoss: executionStopLoss, takeProfit: executionTakeProfit }
        : effectiveProposal;

    if (broker === 'tradelocker' || (broker === 'sim' && tlMeta?.connected)) {
      const referencePrice =
        isMarketOrder
          ? (Number.isFinite(Number(brokerRef)) ? brokerRef : executionProposal.entryPrice)
          : executionProposal.entryPrice;
      const check = await validateBrokerStopLevels({
        symbol: executionProposal.symbol,
        side: executionProposal.action,
        stopLoss: executionProposal.stopLoss,
        takeProfit: executionProposal.takeProfit,
        referencePrice
      });
      if (!check.ok) {
        const msg = check.error || 'Broker constraints blocked this order.';
        addNotification('TradeLocker Blocked', msg, 'error');
        appendTradeAudit(
          'trade_constraints_blocked',
          { reason: msg, broker, symbol: executionProposal.symbol },
          'error',
          executionProposal.symbol
        );
        return { ok: false as const, error: msg, broker };
      }
      if (check.warning) {
        addNotification('Broker Constraints', check.warning, 'warning');
      }
    }

    if (guardrailsActive && (broker === 'tradelocker' || (broker === 'sim' && tlMeta?.connected))) {
      const spreadModel = String(effectiveAutoCfg?.spreadLimitModel || 'none').toLowerCase();
      if (spreadModel !== 'none') {
        const quote = brokerQuote;
        const bid = Number(quote?.bid);
        const ask = Number(quote?.ask);
        const spreadValueRaw = Number(quote?.spread);
        const spreadValue =
          Number.isFinite(spreadValueRaw)
            ? spreadValueRaw
            : Number.isFinite(bid) && Number.isFinite(ask)
              ? ask - bid
              : Number.NaN;
        const referencePrice = getBrokerReferencePriceFromQuote(quote);
        const quoteTs = Number(quote?.fetchedAtMs ?? quote?.timestampMs ?? 0);
        const quoteAgeMs = brokerQuoteAgeMs ?? (quoteTs > 0 ? Date.now() - quoteTs : null);
        const quoteStale = quoteAgeMs == null || quoteAgeMs > 30_000;

        if (!Number.isFinite(spreadValue) || !Number.isFinite(referencePrice) || quoteStale) {
          const msg = 'Spread guardrail blocked: broker quote unavailable or stale.';
          addNotification('AutoPilot Blocked', msg, 'warning');
          appendTradeAudit(
            'trade_blocked',
            { reason: msg, broker, block: 'spread_guardrail', quoteAgeMs: quoteAgeMs ?? null },
            'warn',
            effectiveProposal.symbol
          );
          return { ok: false as const, error: msg, broker };
        }

        if (spreadModel === 'percent') {
          const limitPct = Number(effectiveAutoCfg?.spreadLimitPct);
          if (Number.isFinite(limitPct) && limitPct > 0) {
            const spreadPct = (spreadValue / referencePrice) * 100;
            if (Number.isFinite(spreadPct) && spreadPct > limitPct) {
              const msg = `Spread too wide (${spreadPct.toFixed(3)}% > ${limitPct}%).`;
              addNotification('AutoPilot Blocked', msg, 'warning');
              appendTradeAudit(
                'trade_blocked',
                { reason: msg, broker, block: 'spread_limit_pct', spreadPct, limitPct },
                'warn',
                effectiveProposal.symbol
              );
              return { ok: false as const, error: msg, broker };
            }
          }
        }

        if (spreadModel === 'atr') {
          const atrMult = Number(effectiveAutoCfg?.spreadLimitAtrMult);
          if (Number.isFinite(atrMult) && atrMult > 0) {
            const atrRes = await getAtr14Cached(effectiveProposal.symbol);
            if (!atrRes.ok || !Number.isFinite(atrRes.atr)) {
              const msg = atrRes?.error ? String(atrRes.error) : 'ATR unavailable for spread guardrail.';
              addNotification('AutoPilot Blocked', msg, 'warning');
              appendTradeAudit(
                'trade_blocked',
                { reason: msg, broker, block: 'spread_limit_atr' },
                'warn',
                effectiveProposal.symbol
              );
              return { ok: false as const, error: msg, broker };
            }
            const limit = atrRes.atr * atrMult;
            if (Number.isFinite(limit) && spreadValue > limit) {
              const msg = `Spread too wide (${formatBrokerPrice(spreadValue)} > ${formatBrokerPrice(limit)}).`;
              addNotification('AutoPilot Blocked', msg, 'warning');
              appendTradeAudit(
                'trade_blocked',
                { reason: msg, broker, block: 'spread_limit_atr', atr: atrRes.atr, atrMult },
                'warn',
                effectiveProposal.symbol
              );
              return { ok: false as const, error: msg, broker };
            }
          }
        }
      }
    }

    let groupLotRemaining: number | null = null;
    let groupKey: string | null = null;
    if (guardrailsActive && (broker === 'tradelocker' || broker === 'sim' || broker === 'shadow')) {
      const groupMap = parseSymbolGroupMapRaw(effectiveAutoCfg?.symbolGroupMapRaw);
      const groupCaps = parseGroupCapsRaw(effectiveAutoCfg?.groupCapsRaw);
      if (groupMap.size > 0 && groupCaps.size > 0) {
        const resolveGroup = (symbol: string) => {
          const variants = buildSymbolKeyVariants(symbol);
          for (const key of variants) {
            const group = groupMap.get(key);
            if (group) return group;
          }
          return null;
        };
        const targetGroup = resolveGroup(effectiveProposal.symbol);
        if (targetGroup) {
          groupKey = targetGroup;
          const cap = groupCaps.get(targetGroup);
          const maxPositionsRaw = cap?.maxPositions != null ? Number(cap.maxPositions) : null;
          const maxLotRaw = cap?.maxLot != null ? Number(cap.maxLot) : null;
          const positions = broker === 'tradelocker'
            ? (Array.isArray(tlMeta?.positions) ? tlMeta.positions : [])
            : simOpenPositions;
          const groupPositions = positions.filter((p: any) => resolveGroup(String(p?.symbol || '')) === targetGroup);
          const groupOpenCount = groupPositions.length;
          const groupOpenLot = groupPositions.reduce((acc: number, p: any) => {
            const size = Number(p?.size ?? p?.qty ?? p?.lots ?? 0);
            return acc + (Number.isFinite(size) ? size : 0);
          }, 0);

          if (Number.isFinite(maxPositionsRaw) && maxPositionsRaw != null && maxPositionsRaw > 0 && groupOpenCount >= maxPositionsRaw) {
            const msg = `Group max positions reached (${groupOpenCount}/${maxPositionsRaw}) for ${targetGroup}.`;
            addNotification('AutoPilot Blocked', msg, 'warning');
            appendTradeAudit(
              'trade_blocked',
              { reason: msg, broker, block: 'group_max_positions', group: targetGroup, groupOpenCount, maxPositionsRaw },
              'warn',
              effectiveProposal.symbol
            );
            return { ok: false as const, error: msg, broker };
          }

          if (Number.isFinite(maxLotRaw) && maxLotRaw != null && maxLotRaw > 0) {
            const remaining = maxLotRaw - groupOpenLot;
            if (remaining <= 0) {
              const msg = `Group max lot reached (${groupOpenLot.toFixed(2)}/${maxLotRaw.toFixed(2)}) for ${targetGroup}.`;
              addNotification('AutoPilot Blocked', msg, 'warning');
              appendTradeAudit(
                'trade_blocked',
                { reason: msg, broker, block: 'group_max_lot', group: targetGroup, groupOpenLot, maxLotRaw },
                'warn',
                effectiveProposal.symbol
              );
              return { ok: false as const, error: msg, broker };
            }
            groupLotRemaining = remaining;
          }
        }
      }
    }

    let perSymbolMaxLotCap: number | null = null;
    if (guardrailsActive && (broker === 'tradelocker' || broker === 'sim')) {
      const capMap = parseSymbolCapsRaw(effectiveAutoCfg?.symbolCapsRaw);
      const symbolKeys = new Set(buildSymbolKeyVariants(effectiveProposal.symbol));
      const findCap = () => {
        for (const key of symbolKeys) {
          const cap = capMap.get(key);
          if (cap) return cap;
        }
        return null;
      };
      const cap = findCap();

      const perSymbolMaxPositionsRaw =
        cap?.maxPositions != null ? Number(cap.maxPositions) : Number(effectiveAutoCfg?.perSymbolMaxPositions);
      const perSymbolMaxLotRaw =
        cap?.maxLot != null ? Number(cap.maxLot) : Number(effectiveAutoCfg?.perSymbolMaxLot);
      perSymbolMaxLotCap = Number.isFinite(perSymbolMaxLotRaw) ? perSymbolMaxLotRaw : null;

      const positions = broker === 'tradelocker'
        ? (Array.isArray(tlMeta?.positions) ? tlMeta.positions : [])
        : broker === 'shadow'
          ? Array.from(shadowOpenTradesRef.current.values())
          : simOpenPositions;
      const matchesSymbol = (value: string) => {
        const variants = buildSymbolKeyVariants(value);
        return variants.some((k) => symbolKeys.has(k));
      };
      const symbolOpenCount = positions.filter((p: any) => matchesSymbol(String(p?.symbol || ''))).length;

      if (Number.isFinite(perSymbolMaxPositionsRaw) && perSymbolMaxPositionsRaw > 0 && symbolOpenCount >= perSymbolMaxPositionsRaw) {
        const msg = `Per-symbol max positions reached (${symbolOpenCount}/${perSymbolMaxPositionsRaw}) for ${effectiveProposal.symbol}.`;
        addNotification('AutoPilot Blocked', msg, 'warning');
        appendTradeAudit(
          'trade_blocked',
          { reason: msg, broker, block: 'per_symbol_max_positions', symbolOpenCount, perSymbolMaxPositionsRaw },
          'warn',
          effectiveProposal.symbol
        );
        return { ok: false as const, error: msg, broker };
      }
    }

    let qty = defaultQty;
    if (guardrailsActive && broker === 'tradelocker') {
      if (Number.isFinite(groupLotRemaining) && groupLotRemaining != null && groupLotRemaining > 0 && qty != null) {
        const numericQty = Number(qty);
        if (Number.isFinite(numericQty) && numericQty > groupLotRemaining) {
          qty = groupLotRemaining;
          const label = groupKey ? ` (${groupKey})` : '';
          addNotification('Lot Size Capped', `${effectiveProposal.symbol}${label} capped at ${groupLotRemaining.toFixed(2)} lots.`, 'warning');
        }
      }
      if (Number.isFinite(perSymbolMaxLotCap) && perSymbolMaxLotCap != null && perSymbolMaxLotCap > 0 && qty != null) {
        const numericQty = Number(qty);
        if (Number.isFinite(numericQty) && numericQty > perSymbolMaxLotCap) {
          qty = perSymbolMaxLotCap;
          addNotification('Lot Size Capped', `${effectiveProposal.symbol} capped at ${perSymbolMaxLotCap} lots.`, 'warning');
        }
      }

      // Important: TradeLocker qty is broker-specific (often "lots"). A naive riskBudget/stopDist sizing can explode sizes.
      // For now, keep the user's configured default qty and only apply a conservative clamp derived from the UI's "Max Lot Size" hint.
      const riskPct = Number(effectiveAutoCfg?.riskPerTrade);
      const equityNow = Number(tlMeta?.equity);
      if (Number.isFinite(riskPct) && riskPct > 0 && Number.isFinite(equityNow) && equityNow > 0) {
        const maxLots = (equityNow * (riskPct / 100)) / 100;
        if (Number.isFinite(maxLots) && maxLots > 0 && qty != null && Number.isFinite(Number(qty)) && Number(qty) > maxLots) {
          qty = maxLots;
        }
      }
    }

    const dedupeKey = computeTradeDedupeKey({ proposal: effectiveProposal, broker, accountKey, orderType, qty });

    let ledgerId: string | null = null;
    const setupMeta =
      proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
    const playbook = normalizeExecutionPlaybook(setupMeta?.playbook || null);
    const playbookState = playbook ? buildPlaybookState(playbook) : null;
    const reserveRes = await reserveLedgerEntry({
      ledger: window.glass?.tradeLedger,
      dedupeKey,
      windowMs: 45_000,
      fallbackMap: tradeDedupeFallbackRef.current,
      fallbackWindowMs: DEDUPE_FALLBACK_WINDOW_MS,
      entry: {
        kind: 'trade',
        schemaVersion: 'trade_v1',
        source,
        broker,
        status: 'SUBMITTING',
        idempotencyKey: dedupeKey,
        messageId: messageId || null,
        runId: runId || null,
        decisionId,
        executionId: null,
        executionMode: executionMode || null,
        autoPilotMode: source === 'autopilot' ? (effectiveAutoCfg?.mode || null) : null,
        agentId: proposal.agentId || null,
        reason: proposal.reason || null,
        expiresAtMs: proposal.expiresAtMs ?? null,
        setup: setupMeta,
        setupWatcherId: setupMeta?.watcherId ?? null,
        setupStrategy: setupMeta?.strategy ?? null,
        setupTimeframe: setupMeta?.timeframe ?? null,
        setupLibraryKey: setupMeta?.libraryKey ?? null,
        setupLibraryTier: setupMeta?.libraryTier ?? null,
        setupLibraryScore: setupMeta?.libraryScore ?? null,
        setupLibraryWinRateTier: setupMeta?.libraryWinRateTier ?? null,
        setupSignalId: setupMeta?.signalId ?? null,
        setupSignalType: setupMeta?.signalType ?? null,
        setupMode: setupMeta?.mode ?? null,
        setupSource: setupMeta?.source ?? null,
        playbook: playbook ?? null,
        playbookState,
        symbol: executionProposal.symbol,
        symbolOriginal: proposal.symbol,
        action: executionProposal.action,
        entryPrice: executionProposal.entryPrice,
        stopLoss: executionProposal.stopLoss,
        takeProfit: executionProposal.takeProfit,
        qty: qty ?? null,
        orderType,
        account: broker === 'tradelocker'
          ? {
              env: tlMeta?.env || null,
              server: tlMeta?.server || null,
              accountId: tlMeta?.accountId ?? null,
              accNum: tlMeta?.accNum ?? null
            }
          : null
      }
    });

    if (reserveRes.ok && reserveRes.reserved === false) {
      const prevAt = reserveRes?.previousAtMs ? Number(reserveRes.previousAtMs) : 0;
      const seconds = prevAt > 0 ? Math.max(1, Math.ceil((Date.now() - prevAt) / 1000)) : null;
      const msg = seconds ? `Duplicate blocked (similar trade submitted ~${seconds}s ago).` : 'Duplicate blocked (similar trade recently submitted).';
      addNotification('Duplicate Blocked', msg, 'warning');
      appendTradeAudit(
        'trade_duplicate_blocked',
        { reason: msg, broker, dedupeKey, idempotencyKey: dedupeKey, previousAtMs: prevAt || null, fallback: reserveRes.fallback === true },
        'warn',
        effectiveProposal.symbol
      );
      return { ok: false as const, error: msg, broker };
    }

    if (reserveRes.ok && reserveRes.entry?.id) {
      ledgerId = String(reserveRes.entry.id);
      try {
        const ledger = window.glass?.tradeLedger;
        if (ledgerId && ledger?.update) {
          await ledger.update({ id: ledgerId, patch: { executionId: ledgerId } });
        }
      } catch {
        // ignore
      }
    }

    const entry = `Action: ${executionProposal.action}\nSymbol: ${executionProposal.symbol}\nEntry: ${executionProposal.entryPrice}\nSL: ${executionProposal.stopLoss}\nTP: ${executionProposal.takeProfit}\nReason: AI Recommendation (${proposal.reason || 'No specific reason'})`;
    setJournalEntry(entry);

    if (shadowMode) {
      const now = Date.now();
      const setupMeta = proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
      const setupTimeframe = setupMeta?.timeframe ? String(setupMeta.timeframe) : '';
      let shadowRegimeKey: string | null = null;
      if (setupTimeframe) {
        const symbolKey = normalizeSymbolKey(executionProposal.symbol);
        const tfKey = normalizeTimeframeKey(setupTimeframe);
        if (symbolKey && tfKey) {
          const key = `${symbolKey}:${tfKey}`;
          const snapshot = setupRegimesRef.current?.[key];
          if (snapshot?.label) shadowRegimeKey = snapshot.label;
        }
      }

      try {
        const ledger = window.glass?.tradeLedger;
        if (ledgerId && ledger?.update) {
          await ledger.update({
            id: ledgerId,
            patch: {
              status: 'OPEN',
              positionStatus: 'OPEN',
              positionOpenedAtMs: now,
              broker: 'shadow',
              executionMode: 'shadow',
              shadowEntryPrice: executionEntry ?? executionProposal.entryPrice,
              shadowRegimeKey,
              brokerQuote
            }
          });
        }
      } catch { /* ignore */ }

      addNotification('Shadow Trade Logged', `${executionProposal.action} ${executionProposal.symbol} recorded (no execution).`, 'info');
      appendTradeAudit(
        'shadow_trade_open',
        {
          broker: 'shadow',
          symbol: executionProposal.symbol,
          qty: qty ?? null,
          orderType,
          ledgerId,
          shadowRegimeKey
        },
        'info',
        executionProposal.symbol
      );

      const shadowSignalId = setupMeta?.signalId ? String(setupMeta.signalId).trim() : '';
      if (shadowSignalId) {
        void updateSetupSignalStatus({
          signalId: shadowSignalId,
          status: 'triggered',
          reason: 'shadow_trade',
          match: {
            profileId: setupMeta?.profileId ?? null,
            watcherId: setupMeta?.watcherId ?? null,
            paramsHash: setupMeta?.paramsHash ?? null,
            signalType: setupMeta?.signalType ?? null
          }
        });
      }

      void refreshShadowTrades({ force: true });
      return { ok: true as const, broker: 'shadow' as const, ledgerId, filled: true, executionMode };
    }

    if (canUseTradeLocker) {
      const executionTargets = resolveTradeLockerExecutionTargets();
      if (executionTargets.length === 0) {
        const msg = 'TradeLocker active account not set. Open Locker and select an account.';
        addNotification('TradeLocker Blocked', msg, 'warning');
        appendTradeAudit('trade_blocked', { reason: msg, broker: 'tradelocker', block: 'missing_account' }, 'warn', executionProposal.symbol);
        try {
          const ledger = window.glass?.tradeLedger;
          if (ledgerId && ledger?.update) await ledger.update({ id: ledgerId, patch: { status: 'REJECTED', error: msg } });
        } catch { /* ignore */ }
        return { ok: false as const, error: msg, broker: 'tradelocker' as const };
      }

      const snapshotKey = resolveSnapshotSourceKey();
      const primaryKey = snapshotKey && executionTargets.includes(snapshotKey) ? snapshotKey : executionTargets[0];
      const strategyId = computeClientStrategyIdFromDedupeKey(dedupeKey);
      const qtyLabel = qty != null && Number.isFinite(Number(qty)) ? ` (${Number(qty)})` : '';
      const targetLabel = executionTargets.length > 1 ? ` (${executionTargets.length} accounts)` : '';
      addNotification('Order Submitted', `${executionProposal.action} ${executionProposal.symbol}${qtyLabel} sent to TradeLocker${targetLabel}`, 'info');
      appendTradeAudit(
        'trade_submitted',
        { broker: 'tradelocker', symbol: executionProposal.symbol, qty: qty ?? null, orderType, strategyId, ledgerId, idempotencyKey: dedupeKey, targets: executionTargets },
        'info',
        executionProposal.symbol
      );

      const normalizeProposalForAccount = async (accountKey: string) => {
        let normalized = false;
        let proposalForAccount = executionProposal;
        if (tlNormalizeEnabledRef.current) {
          const refKey = resolveNormalizationReferenceKey();
          if (refKey && refKey !== accountKey) {
            await fetchTradeLockerQuotesForAccount(refKey, [executionProposal.symbol], { skipLock: true, restoreKey: null });
            await fetchTradeLockerQuotesForAccount(accountKey, [executionProposal.symbol], { skipLock: true, restoreKey: null });
            const offset = getNormalizationOffsetForAccount(accountKey, executionProposal.symbol);
            const offsetValue = executionProposal.action === 'BUY' ? offset?.askOffset : offset?.bidOffset;
            if (offset && Number.isFinite(Number(offsetValue))) {
              const adjust = (value: any) => {
                const num = Number(value);
                return Number.isFinite(num) ? num + Number(offsetValue) : value;
              };
              proposalForAccount = {
                ...executionProposal,
                entryPrice: adjust(executionProposal.entryPrice),
                stopLoss: adjust(executionProposal.stopLoss),
                takeProfit: adjust(executionProposal.takeProfit)
              };
              normalized = true;
            }
          }
        }
        return { proposal: proposalForAccount, normalized };
      };

      const useLegacySubmission = readLegacyTradeLockerSubmissionFlag();
      const results = useLegacySubmission
        ? await withTradeLockerAccountLock(async () => {
            const output: Array<{ accountKey: string; res: any; normalized: boolean; proposal: TradeProposal }> = [];
            for (const accountKey of executionTargets) {
              const switchRes = await ensureTradeLockerAccount(accountKey, 'trade_execute');
              if (!switchRes.ok) {
                output.push({ accountKey, res: { ok: false, error: switchRes.error }, normalized: false, proposal: executionProposal });
                continue;
              }
              const { proposal: proposalForAccount, normalized } = await normalizeProposalForAccount(accountKey);
              const res = await requestBrokerWithAudit(
                'placeOrder',
                {
                  symbol: proposalForAccount.symbol,
                  side: proposalForAccount.action,
                  qty: qty,
                  type: orderType,
                  price: proposalForAccount.entryPrice,
                  stopPrice: orderType === 'stop' ? proposalForAccount.entryPrice : undefined,
                  stopLoss: proposalForAccount.stopLoss,
                  takeProfit: proposalForAccount.takeProfit,
                  strategyId
                },
                {
                  symbol: proposalForAccount.symbol,
                  runId,
                  source: 'trade_execute',
                  brokerId: 'tradelocker'
                }
              );
              output.push({ accountKey, res, normalized, proposal: proposalForAccount });
            }
            if (snapshotKey && snapshotKey !== getTradeLockerAccountKey()) {
              await ensureTradeLockerAccount(snapshotKey, 'trade_restore');
            }
            return output;
          })
        : (
            await submitTradeLockerOrderBatch({
              route: 'trade_execute',
              executionTargets,
              snapshotAccountKey: snapshotKey || null,
              ensureAccount: async (accountKey, reason) => await ensureTradeLockerAccount(accountKey, reason),
              withAccountLock: withTradeLockerAccountLock,
              getActiveAccountKey: getTradeLockerAccountKey,
              switchReason: 'trade_execute',
              restoreReason: 'trade_restore',
              submitForAccount: async (accountKey) => {
                const { proposal: proposalForAccount, normalized } = await normalizeProposalForAccount(accountKey);
                const payload = {
                  symbol: proposalForAccount.symbol,
                  side: proposalForAccount.action,
                  qty: qty,
                  type: orderType,
                  price: proposalForAccount.entryPrice,
                  stopPrice: orderType === 'stop' ? proposalForAccount.entryPrice : undefined,
                  stopLoss: proposalForAccount.stopLoss,
                  takeProfit: proposalForAccount.takeProfit,
                  strategyId
                };
                const res = await requestBrokerWithAudit(
                  'placeOrder',
                  payload,
                  {
                    symbol: proposalForAccount.symbol,
                    runId,
                    source: 'trade_execute',
                    brokerId: 'tradelocker'
                  }
                );
                return { res, normalized, payload: { ...payload, proposalForAccount } };
              }
            })
          ).results.map((row) => ({
            accountKey: row.accountKey,
            res: row.res,
            normalized: !!row.normalized,
            proposal: (row.payload as any)?.proposalForAccount || executionProposal
          }));

      // Make sure the TradeLocker panel reflects new positions / attached TP/SL orders ASAP.
      try {
        const exec = tradeLockerExecRef.current;
        if (exec?.refreshSnapshot) void exec.refreshSnapshot();
        if (exec?.refreshOrders) void exec.refreshOrders();
        if (exec?.refreshAccountMetrics) void exec.refreshAccountMetrics();
      } catch {
        // ignore
      }

      const primaryResult = results.find((r) => r.accountKey === primaryKey) || results[0];
      const res = primaryResult?.res;
      const orderId = extractBrokerOrderId(res);
      const orderStatus = res?.orderStatus != null ? String(res.orderStatus) : null;
      const resolvedSymbol = res?.resolvedSymbol != null ? String(res.resolvedSymbol) : null;
      const positionId = res?.positionId != null ? String(res.positionId).trim() : null;
      const filledQty = res?.filledQty != null && Number.isFinite(Number(res.filledQty)) ? Number(res.filledQty) : null;
      const remainingQty = res?.remainingQty != null && Number.isFinite(Number(res.remainingQty)) ? Number(res.remainingQty) : null;
      const statusUpper = orderStatus ? orderStatus.toUpperCase() : '';
      const filledByStatus =
        statusUpper.includes('FILL') || statusUpper.includes('EXECUT') || statusUpper.includes('DONE') || statusUpper.includes('COMPLETE');
      const isFilled = (filledQty != null && filledQty > 0) || filledByStatus;

      const mirrorExecutions = buildMirrorExecutions(results as any, primaryResult?.accountKey || null);

      if (res?.ok) {
        const normalizedQty =
          typeof (res as any)?.qty === 'number' && Number.isFinite(Number((res as any).qty))
            ? Number((res as any).qty)
            : (qty ?? null);
        try {
          const ledger = window.glass?.tradeLedger;
          if (ledgerId && ledger?.update) {
            const patch: any = {
              status: 'ACCEPTED',
              brokerOrderId: orderId,
              brokerResponse: res?.response ?? null,
              clientTag: strategyId,
              qtyNormalized: normalizedQty,
              brokerAcceptedAtMs: Date.now(),
              brokerOrderStatus: orderStatus,
              orderFilledQty: filledQty,
              orderRemainingQty: remainingQty,
              brokerResolvedSymbol: resolvedSymbol,
              mirrorExecutions
            };
            if (positionId) {
              patch.positionId = positionId;
              if (isFilled) {
                patch.status = 'OPEN';
                patch.positionStatus = 'OPEN';
                patch.positionOpenedAtMs = Date.now();
              }
            }
            await ledger.update({ id: ledgerId, patch });
          }
        } catch { /* ignore */ }

        playSound('success');
        const labelSymbol = resolvedSymbol || executionProposal.symbol;
        const idHint = orderId ? ` (#${orderId})` : '';
        const statusHint = orderStatus ? `  (${orderStatus})` : '';
        const kindHint = isFilled
          ? 'filled'
          : orderType === 'limit'
            ? 'limit order placed (pending)'
            : orderType === 'stop'
              ? 'stop order placed (pending)'
              : 'accepted (pending)';
        addNotification(isFilled ? 'TradeLocker Filled' : 'TradeLocker Accepted', `${executionProposal.action} ${labelSymbol} ${kindHint}${idHint}${statusHint}`, 'success');
        setBrokerRateLimitSuppressUntilMs(Date.now() + 15_000);
        appendTradeAudit(
          isFilled ? 'trade_filled' : 'trade_accepted',
          {
            broker: 'tradelocker',
            symbol: labelSymbol,
            orderId,
            positionId,
            orderStatus,
            filledQty,
            remainingQty,
            ledgerId,
            mirrorExecutions
          },
          'info',
          labelSymbol
        );
        if (mirrorExecutions.length > 0 && mirrorExecutions.some((m) => m.ok === false)) {
          addNotification('TradeLocker Mirror', 'Some mirror executions failed. Check Audit for details.', 'warning');
        }
        if (autoPilotConfigRef.current?.telegram?.connected) {
          deferMs(() => {
            addNotification('Telegram Relay', `Sent trade alert to Chat ID: ${autoPilotConfigRef.current.telegram.chatId}`, 'info');
          }, 800);
        }
        if (isFilled || isMarketOrder) {
          const setupMeta = proposal?.setup;
          const signalId = setupMeta?.signalId ? String(setupMeta.signalId).trim() : '';
          if (signalId) {
            void updateSetupSignalStatus({
              signalId,
              status: 'triggered',
              reason: 'trade_executed',
              match: {
                profileId: setupMeta?.profileId ?? null,
                watcherId: setupMeta?.watcherId ?? null,
                paramsHash: setupMeta?.paramsHash ?? null,
                signalType: setupMeta?.signalType ?? null
              }
            });
          }
        }
        return {
          ok: true as const,
          broker: 'tradelocker' as const,
          ledgerId,
          orderId: orderId || null,
          positionId: positionId || null,
          orderStatus: orderStatus || null,
          filled: isFilled,
          filledQty: filledQty ?? null,
          remainingQty: remainingQty ?? null,
          resolvedSymbol: resolvedSymbol || null,
          executionMode
        };
      }
      const err = res?.error ? String(res.error) : 'Unknown error';
      try {
        const ledger = window.glass?.tradeLedger;
        const cancelled =
          statusUpper.includes('CANCEL') ||
          statusUpper.includes('CANCELED') ||
          statusUpper.includes('CANCELLED') ||
          statusUpper.includes('EXPIRE') ||
          statusUpper.includes('EXPIRED') ||
          statusUpper.includes('CLOSE') ||
          statusUpper.includes('CLOSED');
        if (ledgerId && ledger?.update) await ledger.update({
          id: ledgerId,
          patch: {
            status: cancelled ? 'CANCELLED' : 'REJECTED',
            brokerOrderId: orderId,
            brokerOrderStatus: orderStatus,
            orderFilledQty: filledQty,
            orderRemainingQty: remainingQty,
            brokerResolvedSymbol: resolvedSymbol,
            error: err,
            brokerResponse: res?.response ?? null,
            mirrorExecutions
          }
        });
      } catch { /* ignore */ }
      addNotification('TradeLocker Rejected', err, 'error');
      appendTradeAudit(
        'trade_rejected',
        { broker: 'tradelocker', symbol: resolvedSymbol || effectiveProposal.symbol, error: err, orderId, orderStatus, ledgerId, mirrorExecutions },
        'error',
        resolvedSymbol || effectiveProposal.symbol
      );
      return { ok: false as const, error: err, broker: 'tradelocker' as const };
    }

    const simQty =
      qty != null && Number.isFinite(Number(qty)) && Number(qty) > 0 ? Number(qty) : 1;
    const simRes = await requestBroker('placeOrder', {
      symbol: executionProposal.symbol,
      side: executionProposal.action,
      orderType,
      qty: simQty,
      price: executionProposal.entryPrice,
      stopLoss: executionProposal.stopLoss,
      takeProfit: executionProposal.takeProfit,
      autoFill: true
    }, { brokerId: 'sim' });
    if (simRes?.ok) {
      const orderId = extractBrokerOrderId(simRes) || null;
      const orderStatus = simRes?.orderStatus ?? simRes?.order?.status ?? null;
      const positionId = simRes?.positionId ?? simRes?.position?.id ?? null;
      const filledQty = simRes?.filledQty != null ? Number(simRes.filledQty) : null;
      const remainingQty = simRes?.remainingQty != null ? Number(simRes.remainingQty) : null;
      const statusUpper = orderStatus ? String(orderStatus).toUpperCase() : '';
      const isFilled = !!positionId || statusUpper.includes('FILL');
      try {
        const ledger = window.glass?.tradeLedger;
        if (ledgerId && ledger?.update) {
          await ledger.update({
            id: ledgerId,
            patch: {
              status: isFilled ? 'EXECUTED' : 'ACCEPTED',
              brokerOrderId: orderId,
              brokerOrderStatus: orderStatus,
              brokerResolvedSymbol: executionProposal.symbol,
              orderFilledQty: filledQty,
              orderRemainingQty: remainingQty,
              brokerAcceptedAtMs: Date.now(),
              brokerFilledAtMs: isFilled ? Date.now() : null,
              brokerResponse: simRes?.order ?? simRes?.response ?? null
            }
          });
        }
      } catch { /* ignore */ }
      playSound('success');
      addNotification('Sim Filled', `${executionProposal.action} ${executionProposal.symbol} executed at ${executionProposal.entryPrice}`, 'success');
      appendTradeAudit(
        'trade_simulated',
        { broker: 'sim', symbol: executionProposal.symbol, ledgerId, orderId, positionId, orderStatus },
        'info',
        executionProposal.symbol
      );
      if (autoPilotConfigRef.current?.telegram?.connected) {
        deferMs(() => {
          addNotification('Telegram Relay', `Sent trade alert to Chat ID: ${autoPilotConfigRef.current.telegram.chatId}`, 'info');
        }, 800);
      }
      const simSetupMeta = proposal?.setup;
      const simSignalId = simSetupMeta?.signalId ? String(simSetupMeta.signalId).trim() : '';
      if (simSignalId) {
        void updateSetupSignalStatus({
          signalId: simSignalId,
          status: 'triggered',
          reason: 'trade_executed',
          match: {
            profileId: simSetupMeta?.profileId ?? null,
            watcherId: simSetupMeta?.watcherId ?? null,
            paramsHash: simSetupMeta?.paramsHash ?? null,
            signalType: simSetupMeta?.signalType ?? null
          }
        });
      }
      return { ok: true as const, broker: 'sim' as const, ledgerId, filled: isFilled, executionMode, orderId, positionId };
    }

    const simErr = simRes?.error ? String(simRes.error) : 'Sim broker order failed.';
    try {
      const ledger = window.glass?.tradeLedger;
      if (ledgerId && ledger?.update) await ledger.update({ id: ledgerId, patch: { status: 'REJECTED', error: simErr } });
    } catch { /* ignore */ }
    addNotification('Sim Rejected', simErr, 'error');
    appendTradeAudit(
      'trade_rejected',
      { broker: 'sim', symbol: executionProposal.symbol, error: simErr, ledgerId },
      'error',
      executionProposal.symbol
    );
    return { ok: false as const, error: simErr, broker: 'sim' as const };
  }, [
    addNotification,
    ensureTradeLockerAccount,
    fetchBrokerQuoteForSymbol,
    fetchTradeLockerQuotesForAccount,
    getBrokerQuoteForSymbol,
    getNormalizationOffsetForAccount,
    getTradeLockerAccountKey,
    normalizeExecutionMode,
    refreshShadowTrades,
    resolveNormalizationReferenceKey,
    resolveSnapshotSourceKey,
    resolveTradeLockerExecutionTargets,
    resolveTradeLockerSymbolBestEffort,
    requestBrokerWithAudit,
    runPreTradeRiskGate,
    updateSetupSignalStatus,
    withTradeLockerAccountLock
  ]);

  const executeMt5TradeRequestDirect = useCallback(async (
    proposal: TradeProposal,
    source: 'manual' | 'autopilot',
    opts?: {
      executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
      runId?: string;
      autoConfigOverride?: Record<string, any> | null;
    }
  ) => {
    const autoCfg = autoPilotConfigRef.current || {};
    const mergedCfg = opts?.autoConfigOverride ? { ...autoCfg, ...opts.autoConfigOverride } : autoCfg;
    const { effective: effectiveAutoCfg } = resolveAutoPilotPolicy(mergedCfg);
    const executionMode =
      normalizeExecutionMode(opts?.executionMode) ||
      (source === 'autopilot' ? normalizeExecutionMode(mergedCfg?.executionMode) : null) ||
      'live';

    const configuredLots = Number(effectiveAutoCfg?.lotSize);
    let qty = Number.isFinite(configuredLots) && configuredLots > 0 ? configuredLots : 0;
    if (!Number.isFinite(qty) || qty <= 0) {
      const riskPct = Number(effectiveAutoCfg?.riskPerTrade);
      if (Number.isFinite(riskPct) && riskPct > 0) {
        let equity = Number(mt5AccountSpecRef.current?.equity);
        if (!Number.isFinite(equity) || equity <= 0) {
          try {
            const spec = await fetchMt5AccountSpec();
            if (spec) {
              setMt5AccountSpec(spec);
              equity = Number(spec.equity);
            }
          } catch {
            // ignore MT5 equity fetch failures
          }
        }
        if (Number.isFinite(equity) && equity > 0) {
          const approx = (equity * (riskPct / 100)) / 100;
          if (Number.isFinite(approx) && approx > 0) qty = approx;
        }
      }
    }
    if (!Number.isFinite(qty) || qty <= 0) qty = 0.1;

    if (!Number.isFinite(qty) || qty <= 0) {
      const error = 'MT5 order blocked: invalid lot size.';
      addNotification('MT5 Blocked', error, 'warning');
      void appendAuditEvent({
        eventType: 'trade_blocked',
        level: 'warn',
        symbol: proposal.symbol || null,
        payload: { broker: 'mt5', reason: error, source }
      });
      return { ok: false as const, error, broker: 'mt5' as const };
    }

    const adapter = createMt5Adapter();
    let resolvedSymbol = proposal.symbol;
    try {
      const linkCfg = brokerLinkConfigRef.current || DEFAULT_BROKER_LINK_CONFIG;
      const next = await resolveBrokerSymbol({
        symbol: resolvedSymbol,
        brokerId: 'mt5',
        config: linkCfg,
        adapter
      });
      if (next) resolvedSymbol = next;
    } catch {
      // ignore resolve failures
    }

    const intent = {
      symbol: resolvedSymbol,
      side: proposal.action,
      type: 'market' as const,
      qty,
      entryPrice: proposal.entryPrice,
      stopLoss: proposal.stopLoss,
      takeProfit: proposal.takeProfit,
      comment: proposal.reason ? String(proposal.reason).slice(0, 64) : null,
      sourceBroker: 'mt5' as const
    };

    const res = await adapter.placeOrder?.(intent as any);
    if (!res?.ok) {
      const error = res?.error ? String(res.error) : 'MT5 order failed.';
      addNotification('MT5 Rejected', error, 'error');
      void appendAuditEvent({
        eventType: 'trade_rejected',
        level: 'error',
        symbol: resolvedSymbol,
        payload: { broker: 'mt5', error, source }
      });
      return { ok: false as const, error, broker: 'mt5' as const };
    }

    addNotification('MT5 Submitted', `${proposal.action} ${resolvedSymbol} sent to MT5`, 'success');
    void appendAuditEvent({
      eventType: 'trade_submitted',
      level: 'info',
      symbol: resolvedSymbol,
      payload: {
        broker: 'mt5',
        source,
        orderId: res.orderId ?? null,
        positionId: res.positionId ?? null,
        executionMode
      }
    });

    return {
      ok: true as const,
      broker: 'mt5' as const,
      orderId: res.orderId ?? null,
      positionId: res.positionId ?? null,
      filled: true,
      executionMode
    };
  }, [addNotification, appendAuditEvent, normalizeExecutionMode, resolveAutoPilotPolicy]);

  const updateExecutionQueueEntry = useCallback(async (ledgerId: string | null, patch: Record<string, any>) => {
    if (!ledgerId) return;
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.update) return;
    try {
      await ledger.update({ id: ledgerId, patch });
    } catch {
      // ignore ledger failures
    }
  }, []);

  const runExecutionPayload = useCallback(async (payload: ExecutionQueuePayload) => {
    if (payload.executor === 'mt5') {
      return executeMt5TradeRequestDirect(payload.proposal, payload.source, payload.opts ?? undefined);
    }
    return executeTradeRequestDirect(payload.proposal, payload.source, payload.opts ?? undefined);
  }, [executeMt5TradeRequestDirect, executeTradeRequestDirect]);

  const scheduleExecutionQueueDrain = useCallback(() => {
    if (executionQueueDrainScheduledRef.current) return;
    executionQueueDrainScheduledRef.current = true;
    deferMs(() => {
      executionQueueDrainScheduledRef.current = false;
      const drain = executionQueueDrainRef.current;
      if (drain) drain();
    }, 0);
  }, []);

  const buildExecutionQueueKnownKey = useCallback((ledgerId: string | null, dedupeKey: string) => {
    if (ledgerId) return `ledger:${ledgerId}`;
    const cleaned = String(dedupeKey || '').trim();
    return cleaned ? `dedupe:${cleaned}` : `dedupe:unknown`;
  }, []);

  const pushExecutionQueueItem = useCallback((item: ExecutionQueueItem, knownKey: string) => {
    if (executionQueueKnownRef.current.has(knownKey)) return false;
    executionQueueKnownRef.current.add(knownKey);
    const queue = executionQueueRef.current;
    queue.push(item);
    queue.sort((a, b) => {
      const aTs = Number(a.payload?.queuedAtMs || 0);
      const bTs = Number(b.payload?.queuedAtMs || 0);
      if (aTs !== bTs) return aTs - bTs;
      return String(a.dedupeKey || '').localeCompare(String(b.dedupeKey || ''));
    });
    scheduleExecutionQueueDrain();
    return true;
  }, [scheduleExecutionQueueDrain]);

  const drainExecutionQueue = useCallback(() => {
    const queue = executionQueueRef.current;
    if (executionQueueInFlightRef.current >= EXECUTION_QUEUE_CONCURRENCY) return;
    if (queue.length === 0) return;

    while (executionQueueInFlightRef.current < EXECUTION_QUEUE_CONCURRENCY && queue.length > 0) {
      const next = queue.shift();
      if (!next) break;
      const queueKey = buildExecutionQueueKnownKey(next.ledgerId, next.dedupeKey);
      const now = Date.now();
      const queuedAtMs = Number(next.payload?.queuedAtMs) || now;
      if (now - queuedAtMs > EXECUTION_QUEUE_MAX_AGE_MS) {
        const msg = 'Execution queue item expired.';
        void updateExecutionQueueEntry(next.ledgerId, { status: 'CANCELLED', error: msg, completedAtMs: now });
        executionQueueKnownRef.current.delete(queueKey);
        next.resolve?.({ ok: false as const, error: msg, code: 'queue_expired' });
        continue;
      }

      executionQueueInFlightRef.current += 1;
      (async () => {
        const attempt = Number(next.payload?.attempts || 0) + 1;
        next.payload.attempts = attempt;
        next.payload.retryCount = attempt;
        next.payload.lastAttemptAtMs = now;
        next.payload.submittedAtMs = Number(next.payload.submittedAtMs || 0) || now;
        executionAuditService.noteSubmitted({
          signalId: next.payload.signalId || null,
          dedupeKey: next.dedupeKey,
          ledgerId: next.ledgerId,
          submittedAt: next.payload.submittedAtMs,
          retryCount: attempt,
          broker: next.payload.brokerHint ?? next.payload.opts?.forceBroker ?? null,
          source: next.payload.source
        });
        await updateExecutionQueueEntry(next.ledgerId, {
          status: 'IN_FLIGHT',
          attempts: attempt,
          lastAttemptAtMs: now,
          submittedAtMs: next.payload.submittedAtMs,
          retryCount: attempt,
          payload: next.payload
        });

        let result: any;
        try {
          result = await runExecutionPayload(next.payload);
        } catch (err: any) {
          result = { ok: false, error: err?.message ? String(err.message) : 'Execution failed.' };
        }
        const ok = !!(result && result.ok !== false);
        const completedAtMs = Date.now();
        const brokerOrderId = extractBrokerOrderId(result) || (result?.orderId != null ? String(result.orderId) : null);
        next.payload.ackAtMs = completedAtMs;
        next.payload.brokerOrderId = brokerOrderId;
        executionAuditService.noteAck({
          signalId: next.payload.signalId || null,
          dedupeKey: next.dedupeKey,
          ackAt: completedAtMs,
          brokerOrderId,
          retryCount: attempt,
          broker: result?.broker ?? next.payload.brokerHint ?? next.payload.opts?.forceBroker ?? null
        });
        await updateExecutionQueueEntry(next.ledgerId, {
          status: ok ? 'EXECUTED' : 'FAILED',
          completedAtMs,
          ackAtMs: completedAtMs,
          brokerOrderId: brokerOrderId || null,
          retryCount: attempt,
          error: ok ? null : (result?.error ? String(result.error) : 'Execution failed.'),
          result: ok ? result : undefined
        });
        next.resolve?.(result);
      })()
        .finally(() => {
          executionQueueInFlightRef.current = Math.max(0, executionQueueInFlightRef.current - 1);
          executionQueueKnownRef.current.delete(queueKey);
          scheduleExecutionQueueDrain();
        });
    }
  }, [buildExecutionQueueKnownKey, runExecutionPayload, scheduleExecutionQueueDrain, updateExecutionQueueEntry]);

  useEffect(() => {
    executionQueueDrainRef.current = drainExecutionQueue;
  }, [drainExecutionQueue]);

  const enqueueExecutionPayload = useCallback(async (payload: ExecutionQueuePayload) => {
    const now = Date.now();
    payload.queuedAtMs = Number(payload.queuedAtMs) || now;
    payload.attempts = Number(payload.attempts || 0) || 0;
    payload.lastAttemptAtMs = payload.lastAttemptAtMs ?? null;

    const dedupeKey = buildExecutionQueueKey(payload);
    const proposal = payload.proposal;
    const proposalSetup = proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
    payload.signalId = payload.signalId || (proposalSetup?.signalId ? String(proposalSetup.signalId) : null) || null;
    payload.dedupeKey = dedupeKey;
    payload.retryCount = Number(payload.attempts || 0);
    const entry = {
      kind: EXECUTION_QUEUE_KIND,
      schemaVersion: 'execution_queue_v1',
      source: payload.source,
      broker: payload.brokerHint ?? payload.opts?.forceBroker ?? null,
      status: 'QUEUED',
      executor: payload.executor,
      messageId: proposal?.messageId ?? null,
      runId: payload.opts?.runId ?? null,
      symbol: proposal?.symbol ?? null,
      action: proposal?.action ?? null,
      entryPrice: proposal?.entryPrice ?? null,
      stopLoss: proposal?.stopLoss ?? null,
      takeProfit: proposal?.takeProfit ?? null,
      queuedAtMs: payload.queuedAtMs,
      attempts: payload.attempts,
      lastAttemptAtMs: payload.lastAttemptAtMs ?? null,
       submittedAtMs: payload.submittedAtMs ?? null,
       ackAtMs: payload.ackAtMs ?? null,
       brokerOrderId: payload.brokerOrderId ?? null,
       retryCount: payload.retryCount ?? 0,
       signalId: payload.signalId ?? null,
       dedupeKey,
      payload
    };

    const reserveRes = await reserveLedgerEntry({
      ledger: window.glass?.tradeLedger,
      dedupeKey,
      windowMs: EXECUTION_QUEUE_DEDUPE_WINDOW_MS,
      fallbackMap: executionQueueDedupeFallbackRef.current,
      entry
    });

    if (reserveRes.ok && reserveRes.reserved === false) {
      const prevAt = reserveRes?.previousAtMs ? Number(reserveRes.previousAtMs) : 0;
      const seconds = prevAt > 0 ? Math.max(1, Math.ceil((Date.now() - prevAt) / 1000)) : null;
      const msg = seconds
        ? `Duplicate blocked (similar execution queued ~${seconds}s ago).`
        : 'Duplicate blocked (similar execution already queued).';
      addNotification('Duplicate Blocked', msg, 'warning');
      return { ok: false as const, error: msg, duplicate: true };
    }

    const ledgerId = reserveRes.entry?.id ? String(reserveRes.entry.id) : null;
    const knownKey = buildExecutionQueueKnownKey(ledgerId, dedupeKey);

    return new Promise<any>((resolve) => {
      const item: ExecutionQueueItem = { ledgerId, dedupeKey, payload, resolve };
      const queued = pushExecutionQueueItem(item, knownKey);
      if (!queued) {
        const msg = 'Duplicate execution already queued.';
        resolve({ ok: false as const, error: msg, duplicate: true });
        return;
      }
      executionAuditService.noteSubmitted({
        signalId: payload.signalId || null,
        dedupeKey,
        ledgerId,
        submittedAt: null,
        retryCount: payload.retryCount ?? payload.attempts ?? 0,
        broker: payload.brokerHint ?? payload.opts?.forceBroker ?? null,
        source: payload.source
      });
    });
  }, [addNotification, buildExecutionQueueKnownKey, pushExecutionQueueItem]);

  const rehydrateExecutionQueue = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list) return;
    let res: any = null;
    try {
      res = await ledger.list({ limit: EXECUTION_QUEUE_RECOVERY_LIMIT });
    } catch {
      return;
    }
    if (!res?.ok || !Array.isArray(res.entries)) return;
    const terminal = new Set(['EXECUTED', 'FAILED', 'REJECTED', 'CANCELLED', 'CANCELED', 'CLOSED']);
    const now = Date.now();
    const entries = res.entries.filter((entry: any) => entry?.kind === EXECUTION_QUEUE_KIND);
    if (entries.length === 0) return;

    for (const entry of entries.slice().reverse()) {
      const status = String(entry?.status || '').toUpperCase();
      if (terminal.has(status)) continue;
      const payload = entry?.payload && typeof entry.payload === 'object' ? entry.payload as ExecutionQueuePayload : null;
      if (!payload || (payload.executor !== 'trade' && payload.executor !== 'mt5') || !payload.proposal) continue;
      payload.queuedAtMs = Number(payload.queuedAtMs) || Number(entry.queuedAtMs) || Number(entry.createdAtMs) || now;
      payload.attempts = Number(payload.attempts || entry.attempts || 0) || 0;
      payload.lastAttemptAtMs = payload.lastAttemptAtMs ?? entry.lastAttemptAtMs ?? null;
      payload.signalId = payload.signalId || (payload.proposal?.setup?.signalId ? String(payload.proposal.setup.signalId) : null) || (entry?.signalId ? String(entry.signalId) : null);
      payload.submittedAtMs = Number(payload.submittedAtMs || entry.submittedAtMs || 0) || null;
      payload.ackAtMs = Number(payload.ackAtMs || entry.ackAtMs || 0) || null;
      payload.brokerOrderId = payload.brokerOrderId || (entry?.brokerOrderId ? String(entry.brokerOrderId) : null);
      payload.retryCount = Number(payload.retryCount || entry.retryCount || payload.attempts || 0) || 0;
      if (now - payload.queuedAtMs > EXECUTION_QUEUE_MAX_AGE_MS) {
        const msg = 'Execution queue item expired.';
        void updateExecutionQueueEntry(entry.id ? String(entry.id) : null, { status: 'CANCELLED', error: msg, completedAtMs: now });
        continue;
      }
      const dedupeKey = entry?.dedupeKey ? String(entry.dedupeKey) : buildExecutionQueueKey(payload);
      payload.dedupeKey = dedupeKey;
      const ledgerId = entry?.id ? String(entry.id) : null;
      const knownKey = buildExecutionQueueKnownKey(ledgerId, dedupeKey);
      if (executionQueueKnownRef.current.has(knownKey)) continue;
      executionAuditService.noteSubmitted({
        signalId: payload.signalId || null,
        dedupeKey,
        ledgerId,
        submittedAt: payload.submittedAtMs ?? null,
        retryCount: payload.retryCount ?? payload.attempts ?? 0,
        broker: payload.brokerHint ?? payload.opts?.forceBroker ?? null,
        source: payload.source
      });
      if (payload.ackAtMs) {
        executionAuditService.noteAck({
          signalId: payload.signalId || null,
          dedupeKey,
          ackAt: payload.ackAtMs,
          brokerOrderId: payload.brokerOrderId || null,
          retryCount: payload.retryCount ?? payload.attempts ?? 0,
          broker: payload.brokerHint ?? payload.opts?.forceBroker ?? null
        });
      }
      if (status !== 'QUEUED') {
        void updateExecutionQueueEntry(ledgerId, { status: 'QUEUED', queuedAtMs: payload.queuedAtMs });
      }
      const item: ExecutionQueueItem = { ledgerId, dedupeKey, payload };
      pushExecutionQueueItem(item, knownKey);
    }
  }, [buildExecutionQueueKnownKey, pushExecutionQueueItem, updateExecutionQueueEntry]);

  useEffect(() => {
    if (executionQueueRehydratedRef.current) return;
    executionQueueRehydratedRef.current = true;
    void rehydrateExecutionQueue();
  }, [rehydrateExecutionQueue]);

  const executeTradeRequest = useCallback(async (
    proposal: TradeProposal,
    source: 'manual' | 'autopilot',
    opts?: {
      forceBroker?: 'sim' | 'tradelocker' | 'mt5';
      executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
      runId?: string;
      autoConfigOverride?: Record<string, any> | null;
    }
  ) => {
    return enqueueExecutionPayload({
      kind: EXECUTION_QUEUE_KIND,
      executor: 'trade',
      proposal,
      source,
      brokerHint: opts?.forceBroker ?? null,
      opts: opts ?? null,
      queuedAtMs: Date.now()
    });
  }, [enqueueExecutionPayload]);

  const executeMt5TradeRequest = useCallback(async (
    proposal: TradeProposal,
    source: 'manual' | 'autopilot',
    opts?: {
      executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
      runId?: string;
      autoConfigOverride?: Record<string, any> | null;
    }
  ) => {
    return enqueueExecutionPayload({
      kind: EXECUTION_QUEUE_KIND,
      executor: 'mt5',
      proposal,
      source,
      brokerHint: 'mt5',
      opts: opts ?? null,
      queuedAtMs: Date.now()
    });
  }, [enqueueExecutionPayload]);

  const brokerRefreshNotBeforeRef = React.useRef<number>(0);

  const executeBrokerActionRequest = useCallback(async (action: BrokerAction) => {
    const meta = tradeLockerExecRef.current || {};
    const now = Date.now();
    const messageId = action.messageId ? String(action.messageId).trim() : '';
    const ledger = window.glass?.tradeLedger;
    let brokerActionLedgerId: string | null = null;
    const brokerActionDedupeWindowMs = 45_000;
    const actionSource = String(action?.source || '').toLowerCase();
    const autoCfg = autoPilotConfigRef.current || {};
    const { effective: effectiveAutoCfg } = resolveAutoPilotPolicy(autoCfg);

    const appendBrokerActionEvent = (eventType: string, extra?: Record<string, any>, level: 'info' | 'warn' | 'error' = 'info') => {
      const symbol = extra?.symbol || action.symbol || null;
      void appendAuditEvent({
        eventType,
        level,
        symbol,
        decisionId: messageId || null,
        payload: {
          actionType: action.type,
          messageId: messageId || null,
          agentId: action.agentId || null,
          reason: action.reason || null,
          ...(extra || {})
        }
      });
    };

    const appendBrokerActionAudit = async (extra?: Record<string, any>) => {
      if (action.type === 'REFRESH_BROKER') return { ok: true, reserved: true };
      const idempotencyKey = computeBrokerActionIdempotencyKey({ ...action, ...(extra || {}) });
      const reserveRes = await reserveLedgerEntry({
        ledger,
        dedupeKey: idempotencyKey,
        windowMs: brokerActionDedupeWindowMs,
        fallbackMap: brokerActionDedupeFallbackRef.current,
        entry: {
          kind: 'broker_action',
          schemaVersion: 'broker_action_v1',
          source: 'broker_action',
          broker: 'tradelocker',
          status: 'SUBMITTING',
          idempotencyKey,
          actionType: action.type,
          messageId: messageId || null,
          agentId: action.agentId || null,
          reason: action.reason || null,
          symbol: action.symbol ? String(action.symbol) : null,
          positionId: action.positionId ? String(action.positionId) : null,
          orderId: action.orderId ? String(action.orderId) : null,
          qty: action.qty != null ? Number(action.qty) : null,
          price: action.price != null ? Number(action.price) : null,
          stopLoss: action.stopLoss ?? null,
          takeProfit: action.takeProfit ?? null,
          stopLossUsd: action.stopLossUsd ?? null,
          takeProfitUsd: action.takeProfitUsd ?? null,
          trailingOffset: action.trailingOffset ?? null,
          ...(extra || {})
        }
      });
      if (reserveRes?.ok && reserveRes.entry?.id) brokerActionLedgerId = String(reserveRes.entry.id);
      return {
        ...reserveRes,
        dedupeKey: idempotencyKey,
        idempotencyKey
      };
    };

    const pause = (ms: number) => sleepMs(ms);

    const resolvePositionId = (positions: any[]) => {
      let positionId = String(action.positionId || '').trim();
      if (positionId) return positionId;
      const symbolRaw = String(action.symbol || '').trim();
      if (symbolRaw) {
        const targets = positions.filter((p: any) =>
          buildSymbolKeyVariants(String(p?.symbol || '')).some((k) => buildSymbolKeyVariants(symbolRaw).includes(k))
        );
        if (targets.length === 1) positionId = String(targets[0]?.id || '').trim();
      } else if (positions.length === 1) {
        positionId = String(positions[0]?.id || '').trim();
      }
      return positionId;
    };

    const resolveOrderId = (orders: any[]) => {
      let orderId = String(action.orderId || '').trim();
      if (orderId) return orderId;
      const symbolRaw = String(action.symbol || '').trim();
      if (symbolRaw) {
        const targets = orders.filter((o: any) =>
          buildSymbolKeyVariants(String(o?.symbol || '')).some((k) => buildSymbolKeyVariants(symbolRaw).includes(k))
        );
        if (targets.length === 1) orderId = String(targets[0]?.id || '').trim();
      } else if (orders.length === 1) {
        orderId = String(orders[0]?.id || '').trim();
      }
      return orderId;
    };

    const normalizeStopValue = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num) || num <= 0) return null;
      return num;
    };

    const deriveStopsFromOrders = (position: any, orders: any[]) => {
      if (!position || !Array.isArray(orders) || orders.length === 0) return {};
      const symbol = String(position?.symbol || '').trim();
      if (!symbol) return {};
      const entry = Number(position?.entryPrice);
      if (!Number.isFinite(entry) || entry <= 0) return {};
      const side = String(position?.type || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
      const key = normalizeSymbolLoose(symbol);
      if (!key) return {};

      const candidates = orders.filter((o: any) => {
        const oSymbol = String(o?.symbol || '').trim();
        if (!oSymbol) return false;
        const oSide = String(o?.side || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
        if (oSide === side) return false;
        return normalizeSymbolLoose(oSymbol) === key;
      });
      if (!candidates.length) return {};

      const prices = candidates
        .map((o: any) => Number(o?.price))
        .filter((p: any) => Number.isFinite(p) && p > 0);
      if (!prices.length) return {};

      let derivedSL: number | null = null;
      let derivedTP: number | null = null;

      if (side === 'BUY') {
        const above = prices.filter((p) => p > entry).sort((a, b) => a - b);
        const below = prices.filter((p) => p < entry).sort((a, b) => b - a);
        if (above.length > 0) derivedTP = above[0];
        if (below.length > 0) derivedSL = below[0];
      } else {
        const below = prices.filter((p) => p < entry).sort((a, b) => b - a);
        const above = prices.filter((p) => p > entry).sort((a, b) => a - b);
        if (below.length > 0) derivedTP = below[0];
        if (above.length > 0) derivedSL = above[0];
      }

      const out: { stopLoss?: number; takeProfit?: number } = {};
      if (derivedSL != null && Number.isFinite(derivedSL) && derivedSL > 0) out.stopLoss = derivedSL;
      if (derivedTP != null && Number.isFinite(derivedTP) && derivedTP > 0) out.takeProfit = derivedTP;
      return out;
    };

    const computeValuePerPoint = (position: any, quote: any) => {
      if (!position) return null;
      const entry = Number(position?.entryPrice);
      if (!Number.isFinite(entry) || entry <= 0) return null;
      const pnl = Number(position?.pnl);
      if (!Number.isFinite(pnl) || Math.abs(pnl) <= 1e-6) return null;
      const refPrice = getBrokerReferencePriceFromQuote(quote);
      if (!Number.isFinite(Number(refPrice))) return null;
      const side = String(position?.type || '').toUpperCase() === 'SELL' ? -1 : 1;
      const delta = (Number(refPrice) - entry) * side;
      if (!Number.isFinite(delta) || Math.abs(delta) <= 1e-6) return null;
      const vpp = Math.abs(pnl / delta);
      if (!Number.isFinite(vpp) || vpp <= 0) return null;
      return vpp;
    };

    const refreshSnapshotIfStale = async () => {
      if (!meta.refreshSnapshot) return false;
      const current = tradeLockerExecRef.current || {};
      const last = Number(current.snapshotUpdatedAtMs || 0);
      const ageMs = last > 0 ? Date.now() - last : Number.POSITIVE_INFINITY;
      const hasPositions = Array.isArray(current.positions) && current.positions.length > 0;
      if (ageMs < 2500 && hasPositions) return false;
      try {
        await meta.refreshSnapshot();
      } catch {
        return false;
      }
      await pause(150);
      return true;
    };

    const refreshOrdersIfStale = async () => {
      if (!meta.refreshOrders) return false;
      const current = tradeLockerExecRef.current || {};
      const last = Number(current.snapshotUpdatedAtMs || 0);
      const ageMs = last > 0 ? Date.now() - last : Number.POSITIVE_INFINITY;
      const hasOrders = Array.isArray(current.orders) && current.orders.length > 0;
      if (ageMs < 2500 && hasOrders) return false;
      try {
        await meta.refreshOrders();
      } catch {
        return false;
      }
      await pause(150);
      return true;
    };

    if (!action || !action.type) {
      return { ok: false as const, error: 'Invalid broker action.' };
    }

    if (actionSource.includes('autopilot') && effectiveAutoCfg?.killSwitch) {
      const safeTypes = new Set<BrokerActionType>(['CLOSE_POSITION', 'CANCEL_ORDER', 'REFRESH_BROKER']);
      if (!safeTypes.has(action.type)) {
        const msg = 'AutoPilot kill switch is ON.';
        addNotification('AutoPilot Blocked', msg, 'warning');
        appendBrokerActionEvent('broker_action_blocked', {
          actionType: action.type,
          reason: msg,
          block: 'kill_switch'
        }, 'warn');
        return { ok: false as const, error: msg, code: 'autopilot_killswitch' };
      }
    }

    if (action.type === 'REFRESH_BROKER') {
      const cooldownMs = 5_000;
      const notBefore = Number(brokerRefreshNotBeforeRef.current || 0);
      if (notBefore && now < notBefore) {
        const waitSec = Math.max(1, Math.ceil((notBefore - now) / 1000));
        return { ok: false as const, error: `Broker refresh throttled. Try again in ${waitSec}s.` };
      }
      brokerRefreshNotBeforeRef.current = now + cooldownMs;

      try {
        const scope = action.scope || 'all';
        if (scope === 'snapshot') {
          await meta.refreshSnapshot?.();
        } else if (scope === 'orders') {
          await meta.refreshOrders?.();
        } else if (scope === 'metrics') {
          await meta.refreshAccountMetrics?.();
        } else {
          await Promise.all([
            meta.refreshSnapshot?.(),
            meta.refreshOrders?.(),
            meta.refreshAccountMetrics?.()
          ]);
        }
        addNotification('Broker Snapshot', 'Broker data refreshed.', 'info');
        return { ok: true as const };
      } catch (e: any) {
        const msg = e?.message ? String(e.message) : 'Failed to refresh broker snapshot.';
        addNotification('Broker Snapshot', msg, 'error');
        return { ok: false as const, error: msg };
      }
    }

    if (!meta.connected) {
      return { ok: false as const, error: 'TradeLocker is not connected.' };
    }

    if (action.type === 'CLOSE_POSITION') {
      let positions = Array.isArray(meta.positions) ? meta.positions : [];
      let positionId = resolvePositionId(positions);
      if (!positionId) {
        const refreshed = await refreshSnapshotIfStale();
        if (refreshed) {
          const latest = tradeLockerExecRef.current || {};
          positions = Array.isArray(latest.positions) ? latest.positions : [];
          positionId = resolvePositionId(positions);
        }
      }
      if (!positionId) {
        return { ok: false as const, error: 'Missing position ID. Ask the agent to use the ID shown in the broker snapshot.' };
      }
      const qty = action.qty != null ? Number(action.qty) : 0;
      const auditRes = await appendBrokerActionAudit({ targetType: 'position', targetId: positionId, symbol: action.symbol || null });
      if (auditRes?.ok && auditRes.reserved === false) {
        const msg = 'Duplicate broker action blocked (close position).';
        addNotification('Duplicate Blocked', msg, 'warning');
        appendBrokerActionEvent('broker_action_duplicate_blocked', {
          targetType: 'position',
          targetId: positionId,
          symbol: action.symbol || null,
          dedupeKey: auditRes.dedupeKey || null,
          idempotencyKey: auditRes.idempotencyKey || null
        }, 'warn');
        return { ok: true as const, duplicate: true, message: msg };
      }
      appendBrokerActionEvent('broker_action_submitted', { targetType: 'position', targetId: positionId, symbol: action.symbol || null });
      const res = await meta.closePosition?.(positionId, Number.isFinite(qty) ? qty : 0);
      if (res?.ok) {
        const pos = positions.find((p: any) => String(p?.id) === positionId) || null;
        const qtyLabel = qty && qty > 0 ? ` (qty ${qty})` : '';
        addNotification('Close Requested', `${pos?.symbol || action.symbol || 'Position'} close sent to TradeLocker${qtyLabel}`, 'info');
        appendBrokerActionEvent('broker_action_executed', {
          targetType: 'position',
          targetId: positionId,
          symbol: pos?.symbol || action.symbol || null
        });
        try {
          if (brokerActionLedgerId && ledger?.update) {
            await ledger.update({
              id: brokerActionLedgerId,
              patch: { status: 'EXECUTED', executedAtMs: Date.now(), brokerResponse: res?.response ?? null }
            });
          }
        } catch {
          // ignore ledger failures
        }
        return { ok: true as const };
      }
      const err = res?.error ? String(res.error) : 'Failed to close position.';
      addNotification('Close Failed', err, 'error');
      appendBrokerActionEvent('broker_action_failed', {
        targetType: 'position',
        targetId: positionId,
        symbol: action.symbol || null,
        error: err
      }, 'error');
      try {
        if (brokerActionLedgerId && ledger?.update) {
          await ledger.update({
            id: brokerActionLedgerId,
            patch: { status: 'REJECTED', executedAtMs: Date.now(), error: err, brokerResponse: res?.response ?? null }
          });
        }
      } catch {
        // ignore ledger failures
      }
      return { ok: false as const, error: err };
    }

    if (action.type === 'CANCEL_ORDER') {
      let orders = Array.isArray(meta.orders) ? meta.orders : [];
      let orderId = resolveOrderId(orders);
      if (!orderId) {
        const refreshed = await refreshOrdersIfStale();
        if (refreshed) {
          const latest = tradeLockerExecRef.current || {};
          orders = Array.isArray(latest.orders) ? latest.orders : [];
          orderId = resolveOrderId(orders);
        }
      }
      if (!orderId) {
        return { ok: false as const, error: 'Missing order ID. Ask the agent to use the ID shown in the broker snapshot.' };
      }
      const auditRes = await appendBrokerActionAudit({ targetType: 'order', targetId: orderId, symbol: action.symbol || null });
      if (auditRes?.ok && auditRes.reserved === false) {
        const msg = 'Duplicate broker action blocked (cancel order).';
        addNotification('Duplicate Blocked', msg, 'warning');
        appendBrokerActionEvent('broker_action_duplicate_blocked', {
          targetType: 'order',
          targetId: orderId,
          symbol: action.symbol || null,
          dedupeKey: auditRes.dedupeKey || null,
          idempotencyKey: auditRes.idempotencyKey || null
        }, 'warn');
        return { ok: true as const, duplicate: true, message: msg };
      }
      appendBrokerActionEvent('broker_action_submitted', { targetType: 'order', targetId: orderId, symbol: action.symbol || null });
      const res = await meta.cancelOrder?.(orderId);
      if (res?.ok) {
        const ord = orders.find((o: any) => String(o?.id) === orderId) || null;
        addNotification('Cancel Requested', `${ord?.symbol || action.symbol || 'Order'} cancel sent to TradeLocker`, 'info');
        appendBrokerActionEvent('broker_action_executed', {
          targetType: 'order',
          targetId: orderId,
          symbol: ord?.symbol || action.symbol || null
        });
        try {
          if (brokerActionLedgerId && ledger?.update) {
            await ledger.update({
              id: brokerActionLedgerId,
              patch: { status: 'EXECUTED', executedAtMs: Date.now(), brokerResponse: res?.response ?? null }
            });
          }
        } catch {
          // ignore ledger failures
        }
        return { ok: true as const };
      }
      const err = res?.error ? String(res.error) : 'Failed to cancel order.';
      addNotification('Cancel Failed', err, 'error');
      appendBrokerActionEvent('broker_action_failed', {
        targetType: 'order',
        targetId: orderId,
        symbol: action.symbol || null,
        error: err
      }, 'error');
      try {
        if (brokerActionLedgerId && ledger?.update) {
          await ledger.update({
            id: brokerActionLedgerId,
            patch: { status: 'REJECTED', executedAtMs: Date.now(), error: err, brokerResponse: res?.response ?? null }
          });
        }
      } catch {
        // ignore ledger failures
      }
      return { ok: false as const, error: err };
    }

    if (action.type === 'MODIFY_ORDER') {
      let orders = Array.isArray(meta.orders) ? meta.orders : [];
      let orderId = resolveOrderId(orders);
      if (!orderId) {
        const refreshed = await refreshOrdersIfStale();
        if (refreshed) {
          const latest = tradeLockerExecRef.current || {};
          orders = Array.isArray(latest.orders) ? latest.orders : [];
          orderId = resolveOrderId(orders);
        }
      }
      if (!orderId) {
        return { ok: false as const, error: 'Missing order ID. Ask the agent to use the ID shown in the broker snapshot.' };
      }

      const normalizeOptionalPositive = (value: any, label: string) => {
        if (value === undefined || value === null || value === '') return { set: false, invalid: false };
        const num = Number(value);
        if (!Number.isFinite(num) || num <= 0) return { set: false, invalid: true, error: `${label} must be a positive number.` };
        return { set: true, invalid: false, value: num };
      };

      let price: number | null | undefined;
      let qty: number | null | undefined;
      let stopLoss: number | null | undefined;
      let takeProfit: number | null | undefined;

      const priceInput = normalizeOptionalPositive(action.price, 'Price');
      if (priceInput.invalid) return { ok: false as const, error: priceInput.error || 'Price must be a positive number.' };
      if (priceInput.set) price = priceInput.value;

      const qtyInput = normalizeOptionalPositive(action.qty, 'Qty');
      if (qtyInput.invalid) return { ok: false as const, error: qtyInput.error || 'Qty must be a positive number.' };
      if (qtyInput.set) qty = qtyInput.value;

      const normalizeStopValue = (value: any) => {
        if (value == null || value === '') return { set: false, invalid: false };
        const num = Number(value);
        if (!Number.isFinite(num)) return { set: false, invalid: true };
        if (num === 0) return { set: false, invalid: false };
        if (num < 0) return { set: false, invalid: true };
        return { set: true, invalid: false, value: num };
      };

      if (action.clearStopLoss) {
        stopLoss = null;
      } else {
        const sl = normalizeStopValue(action.stopLoss);
        if (sl.set) {
          stopLoss = sl.value;
        } else if (sl.invalid) {
          return { ok: false as const, error: 'Stop loss must be a positive number.' };
        }
      }

      if (action.clearTakeProfit) {
        takeProfit = null;
      } else {
        const tp = normalizeStopValue(action.takeProfit);
        if (tp.set) {
          takeProfit = tp.value;
        } else if (tp.invalid) {
          return { ok: false as const, error: 'Take profit must be a positive number.' };
        }
      }

      if (price === undefined && qty === undefined && stopLoss === undefined && takeProfit === undefined) {
        return { ok: false as const, error: 'No modifications provided.' };
      }

      const auditRes = await appendBrokerActionAudit({ targetType: 'order', targetId: orderId, price: price ?? null, symbol: action.symbol || null });
      if (auditRes?.ok && auditRes.reserved === false) {
        const msg = 'Duplicate broker action blocked (modify order).';
        addNotification('Duplicate Blocked', msg, 'warning');
        appendBrokerActionEvent('broker_action_duplicate_blocked', {
          targetType: 'order',
          targetId: orderId,
          symbol: action.symbol || null,
          dedupeKey: auditRes.dedupeKey || null,
          idempotencyKey: auditRes.idempotencyKey || null
        }, 'warn');
        return { ok: true as const, duplicate: true, message: msg };
      }
      appendBrokerActionEvent('broker_action_submitted', { targetType: 'order', targetId: orderId, symbol: action.symbol || null });
      const res = await meta.modifyOrder?.({ orderId, price, qty, stopLoss, takeProfit });
      if (res?.ok) {
        const ord = orders.find((o: any) => String(o?.id) === orderId) || null;
        addNotification('Modify Requested', `${ord?.symbol || action.symbol || 'Order'} modification sent to TradeLocker`, 'info');
        appendBrokerActionEvent('broker_action_executed', {
          targetType: 'order',
          targetId: orderId,
          symbol: ord?.symbol || action.symbol || null
        });
        try {
          if (brokerActionLedgerId && ledger?.update) {
            await ledger.update({
              id: brokerActionLedgerId,
              patch: { status: 'EXECUTED', executedAtMs: Date.now(), brokerResponse: res?.response ?? null }
            });
          }
        } catch {
          // ignore ledger failures
        }
        return { ok: true as const };
      }
      const err = res?.error ? String(res.error) : 'Failed to modify order.';
      addNotification('Modify Failed', err, 'error');
      appendBrokerActionEvent('broker_action_failed', {
        targetType: 'order',
        targetId: orderId,
        symbol: action.symbol || null,
        error: err
      }, 'error');
      try {
        if (brokerActionLedgerId && ledger?.update) {
          await ledger.update({
            id: brokerActionLedgerId,
            patch: { status: 'REJECTED', executedAtMs: Date.now(), error: err, brokerResponse: res?.response ?? null }
          });
        }
      } catch {
        // ignore ledger failures
      }
      return { ok: false as const, error: err };
    }

    if (action.type === 'MODIFY_POSITION') {
      let positions = Array.isArray(meta.positions) ? meta.positions : [];
      let positionId = resolvePositionId(positions);
      if (!positionId) {
        const refreshed = await refreshSnapshotIfStale();
        if (refreshed) {
          const latest = tradeLockerExecRef.current || {};
          positions = Array.isArray(latest.positions) ? latest.positions : [];
          positionId = resolvePositionId(positions);
        }
      }
      if (!positionId) {
        return { ok: false as const, error: 'Missing position ID. Ask the agent to use the ID shown in the broker snapshot.' };
      }

      let stopLoss: number | null | undefined;
      let takeProfit: number | null | undefined;
      let trailingOffset: number | null | undefined;

      const stopLossUsdRaw = action.stopLossUsd != null ? Number(action.stopLossUsd) : null;
      const takeProfitUsdRaw = action.takeProfitUsd != null ? Number(action.takeProfitUsd) : null;
      const stopLossUsd =
        stopLossUsdRaw != null && Number.isFinite(stopLossUsdRaw) && stopLossUsdRaw > 0 ? stopLossUsdRaw : null;
      const takeProfitUsd =
        takeProfitUsdRaw != null && Number.isFinite(takeProfitUsdRaw) && takeProfitUsdRaw > 0 ? takeProfitUsdRaw : null;
      const hasStopLossUsd = stopLossUsd != null;
      const hasTakeProfitUsd = takeProfitUsd != null;

      const normalizeInputStop = (value: any) => {
        if (value == null || value === '') return { set: false, invalid: false };
        const num = Number(value);
        if (!Number.isFinite(num)) return { set: false, invalid: true };
        if (num === 0) return { set: false, invalid: false };
        if (num < 0) return { set: false, invalid: true };
        return { set: true, invalid: false, value: num };
      };

      if (action.clearStopLoss) {
        stopLoss = null;
      } else {
        const sl = normalizeInputStop(action.stopLoss);
        if (sl.set) {
          stopLoss = sl.value;
        } else if (sl.invalid && !hasStopLossUsd) {
          return { ok: false as const, error: 'Stop loss must be a positive number.' };
        }
      }

      if (action.clearTakeProfit) {
        takeProfit = null;
      } else {
        const tp = normalizeInputStop(action.takeProfit);
        if (tp.set) {
          takeProfit = tp.value;
        } else if (tp.invalid && !hasTakeProfitUsd) {
          return { ok: false as const, error: 'Take profit must be a positive number.' };
        }
      }

      let pos = positions.find((p: any) => String(p?.id) === positionId) || null;
      let orders = Array.isArray(meta.orders) ? meta.orders : [];
      let symbol = String(pos?.symbol || action.symbol || '').trim();
      let side = String(pos?.type || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
      let entryPrice = Number(pos?.entryPrice);
      let quote = symbol ? getBrokerQuoteForSymbol(symbol) : null;

      if (hasStopLossUsd || hasTakeProfitUsd) {
        let vpp = computeValuePerPoint(pos, quote);
        if (!Number.isFinite(entryPrice) || entryPrice <= 0 || !Number.isFinite(Number(vpp))) {
          const refreshed = await refreshSnapshotIfStale();
          if (refreshed) {
            const latest = tradeLockerExecRef.current || {};
            positions = Array.isArray(latest.positions) ? latest.positions : positions;
            orders = Array.isArray(latest.orders) ? latest.orders : orders;
            pos = positions.find((p: any) => String(p?.id) === positionId) || null;
            symbol = String(pos?.symbol || action.symbol || '').trim();
            side = String(pos?.type || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
            entryPrice = Number(pos?.entryPrice);
            quote = symbol ? getBrokerQuoteForSymbol(symbol) : quote;
            vpp = computeValuePerPoint(pos, quote);
          }
        }

        if (hasStopLossUsd) {
          if (!Number.isFinite(entryPrice) || entryPrice <= 0 || !Number.isFinite(Number(vpp))) {
            return { ok: false as const, error: 'Cannot convert $ stop loss to price without entry + broker quote/PnL.' };
          }
          const dist = Math.abs(stopLossUsd) / Number(vpp);
          if (!Number.isFinite(dist) || dist <= 0) {
            return { ok: false as const, error: 'Stop loss $ amount is invalid.' };
          }
          stopLoss = side === 'SELL' ? entryPrice + dist : entryPrice - dist;
        }

        if (hasTakeProfitUsd) {
          if (!Number.isFinite(entryPrice) || entryPrice <= 0 || !Number.isFinite(Number(vpp))) {
            return { ok: false as const, error: 'Cannot convert $ take profit to price without entry + broker quote/PnL.' };
          }
          const dist = Math.abs(takeProfitUsd) / Number(vpp);
          if (!Number.isFinite(dist) || dist <= 0) {
            return { ok: false as const, error: 'Take profit $ amount is invalid.' };
          }
          takeProfit = side === 'SELL' ? entryPrice - dist : entryPrice + dist;
        }
      }

      if (action.trailingOffset != null) {
        const to = Number(action.trailingOffset);
        if (!Number.isFinite(to) || to <= 0) {
          if (stopLoss === undefined && takeProfit === undefined) {
            return { ok: false as const, error: 'Trailing offset must be a positive number.' };
          }
        } else {
          trailingOffset = to;
        }
      }

      let existingStopLoss = normalizeStopValue(pos?.stopLoss);
      let existingTakeProfit = normalizeStopValue(pos?.takeProfit);
      if (existingStopLoss == null || existingTakeProfit == null) {
        const derived = deriveStopsFromOrders(pos, orders);
        if (existingStopLoss == null && derived.stopLoss != null) existingStopLoss = derived.stopLoss;
        if (existingTakeProfit == null && derived.takeProfit != null) existingTakeProfit = derived.takeProfit;
      }

      if (!action.clearStopLoss && stopLoss === undefined && existingStopLoss != null) stopLoss = existingStopLoss;
      if (!action.clearTakeProfit && takeProfit === undefined && existingTakeProfit != null) takeProfit = existingTakeProfit;

      if (stopLoss === undefined && takeProfit === undefined && trailingOffset === undefined) {
        return { ok: false as const, error: 'No stop loss or take profit changes provided.' };
      }

      if (symbol && (stopLoss != null || takeProfit != null)) {
        const brokerRef = getBrokerReferencePriceFromQuote(quote);
        const referencePrice =
          brokerRef != null && Number.isFinite(Number(brokerRef))
            ? Number(brokerRef)
            : pos?.entryPrice != null && Number.isFinite(Number(pos.entryPrice))
              ? Number(pos.entryPrice)
              : null;
        const check = await validateBrokerStopLevels({
          symbol,
          side,
          stopLoss,
          takeProfit,
          referencePrice
        });
        if (!check.ok) {
          const msg = check.error || 'Broker constraints blocked this modification.';
          addNotification('Modify Blocked', msg, 'error');
          return { ok: false as const, error: msg };
        }
        if (check.warning) {
          addNotification('Broker Constraints', check.warning, 'warning');
        }
      }

      const auditRes = await appendBrokerActionAudit({ targetType: 'position', targetId: positionId, symbol: symbol || null });
      if (auditRes?.ok && auditRes.reserved === false) {
        const msg = 'Duplicate broker action blocked (modify position).';
        addNotification('Duplicate Blocked', msg, 'warning');
        appendBrokerActionEvent('broker_action_duplicate_blocked', {
          targetType: 'position',
          targetId: positionId,
          symbol: symbol || null,
          dedupeKey: auditRes.dedupeKey || null,
          idempotencyKey: auditRes.idempotencyKey || null
        }, 'warn');
        return { ok: true as const, duplicate: true, message: msg };
      }
      appendBrokerActionEvent('broker_action_submitted', { targetType: 'position', targetId: positionId, symbol: symbol || null });
      const res = await meta.modifyPosition?.({ positionId, stopLoss, takeProfit, trailingOffset });
      if (res?.ok) {
        const label = pos?.symbol || action.symbol || 'Position';
        addNotification('Modify Requested', `${label} SL/TP update sent to TradeLocker`, 'info');
        appendBrokerActionEvent('broker_action_executed', {
          targetType: 'position',
          targetId: positionId,
          symbol: label
        });
        try {
          if (brokerActionLedgerId && ledger?.update) {
            await ledger.update({
              id: brokerActionLedgerId,
              patch: {
                status: 'EXECUTED',
                executedAtMs: Date.now(),
                brokerResponse: res?.response ?? null
              }
            });
          }
        } catch {
          // ignore ledger failures
        }
        return { ok: true as const };
      }
      const err = res?.error ? String(res.error) : 'Failed to modify position.';
      addNotification('Modify Failed', err, 'error');
      appendBrokerActionEvent('broker_action_failed', {
        targetType: 'position',
        targetId: positionId,
        symbol: symbol || null,
        error: err
      }, 'error');
      try {
        if (brokerActionLedgerId && ledger?.update) {
          await ledger.update({
            id: brokerActionLedgerId,
            patch: { status: 'REJECTED', executedAtMs: Date.now(), error: err, brokerResponse: res?.response ?? null }
          });
        }
      } catch {
        // ignore ledger failures
      }
      return { ok: false as const, error: err };
    }

    return { ok: false as const, error: 'Unsupported broker action.' };
  }, [addNotification, appendAuditEvent, resolveAutoPilotPolicy]);

  const executeTicketOrder = useCallback(async (args: Record<string, any>) => {
    const handler = handleTradeLockerPlaceOrderRef.current;
    if (!handler) return { ok: false as const, error: 'TradeLocker order handler unavailable.' };
    const res: any = await Promise.resolve(handler(args));
    if (res?.ok) return { ok: true as const, data: res };
    return {
      ok: false as const,
      error: res?.error ? String(res.error) : 'TradeLocker order failed.',
      code: res?.code ? String(res.code) : undefined
    };
  }, []);

  const executeBulkCancelOrders = useCallback(async (input: { orderIds?: string[]; symbol?: string; reason?: string; source?: string }) => {
    const orders = Array.isArray(tlOrdersRef.current) ? tlOrdersRef.current : [];
    const symbolFilter = input.symbol ? normalizeSymbolKey(input.symbol) : '';
    const ids = Array.isArray(input.orderIds) ? input.orderIds.map((id) => String(id || '').trim()).filter(Boolean) : [];
    const targets = ids.length > 0
      ? orders.filter((order) => ids.includes(String(order?.id || '').trim()))
      : orders.filter((order) => {
          if (!symbolFilter) return true;
          return normalizeSymbolKey(order?.symbol || '') === symbolFilter;
        });
    if (targets.length === 0) return { ok: true as const, data: { total: 0, cancelled: 0, results: [] } };
    const results: Array<{ id: string; ok: boolean; error?: string; code?: string }> = [];
    const source = input.source ? String(input.source) : 'manual';
    const reason = input.reason ? String(input.reason) : 'Bulk cancel';
    for (const order of targets) {
      const id = String(order?.id || '').trim();
      if (!id) continue;
      const action: BrokerAction = {
        type: 'CANCEL_ORDER',
        status: 'PENDING',
        orderId: id,
        symbol: order?.symbol ? String(order.symbol) : undefined,
        source,
        reason
      };
      const res = await executeBrokerActionRequest(action);
      results.push({ id, ok: !!res?.ok, error: res?.ok ? undefined : res?.error, code: res?.code });
    }
    const cancelled = results.filter((r) => r.ok).length;
    return { ok: cancelled === results.length, data: { total: results.length, cancelled, results } };
  }, [executeBrokerActionRequest]);

  const executeBulkClosePositions = useCallback(async (input: { positionIds?: string[]; symbol?: string; qty?: number; reason?: string; source?: string }) => {
    const positions = Array.isArray(tlPositionsRef.current) ? tlPositionsRef.current : [];
    const symbolFilter = input.symbol ? normalizeSymbolKey(input.symbol) : '';
    const ids = Array.isArray(input.positionIds) ? input.positionIds.map((id) => String(id || '').trim()).filter(Boolean) : [];
    const qty = Number.isFinite(Number(input.qty)) ? Number(input.qty) : 0;
    const targets = ids.length > 0
      ? positions.filter((pos) => ids.includes(String(pos?.id || '').trim()))
      : positions.filter((pos) => {
          if (!symbolFilter) return true;
          return normalizeSymbolKey(pos?.symbol || '') === symbolFilter;
        });
    if (targets.length === 0) return { ok: true as const, data: { total: 0, closed: 0, results: [] } };
    const results: Array<{ id: string; ok: boolean; error?: string; code?: string }> = [];
    const source = input.source ? String(input.source) : 'manual';
    const reason = input.reason ? String(input.reason) : 'Bulk close';
    for (const pos of targets) {
      const id = String(pos?.id || '').trim();
      if (!id) continue;
      const action: BrokerAction = {
        type: 'CLOSE_POSITION',
        status: 'PENDING',
        positionId: id,
        qty: qty || undefined,
        symbol: pos?.symbol ? String(pos.symbol) : undefined,
        source,
        reason
      };
      const res = await executeBrokerActionRequest(action);
      results.push({ id, ok: !!res?.ok, error: res?.ok ? undefined : res?.error, code: res?.code });
    }
    const closed = results.filter((r) => r.ok).length;
    return { ok: closed === results.length, data: { total: results.length, closed, results } };
  }, [executeBrokerActionRequest]);

  const executionApi = React.useMemo(() => {
    return createExecutionApi({
      executeTrade: executeTradeRequest,
      executeBrokerAction: executeBrokerActionRequest,
      executeTicketOrder,
      executeBulkCancelOrders,
      executeBulkClosePositions
    });
  }, [executeBrokerActionRequest, executeBulkCancelOrders, executeBulkClosePositions, executeTicketOrder, executeTradeRequest]);

  const executeBrokerCommand = useCallback((command: ExecutionCommand) => {
    if (!command || typeof command !== 'object') {
      return { ok: false as const, error: 'Invalid execution command.' };
    }
    return executionApi.execute(command);
  }, [executionApi]);

  const executeTradeRequestViaApi = useCallback(async (
    proposal: TradeProposal,
    source: 'manual' | 'autopilot',
    opts?: {
      forceBroker?: 'sim' | 'tradelocker' | 'mt5';
      executionMode?: 'suggest' | 'paper' | 'live' | 'shadow';
      runId?: string;
      autoConfigOverride?: Record<string, any> | null;
    }
  ) => {
    const forceBroker = opts?.forceBroker;
    if (forceBroker === 'mt5') {
      return executeMt5TradeRequest(proposal, source, {
        executionMode: opts?.executionMode,
        runId: opts?.runId,
        autoConfigOverride: opts?.autoConfigOverride
      });
    }

    const setupMeta = proposal?.setup && typeof proposal.setup === 'object' ? proposal.setup : null;
    const isSignalPanel = setupMeta?.signalType === 'signal_panel' || setupMeta?.source === 'signal_panel';
    const linkCfg = brokerLinkConfigRef.current;

    if (!forceBroker && isSignalPanel && linkCfg?.signalDefaults) {
      const targets: Array<'mt5' | 'tradelocker'> = [];
      if (linkCfg.signalDefaults.sendToMt5) targets.push('mt5');
      if (linkCfg.signalDefaults.sendToTradeLocker) targets.push('tradelocker');

      if (targets.length > 0) {
        const preferred =
          targets.includes(linkCfg.masterBroker)
            ? (linkCfg.masterBroker as 'mt5' | 'tradelocker')
            : targets[0];
        const runBroker = async (brokerId: 'mt5' | 'tradelocker') => {
          try {
            if (brokerId === 'mt5') {
              return await executeMt5TradeRequest(proposal, source, {
                executionMode: opts?.executionMode,
                runId: opts?.runId,
                autoConfigOverride: opts?.autoConfigOverride
              });
            }
            return await executeTradeRequest(proposal, source, {
              ...opts,
              forceBroker: 'tradelocker'
            });
          } catch (err: any) {
            return {
              ok: false as const,
              error: err?.message ? String(err.message) : 'Execution failed.',
              broker: brokerId
            };
          }
        };
        const primaryRes = await runBroker(preferred);
        const secondaryId = targets.find((t) => t !== preferred);
        if (secondaryId) {
          if (primaryRes?.ok) {
            void runBroker(secondaryId);
            return primaryRes;
          }
          const secondaryRes = await runBroker(secondaryId);
          if (!primaryRes?.ok && secondaryRes?.ok) return secondaryRes;
        }
        return primaryRes;
      }
    }

    let res: any;
    try {
      res = await executeBrokerCommand({ kind: 'trade', proposal, source, opts });
    } catch (err: any) {
      return { ok: false as const, error: err?.message ? String(err.message) : 'Trade execution failed.' };
    }
    if (!res.ok) return { ok: false as const, error: res.error };
    return res.data;
  }, [executeBrokerCommand, executeMt5TradeRequest, executeTradeRequest]);

  useEffect(() => {
    executeBrokerActionRequestRef.current = executeBrokerActionRequest;
  }, [executeBrokerActionRequest]);

  useEffect(() => {
    executeTradeRequestRef.current = executeTradeRequestViaApi;
  }, [executeTradeRequestViaApi]);

  const executeBrokerActionViaApi = useCallback(async (action: BrokerAction) => {
    const res = await executeBrokerCommand({ kind: 'broker_action', action });
    if (!res.ok) return { ok: false as const, error: res.error, code: res.code };
    return res.data;
  }, [executeBrokerCommand]);

  const executeTicketOrderViaApi = useCallback(async (args: Record<string, any>) => {
    return executeBrokerCommand({ kind: 'ticket_order', args });
  }, [executeBrokerCommand]);

  const executeBulkCancelOrdersViaApi = useCallback(async (input: { orderIds?: string[]; symbol?: string; reason?: string; source?: string }) => {
    return executeBrokerCommand({ kind: 'bulk_cancel_orders', ...input });
  }, [executeBrokerCommand]);

  const executeBulkClosePositionsViaApi = useCallback(async (input: { positionIds?: string[]; symbol?: string; qty?: number; reason?: string; source?: string }) => {
    return executeBrokerCommand({ kind: 'bulk_close_positions', ...input });
  }, [executeBrokerCommand]);

  const parseTelegramChatIds = useCallback((raw: string) => {
    const text = String(raw || '').trim();
    if (!text) return [] as string[];
    return text.split(/[,\s]+/g).map((entry) => entry.trim()).filter(Boolean);
  }, []);

  const sendTelegramText = useCallback(async (text: string, chatIdOverride?: string, opts?: { replyMarkup?: any }) => {
    const sender = window.glass?.telegram?.sendMessage;
    if (!sender) return { ok: false, error: 'Telegram relay unavailable.' };
    const chatId = String(chatIdOverride || signalTelegramChatId || '').trim();
    const clean = String(text || '').trim();
    if (!signalTelegramBotToken || !chatId || !clean) {
      return { ok: false, error: 'Telegram bot token, chat id, and text are required.' };
    }
    const res = await sender({ botToken: signalTelegramBotToken, chatId, text: clean, replyMarkup: opts?.replyMarkup });
    if (!res?.ok) {
      const err = res?.error ? String(res.error) : 'Telegram send failed.';
      addNotification('Telegram Relay', err, 'error');
    }
    return res;
  }, [addNotification, signalTelegramBotToken, signalTelegramChatId]);

  const sendTelegramPhoto = useCallback(async (dataUrl: string, caption?: string, chatIdOverride?: string) => {
    const sender = window.glass?.telegram?.sendPhoto;
    if (!sender) return { ok: false, error: 'Telegram relay unavailable.' };
    const chatId = String(chatIdOverride || signalTelegramChatId || '').trim();
    const clean = String(dataUrl || '').trim();
    if (!signalTelegramBotToken || !chatId || !clean) {
      return { ok: false, error: 'Telegram bot token, chat id, and image are required.' };
    }
    const res = await sender({ botToken: signalTelegramBotToken, chatId, dataUrl: clean, caption });
    if (!res?.ok) {
      const err = res?.error ? String(res.error) : 'Telegram send failed.';
      addNotification('Telegram Relay', err, 'error');
    }
    return res;
  }, [addNotification, signalTelegramBotToken, signalTelegramChatId]);

  const answerTelegramCallback = useCallback(async (callbackId: string, text?: string) => {
    const responder = window.glass?.telegram?.answerCallback;
    if (!responder) return { ok: false, error: 'Telegram callback unavailable.' };
    const clean = String(text || '').trim();
    if (!signalTelegramBotToken || !callbackId) {
      return { ok: false, error: 'Telegram bot token and callback id are required.' };
    }
    return responder({ botToken: signalTelegramBotToken, callbackId, text: clean || undefined });
  }, [signalTelegramBotToken]);

  const sendTelegramAlert = useCallback(async (title: string, message: string, chatIdOverride?: string) => {
    if (!telegramAlertsActive) return { ok: false, skipped: true };
    const header = String(title || '').trim();
    const body = String(message || '').trim();
    const text = header ? [header, body].filter(Boolean).join('\n') : body;
    if (!text) return { ok: false, error: 'Alert payload empty.' };
    return sendTelegramText(text, chatIdOverride);
  }, [sendTelegramText, telegramAlertsActive]);

  const telegramSymbolCandidates = React.useMemo(() => {
    const list: string[] = [];
    const seen = new Set<string>();
    const push = (value: any) => {
      const sym = String(value || '').trim();
      if (!sym) return;
      const key = normalizeSymbolKeyShared(sym);
      if (!key || seen.has(key)) return;
      seen.add(key);
      list.push(sym);
    };
    push(symbolScopeSymbol);
    push(activeBrokerSymbol);
    signalSymbols.forEach(push);
    brokerWatchSymbols.forEach(push);
    patternSymbols.forEach(push);
    const map = brokerLinkConfig?.symbolMap || [];
    for (const entry of map) {
      if (!entry) continue;
      push(entry.canonical);
      push(entry.mt5);
      push(entry.tradelocker);
    }
    return list;
  }, [activeBrokerSymbol, brokerLinkConfig, brokerWatchSymbols, patternSymbols, signalSymbols, symbolScopeSymbol]);

  const parseTelegramSymbol = useCallback((text: string) => {
    const raw = String(text || '').trim();
    if (!raw) return '';
    const upper = raw.toUpperCase();
    const lower = raw.toLowerCase();
    const aliasMap: Array<{ keys: string[]; symbol: string }> = [
      { keys: ['gold', 'xau'], symbol: 'XAUUSD' },
      { keys: ['nas100', 'nas', 'us100'], symbol: 'NAS100' },
      { keys: ['us30', 'dow', 'dj30'], symbol: 'US30' },
      { keys: ['btc', 'bitcoin'], symbol: 'BTCUSD' }
    ];
    for (const alias of aliasMap) {
      if (alias.keys.some((key) => lower.includes(key))) return alias.symbol;
    }
    for (const candidate of telegramSymbolCandidates) {
      const variants = buildSymbolKeyVariantsShared(candidate).map((v) => String(v).toUpperCase());
      if (variants.some((v) => v && upper.includes(v))) return candidate;
    }
    const tokenMatch = upper.match(/\b[A-Z]{2,6}[A-Z0-9]{0,6}(?:\.[A-Z0-9]+)?\b/);
    return tokenMatch ? tokenMatch[0] : '';
  }, [telegramSymbolCandidates]);

  const parseTelegramTimeframe = useCallback((text: string) => {
    const raw = String(text || '');
    if (!raw) return '';
    const lower = raw.toLowerCase();
    const direct = lower.match(/\b(\d+)\s*(m|h|d|w)\b/);
    if (direct) return normalizeTimeframeKey(`${direct[1]}${direct[2]}`);
    const swapped = lower.match(/\b(m|h|d|w)\s*(\d+)\b/);
    if (swapped) return normalizeTimeframeKey(`${swapped[2]}${swapped[1]}`);
    const hr = lower.match(/\b(\d+)\s*(hr|hrs|hour|hours)\b/);
    if (hr) return normalizeTimeframeKey(`${hr[1]}h`);
    const min = lower.match(/\b(\d+)\s*(min|mins|minute|minutes)\b/);
    if (min) return normalizeTimeframeKey(`${min[1]}m`);
    return '';
  }, []);

  const parseTelegramBroker = useCallback((text: string) => {
    const lower = String(text || '').toLowerCase();
    if (/\btradelocker\b|\btrade locker\b|\blocker\b|\btl\b/.test(lower)) {
      return 'tradelocker' as const;
    }
    if (lower.includes('mt5') || lower.includes('metatrader') || lower.includes('meta trader')) {
      return 'mt5' as const;
    }
    return null;
  }, []);

  const parseTelegramAccountHint = useCallback((text: string) => {
    const lower = String(text || '').toLowerCase();
    const match = lower.match(/\b(?:acct|account)\s*[:=]\s*([a-z0-9_-]+)/i);
    if (match && match[1]) return match[1];
    const hashMatch = lower.match(/#(\d{2,})/);
    if (hashMatch && hashMatch[1]) return hashMatch[1];
    return '';
  }, []);

  const parseTelegramQtySpec = useCallback((text: string): TelegramQtySpec | null => {
    const lower = String(text || '').toLowerCase();
    if (lower.includes('half')) return { mode: 'fraction' as const, value: 0.5 };
    if (lower.includes('quarter')) return { mode: 'fraction' as const, value: 0.25 };
    const pct = lower.match(/(\d+(?:\.\d+)?)\s*%/);
    if (pct) {
      const value = Number(pct[1]) / 100;
      return Number.isFinite(value) ? { mode: 'fraction' as const, value } : null;
    }
    const lots = lower.match(/(\d+(?:\.\d+)?)\s*(lot|lots)\b/);
    if (lots) {
      const value = Number(lots[1]);
      return Number.isFinite(value) ? { mode: 'absolute' as const, value } : null;
    }
    const raw = lower.match(/\bclose\s+(\d+(?:\.\d+)?)\b/);
    if (raw) {
      const value = Number(raw[1]);
      return Number.isFinite(value) ? { mode: 'absolute' as const, value } : null;
    }
    return null;
  }, []);

  const fetchTelegramNewsSnapshot = useCallback(async (symbol: string) => {
    const api = window.glass?.news;
    if (!api?.getSnapshot) return null;
    try {
      const res = await api.getSnapshot({ symbol, limit: 6, force: false });
      if (!res?.ok) return null;
      return (res.snapshot || null) as NewsSnapshot | null;
    } catch {
      return null;
    }
  }, []);

  const formatTelegramNewsTone = useCallback((tone?: string | null, toneScore?: number | null) => {
    const label = String(tone || '').trim().toUpperCase();
    if (!label) return '';
    const score = Number.isFinite(Number(toneScore)) ? Number(toneScore) : null;
    const scoreLabel = score != null && score !== 0 ? ` ${score > 0 ? '+' : ''}${score}` : '';
    return `${label}${scoreLabel}`;
  }, []);

  const formatTelegramSignalLine = useCallback((entry: SignalEntry) => {
    const idShort = entry.id ? entry.id.slice(-6) : '';
    const tf = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
    const prob = Number.isFinite(Number(entry.probability)) ? Math.round(Number(entry.probability)) : null;
    const parts = [idShort, entry.action, entry.symbol, tf].filter(Boolean);
    if (prob != null) parts.push(`p${prob}`);
    parts.push(entry.status || 'PROPOSED');
    return parts.join(' ');
  }, [formatTimeframeLabel]);

  const resolveTelegramSignalEntry = useCallback((token: string) => {
    const cleaned = String(token || '').trim();
    const entries = Array.isArray(signalEntriesRef.current) ? signalEntriesRef.current : [];
    const ordered = entries.slice().sort((a, b) => (b.createdAtMs || 0) - (a.createdAtMs || 0));
    if (!cleaned) return ordered[0] || null;
    const exact = ordered.find((entry) => entry.id === cleaned);
    if (exact) return exact;
    const lower = cleaned.toLowerCase();
    const byPrefix = ordered.find((entry) => entry.id.toLowerCase().startsWith(lower));
    if (byPrefix) return byPrefix;
    const bySuffix = ordered.find((entry) => entry.id.toLowerCase().endsWith(lower));
    if (bySuffix) return bySuffix;
    const symbolKey = normalizeSymbolKeyShared(cleaned);
    if (symbolKey) {
      const bySymbol = ordered.find((entry) => normalizeSymbolKeyShared(entry.symbol) === symbolKey);
      if (bySymbol) return bySymbol;
    }
    return null;
  }, []);

  const pruneTelegramPendingActions = useCallback(() => {
    const now = Date.now();
    if (now - telegramPendingCleanupAtRef.current < 3000) return;
    telegramPendingCleanupAtRef.current = now;
    const map = telegramPendingActionsRef.current;
    for (const [id, action] of map.entries()) {
      if (action.expiresAtMs <= now) map.delete(id);
    }
  }, []);

  const resolveTelegramPendingAction = useCallback((id: string) => {
    const key = String(id || '').trim();
    if (!key) return null;
    pruneTelegramPendingActions();
    const pending = telegramPendingActionsRef.current.get(key) || null;
    if (!pending) return null;
    if (pending.expiresAtMs <= Date.now()) {
      telegramPendingActionsRef.current.delete(key);
      return null;
    }
    return pending;
  }, [pruneTelegramPendingActions]);

  const queueTelegramConfirmation = useCallback(async (input: {
    chatId: string;
    summary: string;
    kind: TelegramPendingAction['kind'];
    payload: TelegramPendingAction['payload'];
  }) => {
    if (!signalTelegramConfirmationsEnabled) return { ok: false, skipped: true };
    const now = Date.now();
    pruneTelegramPendingActions();
    const id = `tg_${now.toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
    const expiresAtMs = now + signalTelegramConfirmationTimeoutSec * 1000;
    const pending: TelegramPendingAction = {
      id,
      kind: input.kind,
      payload: input.payload,
      createdAtMs: now,
      expiresAtMs,
      chatId: input.chatId,
      summary: input.summary
    };
    telegramPendingActionsRef.current.set(id, pending);
    const ttlSec = Math.max(0, Math.round((expiresAtMs - now) / 1000));
    await sendTelegramText(`Confirm: ${input.summary}\nExpires in ${ttlSec}s.`, input.chatId, {
      replyMarkup: {
        inline_keyboard: [
          [
            { text: 'Confirm', callback_data: `confirm:${id}` },
            { text: 'Cancel', callback_data: `cancel:${id}` }
          ]
        ]
      }
    });
    return { ok: true, id };
  }, [pruneTelegramPendingActions, sendTelegramText, signalTelegramConfirmationTimeoutSec, signalTelegramConfirmationsEnabled]);

  const runTelegramSignalAction = useCallback(async (input: {
    type: 'execute' | 'reject' | 'cancel';
    entry: SignalEntry;
    chatId: string;
    forceBroker?: BrokerId | null;
  }) => {
    const entry = input.entry;
    const idLabel = entry.id ? entry.id.slice(-6) : '';
    const brokerLabel = input.forceBroker ? ` (${input.forceBroker.toUpperCase()})` : '';
    try {
      if (input.type === 'execute') {
        await executeSignalTrade(entry.id, 'manual', entry, { forceBroker: input.forceBroker ?? undefined });
        await sendTelegramText(`Execution requested${brokerLabel}: ${entry.action} ${entry.symbol} ${idLabel}`.trim(), input.chatId);
      } else if (input.type === 'reject') {
        await rejectSignalEntry(entry.id);
        await sendTelegramText(`Rejected signal ${idLabel}.`, input.chatId);
      } else {
        await cancelSignalOrder(entry.id);
        await sendTelegramText(`Cancel requested for ${idLabel}.`, input.chatId);
      }
      void appendAuditEvent({
        eventType: 'telegram_action',
        symbol: entry.symbol,
        payload: {
          action: input.type,
          signalId: entry.id,
          broker: input.forceBroker || null,
          chatId: input.chatId
        }
      });
    } catch (err: any) {
      const msg = err?.message ? String(err.message) : 'Telegram action failed.';
      await sendTelegramText(msg, input.chatId);
    }
  }, [appendAuditEvent, cancelSignalOrder, executeSignalTrade, rejectSignalEntry, sendTelegramText]);

  const runTelegramManageAction = useCallback(async (input: {
    chatId: string;
    broker: 'mt5' | 'tradelocker';
    requestedSymbol?: string | null;
    isBreakeven?: boolean;
    qtySpec?: TelegramQtySpec | null;
    accountHint?: string | null;
  }) => {
    const chatId = input.chatId;
    const requestedSymbol = input.requestedSymbol || '';
    const qtySpec = input.qtySpec || null;
    void appendAuditEvent({
      eventType: 'telegram_action',
      symbol: requestedSymbol || null,
      payload: {
        action: input.isBreakeven ? 'breakeven' : 'close',
        broker: input.broker,
        chatId
      }
    });
    if (input.broker === 'tradelocker') {
      let positions = Array.isArray(tlPositionsRef.current) ? tlPositionsRef.current : [];
      const accountHint = input.accountHint ? String(input.accountHint).trim() : '';
      if (accountHint) {
        const api = window.glass?.tradelocker;
        if (!api?.getAccounts || !api?.setActiveAccount) {
          await sendTelegramText('TradeLocker account switching unavailable.', chatId);
          return;
        }
        const res = await api.getAccounts();
        const accounts = Array.isArray(res?.accounts) ? res.accounts : [];
        const match = accounts.find((acc) => {
          const id = acc?.id != null ? String(acc.id) : '';
          const accNum = acc?.accNum != null ? String(acc.accNum) : '';
          return id === accountHint || accNum === accountHint;
        });
        if (!match) {
          await sendTelegramText(`TradeLocker account ${accountHint} not found.`, chatId);
          return;
        }
        const switchRes = await api.setActiveAccount({ accountId: Number(match.id), accNum: Number(match.accNum) });
        if (switchRes?.ok === false) {
          await sendTelegramText(switchRes?.error ? String(switchRes.error) : 'Failed to switch TradeLocker account.', chatId);
          return;
        }
        try {
          dispatchGlassEvent(GLASS_EVENT.TRADELOCKER_ACCOUNT_CHANGED, {
            accountId: Number(match.id),
            accNum: Number(match.accNum),
            source: 'telegram',
            atMs: Date.now()
          });
        } catch {
          // ignore renderer event dispatch failures
        }
        if (api?.getSnapshot) {
          const snapRes = await api.getSnapshot({ includeOrders: false });
          if (snapRes?.ok && Array.isArray(snapRes.positions)) {
            positions = snapRes.positions
              .map((p: any) => ({
                id: String(p?.id || ''),
                symbol: String(p?.symbol || ''),
                size: Number(p?.size),
                entryPrice: Number(p?.entryPrice)
              }))
              .filter((p: any) => p.id && p.symbol);
          }
        }
      }
      const matches = (symbol: string) => {
        if (!requestedSymbol) return true;
        const targetKeys = buildSymbolKeyVariantsShared(requestedSymbol).map((v) => String(v).toUpperCase());
        const posKeys = buildSymbolKeyVariantsShared(symbol).map((v) => String(v).toUpperCase());
        return posKeys.some((key) => targetKeys.includes(key));
      };
      let targets = positions.filter((pos) => pos?.symbol && matches(String(pos.symbol)));
      if (!requestedSymbol && targets.length !== 1) {
        await sendTelegramText('Multiple TradeLocker positions open. Specify a symbol.', chatId);
        return;
      }
      if (targets.length === 0) {
        await sendTelegramText('No matching TradeLocker positions found.', chatId);
        return;
      }

      if (input.isBreakeven) {
        const results: Array<{ ok: boolean; error?: string }> = [];
        for (const pos of targets) {
          const entry = Number(pos?.entryPrice);
          if (!Number.isFinite(entry) || entry <= 0) {
            results.push({ ok: false, error: 'Missing entry price.' });
            continue;
          }
          const res = await executeBrokerActionViaApi({
            type: 'MODIFY_POSITION',
            positionId: String(pos.id),
            symbol: String(pos.symbol || ''),
            stopLoss: entry,
            source: 'telegram',
            reason: 'Telegram breakeven'
          });
          results.push({ ok: !!res?.ok, error: res?.error });
        }
        const okCount = results.filter((r) => r.ok).length;
        const failCount = results.length - okCount;
        await sendTelegramText(
          `TradeLocker breakeven: ${okCount}/${results.length} updated${failCount ? `, ${failCount} failed` : ''}.`,
          chatId
        );
        return;
      }

      const results: Array<{ ok: boolean; error?: string }> = [];
      for (const pos of targets) {
        const size = Number(pos?.size);
        let qty = 0;
        if (qtySpec && Number.isFinite(size) && size > 0) {
          if (qtySpec.mode === 'fraction') {
            qty = Math.max(0, size * qtySpec.value);
          } else {
            qty = Math.max(0, qtySpec.value);
          }
          if (qty >= size) qty = 0;
        }
        const res = await executeBrokerActionViaApi({
          type: 'CLOSE_POSITION',
          positionId: String(pos.id),
          symbol: String(pos.symbol || ''),
          qty: qty > 0 ? qty : undefined,
          source: 'telegram',
          reason: 'Telegram close'
        });
        results.push({ ok: !!res?.ok, error: res?.error });
      }
      const okCount = results.filter((r) => r.ok).length;
      const failCount = results.length - okCount;
      await sendTelegramText(
        `TradeLocker close: ${okCount}/${results.length} sent${failCount ? `, ${failCount} failed` : ''}.`,
        chatId
      );
      return;
    }

    const mt5PositionsRes = await fetchMt5('/positions');
    const mt5Positions = Array.isArray(mt5PositionsRes.data?.positions) ? mt5PositionsRes.data.positions : [];
    const matches = (symbol: string) => {
      if (!requestedSymbol) return true;
      const targetKey = normalizeSymbolKeyShared(requestedSymbol);
      const posKey = normalizeSymbolKeyShared(symbol);
      return targetKey && posKey === targetKey;
    };
    let targets = mt5Positions.filter((pos) => pos?.symbol && matches(String(pos.symbol)));
    if (!requestedSymbol && targets.length !== 1) {
      await sendTelegramText('Multiple MT5 positions open. Specify a symbol.', chatId);
      return;
    }
    if (targets.length === 0) {
      await sendTelegramText('No matching MT5 positions found.', chatId);
      return;
    }

    if (input.isBreakeven) {
      const results: Array<{ ok: boolean; error?: string }> = [];
      for (const pos of targets) {
        const entry = Number(pos?.price_open ?? pos?.price);
        if (!Number.isFinite(entry) || entry <= 0) {
          results.push({ ok: false, error: 'Missing entry price.' });
          continue;
        }
        const res = await fetchMt5('/position/modify', {
          method: 'POST',
          body: JSON.stringify({ position: pos?.ticket ?? pos?.position ?? pos?.id, sl: entry })
        });
        results.push({ ok: !!res?.ok, error: res?.error });
      }
      const okCount = results.filter((r) => r.ok).length;
      const failCount = results.length - okCount;
      await sendTelegramText(`MT5 breakeven: ${okCount}/${results.length} updated${failCount ? `, ${failCount} failed` : ''}.`, chatId);
      return;
    }

    const results: Array<{ ok: boolean; error?: string }> = [];
    for (const pos of targets) {
      const size = Number(pos?.volume);
      let volume: number | null = null;
      if (qtySpec && Number.isFinite(size) && size > 0) {
        if (qtySpec.mode === 'fraction') {
          volume = Math.max(0, size * qtySpec.value);
        } else {
          volume = Math.max(0, qtySpec.value);
        }
        if (volume >= size) volume = null;
      }
      const payload: any = { position: pos?.ticket ?? pos?.position ?? pos?.id };
      if (volume != null && volume > 0) payload.volume = volume;
      const res = await fetchMt5('/position/close', { method: 'POST', body: JSON.stringify(payload) });
      results.push({ ok: !!res?.ok, error: res?.error });
    }
    const okCount = results.filter((r) => r.ok).length;
    const failCount = results.length - okCount;
    await sendTelegramText(`MT5 close: ${okCount}/${results.length} sent${failCount ? `, ${failCount} failed` : ''}.`, chatId);
  }, [appendAuditEvent, executeBrokerActionViaApi, fetchMt5, sendTelegramText]);

  const executeTelegramPendingAction = useCallback(async (pending: TelegramPendingAction) => {
    const chatId = pending.chatId;
    if (pending.kind === 'manage_positions') {
      const broker = pending.payload.broker || 'mt5';
      await runTelegramManageAction({
        chatId,
        broker,
        requestedSymbol: pending.payload.requestedSymbol || null,
        isBreakeven: !!pending.payload.isBreakeven,
        qtySpec: pending.payload.qtySpec || null,
        accountHint: pending.payload.accountHint || null
      });
      return;
    }

    const entryId = pending.payload.entryId || '';
    const entry = resolveTelegramSignalEntry(entryId);
    if (!entry) {
      await sendTelegramText('Signal not found or expired.', chatId);
      return;
    }
    if (pending.kind === 'signal_execute') {
      await runTelegramSignalAction({
        type: 'execute',
        entry,
        chatId,
        forceBroker: pending.payload.forceBroker || null
      });
      return;
    }
    if (pending.kind === 'signal_reject') {
      await runTelegramSignalAction({ type: 'reject', entry, chatId });
      return;
    }
    if (pending.kind === 'signal_cancel') {
      await runTelegramSignalAction({ type: 'cancel', entry, chatId });
    }
  }, [resolveTelegramSignalEntry, runTelegramManageAction, runTelegramSignalAction, sendTelegramText]);



  const isVisionCapableModelName = useCallback((value: string) => {
    const model = String(value || '').trim().toLowerCase();
    if (!model) return false;
    return model.startsWith('gpt-5.2');
  }, []);

  const resolveVisionSupport = useCallback(() => {
    try {
      const bridge = (window as any)?.glass?.openai;
      if (bridge) return { ok: true as const };
    } catch {
      // ignore
    }
    const readEnv = (key: string) => {
      try {
        const metaEnv = (import.meta as any)?.env;
        if (metaEnv && metaEnv[key]) return String(metaEnv[key] || '').trim();
      } catch {
        // ignore
      }
      try {
        const procEnv = (globalThis as any)?.process?.env;
        if (procEnv && procEnv[key]) return String(procEnv[key] || '').trim();
      } catch {
        // ignore
      }
      return '';
    };
    let apiKey = '';
    try {
      apiKey = String(localStorage.getItem('glass_openai_api_key') || '').trim();
    } catch {
      // ignore
    }
    if (!apiKey) apiKey = readEnv('OPENAI_API_KEY') || readEnv('API_KEY');
    if (!apiKey) return { ok: false as const, error: 'OpenAI API key missing for vision actions.' };

    let model = '';
    try {
      model = String(localStorage.getItem('glass_openai_vision_model') || '').trim();
    } catch {
      // ignore
    }
    if (!model) model = readEnv('OPENAI_VISION_MODEL') || readEnv('OPENAI_MODEL') || 'gpt-5.2';
    if (!isVisionCapableModelName(model)) {
      return { ok: false as const, error: `Vision model "${model}" does not support images.` };
    }
    return { ok: true as const };
  }, [isVisionCapableModelName]);

  const getNativeChartReadiness = useCallback((opts?: { requireData?: boolean }) => {
    const chart = nativeChartRef.current;
    if (!chart) {
      return { ok: false as const, message: 'Native chart not ready yet.' };
    }
    if (!opts?.requireData) return { ok: true as const };
    const meta = chart.getMeta ? chart.getMeta() : null;
    const frames = Array.isArray(meta?.frames) ? meta.frames : [];
    const hasBars = frames.some((frame) => Number(frame?.bars || 0) > 0);
    const updatedAtMs = Number(meta?.updatedAtMs || 0);
    if (!hasBars || !updatedAtMs) {
      return { ok: false as const, message: 'Native chart data not ready yet.' };
    }
    return { ok: true as const };
  }, []);

  const waitForNativeChartReady = useCallback(async (opts?: { requireData?: boolean; timeoutMs?: number }) => {
    const timeoutMs = Number.isFinite(Number(opts?.timeoutMs))
      ? Math.max(300, Math.floor(Number(opts?.timeoutMs)))
      : 2000;
    const sleep = (ms: number) => sleepMs(ms);
    if (!nativeChartMounted) setNativeChartMounted(true);
    const startedAt = Date.now();
    while (Date.now() - startedAt < timeoutMs) {
      const ready = getNativeChartReadiness({ requireData: opts?.requireData });
      if (ready.ok) return { ok: true as const };
      await sleep(250);
    }
    return {
      ok: false as const,
      code: 'chart_not_ready',
      error: opts?.requireData ? 'Native chart data not ready yet.' : 'Native chart not ready yet.',
      retryAfterMs: 800
    };
  }, [getNativeChartReadiness, nativeChartMounted, setNativeChartMounted]);

  const evaluateActionSafety = useCallback((input: {
    actionId: string;
    payload?: Record<string, any> | null;
    source?: string | null;
  }) => {
    const actionId = String(input.actionId || '').trim();
    const definition = getActionDefinitionCached(actionId);
    const safety = definition?.safety || { gates: [], requiresConfirmation: false };
    const gates = Array.isArray(safety.gates) ? safety.gates : [];
    const payload = input.payload && typeof input.payload === 'object' ? input.payload : {};
    const now = Date.now();
    const source = String(input.source || '').toLowerCase();
    const tlMeta = tradeLockerExecRef.current || {};
    const issues: Array<{ code: string; message: string; retryAfterMs?: number }> = [];
    const requiresChartData = CHART_DATA_ACTIONS.has(actionId);

    const requiresVision = definition?.requiresVision === true;
    if (requiresVision) {
      const vision = resolveVisionSupport();
      if (!vision.ok) {
        issues.push({
          code: 'vision_unavailable',
          message: vision.error || 'Vision model unavailable.'
        });
      }
    }

    const requiresBroker = definition?.requiresBroker === true;
    if (requiresBroker) {
      let hasBrokerBridge = false;
      try {
        hasBrokerBridge = !!(window as any)?.glass?.tradelocker;
      } catch {
        hasBrokerBridge = false;
      }
      if (!hasBrokerBridge) {
        issues.push({
          code: 'broker_unavailable',
          message: 'Broker integration unavailable.'
        });
      }
    }

    const confirmed = payload.confirmed === true || payload.confirmation === true || payload.confirm === true;
    const requiresConfirmation = !!safety.requiresConfirmation || gates.includes('confirmation');

    if (gates.includes('risk')) {
      const actionType = String(payload.actionType || payload.type || '').trim().toUpperCase();
      const riskIncreaseTypes = new Set(['OPEN_POSITION', 'PLACE_ORDER', 'INCREASE_POSITION']);
      const clearsStopLoss = payload.clearStopLoss === true;
      const riskIncreaseByType =
        riskIncreaseTypes.has(actionType) ||
        ((actionType === 'MODIFY_POSITION' || actionType === 'MODIFY_ORDER') && clearsStopLoss);
      const riskIncrease = payload.riskIncrease === true || riskIncreaseByType;
      if (actionId === 'broker.action.execute' && riskIncrease && !confirmed) {
        issues.push({
          code: 'risk_requires_confirmation',
          message: 'Risk-increasing broker action requires confirmation.'
        });
      }
    }

    if (requiresConfirmation) {
      if (!confirmed) {
        issues.push({ code: 'confirmation_required', message: 'Action requires confirmation.' });
      }
    }

    if (gates.includes('broker_connected')) {
      if (!tlMeta.connected) {
        issues.push({ code: 'broker_not_connected', message: 'Broker is not connected.' });
      }
    }

    if (gates.includes('broker_trading_enabled')) {
      if (!tlMeta.tradingEnabled) {
        issues.push({ code: 'broker_trading_disabled', message: 'Broker trading is disabled.' });
      }
    }

    if (BROKER_WRITE_ACTIONS.has(actionId)) {
      const upstreamUntil = Number(tlMeta.upstreamBlockedUntilMs || 0);
      if (Number.isFinite(upstreamUntil) && upstreamUntil > now) {
        const detail = tlMeta.upstreamLastError ? ` ${String(tlMeta.upstreamLastError)}` : '';
        issues.push({
          code: 'broker_upstream_unavailable',
          message: `TradeLocker upstream unavailable.${detail}`.trim(),
          retryAfterMs: upstreamUntil - now
        });
      }
    }

    if (gates.includes('autopilot_enabled')) {
      const cfg = autoPilotConfigRef.current || {};
      if (!cfg.enabled) {
        issues.push({ code: 'autopilot_disabled', message: 'AutoPilot is disabled.' });
      }
    }

    if (gates.includes('rate_limit')) {
      const suppressUntil = Number(brokerRateLimitSuppressUntilMs || 0);
      if (Number.isFinite(suppressUntil) && suppressUntil > now) {
        issues.push({
          code: 'rate_limited',
          message: 'Rate limit active. Retry later.',
          retryAfterMs: suppressUntil - now
        });
      }
    }

    if (gates.includes('chart_ready')) {
      const readiness = getNativeChartReadiness({ requireData: requiresChartData });
      if (!readiness.ok) {
        if (!nativeChartMounted) setNativeChartMounted(true);
        issues.push({
          code: 'chart_not_ready',
          message: readiness.message || 'Native chart not ready yet.',
          retryAfterMs: 800
        });
      }
    }

    if (gates.includes('backtester_ready')) {
      const summary = backtesterRef.current?.getSummary?.();
      if ((actionId === 'backtest.summary' || actionId === 'backtest.training_pack') && !summary) {
        issues.push({ code: 'backtester_unavailable', message: 'Backtester summary unavailable.' });
      }
    }

    if (gates.includes('permissions')) {
      const agentId = String(payload.agentId || '').trim();
      const agentName = String(payload.agentName || '').trim().toLowerCase();
      if (agentId || agentName) {
        const list = agentsRef.current || [];
        const target = agentId
          ? list.find((agent) => agent.id === agentId)
          : list.find((agent) => agentName && agent.name.toLowerCase() === agentName);
        if (!target) {
          issues.push({ code: 'agent_not_found', message: 'Agent not found for permission check.' });
        } else {
          const caps = normalizeAgentCapabilities(target.capabilities);
          const isBrokerAction = actionId.startsWith('broker.') || actionId.startsWith('trade.');
          const needsBroker = isBrokerAction;
          const needsTools = !isBrokerAction;
          if (needsBroker && !caps.broker) {
            issues.push({ code: 'agent_broker_denied', message: 'Agent broker permission is disabled.' });
          }
          if (needsTools && !caps.tools) {
            issues.push({ code: 'agent_tools_denied', message: 'Agent tools permission is disabled.' });
          }
        }
      }
    }

    if (gates.includes('risk')) {
      const riskPct = Number(payload.riskPercent ?? payload.riskPct ?? payload.riskPerTrade ?? payload.risk);
      const cfg = autoPilotConfigRef.current || {};
      if (Number.isFinite(riskPct) && Number.isFinite(Number(cfg?.riskPerTrade))) {
        const cap = Number(cfg.riskPerTrade);
        if (riskPct > cap) {
          issues.push({ code: 'risk_exceeds_cap', message: 'Risk exceeds configured limit.' });
        }
      }
      if (source.includes('autopilot') && cfg?.killSwitch) {
        issues.push({ code: 'autopilot_killswitch', message: 'AutoPilot kill switch is ON.' });
      }
    }

    if (issues.length > 0) {
      const first = issues[0];
      void appendAuditEvent({
        eventType: 'action_blocked',
        level: 'warn',
        payload: {
          actionId,
          reason: first.code,
          message: first.message,
          retryAfterMs: first.retryAfterMs ?? null
        }
      });
      return { ok: false as const, error: first.message, code: first.code, retryAfterMs: first.retryAfterMs ?? null };
    }

    return { ok: true as const };
  }, [
    appendAuditEvent,
    brokerRateLimitSuppressUntilMs,
    getNativeChartReadiness,
    nativeChartMounted,
    normalizeAgentCapabilities,
    resolveVisionSupport,
    setNativeChartMounted
  ]);

  const ACTION_TRACE_LIMITS = {
    maxDepth: 2,
    maxKeys: 25,
    maxItems: 25,
    maxString: 220
  };

  const sanitizeActionTraceValue = useCallback((value: any, depth = 0): any => {
    if (value == null) return value;
    if (depth > ACTION_TRACE_LIMITS.maxDepth) return null;
    if (typeof value === 'string') {
      if (value.length <= ACTION_TRACE_LIMITS.maxString) return value;
      return `${value.slice(0, ACTION_TRACE_LIMITS.maxString)}...`;
    }
    if (typeof value === 'number' || typeof value === 'boolean') return value;
    if (Array.isArray(value)) {
      return value.slice(0, ACTION_TRACE_LIMITS.maxItems).map((entry) => sanitizeActionTraceValue(entry, depth + 1));
    }
    if (typeof value === 'object') {
      const entries = Object.entries(value).slice(0, ACTION_TRACE_LIMITS.maxKeys);
      const next: Record<string, any> = {};
      for (const [key, entry] of entries) {
        next[key] = sanitizeActionTraceValue(entry, depth + 1);
      }
      return next;
    }
    return null;
  }, []);

  const normalizeIntentLabel = useCallback((raw: any) => {
    const text = String(raw || '').trim();
    if (!text) return '';
    if (text.length <= 120) return text;
    return `${text.slice(0, 116)}...`;
  }, []);

  const deriveIntentKey = useCallback((input: {
    actionId: string;
    payload?: Record<string, any>;
    source?: string | null;
  }) => {
    const payload = input.payload && typeof input.payload === 'object' ? input.payload : {};
    const playbookId = payload.playbookId ? String(payload.playbookId).trim() : '';
    if (playbookId) return `playbook:${playbookId}`;
    const rawSource = String(input.source || payload.source || '').trim();
    if (rawSource && rawSource.toLowerCase().startsWith('playbook:')) return rawSource;
    const intentRaw = payload.intentKey || payload.intent || payload.reason || '';
    if (intentRaw) return `intent_${hashStringSampled(String(intentRaw), 512)}`;
    return input.actionId;
  }, []);

  const deriveIntentLabel = useCallback((input: {
    actionId: string;
    payload?: Record<string, any>;
    source?: string | null;
  }) => {
    const payload = input.payload && typeof input.payload === 'object' ? input.payload : {};
    if (payload.playbookId) return `Playbook ${payload.playbookId}`;
    if (payload.intentLabel) return normalizeIntentLabel(payload.intentLabel);
    if (payload.intentKey) return normalizeIntentLabel(payload.intentKey);
    if (payload.intent) return normalizeIntentLabel(payload.intent);
    if (payload.reason) return normalizeIntentLabel(payload.reason);
    const rawSource = String(input.source || payload.source || '').trim();
    if (rawSource) return normalizeIntentLabel(rawSource);
    return input.actionId;
  }, [normalizeIntentLabel]);

  const updateRecommendedActionFlows = useCallback(() => {
    const flows: ActionFlowRecommendation[] = [];
    for (const state of actionFlowStateRef.current.values()) {
      for (const entry of state.sequences.values()) {
        flows.push({
          intentKey: state.intentKey,
          intentLabel: state.intentLabel || null,
          symbol: state.symbol || null,
          timeframe: state.timeframe || null,
          sequence: entry.sequence,
          count: entry.count,
          successRate: entry.count > 0 ? entry.successCount / entry.count : 0,
          lastSeenAtMs: entry.lastSeenAtMs
        });
      }
    }
    flows.sort((a, b) => (b.count - a.count) || ((b.lastSeenAtMs || 0) - (a.lastSeenAtMs || 0)));
    setRecommendedActionFlowsState(flows.slice(0, 12));
  }, []);
  updateRecommendedActionFlowsRef.current = updateRecommendedActionFlows;

  const updateActionFlowMemory = useCallback(async (trace: {
    intentKey: string;
    intentLabel?: string | null;
    actionId: string;
    ok: boolean;
    finishedAtMs: number;
    symbol?: string | null;
    timeframe?: string | null;
    source?: string | null;
  }) => {
    const intentKey = trace.intentKey;
    if (!intentKey) return;
    const now = trace.finishedAtMs || Date.now();
    const windowMs = 10 * 60 * 1000;
    const maxRecent = 20;
    const maxSeq = 4;
    const state = actionFlowStateRef.current.get(intentKey) || {
      intentKey,
      intentLabel: trace.intentLabel || null,
      symbol: trace.symbol || null,
      timeframe: trace.timeframe || null,
      sequences: new Map<string, { sequence: string[]; count: number; successCount: number; lastSeenAtMs: number }>(),
      recent: [] as Array<{ actionId: string; ok: boolean; atMs: number }>
    };

    state.intentLabel = trace.intentLabel || state.intentLabel || null;
    if (trace.symbol) state.symbol = trace.symbol;
    if (trace.timeframe) state.timeframe = trace.timeframe;
    state.recent = state.recent.filter((entry) => now - entry.atMs <= windowMs);
    state.recent.push({ actionId: trace.actionId, ok: trace.ok, atMs: now });
    if (state.recent.length > maxRecent) state.recent.splice(0, state.recent.length - maxRecent);

    const seqLimit = Math.min(maxSeq, state.recent.length);
    for (let len = 2; len <= seqLimit; len += 1) {
      const sequence = state.recent.slice(state.recent.length - len).map((entry) => entry.actionId);
      const key = sequence.join(' > ');
      const existing = state.sequences.get(key) || { sequence, count: 0, successCount: 0, lastSeenAtMs: now };
      existing.count += 1;
      if (trace.ok) existing.successCount += 1;
      existing.lastSeenAtMs = now;
      state.sequences.set(key, existing);
    }

    actionFlowStateRef.current.set(intentKey, state);
    actionFlowUpdatedAtRef.current = now;

    const sequences = Array.from(state.sequences.values())
      .sort((a, b) => (b.count - a.count) || (b.lastSeenAtMs - a.lastSeenAtMs))
      .slice(0, 8)
      .map((entry) => ({
        sequence: entry.sequence,
        count: entry.count,
        successCount: entry.successCount,
        successRate: entry.count > 0 ? entry.successCount / entry.count : 0,
        lastSeenAtMs: entry.lastSeenAtMs
      }));

    const ledger = window.glass?.tradeLedger;
    if (ledger?.upsertAgentMemory) {
      await ledger.upsertAgentMemory({
        key: `action_flow:${intentKey}`,
        familyKey: 'action_flow',
        scope: 'shared',
        category: 'action',
        subcategory: 'flow',
        kind: 'action_flow',
        symbol: trace.symbol || null,
        timeframe: trace.timeframe || null,
        summary: `${state.intentLabel || intentKey}`,
        payload: {
          intentKey,
          intentLabel: state.intentLabel || null,
          sequences,
          updatedAtMs: now
        },
        source: trace.source || null,
        tags: ['action_flow', intentKey].filter(Boolean)
      });
    }
    updateRecommendedActionFlows();
  }, [updateRecommendedActionFlows]);

  const resolveActionFlowByIntent = useCallback((input: {
    intentKey?: string | null;
    sequence?: string[] | string | null;
    index?: number | null;
  }) => {
    const intentKey = String(input.intentKey || '').trim();
    const rawSequence = input.sequence;
    const index = Number.isFinite(Number(input.index)) ? Math.max(0, Math.floor(Number(input.index))) : null;

    const normalizeSequence = (value: string[] | string | null | undefined) => {
      if (!value) return [];
      if (Array.isArray(value)) return value.map((entry) => String(entry).trim()).filter(Boolean);
      const parts = String(value).split('>').map((entry) => entry.trim()).filter(Boolean);
      if (parts.length > 0) return parts;
      return String(value).split(',').map((entry) => entry.trim()).filter(Boolean);
    };

    const desiredSequence = normalizeSequence(rawSequence);
    const pickFromList = (list: Array<{ sequence: string[]; count: number; successCount?: number; lastSeenAtMs?: number }>) => {
      if (list.length === 0) return null;
      if (desiredSequence.length > 0) {
        const match = list.find((entry) => entry.sequence.join(' > ') === desiredSequence.join(' > '));
        if (match) return match;
      }
      if (index != null && index < list.length) return list[index];
      return list[0];
    };

    if (intentKey) {
      const state = actionFlowStateRef.current.get(intentKey);
      if (state) {
        const list = Array.from(state.sequences.values())
          .sort((a, b) => (b.count - a.count) || (b.lastSeenAtMs - a.lastSeenAtMs));
        const selected = pickFromList(list);
        if (selected) {
          return {
            intentKey,
            intentLabel: state.intentLabel || null,
            symbol: state.symbol || null,
            timeframe: state.timeframe || null,
            sequence: selected.sequence,
            count: selected.count,
            successRate: selected.count > 0 ? (Number(selected.successCount) || 0) / selected.count : 0,
            lastSeenAtMs: selected.lastSeenAtMs
          } as ActionFlowRecommendation;
        }
      }
    }

    const pool = Array.isArray(recommendedActionFlowsState) ? recommendedActionFlowsState : [];
    const candidates = intentKey ? pool.filter((flow) => flow.intentKey === intentKey) : pool;
    if (candidates.length === 0) return null;
    if (desiredSequence.length > 0) {
      const match = candidates.find((flow) => flow.sequence.join(' > ') === desiredSequence.join(' > '));
      if (match) return match;
    }
    if (index != null && index < candidates.length) return candidates[index];
    return candidates[0];
  }, [recommendedActionFlowsState]);

  const resolveActionFlowIntent = useCallback((text: string) => {
    const raw = String(text || '').trim();
    if (!raw) return null;
    const normalized = raw.toLowerCase();
    const intentKey = `intent_${hashStringSampled(raw, 512)}`;
    const flows = Array.isArray(recommendedActionFlowsState) ? recommendedActionFlowsState : [];
    const exact = flows.find((flow) => flow.intentKey === intentKey);
    if (exact) return exact;
    let best: ActionFlowRecommendation | null = null;
    let bestScore = 0;
    let bestMatched = false;
    for (const flow of flows) {
      const labelRaw = String(flow.intentLabel || flow.intentKey || '').trim().toLowerCase();
      if (!labelRaw) continue;
      let score = 0;
      let matched = false;
      if (normalized.includes(labelRaw)) {
        score += 3;
        matched = true;
      }
      if (labelRaw.includes(normalized)) {
        score += 2;
        matched = true;
      }
      score += Math.min(2, Math.max(0, flow.successRate || 0));
      score += Math.min(2, Math.max(0, (flow.count || 0) / 3));
      if (score > bestScore) {
        bestScore = score;
        best = flow;
        bestMatched = matched;
      }
    }
    if (!best || !bestMatched) return null;
    return best;
  }, [recommendedActionFlowsState]);

  const recordActionTrace = useCallback(async (input: {
    actionId: string;
    payload?: Record<string, any>;
    source?: string | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    agentId?: string | null;
    agentName?: string | null;
    messageId?: string | null;
    correlationId?: string | null;
    runId?: string | null;
    kind?: 'action' | 'tool';
    startedAtMs: number;
  }, result: { ok: boolean; error?: string | null; code?: string | null; data?: Record<string, any> | null }) => {
    const payload = input.payload && typeof input.payload === 'object' ? input.payload : {};
    const source = String(input.source || payload.source || '').trim();
    const shouldLog = !!(input.agentId || input.agentName || source.includes('agent') || source.includes('autopilot') || source.includes('playbook'));
    if (!shouldLog) return;

    const finishedAtMs = Date.now();
    const intentKey = deriveIntentKey({ actionId: input.actionId, payload, source });
    const intentLabel = deriveIntentLabel({ actionId: input.actionId, payload, source });
    const traceId = `action_trace_${hashStringSampled(`${intentKey}:${input.actionId}:${finishedAtMs}`, 2048)}`;
    const tracePayload = {
      id: traceId,
      intentKey,
      intentLabel,
      actionId: input.actionId,
      actionKind: input.kind || 'action',
      ok: !!result.ok,
      error: result.error || null,
      code: result.code || null,
      startedAtMs: input.startedAtMs,
      finishedAtMs,
      durationMs: Math.max(0, finishedAtMs - input.startedAtMs),
      source: source || null,
      symbol: input.symbol || payload.symbol || null,
      timeframe: input.timeframe || payload.timeframe || null,
      strategy: input.strategy || payload.strategy || null,
      agentId: input.agentId || payload.agentId || null,
      agentName: input.agentName || payload.agentName || null,
      messageId: input.messageId || payload.messageId || null,
      correlationId: input.correlationId || payload.correlationId || null,
      runId: input.runId || payload.runId || null,
      payload: sanitizeActionTraceValue(payload)
    };
    const ledger = window.glass?.tradeLedger;
    if (ledger?.upsertAgentMemory) {
      await ledger.upsertAgentMemory({
        id: traceId,
        key: traceId,
        familyKey: `intent:${intentKey}`,
        kind: 'action_trace',
        symbol: tracePayload.symbol || null,
        timeframe: tracePayload.timeframe || null,
        summary: `${intentLabel || intentKey} | ${input.actionId} | ${result.ok ? 'ok' : 'fail'}`,
        payload: tracePayload,
        source: source || null,
        tags: ['action_trace', intentKey, input.actionId].filter(Boolean)
      });
    }

    await updateActionFlowMemory({
      intentKey,
      intentLabel,
      actionId: input.actionId,
      ok: !!result.ok,
      finishedAtMs,
      symbol: tracePayload.symbol,
      timeframe: tracePayload.timeframe,
      source
    });
    void pruneActionTraceMemories();
  }, [deriveIntentKey, deriveIntentLabel, sanitizeActionTraceValue, updateActionFlowMemory, pruneActionTraceMemories]);
  recordActionTraceRef.current = recordActionTrace;

  const resolvePlaybookPath = useCallback((source: Record<string, any>, path: string) => {
    const parts = String(path || '').trim().split('.').filter(Boolean);
    let current: any = source;
    for (const part of parts) {
      if (current == null) return null;
      if (Array.isArray(current)) {
        const idx = Number(part);
        current = Number.isFinite(idx) ? current[idx] : null;
        continue;
      }
      current = (current as any)[part];
    }
    return current;
  }, []);

  const resolvePlaybookValue = useCallback((value: any, source: Record<string, any>) => {
    if (typeof value === 'string') {
      const trimmed = value.trim();
      const exactMatch = trimmed.match(/^\{\{\s*([^}]+)\s*\}\}$/);
      if (exactMatch) {
        return resolvePlaybookPath(source, exactMatch[1]);
      }
      if (trimmed.includes('{{')) {
        return trimmed.replace(/\{\{\s*([^}]+)\s*\}\}/g, (_match, token) => {
          const resolved = resolvePlaybookPath(source, token);
          return resolved == null ? '' : String(resolved);
        });
      }
      return value;
    }
    if (Array.isArray(value)) return value.map((item) => resolvePlaybookValue(item, source));
    if (value && typeof value === 'object') {
      const out: Record<string, any> = {};
      for (const [k, v] of Object.entries(value)) {
        out[k] = resolvePlaybookValue(v, source);
      }
      return out;
    }
    return value;
  }, [resolvePlaybookPath]);

  const chatSystemPrefix = [
    'You are Trading Desk Agents.',
    'Use structured broker + chart-engine data by default.',
    'Only request/attach images when the user explicitly asks to see visuals (e.g., "show me what you see", "analyze the snapshot").',
    'Prefer the SYMBOL SCOPE context for default symbol + multi-timeframe analysis.',
    'When using chat.* actions, set payload.channel="chat" to target the main chat.'
  ].join('\n');

  const { 
  messages, 
  sendMessage, 
  clearChat, 
  isThinking,
    replyMode,
    setReplyMode,
    autoTabVisionEnabled,
    setAutoTabVisionEnabled,
    chartWatchEnabled,
    setChartWatchEnabled,
    chartWatchMode,
    setChartWatchMode,
    chartWatchSnoozedUntilMs,
    snoozeChartWatch,
    clearChartWatchSnooze,
    chartWatchLeadAgentId,
    setChartWatchLeadAgentId,
    postTradeReviewEnabled,
    setPostTradeReviewEnabled,
    postTradeReviewAgentId,
    setPostTradeReviewAgentId,
    enqueuePostTradeReview,
    reviewLastClosedTrade,
    agents,
    activeAgentId,
    addAgent,
    updateAgent,
    deleteAgent,
    switchAgent,
    runChartWatchUpdate,
    isLive,
    liveMode,
    liveStream,
    startLiveSession,
    stopLiveSession,
    sendVideoFrame,
    speakMessage,
    speakingMessageId,
    sessionBias,
    setSessionBias,
    autoPilotConfig,
    setAutoPilotConfig,
    memories,
    addTradeMemory,
    addManualMemory,
    updateMemory: updateTradeMemory,
    deleteMemory: deleteTradeMemory,
    clearMemories: clearTradeMemories,
    executeTradeProposal,
    rejectTradeProposal,
    executeBrokerAction,
    rejectBrokerAction,
    cancelAgentTool
  } = useChat(executeTradeRequestViaApi, {
    getExternalContext: getContextPack,
    systemContextPrefix: chatSystemPrefix,
    onExecuteBrokerAction: executeBrokerActionViaApi,
    onExecuteAgentTool: executeAgentToolRequest,
    onCancelAgentTool: cancelAgentToolRequest,
    onAgentRequest: handleAgentRequest,
    defaultActionSource: 'chat',
    resolveActionFlowIntent
  });

  useEffect(() => {
    executeTradeProposalRef.current = executeTradeProposal;
  }, [executeTradeProposal]);

  useEffect(() => {
    const lastMessage = messages && messages.length > 0 ? messages[messages.length - 1] : null;
    const lastMessageAtMs = lastMessage?.timestamp ? lastMessage.timestamp.getTime() : null;
    chatStateRef.current = {
      ...chatStateRef.current,
      isThinking: !!isThinking,
      replyMode: replyMode != null ? String(replyMode) : null,
      isLive: !!isLive,
      liveMode: liveMode != null ? String(liveMode) : null,
      autoTabVisionEnabled: !!autoTabVisionEnabled,
      chartWatchEnabled: !!chartWatchEnabled,
      chartWatchMode: chartWatchMode != null ? String(chartWatchMode) : null,
      chartWatchSnoozedUntilMs: chartWatchSnoozedUntilMs ?? null,
      postTradeReviewEnabled: !!postTradeReviewEnabled,
      postTradeReviewAgentId: postTradeReviewAgentId != null ? String(postTradeReviewAgentId) : null,
      chartWatchLeadAgentId: chartWatchLeadAgentId != null ? String(chartWatchLeadAgentId) : null,
      sessionBias: sessionBias != null ? String(sessionBias) : null,
      activeAgentId: activeAgentId != null ? String(activeAgentId) : null,
      agentsCount: Array.isArray(agents) ? agents.length : 0,
      messagesCount: Array.isArray(messages) ? messages.length : 0,
      lastMessageAtMs
    };
  }, [
    activeAgentId,
    agents,
    autoTabVisionEnabled,
    chartWatchEnabled,
    chartWatchLeadAgentId,
    chartWatchMode,
    chartWatchSnoozedUntilMs,
    isLive,
    isThinking,
    liveMode,
    messages,
    postTradeReviewAgentId,
    postTradeReviewEnabled,
    replyMode,
    sessionBias
  ]);

  const executeCatalogAction = useCallback(async (input: {
    actionId: string;
    payload?: Record<string, any> | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    mode?: string | null;
    source?: string | null;
  }) => {
    const actionId = String(input?.actionId || '').trim();
    if (!actionId) return { ok: false, error: 'Missing actionId.' };

    const payloadRaw = input?.payload && typeof input.payload === 'object' ? input.payload : {};
    const payload = { ...payloadRaw } as Record<string, any>;
    const normalizeCatalogRuntimeResponse = (raw: any): { handled: boolean; result?: { ok: boolean; error?: string; data?: any } } => {
      if (!raw || typeof raw !== 'object') return { handled: false };
      if (typeof (raw as any).handled === 'boolean') return raw as any;
      if (typeof (raw as any).ok === 'boolean') return { handled: true, result: raw as any };
      return { handled: false };
    };
    const savedConfig = tlSavedConfigRef.current;
    const quoteMap = quotesBySymbolRef.current || {};
    const resolveChatChannel = (value: any) => {
      const raw = String(value || '').trim().toLowerCase();
      if (!raw) return 'chat';
      if (raw === 'chart' || raw === 'chartchat' || raw === 'chart_chat') return 'chart';
      return 'chat';
    };
    const sourceHint = String(input?.source || payload.source || '').toLowerCase();
    const sourceChannel = sourceHint.includes('chart') ? 'chart' : '';
    const chatChannel = resolveChatChannel(payload.channel || payload.scope || payload.target || payload.chat || sourceChannel);
    const chartHandlers = chartChatHandlersRef.current || {};
    const persistSetting = (key: string, value: any, opts?: { normalizeBool?: boolean }) => {
      try {
        const normalized =
          opts?.normalizeBool && typeof value === 'boolean'
            ? value
              ? '1'
              : '0'
            : value == null
              ? ''
              : String(value).trim();
        if (normalized) localStorage.setItem(key, normalized);
        else localStorage.removeItem(key);
      } catch {
        // ignore storage access issues
      }
    };
    await loadActionCatalogModule();
    const definition = getActionDefinitionCached(actionId);
    const chartGates = Array.isArray(definition?.safety?.gates) ? definition?.safety?.gates : [];
    if (chartGates.includes('chart_ready')) {
      const waitRes = await waitForNativeChartReady({
        requireData: CHART_DATA_ACTIONS.has(actionId),
        timeoutMs: Number.isFinite(Number(definition?.defaultTimeoutMs))
          ? Math.max(800, Math.floor(Number(definition?.defaultTimeoutMs)))
          : 2000
      });
      if (!waitRes.ok) {
        return { ok: false, error: waitRes.error || 'Native chart not ready yet.', code: waitRes.code, retryAfterMs: waitRes.retryAfterMs ?? null };
      }
    }
    const safety = evaluateActionSafety({
      actionId,
      payload,
      source: input?.source || payload.source
    });
    if (!safety.ok) {
      return { ok: false, error: safety.error || 'Action blocked.', code: safety.code, retryAfterMs: safety.retryAfterMs ?? null };
    }

    const toolType = getToolTypeForActionIdCached(actionId);
    if (toolType) {
      const action: AgentToolAction = {
        type: toolType,
        status: 'PENDING',
        ...payload
      };
      if (input?.symbol && action.symbol == null) action.symbol = input.symbol;
      if (input?.timeframe && action.timeframe == null) action.timeframe = input.timeframe;
      if (input?.strategy && action.strategy == null) action.strategy = input.strategy;
      if (input?.mode && action.mode == null) action.mode = input.mode;

      const result = await executeAgentToolRequest(action);
      if (!result.ok) {
        const detail = result.payload && typeof result.payload === 'object'
          ? (result.payload as any).detail
          : undefined;
        return { ok: false, error: result.text || 'Tool request failed.', data: result.payload ?? null, code: typeof detail === 'string' ? detail : undefined };
      }
      return { ok: true, data: result.payload ?? null, text: result.text || '' };
    }

    const brokerType = getBrokerActionTypeForActionIdCached(actionId);
    if (brokerType) {
      const action: BrokerAction = {
        type: brokerType,
        status: 'PENDING',
        ...payload
      };
      if (action.source == null && (input?.source || payload.source)) {
        action.source = input?.source || payload.source;
      }
      if (input?.symbol && action.symbol == null) action.symbol = input.symbol;
      const result = await executeBrokerActionViaApi(action);
      if (!result?.ok) {
        return { ok: false, error: result?.error || 'Broker action failed.', code: (result as any)?.code || undefined };
      }
      return { ok: true, data: result ?? null };
    }

    const resolveSidebarMode = (raw: any): SidebarMode | null => {
      const key = String(raw || '').trim().toLowerCase();
      if (!key) return null;
      if (key === 'chart' || key === 'nativechart' || key === 'native_chart') return 'nativechart';
      if (key === 'chartchat' || key === 'chart_chat') return 'chartchat';
      if (key === 'chat') return 'chat';
      if (key === 'patterns' || key === 'pattern') return 'patterns';
      if (key === 'snapshot' || key === 'snap') return 'snapshot';
      if (key === 'shadow') return 'shadow';
      if (key === 'notes') return 'notes';
      if (key === 'autopilot') return 'autopilot';
      if (key === 'signal' || key === 'signals') return 'signal';
      if (key === 'tradelocker' || key === 'trade') return 'tradelocker';
      if (key === 'backtester' || key === 'backtest') return 'backtester';
      if (key === 'setups' || key === 'setup') return 'setups';
      if (key === 'dashboard') return 'dashboard';
      if (key === 'agent' || key === 'agentcreator' || key === 'agent_creator' || key === 'creator') return 'agentcreator';
      if (key === 'memory' || key === 'agentmemory' || key === 'agent_memory') return 'agentmemory';
      if (key === 'agentlab' || key === 'agent_lab' || key === 'lab') return 'agentlab';
      if (key === 'audit') return 'audit';
      if (key === 'changes') return 'changes';
      if (key === 'mt5') return 'mt5';
      if (key === 'leaderboard') return 'leaderboard';
      return null;
    };

    {
      const uiRuntime = await loadCatalogUiRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await uiRuntime.runCatalogUiRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          sidebarControlRef,
          resolveSidebarMode,
          openCommandPalette,
          closeCommandPalette,
          setCommandPaletteOpen,
          setIsSettingsOpen,
          addTab,
          updateTab,
          tabsRef,
          activeTabIdRef,
          setActiveTabId,
          closeTab,
          setTabLabel,
          browserControlsRef,
          isFullscreen,
          setIsFullscreen
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'UI action failed.' };
    }
    {
      const playbookRuntime = await loadCatalogPlaybookRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await playbookRuntime.runCatalogPlaybookRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          enqueuePlaybookRunRef,
          definition,
          taskPlaybooksRef,
          upsertTaskPlaybook,
          resumePlaybookRunRef
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Playbook action failed.' };
    }
    {
      const chartRuntime = await loadCatalogChartRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await chartRuntime.runCatalogChartRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          chartEngine,
          chartWatchEnabled,
          setChartWatchEnabled,
          setChartWatchMode,
          snoozeChartWatch,
          clearChartWatchSnooze,
          setChartWatchLeadAgentId,
          nativeChartRef,
          persistChartSnapshotMemory,
          isChartFullscreen,
          setIsChartFullscreen,
          chartSessions,
          chatChannel,
          chartHandlers,
          setSessionBias,
          updateSymbolScope,
          normalizeScopeTimeframes,
          clearSymbolScope,
          activeTabIdRef,
          tabsRef
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Chart action failed.' };
    }
    {
      const tabsNow = tabsRef.current || [];
      const chatLiveRuntime = await loadCatalogChatLiveRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await chatLiveRuntime.runCatalogChatLiveRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          chatChannel,
          chartHandlers,
          setReplyMode,
          clearChat,
          activeTabIdRef,
          tabsNow,
          chartChatContextRef,
          normalizeTimeframeKey,
          sendMessage,
          setAutoTabVisionEnabled,
          startLiveSession,
          stopLiveSession,
          liveStream,
          setPostTradeReviewEnabled,
          setPostTradeReviewAgentId,
          reviewLastClosedTrade
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Chat/Live action failed.' };
    }
    {
      const settingsRuntime = await loadCatalogSettingsAutopilotRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await settingsRuntime.runCatalogSettingsAutopilotRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          persistSetting,
          setAutoPilotConfig,
          activeBrokerIdRef
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Settings/AutoPilot action failed.' };
    }
    {
      const brokerRuntime = await loadCatalogBrokerRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await brokerRuntime.runCatalogBrokerRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          refreshSnapshotRef,
          refreshQuotesRef,
          quoteMap,
          savedConfig,
          normalizeSymbolKey,
          executeBulkCancelOrdersViaApi,
          executeBulkClosePositionsViaApi,
          executeTicketOrderViaApi,
          tlSearchInstrumentsRef,
          tlPositionsRef,
          tlOrdersRef
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Broker action failed.' };
    }
    {
      const runtimeModule = await loadCatalogAgentRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await runtimeModule.runCatalogAgentRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          actionTaskTreeRunsState,
          addAgent,
          addManualMemory,
          agentTestPendingRef,
          agentsRef,
          buildAgentTestRun,
          buildAgentTestRunKey,
          buildShadowTradeCompare,
          buildTruthReplay,
          deleteAgent,
          deleteTradeMemory,
          enqueuePlaybookRunRef,
          executeAgentToolRequest,
          executeCatalogAction,
          getTechAgentLogs,
          handleReplayTaskTree,
          isEntryClosed,
          isShadowEntry,
          liveErrorsRef,
          loadAgentTestScenario,
          loadAuditActionRuntimeModule,
          loadChangesShadowActionRuntimeModule,
          loadNotesActionRuntimeModule,
          normalizeAgentTestScenario,
          normalizeSymbolKey,
          persistAgentTestRun,
          persistAgentTestScenario,
          refreshShadowTrades,
          resolveScenarioPlaybook,
          resumeTaskTreeRun,
          setShadowTradeCompare,
          setTimeout,
          shadowLedgerCacheRef,
          shadowTradeCompare,
          shadowTradeCompareAtRef,
          shadowTradeCompareRef,
          shadowTradeStats,
          shadowTradeStatsRef,
          switchAgent,
          taskTreeRunsState,
          updateAgentRef,
          updateTradeMemory
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Agent action failed.' };
    }
    {
      const runtimeModule = await loadCatalogOpsRuntimeModule();
      const runtimeRes = normalizeCatalogRuntimeResponse(await runtimeModule.runCatalogOpsRuntime({
        actionId,
        payload,
        requestContext: input,
        context: {
          backtestOptimizationCancelRef,
          backtesterRef,
          buildParamGridFromParams,
          buildSetupLibraryEntry,
          buildSetupLibraryTierKey,
          chartChatMessages,
          clearSetupSignals,
          definition,
          executeBrokerAction,
          executeChartChatBrokerAction,
          executeChartChatTradeProposal,
          executeTradeProposal,
          executeTradeProposalRef,
          formatExecutionSummary,
          formatValidationSummary,
          loadBacktestCatalogRuntimeModule,
          loadBacktestOptimizationHistory,
          loadBacktesterActionRuntimeModule,
          matchesSetupWatcher,
          messages,
          normalizeExecutionPresetKey,
          normalizeSetupMode,
          normalizeSetupStrategy,
          normalizeSetupTimeframe,
          normalizeSymbolKey,
          recommendedActionFlowsState,
          refreshSetupLibrary,
          rejectBrokerAction,
          rejectChartChatBrokerAction,
          rejectChartChatTradeProposal,
          rejectTradeProposal,
          resolveActionFlowByIntent,
          resolveExecutionConfig,
          runBacktestOptimization,
          runBacktestOptimizationWorker,
          runRecommendedActionFlowRef,
          setBacktesterMounted,
          setupWatchersRef,
          shouldReplaceLibraryEntry,
          sidebarControlRef,
          updateSetupWatcher,
          validateTradeProposalBasic
        }
      }));
      if (runtimeRes.handled) return runtimeRes.result || { ok: false, error: 'Catalog action failed.' };
    }
    return { ok: false, error: `Unsupported action: ${actionId}` };
  }, [
    chartEngine,
    chartSessions,
    buildSetupLibraryEntry,
    buildSetupLibraryTierKey,
    buildTruthReplay,
    evaluateActionSafety,
    addAgent,
    addManualMemory,
    addTab,
    closeCommandPalette,
    closeTab,
    deleteAgent,
    deleteTradeMemory,
    executeAgentToolRequest,
    executeBrokerActionViaApi,
    executeBulkCancelOrdersViaApi,
    executeBulkClosePositionsViaApi,
    executeTicketOrderViaApi,
    isChartFullscreen,
    isFullscreen,
    openCommandPalette,
    persistChartSnapshotMemory,
    refreshSetupLibrary,
    recommendedActionFlowsState,
    resolveActionFlowByIntent,
    setActiveTabId,
    setAutoPilotConfig,
    setBacktesterMounted,
    setCommandPaletteOpen,
    setIsChartFullscreen,
    setIsFullscreen,
    setIsSettingsOpen,
    setSessionBias,
    setTabLabel,
    shouldReplaceLibraryEntry,
    switchAgent,
    updateTab,
    updateSetupWatcher,
    updateTradeMemory,
    upsertTaskPlaybook
  ]);

  const ensureTaskPlaybook = useCallback((input?: { playbookId?: string | null; playbook?: TaskPlaybook | null }) => {
    const explicit = input?.playbook ? normalizeTaskPlaybook(input.playbook) : null;
    if (explicit) return explicit;
    const id = String(input?.playbookId || '').trim();
    const library = taskPlaybooksRef.current || [];
    if (id) {
      const found = library.find((p) => p.id === id);
      if (found) return found;
    }
    const fallback = library.find((p) => p.id === 'playbook.trade_session_mtf.v1');
    return fallback || buildDefaultTradeSessionPlaybook();
  }, []);

  const persistAgentTestScenario = useCallback(async (scenario: AgentTestScenario) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return { ok: false, error: 'Agent memory unavailable.' };
    const entry = buildAgentTestScenarioMemoryEntry(scenario);
    const res = await ledger.upsertAgentMemory(entry);
    if (!res?.ok) return { ok: false, error: res?.error || 'Failed to save test scenario.' };
    return { ok: true, data: { scenario } };
  }, []);

  const seedAgentTestScenarios = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.listAgentMemory) return;
    try {
      const existing = await ledger.listAgentMemory({ limit: 1, kind: 'agent_test_scenario' });
      if (existing?.ok && Array.isArray(existing.memories) && existing.memories.length > 0) return;
    } catch {
      // ignore list failures
    }

    const seeds = [
      {
        id: 'core_system_snapshot',
        name: 'Core: System snapshot',
        description: 'Fetch a consolidated system state snapshot.',
        steps: [{ actionId: 'system.snapshot' }],
        expected: { status: 'completed', minStepsCompleted: 1 },
        tags: ['core', 'snapshot']
      },
      {
        id: 'core_symbol_scope_roundtrip',
        name: 'Core: Symbol scope roundtrip',
        description: 'Set and clear the symbol scope.',
        steps: [
          {
            actionId: 'symbol.scope.set',
            payload: { symbol: 'EURUSD', timeframes: ['4h', '1h', '15m'], source: 'agent_test' }
          },
          { actionId: 'symbol.scope.clear' }
        ],
        expected: { status: 'completed', minStepsCompleted: 2 },
        tags: ['core', 'symbol_scope']
      },
      {
        id: 'core_chart_engine_snapshot',
        name: 'Core: Chart engine snapshot',
        description: 'Fetch chart engine session snapshots.',
        steps: [{ actionId: 'chart.engine.snapshot', payload: { barsLimit: 1, eventsLimit: 1 } }],
        expected: { status: 'completed', minStepsCompleted: 1 },
        tags: ['core', 'chart']
      },
      {
        id: 'core_diagnostics_export',
        name: 'Core: Diagnostics export',
        description: 'Build a diagnostics bundle for system state.',
        steps: [
          {
            actionId: 'diagnostics.export',
            payload: {
              mode: 'return',
              detail: 'summary',
              includeAudit: false,
              includeErrors: false,
              includeTechLogs: false
            }
          }
        ],
        expected: { status: 'completed', minStepsCompleted: 1 },
        tags: ['core', 'diagnostics']
      },
      {
        id: 'core_agent_runner_status',
        name: 'Core: Agent runner status',
        description: 'Check the agent runner service status.',
        steps: [{ actionId: 'agent_runner.status' }],
        expected: { status: 'completed', minStepsCompleted: 1 },
        tags: ['core', 'agent']
      }
    ];

    for (const seed of seeds) {
      const scenario = normalizeAgentTestScenario(seed);
      if (!scenario) continue;
      await persistAgentTestScenario(scenario);
    }
  }, [persistAgentTestScenario]);

  useEffect(() => {
    void seedAgentTestScenarios();
  }, [seedAgentTestScenarios]);

  const persistAgentTestRun = useCallback(async (run: AgentTestRun, scenario?: AgentTestScenario | null) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return { ok: false, error: 'Agent memory unavailable.' };
    const entry = buildAgentTestRunMemoryEntry(run, scenario || null);
    const res = await ledger.upsertAgentMemory(entry);
    if (!res?.ok) return { ok: false, error: res?.error || 'Failed to save test run.' };
    return { ok: true };
  }, []);

  const loadAgentTestScenario = useCallback(async (input: { id?: string | null; key?: string | null }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.getAgentMemory) return { ok: false, error: 'Agent memory unavailable.' };
    const rawId = input.id ? String(input.id).trim() : '';
    const rawKey = input.key ? String(input.key).trim() : '';
    const idIsKey = rawId.startsWith('agent_test_scenario:');
    const key = rawKey || (idIsKey ? rawId : rawId ? buildAgentTestScenarioKey(rawId) : '');
    if (!key && !rawId) return { ok: false, error: 'Scenario id is required.' };
    const res = await ledger.getAgentMemory({ key: key || undefined, id: idIsKey ? undefined : rawId || undefined });
    if (!res?.ok || !res.memory) return { ok: false, error: res?.error || 'Scenario not found.' };
    const scenario = normalizeAgentTestScenario(res.memory.payload || res.memory);
    if (!scenario) return { ok: false, error: 'Invalid scenario payload.' };
    return { ok: true, scenario };
  }, []);

  const handleAgentTestRunUpdate = useCallback(async (playbookRun: TaskPlaybookRun) => {
    const pending = agentTestPendingRef.current.get(playbookRun.runId);
    if (!pending) return;
    const baseRun = pending.run;
    const updatedBase: AgentTestRun = {
      ...baseRun,
      status: playbookRun.status,
      startedAtMs: Number.isFinite(Number(playbookRun.startedAtMs))
        ? Number(playbookRun.startedAtMs)
        : baseRun.startedAtMs,
      finishedAtMs: Number.isFinite(Number(playbookRun.finishedAtMs))
        ? Number(playbookRun.finishedAtMs)
        : baseRun.finishedAtMs || null,
      updatedAtMs: Date.now()
    };
    const terminal =
      playbookRun.status === 'completed' ||
      playbookRun.status === 'failed' ||
      playbookRun.status === 'skipped';
    if (!terminal) {
      pending.run = updatedBase;
      void persistAgentTestRun(updatedBase, pending.scenario);
      return;
    }
    let truthEvents: TruthEventRecord[] = [];
    const ledger = window.glass?.tradeLedger;
    if (ledger?.listEvents) {
      try {
        const res = await ledger.listEvents({ limit: 500, kind: 'truth_event', runId: playbookRun.runId });
        if (res?.ok && Array.isArray(res.entries)) truthEvents = res.entries as TruthEventRecord[];
      } catch {
        // ignore truth fetch failures
      }
    }
    const evaluated = evaluateAgentTestRun({
      scenario: pending.scenario,
      playbookRun,
      truthEvents,
      baseRun: updatedBase
    });
    pending.run = evaluated;
    agentTestPendingRef.current.delete(playbookRun.runId);
    void persistAgentTestRun(evaluated, pending.scenario);
  }, [persistAgentTestRun]);

  const upsertTaskPlaybookRun = useCallback((run: TaskPlaybookRun) => {
    const list = [...(taskPlaybookRunsRef.current || [])];
    const idx = list.findIndex((item) => item.runId === run.runId);
    if (idx >= 0) list[idx] = run;
    else list.unshift(run);
    taskPlaybookRunsRef.current = list.slice(0, 40);
    taskPlaybookActiveRunRef.current = run;
    taskPlaybookUpdatedAtRef.current = Date.now();
    setTaskPlaybookUpdatedAtMs(Date.now());
    const ledger = window.glass?.tradeLedger;
    if (ledger?.createPlaybookRun) {
      void ledger.createPlaybookRun(run);
    }
    void handleAgentTestRunUpdate(run);
  }, [handleAgentTestRunUpdate]);

  const TASK_TREE_RUN_LIMIT = 30;
  const normalizeTaskTreeRunEntry = useCallback((summary: any): TaskTreeRunEntry | null => {
    if (!summary || typeof summary !== 'object') return null;
    const runId = String(summary.runId || '').trim();
    if (!runId) return null;
    const stepsRaw = Array.isArray(summary.steps) ? summary.steps : [];
    const context =
      summary.context && typeof summary.context === 'object'
        ? {
            source: summary.context.source != null ? String(summary.context.source) : null,
            correlationId: summary.context.correlationId != null ? String(summary.context.correlationId) : null,
            symbol: summary.context.symbol != null ? String(summary.context.symbol) : null,
            timeframe: summary.context.timeframe != null ? String(summary.context.timeframe) : null,
            strategy: summary.context.strategy != null ? String(summary.context.strategy) : null,
            watcherId: summary.context.watcherId != null ? String(summary.context.watcherId) : null,
            mode: summary.context.mode != null ? String(summary.context.mode) : null
          }
        : null;
    return {
      runId,
      status: summary.status != null ? String(summary.status) : null,
      createdAtMs: Number(summary.createdAtMs) || null,
      finishedAtMs: Number(summary.finishedAtMs) || null,
      context,
      steps: stepsRaw.slice(0, 50).map((step: any) => ({
        step: String(step.step || ''),
        status: String(step.status || ''),
        startedAtMs: Number(step.startedAtMs) || null,
        finishedAtMs: Number(step.finishedAtMs) || null,
        attempts: Number.isFinite(Number(step.attempts)) ? Number(step.attempts) : null,
        retryCount: Number.isFinite(Number(step.retryCount)) ? Number(step.retryCount) : null,
        error: step.error != null ? String(step.error) : null,
        note: step.note != null ? String(step.note) : null
      }))
    };
  }, []);

  const recordTaskTreeRun = useCallback((summary: any, taskType: 'signal' | 'action') => {
    const entry = normalizeTaskTreeRunEntry(summary);
    if (!entry) return;
    const setter = taskType === 'action' ? setActionTaskTreeRunsState : setTaskTreeRunsState;
    setter((prev) => {
      const next = [...prev];
      const idx = next.findIndex((item) => item.runId === entry.runId);
      if (idx >= 0) next[idx] = entry;
      else next.unshift(entry);
      next.sort((a, b) => (Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0)));
      return next.slice(0, TASK_TREE_RUN_LIMIT);
    });
  }, [normalizeTaskTreeRunEntry]);
  recordTaskTreeRunRef.current = recordTaskTreeRun;

  const TASK_TREE_CONTEXT_LIMITS = {
    maxDepth: 3,
    maxItems: 40,
    maxKeys: 40,
    maxString: 800
  };

  const sanitizeTaskTreeContextValue = useCallback((value: any, depth = 0): any => {
    if (value == null) return value;
    if (depth > TASK_TREE_CONTEXT_LIMITS.maxDepth) return null;
    if (typeof value === 'string') {
      if (value.length <= TASK_TREE_CONTEXT_LIMITS.maxString) return value;
      return `${value.slice(0, TASK_TREE_CONTEXT_LIMITS.maxString)}...`;
    }
    if (typeof value === 'number' || typeof value === 'boolean') return value;
    if (Array.isArray(value)) {
      return value
        .slice(0, TASK_TREE_CONTEXT_LIMITS.maxItems)
        .map((entry) => sanitizeTaskTreeContextValue(entry, depth + 1));
    }
    if (typeof value === 'object') {
      const entries = Object.entries(value).slice(0, TASK_TREE_CONTEXT_LIMITS.maxKeys);
      const next: Record<string, any> = {};
      for (const [key, entry] of entries) {
        next[key] = sanitizeTaskTreeContextValue(entry, depth + 1);
      }
      return next;
    }
    return null;
  }, []);

  const buildTaskTreeStatePayload = useCallback((
    taskType: 'signal' | 'action',
    snapshot: TaskTreeStateSnapshot,
    summary: TaskTreeRunSummary | null
  ) => {
    const sanitizeContext = (ctx: any) => ({
      runId: ctx?.runId || null,
      createdAtMs: Number(ctx?.createdAtMs) || null,
      source: ctx?.source || null,
      correlationId: ctx?.correlationId || null,
      symbol: ctx?.symbol || null,
      timeframe: ctx?.timeframe || null,
      strategy: ctx?.strategy || null,
      watcherId: ctx?.watcherId || null,
      mode: ctx?.mode || null,
      signal: sanitizeTaskTreeContextValue(ctx?.signal),
      watcher: sanitizeTaskTreeContextValue(ctx?.watcher),
      data: sanitizeTaskTreeContextValue(ctx?.data)
    });
    const queue = Array.isArray(snapshot.queue)
      ? snapshot.queue.map((job) => ({
          runId: job.runId,
          status: job.status,
          enqueuedAtMs: job.enqueuedAtMs,
          dedupeKey: job.dedupeKey || null,
          context: sanitizeContext(job.context)
        }))
      : [];
    const current = snapshot.current
      ? {
          runId: snapshot.current.runId,
          status: snapshot.current.status,
          step: snapshot.current.step || null,
          stepStartedAtMs: Number(snapshot.current.stepStartedAtMs) || null,
          context: sanitizeContext(snapshot.current.context),
          lastStep: sanitizeTaskTreeContextValue(snapshot.current.lastStep)
        }
      : null;
    return {
      version: 1,
      taskType,
      updatedAtMs: Date.now(),
      processing: snapshot.processing,
      queueDepth: queue.length,
      queue,
      current,
      lastSummary: summary || null
    };
  }, [sanitizeTaskTreeContextValue]);

  const refreshTaskTreeResumeEntries = useCallback((override?: { signal: any | null; action: any | null }) => {
    const state = override || taskTreeStateRef.current;
    const entries: TaskTreeResumeEntry[] = [];
    (['signal', 'action'] as const).forEach((taskType) => {
      const payload = state?.[taskType];
      if (!payload || typeof payload !== 'object') return;
      const queue = Array.isArray(payload.queue) ? payload.queue : [];
      const current = payload.current && typeof payload.current === 'object' ? payload.current : null;
      const lastSummary = payload.lastSummary && typeof payload.lastSummary === 'object' ? payload.lastSummary : null;
      const runId = current?.runId || queue[0]?.runId || lastSummary?.runId;
      if (!runId) return;
      const status = lastSummary?.status || current?.status || queue[0]?.status || null;
      const contextRaw = current?.context || queue[0]?.context || lastSummary?.context || null;
      const context = contextRaw
        ? {
            source: contextRaw.source || null,
            correlationId: contextRaw.correlationId || null,
            symbol: contextRaw.symbol || null,
            timeframe: contextRaw.timeframe || null,
            strategy: contextRaw.strategy || null,
            watcherId: contextRaw.watcherId || null,
            mode: contextRaw.mode || null
          }
        : null;
      const lastStepRaw = current?.lastStep || (Array.isArray(lastSummary?.steps) ? lastSummary.steps[lastSummary.steps.length - 1] : null);
      const lastStep = lastStepRaw
        ? {
            step: lastStepRaw.step || null,
            status: lastStepRaw.status || null,
            note: lastStepRaw.note || null,
            error: lastStepRaw.error || null
          }
        : null;
      const isBlocked = (lastStep?.status === 'blocked') || (status === 'blocked');
      const blockedReason = isBlocked ? (lastStep?.note || lastStep?.error || null) : null;
      const requiresConfirmation = blockedReason === 'confirmation_required' || blockedReason === 'require_confirmation';
      entries.push({
        taskType,
        runId: String(runId),
        status: status ? String(status) : null,
        createdAtMs: Number(contextRaw?.createdAtMs || lastSummary?.createdAtMs || 0) || null,
        updatedAtMs: Number(payload.updatedAtMs) || null,
        queueDepth: Number(payload.queueDepth || queue.length || 0) || 0,
        blocked: isBlocked,
        blockedReason,
        requiresConfirmation,
        context,
        lastStep
      });
    });
    setTaskTreeResumeEntries(entries);
  }, []);

  const persistTaskTreeState = useCallback((
    taskType: 'signal' | 'action',
    snapshot: TaskTreeStateSnapshot,
    opts?: { immediate?: boolean }
  ) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.upsertAgentMemory) return;
    const lastSummary = taskTreeLastSummaryRef.current[taskType];
    const shouldClear =
      !snapshot.processing &&
      snapshot.queueDepth === 0 &&
      !snapshot.current &&
      lastSummary &&
      lastSummary.status !== 'blocked' &&
      lastSummary.status !== 'failed';
    if (shouldClear) {
      void clearTaskTreeState(taskType, { reason: 'idle' });
      return;
    }

    const payload = buildTaskTreeStatePayload(taskType, snapshot, lastSummary || null);
    const write = async () => {
      try {
        await ledger.upsertAgentMemory({
          key: TASK_TREE_STATE_KEYS[taskType],
          familyKey: TASK_TREE_STATE_KIND,
          kind: TASK_TREE_STATE_KIND,
          summary: `${taskType} task tree state`,
          payload,
          source: 'task_tree'
        });
        taskTreeStateRef.current = { ...taskTreeStateRef.current, [taskType]: payload };
        refreshTaskTreeResumeEntries();
      } catch {
        // ignore persistence failures
      }
    };

    if (opts?.immediate) {
      void write();
      return;
    }

    const timers = taskTreePersistTimerRef.current;
    const existing = timers[taskType];
    if (existing) return;
    timers[taskType] = deferMs(() => {
      timers[taskType] = null;
      void write();
    }, 400);
  }, [buildTaskTreeStatePayload, refreshTaskTreeResumeEntries]);
  persistTaskTreeStateRef.current = persistTaskTreeState;

  const clearTaskTreeState = useCallback(async (
    taskType: 'signal' | 'action',
    opts?: { reason?: string }
  ) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.deleteAgentMemory) return;
    try {
      await ledger.deleteAgentMemory({ key: TASK_TREE_STATE_KEYS[taskType] });
    } catch {
      // ignore
    }
    taskTreeStateRef.current = { ...taskTreeStateRef.current, [taskType]: null };
    refreshTaskTreeResumeEntries();
    if (opts?.reason) {
      void appendAuditEvent({
        eventType: 'task_tree_state_cleared',
        runId: null,
        payload: { taskType, reason: opts.reason }
      });
    }
  }, [appendAuditEvent, refreshTaskTreeResumeEntries]);

  const loadTaskTreeStateFromLedger = useCallback(async () => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.getAgentMemory) return { ok: false, error: 'Agent memory unavailable.' };
    try {
      const [signalRes, actionRes] = await Promise.all([
        ledger.getAgentMemory({ key: TASK_TREE_STATE_KEYS.signal }),
        ledger.getAgentMemory({ key: TASK_TREE_STATE_KEYS.action })
      ]);
      const normalizeState = (payload: any) => {
        if (!payload || typeof payload !== 'object') return null;
        const queueDepth = Number(payload.queueDepth || 0);
        const hasCurrent = !!payload.current;
        const lastStatus = payload.lastSummary?.status ? String(payload.lastSummary.status) : '';
        if (!hasCurrent && queueDepth === 0 && (lastStatus === 'completed' || lastStatus === 'skipped')) {
          return null;
        }
        return payload;
      };
      const signalPayload = signalRes?.ok ? (signalRes.memory?.payload || null) : null;
      const actionPayload = actionRes?.ok ? (actionRes.memory?.payload || null) : null;
      const nextState = {
        signal: normalizeState(signalPayload),
        action: normalizeState(actionPayload)
      };
      if (nextState.signal?.lastSummary) {
        taskTreeLastSummaryRef.current = { ...taskTreeLastSummaryRef.current, signal: nextState.signal.lastSummary };
      }
      if (nextState.action?.lastSummary) {
        taskTreeLastSummaryRef.current = { ...taskTreeLastSummaryRef.current, action: nextState.action.lastSummary };
      }
      taskTreeStateRef.current = nextState;
      refreshTaskTreeResumeEntries(nextState);
      return { ok: true };
    } catch (err: any) {
      return { ok: false, error: err?.message ? String(err.message) : 'Failed to load task tree state.' };
    }
  }, [refreshTaskTreeResumeEntries]);

  useEffect(() => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list) return;
    let cancelled = false;
    (async () => {
      try {
        const res = await ledger.list({ limit: 200 });
        if (!res?.ok || !Array.isArray(res.entries) || cancelled) return;
        const entries = res.entries as any[];
        const taskEntries = entries.filter(
          (entry) => entry?.kind === 'audit_event' && entry?.eventType === 'task_tree_persist' && entry?.payload
        );
        for (const entry of taskEntries) {
          const summary = entry.payload || {};
          const taskTypeRaw = summary?.taskType ? String(summary.taskType) : '';
          const source = summary?.context?.source ? String(summary.context.source) : '';
          const inferred = source.startsWith('action_catalog') ? 'action' : source.includes('setup_signal') ? 'signal' : '';
          const taskType = taskTypeRaw === 'action' ? 'action' : inferred === 'action' ? 'action' : 'signal';
          recordTaskTreeRun(summary, taskType);
        }
      } catch {
        // ignore load failures
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [recordTaskTreeRun]);

  useEffect(() => {
    void loadTaskTreeStateFromLedger();
  }, [loadTaskTreeStateFromLedger]);

  const computeTaskTreeResumeIndex = useCallback((steps: Record<string, any> | null, stepOrder: string[]) => {
    if (!steps || typeof steps !== 'object') return 0;
    for (let i = 0; i < stepOrder.length; i += 1) {
      const step = stepOrder[i];
      const prev = steps[step];
      if (!prev || (prev.status !== 'completed' && prev.status !== 'skipped')) return i;
    }
    return stepOrder.length;
  }, []);

  const resumeTaskTreeRun = useCallback(async (input: {
    taskType: 'signal' | 'action';
    runId?: string | null;
    action?: 'resume' | 'abort' | 'approve' | 'skip';
  }) => {
    const taskType = input.taskType;
    const action = input.action || 'resume';
    const isApprove = action === 'approve';
    const isSkip = action === 'skip';
    const state = taskTreeStateRef.current?.[taskType];
    if (!state || typeof state !== 'object') return { ok: false, error: 'No task tree state to resume.' };
    const runId = input.runId ? String(input.runId) : null;

    if (action === 'abort') {
      await clearTaskTreeState(taskType, { reason: 'abort' });
      if (runId) {
        void appendAuditEvent({
          eventType: 'task_tree_abort',
          runId,
          payload: { taskType, reason: 'user_abort' }
        });
      }
      return { ok: true, aborted: true };
    }

    const queue = Array.isArray(state.queue) ? state.queue : [];
    const current = state.current && typeof state.current === 'object' ? state.current : null;
    const candidates = queue.length > 0 ? queue : current ? [{ ...current, enqueuedAtMs: Date.now() }] : [];
    const filtered = runId ? candidates.filter((job) => String(job.runId || '') === runId) : candidates;
    if (filtered.length === 0) return { ok: false, error: 'No queued task tree jobs found.' };

    const actionOrchestrator = ensureActionTaskTreeRef.current;
    const orchestrator = taskType === 'action' ? actionOrchestrator?.() : ensureTaskTree();
    if (!orchestrator) return { ok: false, error: 'Task tree orchestrator unavailable.' };
    const steps = orchestrator.getSteps();
    let queuedCount = 0;
    for (const job of filtered) {
      const ctx = job.context || {};
      const data = ctx.data && typeof ctx.data === 'object' ? { ...ctx.data } : {};
      const taskState = data._taskTree && typeof data._taskTree === 'object' ? { ...data._taskTree } : { steps: {}, last: null };
      if (isSkip) {
        const lastStep = taskState.last && typeof taskState.last === 'object' ? taskState.last : null;
        const lastId = lastStep?.step ? String(lastStep.step) : '';
        if (lastId && taskState.steps && typeof taskState.steps === 'object' && taskState.steps[lastId]) {
          const updated = {
            ...(taskState.steps[lastId] as Record<string, any>),
            status: 'skipped',
            note: 'user_skip',
            finishedAtMs: Date.now()
          };
          taskState.steps = { ...(taskState.steps as Record<string, any>), [lastId]: updated };
          taskState.last = updated;
        }
      }
      const resumeFromStepIndex = computeTaskTreeResumeIndex(taskState.steps || null, steps);
      taskState.resume = {
        ofRunId: job.runId,
        fromStepIndex: resumeFromStepIndex,
        requestedAtMs: Date.now()
      };
      if (isApprove) {
        taskState.confirmation = true;
        data.confirmed = true;
        data.confirmation = true;
        if (data.payload && typeof data.payload === 'object') {
          data.payload = { ...(data.payload as Record<string, any>), confirmed: true };
        }
      }
      data._taskTree = taskState;
      const res = orchestrator.enqueue({
        source: ctx.source || 'task_tree_resume',
        symbol: ctx.symbol,
        timeframe: ctx.timeframe,
        strategy: ctx.strategy,
        watcherId: ctx.watcherId,
        mode: ctx.mode,
        signal: ctx.signal,
        watcher: ctx.watcher,
        dedupeKey: job.dedupeKey || undefined,
        runId: job.runId,
        data
      });
      if (res?.queued) queuedCount += 1;
    }

    if (queuedCount > 0) {
      await clearTaskTreeState(taskType, { reason: 'resume' });
      const primaryRun = String(filtered[0].runId || '');
      void appendAuditEvent({
        eventType: 'task_tree_resume',
        runId: primaryRun || null,
        payload: { taskType, queuedCount }
      });
    }
    return { ok: queuedCount > 0, queuedCount };
  }, [appendAuditEvent, clearTaskTreeState, computeTaskTreeResumeIndex, ensureTaskTree]);

  const PLAYBOOK_CONTEXT_LIMITS = {
    maxDepth: 3,
    maxItems: 40,
    maxKeys: 40,
    maxString: 500
  };

  const sanitizePlaybookContextValue = useCallback((value: any, depth = 0): any => {
    if (value == null) return value;
    if (depth > PLAYBOOK_CONTEXT_LIMITS.maxDepth) return null;
    if (typeof value === 'string') {
      if (value.length <= PLAYBOOK_CONTEXT_LIMITS.maxString) return value;
      return `${value.slice(0, PLAYBOOK_CONTEXT_LIMITS.maxString)}...`;
    }
    if (typeof value === 'number' || typeof value === 'boolean') return value;
    if (Array.isArray(value)) {
      return value
        .slice(0, PLAYBOOK_CONTEXT_LIMITS.maxItems)
        .map((entry) => sanitizePlaybookContextValue(entry, depth + 1));
    }
    if (typeof value === 'object') {
      const entries = Object.entries(value).slice(0, PLAYBOOK_CONTEXT_LIMITS.maxKeys);
      const next: Record<string, any> = {};
      for (const [key, entry] of entries) {
        next[key] = sanitizePlaybookContextValue(entry, depth + 1);
      }
      return next;
    }
    return null;
  }, []);

  const buildPlaybookRunContext = useCallback((data: Record<string, any>, source: Record<string, any>) => {
    return {
      data: sanitizePlaybookContextValue(data),
      source: sanitizePlaybookContextValue(source)
    };
  }, [sanitizePlaybookContextValue]);

  const stripPlaybookResumeFields = useCallback((input: any) => {
    if (!input || typeof input !== 'object') return {};
    const { resumeContext, resumeFromStepIndex, resumeOfRunId, ...rest } = input;
    return rest;
  }, []);

  const executeTaskPlaybook = useCallback(async (ctx: any) => {
    const playbook = ensureTaskPlaybook({ playbookId: ctx.data?.playbookId, playbook: ctx.data?.playbook });
    if (!playbook) {
      return { ok: false, error: 'Playbook not found.' };
    }

    const autoCfg = autoPilotConfigRef.current || {};
    let desiredMode = normalizeTaskPlaybookMode(ctx.mode || ctx.data?.mode || playbook.defaultMode || 'coordinate');
    const autoEnabled = autoCfg.enabled === true;
    if ((desiredMode === 'autopilot' || desiredMode === 'team') && !autoEnabled) {
      desiredMode = 'coordinate';
    }
    const allowAutoConfirm = desiredMode === 'autopilot' && autoEnabled && !autoCfg.requireConfirmation;
    const watcherMode = allowAutoConfirm ? 'live' : 'suggest';

    const symbol = String(ctx.symbol || playbook.symbol || '').trim();
    const strategy = (ctx.strategy || playbook.strategy || null) as TaskPlaybook['strategy'];
    const timeframes = Array.isArray(ctx.data?.timeframes)
      ? ctx.data.timeframes
      : (Array.isArray(playbook.timeframes) ? playbook.timeframes : null);
    const resumeOfRunId = ctx.data?.resumeOfRunId ? String(ctx.data.resumeOfRunId).trim() : null;
    const resumeFromStepIndex = Number.isFinite(Number(ctx.data?.resumeFromStepIndex))
      ? Math.max(0, Math.floor(Number(ctx.data?.resumeFromStepIndex)))
      : null;
    const resumeContext = ctx.data?.resumeContext && typeof ctx.data.resumeContext === 'object'
      ? ctx.data.resumeContext
      : null;
    const resumeData = resumeContext?.data && typeof resumeContext.data === 'object' ? resumeContext.data : null;
    const resumeSource = resumeContext?.source && typeof resumeContext.source === 'object' ? resumeContext.source : null;
    let resumeControl = resumeContext?.control && typeof resumeContext.control === 'object'
      ? { ...(resumeContext.control as Record<string, any>) }
      : null;
    const startIndex = Number.isFinite(Number(resumeFromStepIndex)) ? Number(resumeFromStepIndex) : 0;
    const resumeId = resumeOfRunId ? String(resumeOfRunId).trim() : null;
    let existingRun: TaskPlaybookRun | null = null;
    if (resumeId) {
      existingRun = (taskPlaybookRunsRef.current || []).find((item) => item.runId === resumeId) || null;
      if (!existingRun) {
        const ledger = window.glass?.tradeLedger;
        if (ledger?.getPlaybookRun) {
          const res = await ledger.getPlaybookRun(resumeId);
          if (res?.ok && res.run) {
            existingRun = res.run as TaskPlaybookRun;
          }
        }
      }
    }
    const stepIndexById = new Map(playbook.steps.map((step, idx) => [step.id, idx]));
    const preservedSteps = Array.isArray(existingRun?.steps)
      ? existingRun.steps.filter((step) => {
        const idx = stepIndexById.get(step.id);
        return idx != null && idx < startIndex && (step.status === 'completed' || step.status === 'skipped');
      })
      : [];
    const preservedIds = new Set(preservedSteps.map((step) => step.id));

    const run: TaskPlaybookRun = {
      runId: resumeId || ctx.runId,
      playbookId: playbook.id,
      playbookName: playbook.name,
      status: 'running',
      mode: desiredMode,
      symbol: symbol || null,
      timeframe: ctx.timeframe || (Array.isArray(timeframes) ? timeframes[0] || null : null),
      strategy: strategy || null,
      startedAtMs: Number.isFinite(Number(existingRun?.startedAtMs)) ? Number(existingRun?.startedAtMs) : Date.now(),
      steps: [...preservedSteps],
      context: null,
      resumeOfRunId: resumeId,
      resumeFromStepIndex: Number.isFinite(Number(resumeFromStepIndex)) ? Number(resumeFromStepIndex) : null
    };
    if (existingRun) {
      run.error = null;
      run.finishedAtMs = null;
    }
    upsertTaskPlaybookRun(run);

    const data: Record<string, any> = {
      ...(resumeData || {}),
      ...stripPlaybookResumeFields(ctx.data || {}),
      symbol,
      strategy,
      timeframes: timeframes || [],
      watcherMode
    };
    const stepResults: Record<string, any> = {};
    data.stepResults = stepResults;
    data.steps = stepResults;
    data.prev = null;
    const source: Record<string, any> = {
      ...(resumeSource || {}),
      symbol,
      timeframe: ctx.timeframe,
      strategy,
      mode: desiredMode,
      watcherMode,
      timeframes: timeframes || [],
      ...data
    };
    source.steps = stepResults;
    source.stepResults = stepResults;
    source.prev = null;
    run.context = buildPlaybookRunContext(data, source);
    upsertTaskPlaybookRun({ ...run });

    const waitMs = (ms: number) => sleepMs(ms);
    const runWithTimeout = async <T,>(promise: Promise<T>, timeoutMs: number | null) => {
      if (!Number.isFinite(Number(timeoutMs)) || Number(timeoutMs) <= 0) return promise;
      let handle: TimerHandle | null = null;
      try {
        const timed = new Promise<T>((resolve) => {
          handle = deferMs(() => {
            resolve({
              ok: false,
              error: 'Playbook step timed out.',
              code: 'timeout'
            } as any);
          }, Math.max(1, Math.floor(Number(timeoutMs))));
        });
        return await Promise.race([promise, timed]);
      } finally {
        if (handle) cancelTimer(handle);
      }
    };

    for (let idx = 0; idx < playbook.steps.length; idx += 1) {
      const step = playbook.steps[idx];
      if (idx < startIndex) {
        if (preservedIds.has(step.id)) {
          continue;
        }
        const skippedEntry: TaskPlaybookRunStep = {
          id: step.id,
          actionId: step.actionId,
          label: step.label || null,
          status: 'skipped',
          startedAtMs: Date.now(),
          finishedAtMs: Date.now(),
          note: 'resume_skip'
        };
        run.steps = [...(run.steps || []), skippedEntry];
        continue;
      }
      const controlMatches = resumeControl
        ? (resumeControl.stepId && resumeControl.stepId === step.id) ||
          (resumeControl.actionId && resumeControl.actionId === step.actionId)
        : false;
      const allowUserStep = controlMatches && resumeControl?.allowUser === true;
      const forceConfirm = controlMatches && resumeControl?.confirm === true;
      const forceSkip = controlMatches && resumeControl?.skip === true;
      if (controlMatches) {
        resumeControl = null;
      }
      if (forceSkip) {
        const skippedEntry: TaskPlaybookRunStep = {
          id: step.id,
          actionId: step.actionId,
          label: step.label || null,
          status: 'skipped',
          startedAtMs: Date.now(),
          finishedAtMs: Date.now(),
          note: 'user_skip'
        };
        run.steps = [...(run.steps || []), skippedEntry];
        continue;
      }
      const stepEntry: TaskPlaybookRunStep = {
        id: step.id,
        actionId: step.actionId,
        label: step.label || null,
        status: 'running',
        startedAtMs: Date.now(),
        attempts: 0,
        retryCount: 0
      };
      run.currentStepId = step.id;
      run.currentActionId = step.actionId;
      run.currentStepIndex = idx;
      run.steps = [...(run.steps || []), stepEntry];
      run.context = buildPlaybookRunContext(data, source);
      upsertTaskPlaybookRun({ ...run });

      if (step.requiresUser && desiredMode !== 'autopilot' && !allowUserStep) {
        stepEntry.status = 'blocked';
        stepEntry.note = 'requires_user';
        stepEntry.finishedAtMs = Date.now();
        run.status = 'blocked';
        run.error = 'Awaiting user coordination.';
        run.finishedAtMs = Date.now();
        run.context = buildPlaybookRunContext(data, source);
        upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
        return { ok: true, skip: true, note: 'halt', data: { run } };
      }

      if (step.skipIfMissing) {
        const resolved = resolvePlaybookPath(source, step.skipIfMissing);
        if (resolved == null || resolved === '' || (Array.isArray(resolved) && resolved.length === 0)) {
          stepEntry.status = 'skipped';
          stepEntry.note = `missing:${step.skipIfMissing}`;
          stepEntry.finishedAtMs = Date.now();
          continue;
        }
      }

      const basePayload = step.payload ? resolvePlaybookValue(step.payload, source) : {};
      const payload = basePayload && typeof basePayload === 'object' ? { ...basePayload } : {};
      const baseSource = ctx.source || ctx.data?.source || `playbook:${playbook.id}`;
      const actionSource = baseSource === 'playbook' ? `playbook:${playbook.id}` : baseSource;
      const traceBase = {
        actionId: step.actionId,
        payload,
        source: actionSource,
        symbol,
        timeframe: ctx.timeframe,
        strategy,
        messageId: payload?.messageId || null,
        correlationId: payload?.correlationId || null,
        runId: ctx.runId,
        kind: 'action' as const,
        startedAtMs: stepEntry.startedAtMs ?? Date.now()
      };
      await loadActionCatalogModule();
      const definition = getActionDefinitionCached(step.actionId);
      const logActionTrace = (result: any) => {
        void recordActionTrace(traceBase, {
          ok: !!result?.ok,
          error: result?.error || null,
          code: result?.code || null,
          data: result?.data ?? null
        });
      };
      const needsConfirm = step.requiresConfirmation === true ||
        (definition?.safety?.requiresConfirmation === true) ||
        (Array.isArray(definition?.safety?.gates) && definition?.safety?.gates?.includes('confirmation'));
      if (forceConfirm || (needsConfirm && allowAutoConfirm)) {
        payload.confirmed = true;
      }

      const resolveMissingCode = (input: { code?: string | null; data?: any; error?: string | null }) => {
        const candidates = new Set([
          'missing_symbol',
          'missing_timeframe',
          'missing_params',
          'missing_levels',
          'watcher_missing_fields',
          'watcher_missing_params',
          'preset_missing_fields'
        ]);
        const raw = input.code && typeof input.code === 'string' ? input.code : '';
        if (raw && candidates.has(raw)) return raw;
        const detail = input.data && typeof input.data === 'object' ? (input.data as any).detail : null;
        if (typeof detail === 'string' && candidates.has(detail)) return detail;
        const text = String(input.error || '').toLowerCase();
        if (text.includes('symbol missing') || text.includes('requires a symbol')) return 'missing_symbol';
        if (text.includes('timeframe') && text.includes('require')) return 'missing_timeframe';
        if (text.includes('paramgrid') || text.includes('params unavailable') || text.includes('requires a param')) return 'missing_params';
        if (text.includes('missing levels')) return 'missing_levels';
        return null;
      };
      const resolveDependencyCode = (input: { code?: string | null; error?: string | null }) => {
        const candidates = new Set([
          'broker_not_connected',
          'broker_trading_disabled',
          'autopilot_disabled',
          'autopilot_killswitch',
          'backtester_unavailable',
          'chart_unavailable',
          'agent_not_found',
          'agent_tools_denied',
          'agent_broker_denied',
          'risk_exceeds_cap',
          'risk_requires_confirmation'
        ]);
        const raw = input.code && typeof input.code === 'string' ? input.code : '';
        if (raw && candidates.has(raw)) return raw;
        return null;
      };
      const retryableCodes = new Set(['rate_limited', 'timeout', 'network']);
      const maxRetries = Number.isFinite(Number(step.maxRetries)) ? Math.max(0, Math.floor(Number(step.maxRetries))) : 0;
      const retryDelayMs = Number.isFinite(Number(step.retryDelayMs)) ? Math.max(0, Math.floor(Number(step.retryDelayMs))) : 1200;
      const timeoutMs = Number.isFinite(Number(step.timeoutMs))
        ? Math.max(0, Math.floor(Number(step.timeoutMs)))
        : Number.isFinite(Number(definition?.defaultTimeoutMs))
          ? Math.max(0, Math.floor(Number(definition?.defaultTimeoutMs)))
          : null;
      const activeStepConfig = {
        id: step.id,
        actionId: step.actionId,
        maxRetries,
        retryDelayMs,
        timeoutMs
      };
      data.activeStepConfig = activeStepConfig;
      source.activeStepConfig = activeStepConfig;
      run.context = buildPlaybookRunContext(data, source);
      upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });

      let attempts = 0;
      let retryCount = 0;
      let lastResult: any = null;
      while (true) {
        attempts += 1;
        const result = await runWithTimeout(
          executeCatalogAction({
            actionId: step.actionId,
            payload,
            symbol,
            timeframe: ctx.timeframe,
            strategy: strategy || undefined,
            mode: watcherMode,
            source: actionSource
          }),
          timeoutMs
        );
        lastResult = result;
        if (result.ok) {
          stepEntry.status = 'completed';
          stepEntry.finishedAtMs = Date.now();
          if (step.storeAs) {
            data[step.storeAs] = result.data ?? null;
          }
          data.lastResult = result.data ?? null;
          break;
        }

        const error = result.error || 'Playbook step failed.';
        const code = result.code ? String(result.code) : null;
        if (code === 'confirmation_required' || (!allowAutoConfirm && needsConfirm)) {
          stepEntry.status = 'blocked';
          stepEntry.note = 'confirmation_required';
          stepEntry.error = error;
          stepEntry.finishedAtMs = Date.now();
          run.status = 'blocked';
          run.error = error;
          run.finishedAtMs = Date.now();
          run.context = buildPlaybookRunContext(data, source);
          upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
          stepEntry.attempts = attempts;
          stepEntry.retryCount = retryCount;
          logActionTrace(result);
          return { ok: true, skip: true, note: 'halt', data: { run } };
        }

        const missingCode = resolveMissingCode({ code, data: result.data, error });
        if (missingCode) {
          if (step.optional) {
            stepEntry.status = 'skipped';
            stepEntry.error = error;
            stepEntry.note = missingCode;
            stepEntry.finishedAtMs = Date.now();
            break;
          }
          stepEntry.status = 'blocked';
          stepEntry.note = missingCode;
          stepEntry.error = error;
          stepEntry.finishedAtMs = Date.now();
          run.status = 'blocked';
          run.error = error;
          run.finishedAtMs = Date.now();
          run.context = buildPlaybookRunContext(data, source);
          upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
          stepEntry.attempts = attempts;
          stepEntry.retryCount = retryCount;
          logActionTrace(result);
          return { ok: true, skip: true, note: 'halt', data: { run } };
        }

        const dependencyCode = resolveDependencyCode({ code, error });
        if (dependencyCode) {
          stepEntry.status = 'blocked';
          stepEntry.note = dependencyCode;
          stepEntry.error = error;
          stepEntry.finishedAtMs = Date.now();
          run.status = 'blocked';
          run.error = error;
          run.finishedAtMs = Date.now();
          run.context = buildPlaybookRunContext(data, source);
          upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
          stepEntry.attempts = attempts;
          stepEntry.retryCount = retryCount;
          logActionTrace(result);
          return { ok: true, skip: true, note: 'halt', data: { run } };
        }

        const retryAfterMs = Number.isFinite(Number(result.retryAfterMs)) ? Math.max(0, Math.floor(Number(result.retryAfterMs))) : null;
        const isRetryable = !!retryAfterMs || (code ? retryableCodes.has(code) : false);
        if (isRetryable && retryCount < maxRetries) {
          retryCount += 1;
          if (retryAfterMs && retryAfterMs > 0) {
            await waitMs(retryAfterMs);
          } else if (retryDelayMs > 0) {
            await waitMs(retryDelayMs);
          }
          continue;
        }

        if (step.optional) {
          stepEntry.status = 'skipped';
          stepEntry.error = error;
          stepEntry.note = 'optional_failed';
          stepEntry.finishedAtMs = Date.now();
          break;
        }
        stepEntry.status = 'failed';
        stepEntry.error = error;
        stepEntry.finishedAtMs = Date.now();
        run.status = 'failed';
        run.error = error;
        run.finishedAtMs = Date.now();
        run.context = buildPlaybookRunContext(data, source);
        upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
        stepEntry.attempts = attempts;
        stepEntry.retryCount = retryCount;
        return { ok: false, error, data: { run } };
      }

      stepEntry.attempts = attempts;
      stepEntry.retryCount = retryCount;
      if (lastResult) {
        logActionTrace(lastResult);
      }
      const outcome = {
        step: step.id,
        actionId: step.actionId,
        status: stepEntry.status,
        attempts,
        retryCount,
        startedAtMs: stepEntry.startedAtMs ?? null,
        finishedAtMs: stepEntry.finishedAtMs ?? null,
        error: stepEntry.error || null,
        note: stepEntry.note || null,
        result: lastResult && lastResult.ok ? lastResult.data ?? null : null
      };
      stepResults[step.id] = outcome;
      data.prev = { ...outcome, step: step.id };
      source.prev = data.prev;
      data.steps = stepResults;
      data.stepResults = stepResults;
      source.steps = stepResults;
      source.stepResults = stepResults;
      Object.assign(source, data);
      run.context = buildPlaybookRunContext(data, source);
    }

    run.status = 'completed';
    run.finishedAtMs = Date.now();
    data.activeStepConfig = null;
    source.activeStepConfig = null;
    run.context = buildPlaybookRunContext(data, source);
    upsertTaskPlaybookRun({ ...run, steps: [...(run.steps || [])] });
    return { ok: true, data: { run } };
  }, [
    ensureTaskPlaybook,
    executeCatalogAction,
    resolvePlaybookPath,
    resolvePlaybookValue,
    recordActionTrace,
    upsertTaskPlaybookRun,
    buildPlaybookRunContext,
    stripPlaybookResumeFields
  ]);

  const ensurePlaybookTaskTree = useCallback(() => {
    if (playbookTaskTreeRef.current) return playbookTaskTreeRef.current;

    const orchestrator = new TaskTreeOrchestrator({
      steps: ['execute'],
      dedupeWindowMs: 10_000,
      maxQueue: 50,
      onAudit: (event) => {
        taskTreeUpdatedAtRef.current = Date.now();
        void appendAuditEvent({
          eventType: event.eventType,
          runId: event.runId || null,
          level: event.level || 'info',
          symbol: event.payload?.symbol || null,
          payload: {
            step: event.step || null,
            status: event.status || null,
            note: event.note || null,
            error: event.error || null,
            taskType: 'playbook',
            ...(event.payload || {})
          }
        });
      },
      onPersist: (summary) => {
        taskTreeUpdatedAtRef.current = Date.now();
        void appendAuditEvent({
          eventType: 'task_tree_persist',
          runId: summary.runId || null,
          symbol: summary.context?.symbol || null,
          payload: { ...(summary as any), taskType: 'playbook' }
        });
      }
    });

    orchestrator.setHandlers({
      execute: async (ctx) => {
        const result = await executeTaskPlaybook(ctx);
        if (result.skip) {
          return { ok: true, skip: true, note: result.note || 'halt', data: { run: result.data?.run || null } };
        }
        if (!result.ok) {
          return { ok: false, error: result.error || 'Playbook failed.' };
        }
        return { ok: true, data: { run: result.data?.run || null } };
      }
    });

    playbookTaskTreeRef.current = orchestrator;
    return orchestrator;
  }, [appendAuditEvent, executeTaskPlaybook]);

  const enqueuePlaybookRun = useCallback((input: {
    runId?: string | null;
    playbookId?: string | null;
    playbook?: TaskPlaybook | null;
    symbol?: string | null;
    timeframe?: string | null;
    timeframes?: string[] | null;
    strategy?: string | null;
    mode?: TaskPlaybookMode | null;
    source?: string | null;
    reason?: string | null;
    resumeContext?: Record<string, any> | null;
    resumeOfRunId?: string | null;
    resumeFromStepIndex?: number | null;
  }) => {
    const playbook = ensureTaskPlaybook(input);
    if (!playbook) return { ok: false, error: 'Playbook not found.' };

    const symbol = String(input.symbol || playbook.symbol || '').trim();
    const timeframe = String(input.timeframe || '').trim();
    const strategy = input.strategy || playbook.strategy || null;
    const mode = normalizeTaskPlaybookMode(input.mode || playbook.defaultMode || 'coordinate');
    const source = input.source || input.reason || 'playbook';
    const resumeKey = input.resumeOfRunId ? `:resume:${input.resumeOfRunId}` : '';
    const dedupeKey = `${playbook.id}:${symbol || ''}:${timeframe || ''}:${strategy || ''}:${mode}${resumeKey}`;

    const tree = ensurePlaybookTaskTree();
    const res = tree.enqueue({
      runId: input.runId ? String(input.runId) : undefined,
      source: String(source),
      symbol: symbol || undefined,
      timeframe: timeframe || undefined,
      strategy: strategy || undefined,
      mode,
      dedupeKey,
      data: {
        playbookId: playbook.id,
        playbook,
        timeframes: Array.isArray(input.timeframes)
          ? input.timeframes
          : (Array.isArray(input.playbook?.timeframes) ? input.playbook?.timeframes : undefined),
        resumeContext: input.resumeContext || null,
        resumeOfRunId: input.resumeOfRunId || null,
        resumeFromStepIndex: input.resumeFromStepIndex ?? null
      }
    });

    return { ok: true, runId: res.runId, queued: res.queued };
  }, [ensurePlaybookTaskTree, ensureTaskPlaybook]);

  const resumePlaybookRun = useCallback(async (
    runId: string,
    opts?: {
      action?: 'resume' | 'approve' | 'skip' | 'abort';
      stepId?: string | null;
      actionId?: string | null;
      overrides?: {
        symbol?: string;
        timeframe?: string;
        strategy?: string;
        timeframes?: string[];
        data?: Record<string, any>;
      };
    }
  ) => {
    const ledger = window.glass?.tradeLedger;
    let run = (taskPlaybookRunsRef.current || []).find((item) => item.runId === runId) || null;
    if (!run && ledger?.getPlaybookRun) {
      const res = await ledger.getPlaybookRun(runId);
      if (res?.ok && res.run) run = res.run as TaskPlaybookRun;
    }
    if (!run) {
      addNotification('Resume Failed', 'Playbook run not found.', 'warning');
      return { ok: false, error: 'Playbook run not found.' };
    }
    const action = opts?.action || 'resume';
    if (action === 'abort') {
      const steps = Array.isArray(run.steps) ? [...run.steps] : [];
      const blockedIdx = steps.findIndex((step) => step.status === 'blocked');
      if (blockedIdx >= 0) {
        steps[blockedIdx] = {
          ...steps[blockedIdx],
          status: 'failed',
          note: 'aborted_by_user',
          finishedAtMs: Date.now()
        };
      }
      const aborted: TaskPlaybookRun = {
        ...run,
        status: 'failed',
        error: 'aborted_by_user',
        finishedAtMs: Date.now(),
        steps
      };
      upsertTaskPlaybookRun(aborted);
      addNotification('Playbook Aborted', 'Run marked as failed by user.', 'warning');
      return { ok: true, aborted: true };
    }
    if (run.status === 'completed') {
      addNotification('Playbook Complete', 'No remaining steps to resume.', 'info');
      return { ok: false, error: 'Playbook already completed.' };
    }
    const steps = Array.isArray(run.steps) ? run.steps : [];
    const resumeIndex = steps.findIndex((step) => step.status !== 'completed' && step.status !== 'skipped');
    const fallbackIndex = Number.isFinite(Number(run.currentStepIndex)) ? Number(run.currentStepIndex) : 0;
    const startIndex = resumeIndex >= 0 ? resumeIndex : Math.max(0, fallbackIndex);
    const resumeContext = run.context && typeof run.context === 'object' ? run.context : null;
    const blockedStep = steps.find((step) => step.status === 'blocked') || null;
    const controlStepId = opts?.stepId || blockedStep?.id || null;
    const controlActionId = opts?.actionId || blockedStep?.actionId || null;
    const overrides = opts?.overrides && typeof opts.overrides === 'object' ? opts.overrides : null;
    const overrideSymbol = overrides?.symbol ? String(overrides.symbol).trim() : '';
    const overrideTimeframe = overrides?.timeframe ? String(overrides.timeframe).trim() : '';
    const overrideStrategy = overrides?.strategy ? String(overrides.strategy).trim() : '';
    const overrideTimeframes = Array.isArray(overrides?.timeframes)
      ? overrides?.timeframes.map((entry) => String(entry).trim()).filter(Boolean)
      : null;
    const overrideData = overrides?.data && typeof overrides.data === 'object' ? overrides.data : null;
    const resumeControl = {
      stepId: controlStepId,
      actionId: controlActionId,
      confirm: action === 'approve' || action === 'resume',
      allowUser: action === 'approve' || action === 'resume',
      skip: action === 'skip'
    };
    const mergedData = { ...(resumeContext?.data || {}), ...(overrideData || {}) };
    if (overrideSymbol) mergedData.symbol = overrideSymbol;
    if (overrideStrategy) mergedData.strategy = overrideStrategy;
    if (overrideTimeframes && overrideTimeframes.length > 0) mergedData.timeframes = overrideTimeframes;
    const mergedSource = { ...(resumeContext?.source || {}), ...mergedData };

    const res = enqueuePlaybookRun({
      runId: run.runId,
      playbookId: run.playbookId,
      symbol: overrideSymbol || run.symbol || undefined,
      timeframe: overrideTimeframe || run.timeframe || undefined,
      strategy: overrideStrategy || run.strategy || undefined,
      timeframes: overrideTimeframes && overrideTimeframes.length > 0 ? overrideTimeframes : undefined,
      mode: run.mode || undefined,
      resumeOfRunId: run.runId,
      resumeFromStepIndex: startIndex,
      resumeContext: { ...(resumeContext || {}), data: mergedData, source: mergedSource, control: resumeControl },
      source: 'playbook_resume'
    });
    if (res.ok) {
      const label = action === 'skip' ? 'Playbook Skipped' : 'Playbook Resumed';
      addNotification(label, `Resuming from step ${startIndex + 1}.`, 'info');
    } else {
      addNotification('Resume Failed', res.error || 'Unable to resume playbook.', 'warning');
    }
    return res;
  }, [addNotification, enqueuePlaybookRun]);

  useEffect(() => {
    enqueuePlaybookRunRef.current = enqueuePlaybookRun;
  }, [enqueuePlaybookRun]);

  useEffect(() => {
    resumePlaybookRunRef.current = resumePlaybookRun;
  }, [resumePlaybookRun]);

  const ensureActionTaskTree = useCallback(() => {
    if (actionTaskTreeRef.current) return actionTaskTreeRef.current;

    const touchUpdatedAt = () => {
      taskTreeUpdatedAtRef.current = Date.now();
    };

    const orchestrator = createActionTaskTree({
      executeCatalogAction,
      appendAuditEvent,
      persistState: (snapshot, opts) => persistTaskTreeState('action', snapshot, opts),
      recordTaskTreeRun: (summary) => recordTaskTreeRun(summary, 'action'),
      recordActionTrace,
      sanitizeActionTraceValue,
      setQueueDepth: setActionTaskQueueDepth,
      touchUpdatedAt,
      setLastSummary: (summary) => {
        taskTreeLastSummaryRef.current = { ...taskTreeLastSummaryRef.current, action: summary };
      },
      actionTaskActiveStepRef
    });

    actionTaskTreeRef.current = orchestrator;
    return orchestrator;
  }, [
    appendAuditEvent,
    executeCatalogAction,
    persistTaskTreeState,
    recordActionTrace,
    recordTaskTreeRun,
    sanitizeActionTraceValue,
    setActionTaskQueueDepth
  ]);
  ensureActionTaskTreeRef.current = ensureActionTaskTree;

  const enqueueCatalogAction = useCallback((input: {
    actionId: string;
    payload?: Record<string, any> | null;
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    mode?: string | null;
    source?: string | null;
    dedupeKey?: string | null;
    correlationId?: string | null;
  }) => {
    const actionId = String(input?.actionId || '').trim();
    if (!actionId) return { ok: false, error: 'Missing actionId.' };
    const payload = input?.payload && typeof input.payload === 'object' ? input.payload : {};
    const definition = getActionDefinitionCached(actionId);
    const symbol = input?.symbol ?? payload.symbol ?? null;
    const timeframe = input?.timeframe ?? payload.timeframe ?? null;
    const strategy = input?.strategy ?? payload.strategy ?? null;
    const mode = input?.mode ?? payload.mode ?? null;
    const baseSource = String(input?.source || 'action_catalog');
    const source = baseSource.includes(actionId) ? baseSource : `${baseSource}:${actionId}`;
    const payloadDedupeKey = payload.dedupeKey ?? payload.idempotencyKey;
    const dedupeKey = input?.dedupeKey
      ? String(input.dedupeKey)
      : payloadDedupeKey
        ? String(payloadDedupeKey)
        : `${actionId}:${symbol || ''}:${timeframe || ''}:${strategy || ''}:${mode || ''}`;

    const tree = ensureActionTaskTree();
    const res = tree.enqueue({
      source,
      correlationId: input?.correlationId ? String(input.correlationId) : undefined,
      symbol: symbol ? String(symbol) : undefined,
      timeframe: timeframe ? String(timeframe) : undefined,
      strategy: strategy ? String(strategy) : undefined,
      mode: mode ? String(mode) : undefined,
      dedupeKey,
      data: {
        actionId,
        definition: definition || null,
        payload,
        correlationId: input?.correlationId ? String(input.correlationId) : null
      }
    });
    const depthRaw = (tree as any)?.queue?.length;
    const depth = Number.isFinite(Number(depthRaw)) ? Number(depthRaw) : 0;
    setActionTaskQueueDepth(depth);
    return { ok: true, runId: res.runId, queued: res.queued };
  }, [ensureActionTaskTree, setActionTaskQueueDepth]);

  useEffect(() => {
    enqueueCatalogActionRef.current = enqueueCatalogAction;
  }, [enqueueCatalogAction]);

  useEffect(() => {
    void loadActionCatalogModule();
  }, []);

  const runRecommendedActionFlow = useCallback((flow: ActionFlowRecommendation, opts?: {
    symbol?: string | null;
    timeframe?: string | null;
    strategy?: string | null;
    mode?: TaskPlaybookMode | null;
    source?: string | null;
  }) => {
    if (!flow || !Array.isArray(flow.sequence)) {
      addNotification('Flow Unavailable', 'No action sequence available to run.', 'warning');
      return { ok: false, error: 'Missing flow sequence.' };
    }
    const sequence = flow.sequence.map((step) => String(step || '').trim()).filter(Boolean);
    if (sequence.length === 0) {
      addNotification('Flow Unavailable', 'No action sequence available to run.', 'warning');
      return { ok: false, error: 'Missing flow sequence.' };
    }
    const symbol = String(opts?.symbol || flow.symbol || '').trim();
    const timeframe = String(opts?.timeframe || flow.timeframe || '').trim();
    const strategy = opts?.strategy ? String(opts.strategy) : null;
    const baseSource = String(opts?.source || `action_flow:${flow.intentKey || 'flow'}`).trim();
    const mode = normalizeTaskPlaybookMode(opts?.mode || 'coordinate');
    const flowKey = hashStringSampled(`${flow.intentKey || 'flow'}:${sequence.join('|')}:${symbol}:${timeframe}`, 512);
    const playbookId = `playbook.action_flow.${flowKey}`;
    const playbook: TaskPlaybook = {
      id: playbookId,
      name: `Flow ${flow.intentLabel || flow.intentKey || 'Actions'}`,
      description: `Action flow ${flow.intentLabel || flow.intentKey || ''}`.trim(),
      owner: 'system',
      symbol: symbol || null,
      timeframes: timeframe ? [timeframe] : null,
      strategy: strategy || null,
      defaultMode: mode,
      steps: sequence.map((actionId, index) => ({
        id: `step_${index + 1}`,
        label: actionId,
        actionId,
        payload: {
          symbol: symbol || undefined,
          timeframe: timeframe || undefined,
          strategy: strategy || undefined,
          intentKey: flow.intentKey || undefined,
          intentLabel: flow.intentLabel || undefined,
          source: baseSource
        }
      })),
      tags: ['action_flow', flow.intentKey || 'flow'].filter(Boolean),
      createdAtMs: Date.now(),
      updatedAtMs: Date.now()
    };

    const res = enqueuePlaybookRun({
      playbook,
      symbol: symbol || undefined,
      timeframe: timeframe || undefined,
      strategy: strategy || undefined,
      mode,
      source: baseSource,
      reason: 'action_flow'
    });
    if (res.ok) {
      void appendAuditEvent({
        eventType: 'autopilot_action_flow_started',
        symbol: symbol || null,
        runId: res.runId || null,
        payload: {
          playbookId: playbook.id,
          intentKey: flow.intentKey || null,
          intentLabel: flow.intentLabel || null,
          source: baseSource,
          timeframe: timeframe || null,
          strategy: strategy || null,
          sequence,
          queued: res.queued ?? null
        }
      });
      void refreshShadowTrades({ force: true, includeCompare: true });
      addNotification('Action Flow Started', playbook.name, 'info');
    } else {
      void appendAuditEvent({
        eventType: 'autopilot_action_flow_failed',
        symbol: symbol || null,
        payload: {
          playbookId: playbook.id,
          intentKey: flow.intentKey || null,
          intentLabel: flow.intentLabel || null,
          source: baseSource,
          timeframe: timeframe || null,
          strategy: strategy || null,
          sequence,
          error: res.error || 'Unable to start flow.'
        }
      });
      addNotification('Action Flow Failed', res.error || 'Unable to start flow.', 'warning');
    }
    return res;
  }, [addNotification, appendAuditEvent, enqueuePlaybookRun, refreshShadowTrades]);
  runRecommendedActionFlowRef.current = runRecommendedActionFlow;

  const {
    messages: chartChatMessages,
    sendMessage: sendChartChatMessage,
    clearChat: clearChartChat,
    isThinking: chartChatThinking,
    replyMode: chartChatReplyMode,
    setReplyMode: setChartChatReplyMode,
    autoTabVisionEnabled: chartChatAutoTabVisionEnabled,
    setAutoTabVisionEnabled: setChartChatAutoTabVisionEnabled,
    chartWatchEnabled: chartChatWatchEnabled,
    setChartWatchEnabled: setChartChatWatchEnabled,
    chartWatchMode: chartChatWatchMode,
    setChartWatchMode: setChartChatWatchMode,
    chartWatchSnoozedUntilMs: chartChatSnoozedUntilMs,
    snoozeChartWatch: chartChatSnoozeWatch,
    clearChartWatchSnooze: clearChartChatSnooze,
    chartWatchLeadAgentId: chartChatLeadAgentId,
    setChartWatchLeadAgentId: setChartChatLeadAgentId,
    agents: chartChatAgents,
    activeAgentId: chartChatActiveAgentId,
    addAgent: addChartChatAgent,
    updateAgent: updateChartChatAgent,
    deleteAgent: deleteChartChatAgent,
    switchAgent: switchChartChatAgent,
    isLive: chartChatIsLive,
    liveMode: chartChatLiveMode,
    liveStream: chartChatLiveStream,
    startLiveSession: startChartChatLive,
    stopLiveSession: stopChartChatLive,
    sendVideoFrame: sendChartChatVideoFrame,
    speakMessage: speakChartChatMessage,
    speakingMessageId: chartChatSpeakingMessageId,
    sessionBias: chartChatSessionBias,
    setSessionBias: setChartChatSessionBias,
    executeTradeProposal: executeChartChatTradeProposal,
    rejectTradeProposal: rejectChartChatTradeProposal,
    executeBrokerAction: executeChartChatBrokerAction,
    rejectBrokerAction: rejectChartChatBrokerAction,
    cancelAgentTool: cancelChartChatAgentTool
  } = useChat(executeTradeRequestViaApi, {
    getExternalContext: getChartChatAgentContext,
    systemContextPrefix: chartChatSystemPrefix,
    disableChartWatch: true,
    onExecuteBrokerAction: executeBrokerActionViaApi,
    onExecuteAgentTool: executeAgentToolRequest,
    onCancelAgentTool: cancelAgentToolRequest,
    onAgentRequest: handleAgentRequest,
    defaultActionSource: 'chart',
    resolveActionFlowIntent
  });

  const sendChartChatMessageWithSnapshot = useCallback(async (
    text: string,
    context: { url: string; title?: string },
    monitoredUrls: string[],
    imageAttachment?: string | Array<{ dataUrl?: string; label?: string; meta?: any }> | null,
    options?: { symbol?: string; timeframes?: string[] }
  ) => {
    const msgId = `chart_${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;
    const symbol = resolveChartChatSymbol(options?.symbol);
    const timeframes = resolveChartChatTimeframes(options?.timeframes);
    const preview = String(text || '').trim().slice(0, 160);

    logChartChatEvent('UI_SEND_CHART_CHAT', {
      msgId,
      symbol,
      activePanel: 'chart_chat',
      timeframesRequested: timeframes,
      textPreview: preview
    });

    const snapshotBundle = await captureChartChatSnapshot(msgId, options);
    const attachments: Array<{ dataUrl?: string; label?: string; meta?: any }> = [];
    if (snapshotBundle?.imageDataUrl) {
      attachments.push({ dataUrl: snapshotBundle.imageDataUrl, label: 'Native chart snapshot' });
    }
    if (Array.isArray(imageAttachment)) {
      imageAttachment.forEach((item) => {
        if (!item) return;
        if (typeof item === 'string') {
          const trimmed = item.trim();
          if (trimmed) attachments.push({ dataUrl: trimmed });
        } else if (typeof item === 'object') {
          attachments.push(item);
        }
      });
    } else if (typeof imageAttachment === 'string') {
      const trimmed = imageAttachment.trim();
      if (trimmed) attachments.push({ dataUrl: trimmed });
    }

    const finalAttachment = attachments.length > 0 ? attachments : null;
    const modelHint = resolveModelType(finalAttachment);
    const hasFrames = Array.isArray(snapshotBundle?.payload?.frames) && snapshotBundle.payload.frames.length > 0;
    const payloadChars = snapshotBundle?.payloadChars || null;
    const payloadWarnings = snapshotBundle?.payload?.diagnostics?.warnings || [];
    const truncated = Array.isArray(payloadWarnings) && payloadWarnings.includes('PAYLOAD_STRIPPED');

    logChartChatEvent('BUILD_AGENT_REQUEST', {
      msgId,
      symbol: snapshotBundle?.status?.symbol || symbol || null,
      hasImage: modelHint === 'vision',
      hasFrames,
      payloadChars,
      truncated
    });

    return sendChartChatMessage(text, context, monitoredUrls, finalAttachment, {
      correlationId: msgId,
      channel: 'chart',
      symbol: snapshotBundle?.status?.symbol || symbol || null,
      modelHint,
      hasImage: modelHint === 'vision',
      hasFrames,
      payloadChars
    });
  }, [
    captureChartChatSnapshot,
    logChartChatEvent,
    resolveChartChatSymbol,
    resolveChartChatTimeframes,
    sendChartChatMessage
  ]);

  const clearChartChatWithSnapshot = useCallback(() => {
    clearChartChat();
    chartChatSnapshotRef.current = null;
    setChartChatSnapshotStatus(null);
  }, [clearChartChat]);

  useEffect(() => {
    chartChatHandlersRef.current = {
      sendMessage: sendChartChatMessageWithSnapshot,
      clearChat: clearChartChatWithSnapshot,
      setReplyMode: setChartChatReplyMode,
      setAutoTabVisionEnabled: setChartChatAutoTabVisionEnabled,
      startLiveSession: startChartChatLive,
      stopLiveSession: stopChartChatLive,
      liveStream: chartChatLiveStream,
      setSessionBias: setChartChatSessionBias
    };
  }, [
    chartChatLiveStream,
    clearChartChatWithSnapshot,
    sendChartChatMessageWithSnapshot,
    setChartChatAutoTabVisionEnabled,
    setChartChatReplyMode,
    setChartChatSessionBias,
    startChartChatLive,
    stopChartChatLive
  ]);

  useEffect(() => {
    liveStatusRef.current = { isLive, chartChatIsLive };
    const lastMessage = chartChatMessages && chartChatMessages.length > 0
      ? chartChatMessages[chartChatMessages.length - 1]
      : null;
    const lastMessageAtMs = lastMessage?.timestamp ? lastMessage.timestamp.getTime() : null;
    chatStateRef.current = {
      ...chatStateRef.current,
      chartChatIsLive: !!chartChatIsLive,
      chartChatThinking: !!chartChatThinking,
      chartChatMessagesCount: Array.isArray(chartChatMessages) ? chartChatMessages.length : 0,
      chartChatLastMessageAtMs: lastMessageAtMs
    };
  }, [chartChatIsLive, chartChatMessages, chartChatThinking, isLive]);

  const chartChatContext = React.useMemo(() => ({
    url: 'chart://engine',
    title: 'Chart Engine'
  }), []);

  useEffect(() => {
    chartChatContextRef.current = chartChatContext;
  }, [chartChatContext]);

  useEffect(() => {
    chartChatSnapshotStatusRef.current = chartChatSnapshotStatus;
  }, [chartChatSnapshotStatus]);

  const postTradeReviewEnabledRef = React.useRef<boolean>(!!postTradeReviewEnabled);
  useEffect(() => {
    postTradeReviewEnabledRef.current = !!postTradeReviewEnabled;
  }, [postTradeReviewEnabled]);

  useEffect(() => {
    agentsRef.current = agents;
    agents.forEach((agent) => {
      if (!agent || !agent.id) return;
      if (!agentBaseInstructionRef.current.has(agent.id)) {
        const base = String(agent.systemInstruction || '').split(ACADEMY_AGENT_UPDATE_MARKER)[0].trim();
        agentBaseInstructionRef.current.set(agent.id, base);
      }
    });
    applyAcademyUpdatesToAgents();
    void refreshShadowProfiles();
  }, [agents, applyAcademyUpdatesToAgents, refreshShadowProfiles]);

  useEffect(() => {
    shadowProfilesRef.current = shadowProfiles;
  }, [shadowProfiles]);

  useEffect(() => {
    shadowAccountsRef.current = shadowAccounts;
  }, [shadowAccounts]);

  useEffect(() => {
    shadowTradeViewsRef.current = shadowTradeViews;
  }, [shadowTradeViews]);

  useEffect(() => {
    mt5AccountSpecRef.current = mt5AccountSpec;
  }, [mt5AccountSpec]);

  useEffect(() => {
    const needsMt5 = (shadowProfiles || []).some((profile) => profile?.liveDeployEnabled && profile.liveBroker === 'mt5');
    if (!needsMt5) return;
    let canceled = false;
    let stop: (() => void) | null = null;
    const poll = async () => {
      try {
        const spec = await fetchMt5AccountSpec();
        if (canceled) return;
        if (spec) {
          setMt5AccountSpec(spec);
        }
      } catch {
        // ignore MT5 polling failures
      }
    };
    void loadMt5AccountSpecControllerModule().then((mod) => {
      if (canceled) return;
      const controller = mod.createMt5AccountSpecController({
        intervalMs: 5_000,
        runOnStart: true,
        tick: poll
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      canceled = true;
      stop?.();
    };
  }, [shadowProfiles]);

  useEffect(() => {
    chartChatAgentsRef.current = chartChatAgents;
  }, [chartChatAgents]);

  useEffect(() => {
    updateAgentRef.current = updateAgent;
  }, [updateAgent]);

  // Sync ref for the callback
  useEffect(() => {
      autoPilotConfigRef.current = autoPilotConfig;
  }, [autoPilotConfig]);

  useEffect(() => {
    const enabled = !!autoPilotConfig?.enabled;
    const killSwitch = !!autoPilotConfig?.killSwitch;
    const mode = autoPilotConfig?.mode ? String(autoPilotConfig.mode) : null;
    const prev = autoCalendarStateRef.current || {};
    const initialized = prev.enabled !== undefined || prev.killSwitch !== undefined || prev.mode !== undefined;

    if (initialized) {
      if (prev.enabled !== enabled) {
        void upsertCalendarEvent({
          type: enabled ? 'auto_session_start' : 'auto_session_end',
          title: enabled ? 'Auto session ON' : 'Auto session OFF',
          startAtMs: Date.now(),
          status: enabled ? 'enabled' : 'disabled',
          metadata: { mode, executionMode: autoPilotConfig?.executionMode ?? null },
          source: 'automation'
        });
      }
      if (prev.killSwitch !== killSwitch) {
        void upsertCalendarEvent({
          type: killSwitch ? 'killswitch_on' : 'killswitch_off',
          title: killSwitch ? 'Auto kill switch ON' : 'Auto kill switch OFF',
          startAtMs: Date.now(),
          status: killSwitch ? 'on' : 'off',
          metadata: { mode, executionMode: autoPilotConfig?.executionMode ?? null },
          source: 'automation'
        });
      }
      if (prev.mode !== mode && mode) {
        void upsertCalendarEvent({
          type: 'autopilot_mode_changed',
          title: `Auto mode ${prev.mode || 'unknown'}  ${mode}`,
          startAtMs: Date.now(),
          status: 'changed',
          metadata: { from: prev.mode || null, to: mode },
          source: 'automation'
        });
      }
    }

    autoCalendarStateRef.current = { enabled, killSwitch, mode };
  }, [autoPilotConfig?.enabled, autoPilotConfig?.executionMode, autoPilotConfig?.killSwitch, autoPilotConfig?.mode, upsertCalendarEvent]);

  useEffect(() => {
    if (shadowFollowStateRef.current == null) {
      shadowFollowStateRef.current = signalShadowFollowEnabled;
      return;
    }
    if (shadowFollowStateRef.current !== signalShadowFollowEnabled) {
      void upsertCalendarEvent({
        type: signalShadowFollowEnabled ? 'shadow_follow_on' : 'shadow_follow_off',
        title: signalShadowFollowEnabled ? 'Shadow follow ON' : 'Shadow follow OFF',
        startAtMs: Date.now(),
        status: signalShadowFollowEnabled ? 'enabled' : 'disabled',
        source: 'automation'
      });
      shadowFollowStateRef.current = signalShadowFollowEnabled;
    }
  }, [signalShadowFollowEnabled, upsertCalendarEvent]);

  useEffect(() => {
    setAutoPilotConfigRef.current = setAutoPilotConfig;
  }, [setAutoPilotConfig]);

  useEffect(() => {
    let hadDirtyShutdown = false;
    try {
      const raw = localStorage.getItem(SHUTDOWN_STATE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object' && parsed.clean === false) {
          hadDirtyShutdown = true;
        }
      }
    } catch {
      // ignore storage errors
    }

    if (hadDirtyShutdown && !recoveryAppliedRef.current) {
      recoveryAppliedRef.current = true;
      setAutoPilotConfig((prev) => ({ ...prev, enabled: false, killSwitch: true }));
      addNotification('Recovery Mode', 'Previous session ended unexpectedly. AutoPilot is disabled.', 'warning');
      void appendAuditEvent({
        eventType: 'app_resume_recovery',
        level: 'warn',
        payload: { reason: 'unclean_shutdown' }
      });
    }

    try {
      localStorage.setItem(SHUTDOWN_STATE_KEY, JSON.stringify({ clean: false, ts: Date.now() }));
    } catch {
      // ignore storage errors
    }

    const handleUnload = () => {
      try {
        localStorage.setItem(SHUTDOWN_STATE_KEY, JSON.stringify({ clean: true, ts: Date.now() }));
      } catch {
        // ignore storage errors
      }
      void appendAuditEvent({
        eventType: 'app_shutdown',
        payload: { clean: true }
      });
    };

    window.addEventListener('beforeunload', handleUnload);
    return () => {
      window.removeEventListener('beforeunload', handleUnload);
    };
  }, [addNotification, appendAuditEvent, setAutoPilotConfig]);

  
  // Sidebar state management
  const { isOpen, mode, toggleSidebar, openSidebar, closeSidebar, switchMode } = useSidebar();
  const [shadowPanelTab, setShadowPanelTab] = useState<'shadow' | 'auto'>('shadow');
  const setShadowPanelTabSafe = useCallback((next: 'shadow' | 'auto') => {
    setShadowPanelTab(next);
    if (next === 'auto') {
      prefetchSidebarMode('autopilot');
    }
  }, [prefetchSidebarMode]);
  useEffect(() => {
    if (mode !== 'patterns') return;
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 2000,
        runOnStart: true,
        onTick: () => {
          setPatternEvents(chartEngine.listRecentEvents(300));
        }
      });
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [chartEngine, mode]);
  useEffect(() => {
    if (mode !== 'snapshot') return;
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 2000,
        runOnStart: true,
        onTick: () => {
          void refreshSnapshotPanelStatus();
        }
      });
    }).catch(() => {
      // ignore lazy controller load errors
    });
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [mode, refreshSnapshotPanelStatus]);

  useEffect(() => {
    outcomeConsistencyEngine.markPanelRead('leaderboard', outcomeFeedCursor);
    if (mode === 'leaderboard') {
      setOutcomeFeedConsistency(outcomeConsistencyEngine.getConsistencyState());
      setPanelFreshness(outcomeConsistencyEngine.getPanelFreshness());
    }
  }, [leaderboardHistory, mode, outcomeFeedCursor]);

  useEffect(() => {
    if (mode !== 'academy') return;
    outcomeConsistencyEngine.markPanelRead('academy', outcomeFeedCursor);
    setOutcomeFeedConsistency(outcomeConsistencyEngine.getConsistencyState());
    setPanelFreshness(outcomeConsistencyEngine.getPanelFreshness());
  }, [mode, outcomeFeedCursor, academyCases, academyLessons, academySymbolLearnings]);

  useEffect(() => {
    if (mode !== 'audit') return;
    outcomeConsistencyEngine.markPanelRead('audit', outcomeFeedCursor);
    setOutcomeFeedConsistency(outcomeConsistencyEngine.getConsistencyState());
    setPanelFreshness(outcomeConsistencyEngine.getPanelFreshness());
  }, [mode, outcomeFeedCursor]);

  useEffect(() => {
    if (mode !== 'changes') return;
    outcomeConsistencyEngine.markPanelRead('changes', outcomeFeedCursor);
    setOutcomeFeedConsistency(outcomeConsistencyEngine.getConsistencyState());
    setPanelFreshness(outcomeConsistencyEngine.getPanelFreshness());
  }, [mode, outcomeFeedCursor]);

  useEffect(() => {
    const sessionValue = (signalSessions.find((entry) => entry?.enabled)?.id || null) as string | null;
    const symbol = String(
      symbolScopeSymbol ||
      signalPrimarySymbol ||
      nativeChartSymbol ||
      activeBrokerSymbol ||
      activeTvParams?.symbol ||
      ''
    ).trim().toUpperCase();
    const timeframe = String(
      symbolScopeTimeframes[0] ||
      signalTimeframes[0] ||
      activeTvTimeframeLabel ||
      ''
    ).trim();
    crossPanelContextEngine.publish({
      symbol: symbol || null,
      timeframe: timeframe || null,
      session: sessionValue,
      agentId: activeAgentId || null,
      strategyId: signalStrategyModes[0] || null,
      originPanel: mode || null
    }, { debounceMs: 60 });
  }, [
    activeAgentId,
    activeBrokerSymbol,
    activeTvParams?.symbol,
    activeTvTimeframeLabel,
    mode,
    nativeChartSymbol,
    signalPrimarySymbol,
    signalSessions,
    signalStrategyModes,
    signalTimeframes,
    symbolScopeSymbol,
    symbolScopeTimeframes
  ]);

  const [appVisible, setAppVisible] = useState(() => !document.hidden);
  const [appFocused, setAppFocused] = useState(() => document.hasFocus());
  useEffect(() => {
    sidebarModeRef.current = mode;
    sidebarStateRef.current = { isOpen: !!isOpen, mode };
    if (mode === 'nativechart') {
      setNativeChartMounted(true);
    }
    if (mode === 'backtester') {
      setBacktesterMounted(true);
    }
    if (mode === 'setups') {
      setSetupsMounted(true);
    }
    if (mode === 'agentcreator') {
      setAgentCreatorMounted(true);
    }
    if (mode === 'agentmemory') {
      setAgentMemoryMounted(true);
    }
    if (mode === 'agentlab') {
      setAgentLabMounted(true);
    }
    if (mode === 'academy') {
      setAcademyMounted(true);
    }
    if (mode === 'audit') {
      setAuditMounted(true);
    }
    if (mode === 'changes') {
      setChangesMounted(true);
    }
  }, [isOpen, mode]);

  useEffect(() => {
    const updateVisibility = () => {
      const visible = !document.hidden;
      setAppVisible(visible);
      setAppFocused(document.hasFocus());
      runtimeScheduler.setVisibility(visible);
    };
    updateVisibility();
    document.addEventListener('visibilitychange', updateVisibility);
    window.addEventListener('focus', updateVisibility);
    window.addEventListener('blur', updateVisibility);
    return () => {
      document.removeEventListener('visibilitychange', updateVisibility);
      window.removeEventListener('focus', updateVisibility);
      window.removeEventListener('blur', updateVisibility);
    };
  }, []);

  const appForeground = appVisible && appFocused;
  const brokerDataActive =
    !!autoPilotConfig?.enabled ||
    signalAutoRefreshEnabled ||
    mode === 'signal' ||
    mode === 'snapshot' ||
    mode === 'shadow' ||
    mode === 'setups' ||
    mode === 'nativechart' ||
    mode === 'tradelocker' ||
    chartChatIsLive ||
    chartChatWatchEnabled;
  const backgroundWatchersEnabled = brokerDataActive || appForeground;
  useEffect(() => {
    backgroundWatchersEnabledRef.current = backgroundWatchersEnabled;
  }, [backgroundWatchersEnabled]);

  const handleSwitchSidebarMode = useCallback((nextMode: SidebarMode) => {
    if (nextMode === 'autopilot') {
      setShadowPanelTabSafe('auto');
      switchMode('shadow');
      return;
    }
    if (nextMode === 'shadow') {
      setShadowPanelTabSafe('shadow');
    }
    switchMode(nextMode);
  }, [setShadowPanelTabSafe, switchMode]);

  const openSidebarMode = useCallback((nextMode: SidebarMode) => {
    openSidebar();
    handleSwitchSidebarMode(nextMode);
  }, [openSidebar, handleSwitchSidebarMode]);

  const setAgentSignalScanEnabled = useCallback((agentId: string, enabled: boolean) => {
    const id = String(agentId || '').trim();
    if (!id) return;
    setAgentScanEnabledById((prev) => ({
      ...(prev || {}),
      [id]: enabled !== false
    }));
  }, []);

  const openSymbolPanel = useCallback(
    (target: 'nativechart' | 'mt5' | 'tradelocker', symbol: string, timeframe?: string | null) => {
      const cleaned = String(symbol || '').trim();
      if (!cleaned) return;
      const frames = timeframe ? [...symbolScopeTimeframes, String(timeframe)] : undefined;
      updateSymbolScope(cleaned, { timeframes: frames, source: target });
      if (target === 'nativechart') {
        setNativeChartSymbol(cleaned);
        pendingChartFocusRef.current = { symbol: cleaned, timeframe: timeframe || undefined };
        const chart = nativeChartRef.current;
        if (chart?.focusSymbol) {
          chart.focusSymbol(cleaned, timeframe || undefined, { revealSetups: true });
          pendingChartFocusRef.current = null;
        }
        openSidebarMode('nativechart');
        return;
      }
      openSidebarMode(target);
    },
    [openSidebarMode, setNativeChartSymbol, symbolScopeTimeframes, updateSymbolScope]
  );
  openSymbolPanelRef.current = openSymbolPanel;

  const publishImmediatePanelContext = useCallback((input: {
    symbol?: string | null;
    timeframe?: string | null;
    agentId?: string | null;
    strategyId?: string | null;
    originPanel: string;
  }) => {
    const symbol = String(input.symbol || '').trim().toUpperCase();
    const timeframe = String(input.timeframe || '').trim();
    const agentId = String(input.agentId || '').trim();
    const strategyId = String(input.strategyId || '').trim();
    const originPanel = String(input.originPanel || '').trim();
    crossPanelContextEngine.publish({
      symbol: symbol || null,
      timeframe: timeframe || null,
      agentId: agentId || null,
      strategyId: strategyId || null,
      originPanel: originPanel || null
    }, { debounceMs: 0, merge: false });
  }, []);

  const publishSignalSelectionContext = useCallback((entry: SignalEntry | null | undefined, originPanel: string = 'signal') => {
    if (!entry) return;
    publishImmediatePanelContext({
      symbol: entry.symbol || null,
      timeframe: entry.timeframe || null,
      agentId: entry.agentId || null,
      strategyId: entry.strategyMode || null,
      originPanel
    });
  }, [publishImmediatePanelContext]);

  const publishAcademySelectionContext = useCallback((entry: AcademyCase | null | undefined, originPanel: string = 'academy') => {
    if (!entry) return;
    publishImmediatePanelContext({
      symbol: entry.symbol || null,
      timeframe: entry.timeframe || null,
      agentId: entry.agentId || null,
      strategyId: entry.strategyMode || null,
      originPanel
    });
  }, [publishImmediatePanelContext]);

  const handleSignalFocus = useCallback((entry: SignalEntry) => {
    publishSignalSelectionContext(entry, 'signal');
  }, [publishSignalSelectionContext]);

  const handleAcademyCaseSelect = useCallback((caseId: string | null) => {
    const id = caseId ? String(caseId).trim() : '';
    setAcademySelectedCaseId(id || null);
    if (!id) return;
    const selectedCase = (academyCasesRef.current || []).find((entry) => entry.id === id) || null;
    if (selectedCase) {
      publishAcademySelectionContext(selectedCase, 'academy');
    }
  }, [publishAcademySelectionContext]);

  const openAcademyCase = useCallback((caseId?: string | null) => {
    const id = caseId ? String(caseId).trim() : '';
    if (id) {
      setAcademySelectedCaseId(id);
      const selectedCase =
        (academyCasesRef.current || []).find((entry) => entry.id === id || entry.signalId === id) || null;
      if (selectedCase) {
        publishAcademySelectionContext(selectedCase, 'academy');
      } else {
        const selectedSignal = (signalEntriesRef.current || []).find((entry) => entry.id === id) || null;
        if (selectedSignal) {
          publishSignalSelectionContext(selectedSignal, 'signal');
        }
      }
    }
    openSidebarMode('academy');
  }, [openSidebarMode, publishAcademySelectionContext, publishSignalSelectionContext]);

  useEffect(() => {
    sidebarControlRef.current = {
      openSidebarMode,
      switchMode: handleSwitchSidebarMode,
      openSidebar,
      closeSidebar,
      toggleSidebar
    };
  }, [closeSidebar, handleSwitchSidebarMode, openSidebar, openSidebarMode, toggleSidebar]);

  const commandActions = React.useMemo<CommandAction[]>(() => {
    const flowActions: CommandAction[] = Array.isArray(recommendedActionFlowsState)
      ? recommendedActionFlowsState.slice(0, 8).map((flow, index) => {
          const label = flow.intentLabel || flow.intentKey || 'Action Flow';
          const meta = [flow.symbol, flow.timeframe].filter(Boolean).join(' ');
          const sequence = Array.isArray(flow.sequence) ? flow.sequence.join(' > ') : '';
          return {
            id: `flow-${flow.intentKey}-${index}`,
            label: `Run Flow: ${label}`,
            group: 'Flows',
            hint: [meta, sequence].filter(Boolean).join(' | '),
            onSelect: () => runRecommendedActionFlow(flow)
          } as CommandAction;
        })
      : [];
    const paletteSymbol = String(symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    const paletteTimeframe = String(symbolScopeTimeframesLabel || activeTvTimeframeLabel || '').trim();
    const symbolActions: CommandAction[] = paletteSymbol
      ? [
          {
            id: 'open-symbol-chart',
            label: `Open ${paletteSymbol} in Chart`,
            group: 'Symbol',
            hint: paletteTimeframe || undefined,
            onSelect: () => openSymbolPanel('nativechart', paletteSymbol)
          },
          {
            id: 'open-symbol-mt5',
            label: `Open ${paletteSymbol} in MT5`,
            group: 'Symbol',
            hint: paletteTimeframe || undefined,
            onSelect: () => openSymbolPanel('mt5', paletteSymbol)
          },
          {
            id: 'open-symbol-tradelocker',
            label: `Open ${paletteSymbol} in TradeLocker`,
            group: 'Symbol',
            hint: paletteTimeframe || undefined,
            onSelect: () => openSymbolPanel('tradelocker', paletteSymbol)
          }
        ]
      : [];
    return [
      { id: 'open-chat', label: 'Open Chat', group: 'Panels', onSelect: () => openSidebarMode('chat') },
      { id: 'open-signal', label: 'Open Signal', group: 'Panels', onSelect: () => openSidebarMode('signal') },
      { id: 'open-snapshot', label: 'Open Snapshot', group: 'Panels', onSelect: () => openSidebarMode('snapshot') },
      { id: 'open-patterns', label: 'Open Patterns', group: 'Panels', onSelect: () => openSidebarMode('patterns') },
      { id: 'open-shadow', label: 'Open Shadow', group: 'Panels', onSelect: () => openSidebarMode('shadow') },
      { id: 'open-calendar', label: 'Open Calendar', group: 'Panels', onSelect: () => openSidebarMode('calendar') },
      { id: 'open-chart-chat', label: 'Open Chart Chat', group: 'Panels', onSelect: () => openSidebarMode('chartchat') },
      { id: 'open-notes', label: 'Open Notes', group: 'Panels', onSelect: () => openSidebarMode('notes') },
      { id: 'open-autopilot', label: 'Open AutoPilot', group: 'Panels', onSelect: () => openSidebarMode('autopilot') },
      { id: 'open-tradelocker', label: 'Open TradeLocker', group: 'Panels', onSelect: () => openSidebarMode('tradelocker') },
      { id: 'open-chart', label: 'Open Native Chart', group: 'Panels', onSelect: () => openSidebarMode('nativechart') },
      { id: 'open-backtester', label: 'Open Backtester', group: 'Panels', onSelect: () => openSidebarMode('backtester') },
      { id: 'open-setups', label: 'Open Setups', group: 'Panels', onSelect: () => openSidebarMode('setups') },
      { id: 'open-agent-creator', label: 'Open Agent', group: 'Panels', onSelect: () => openSidebarMode('agentcreator') },
      { id: 'open-memory', label: 'Open Memory', group: 'Panels', onSelect: () => openSidebarMode('agentmemory') },
      { id: 'open-agent-lab', label: 'Open Agent Lab', group: 'Panels', onSelect: () => openSidebarMode('agentlab') },
      { id: 'open-academy', label: 'Open Academy', group: 'Panels', onSelect: () => openSidebarMode('academy') },
      { id: 'open-monitor', label: 'Open Monitor', group: 'Panels', onSelect: () => openSidebarMode('monitor') },
      { id: 'open-audit', label: 'Open Audit Trail', group: 'Panels', onSelect: () => openSidebarMode('audit') },
      { id: 'open-changes', label: 'Open Changes', group: 'Panels', onSelect: () => openSidebarMode('changes') },
      { id: 'toggle-sidebar', label: isOpen ? 'Hide Sidebar' : 'Show Sidebar', group: 'System', onSelect: () => toggleSidebar() },
      { id: 'open-settings', label: 'Open Settings', group: 'System', shortcut: 'Ctrl+,', onSelect: () => openSettings() },
      { id: 'toggle-fullscreen', label: 'Toggle Fullscreen', group: 'System', shortcut: 'F11', onSelect: () => toggleFullscreen() },
      { id: 'context-pack-copy', label: 'Context Pack: Copy', group: 'Context', hint: 'Copy the agent context snapshot', onSelect: () => captureContextPack({ copy: true }) },
      { id: 'context-pack-save', label: 'Context Pack: Save', group: 'Context', hint: 'Save to agent memory', onSelect: () => captureContextPack({ save: true }) },
      ...symbolActions,
      ...flowActions
    ];
  }, [
    activeBrokerSymbol,
    activeTvParams?.symbol,
    activeTvTimeframeLabel,
    captureContextPack,
    isOpen,
    openSettings,
    openSidebarMode,
    openSymbolPanel,
    recommendedActionFlowsState,
    runRecommendedActionFlow,
    symbolScopeSymbol,
    symbolScopeTimeframesLabel,
    toggleFullscreen,
    toggleSidebar
  ]);

  const focusNativeChart = useCallback(
    (symbol?: string, timeframe?: string) => {
      const nextSymbol = String(symbol || '').trim();
      if (nextSymbol) {
        setNativeChartSymbol(nextSymbol);
        pendingChartFocusRef.current = { symbol: nextSymbol, timeframe };
      }

      const chart = nativeChartRef.current;
      if (chart?.focusSymbol && nextSymbol) {
        chart.focusSymbol(nextSymbol, timeframe, { revealSetups: true });
        pendingChartFocusRef.current = null;
      } else if (chart?.ensureFrameActive && timeframe) {
        chart.ensureFrameActive(timeframe);
      }
      if (chart?.setShowSetups) {
        chart.setShowSetups(true);
      }

      switchMode('nativechart');
    },
    [switchMode]
  );

  const handleExplainSetupSignal = useCallback(
    (signalId: string, profileId?: string | null) => {
      const id = String(signalId || '').trim();
      if (!id) return;
      const profile = profileId ? String(profileId).trim() : '';
      const prompt = profile
        ? `Explain setup signal ${id} for profile ${profile}.`
        : `Explain setup signal ${id}.`;
      openSidebar();
      switchMode('chartchat');
      sendChartChatMessageWithSnapshot(prompt, chartChatContext, [], null);
    },
    [chartChatContext, openSidebar, sendChartChatMessageWithSnapshot, switchMode]
  );

  const handleReplayTrade = useCallback(
    (payload: {
      symbol: string;
      timeframe?: string | null;
      entryPrice?: number | null;
      stopLoss?: number | null;
      takeProfit?: number | null;
      closePrice?: number | null;
      action?: string | null;
      ledgerId?: string | null;
      noteId?: string | null;
    }) => {
      const symbol = String(payload?.symbol || '').trim();
      if (!symbol) return;
      const timeframe = payload?.timeframe ? String(payload.timeframe).trim() : null;
      const entry = Number(payload?.entryPrice);
      const stop = Number(payload?.stopLoss);
      const tp = Number(payload?.takeProfit);
      const close = Number(payload?.closePrice);
      const action = String(payload?.action || '').toUpperCase();
      const levels = [];
      if (Number.isFinite(entry)) {
        levels.push({
          price: entry,
          label: `${action === 'SELL' ? 'SELL' : action === 'BUY' ? 'BUY' : 'Trade'} Entry`,
          color: '#38bdf8',
          priority: 26
        });
      }
      if (Number.isFinite(stop)) {
        levels.push({
          price: stop,
          label: 'Stop',
          color: '#f97316',
          style: 'dashed',
          priority: 25
        });
      }
      if (Number.isFinite(tp)) {
        levels.push({
          price: tp,
          label: 'TP',
          color: '#22c55e',
          style: 'dashed',
          priority: 25
        });
      }
      if (Number.isFinite(close)) {
        levels.push({
          price: close,
          label: 'Close',
          color: '#facc15',
          priority: 24
        });
      }
      const annotation: ReviewAnnotation = {
        id: payload?.ledgerId ? `review_${payload.ledgerId}` : `review_${Date.now()}`,
        symbol,
        timeframe,
        createdAtMs: Date.now(),
        levels,
        note: payload?.noteId || null
      };
      setReviewAnnotations(levels.length > 0 ? [annotation] : []);
      nativeChartRef.current?.setShowReviews?.(true);
      focusNativeChart(symbol, timeframe || undefined);
    },
    [focusNativeChart]
  );

  useEffect(() => {
    if (!nativeChartMounted) return;
    const pending = pendingChartFocusRef.current;
    if (!pending) return;
    const chart = nativeChartRef.current;
    if (!chart?.focusSymbol) return;
    chart.focusSymbol(pending.symbol, pending.timeframe, { revealSetups: true });
    chart.setShowSetups?.(true);
    pendingChartFocusRef.current = null;
  }, [nativeChartMounted]);

  useEffect(() => {
    if (!nativeChartMounted && mode !== 'nativechart') return;
    const ensureConnect = ensureTradeLockerConnectedRef.current;
    if (!ensureConnect) return;
    void ensureConnect('native_chart_panel');
  }, [mode, nativeChartMounted]);

  useEffect(() => {
    if (mode !== 'backtester') return;
    flushPendingBacktestApply();
  }, [flushPendingBacktestApply, mode]);

  const keepWatchedTabsMountedRequested =
    isLive ||
    (chartWatchEnabled && isOpen && mode === 'chat') ||
    (autoTabVisionEnabled && isOpen && mode === 'chat');
  const keepWatchedTabsMounted = keepWatchedTabsMountedRequested && !isSettingsOpen;
  const [tradeLockerStartupGate, setTradeLockerStartupGate] = useState<{ phase: 'booting' | 'restoring' | 'settled'; bridgeReady: boolean }>({
    phase: 'booting',
    bridgeReady: false
  });

  // TradeLocker (real broker connection)
  const {
    status: tlStatus,
    connectionMeta: tlConnectionMeta,
    lastError: tlLastError,
    savedConfig: tlSavedConfig,
    balance: tlBalance,
    equity: tlEquity,
    positions: tlPositions,
    orders: tlOrders,
    ordersError: tlOrdersError,
    ordersHistory: tlOrdersHistory,
    ordersHistoryError: tlOrdersHistoryError,
    accountMetrics: tlAccountMetrics,
    accountMetricsError: tlAccountMetricsError,
    snapshotUpdatedAtMs: tlSnapshotUpdatedAtMs,
    upstreamBlockedUntilMs: tlUpstreamBlockedUntilMs,
    upstreamLastError: tlUpstreamLastError,
    upstreamLastStatus: tlUpstreamLastStatus,
    statusMeta: tlStatusMeta,
    accounts: tlAccounts,
    accountsError: tlAccountsError,
    quotesBySymbol: tlQuotesBySymbol,
    quotesError: tlQuotesError,
    quotesUpdatedAtMs: tlQuotesUpdatedAtMs,
    streamStatus: tlStreamStatus,
    streamError: tlStreamError,
    streamUpdatedAtMs: tlStreamUpdatedAtMs,
    startupAutoRestore: tlStartupAutoRestore,
    refreshSavedConfig: tlRefreshSavedConfig,
    refreshAccounts: tlRefreshAccounts,
    refreshSnapshot: tlRefreshSnapshot,
    refreshOrders: tlRefreshOrders,
    refreshOrdersHistory: tlRefreshOrdersHistory,
    refreshAccountMetrics: tlRefreshAccountMetrics,
    refreshQuotes: tlRefreshQuotes,
    setActiveAccount: tlSetActiveAccount,
    closePosition: tlClosePosition,
    modifyPosition: tlModifyPosition,
    modifyOrder: tlModifyOrder,
    cancelOrder: tlCancelOrder,
    placeOrder: tlPlaceOrder,
    connect: tlConnect,
    searchInstruments: tlSearchInstruments
  } = useTradeLocker(brokerDataActive, {
    watchSymbols: brokerWatchSymbols,
    suppressRateLimitUntilMs: brokerRateLimitSuppressUntilMs,
    onQuote: ingestBrokerQuote,
    withAccountLock: withTradeLockerAccountLock,
    accountBusyRef: tradeLockerAccountBusyRef,
    startupPhase: tradeLockerStartupGate.phase,
    startupBridgeReady: tradeLockerStartupGate.bridgeReady
  });
  tradeLockerExecutionGateRef.current.connected = tlStatus === 'connected';
  tradeLockerExecutionGateRef.current.upstreamBlockedUntilMs =
    Number.isFinite(Number(tlUpstreamBlockedUntilMs)) ? Number(tlUpstreamBlockedUntilMs) : null;
  tlSavedConfigRef.current = tlSavedConfig;
  tlSetActiveAccountRef.current = tlSetActiveAccount;
  refreshSnapshotRef.current = tlRefreshSnapshot;
  refreshQuotesRef.current = tlRefreshQuotes;
  tlCancelOrderRef.current = tlCancelOrder;
  tlClosePositionRef.current = tlClosePosition;
  tlSearchInstrumentsRef.current = tlSearchInstruments;
  tlOrdersRef.current = Array.isArray(tlOrders) ? tlOrders : [];
  tlOrdersHistoryRef.current = Array.isArray(tlOrdersHistory) ? tlOrdersHistory : [];
  tlPositionsRef.current = Array.isArray(tlPositions) ? tlPositions : [];
  quotesBySymbolRef.current = tlQuotesBySymbol ?? null;
  const tlAccountsRef = React.useRef(tlAccounts);
  useEffect(() => {
    const accountsList = Array.isArray(tlAccounts) ? tlAccounts : [];
    tlAccountsRef.current = accountsList;
    const map = new Map<string, { env: string; server: string; accountId: number; accNum: number }>();
    const env = tlSavedConfig?.env ? String(tlSavedConfig.env) : '';
    const server = tlSavedConfig?.server ? String(tlSavedConfig.server) : '';
    if (env && server && accountsList.length > 0) {
      for (const acct of accountsList) {
        const accountId = parseTradeLockerAccountNumber(acct?.id);
        const accNum = parseTradeLockerAccountNumber(acct?.accNum);
        if (accountId == null || accNum == null) continue;
        const key = buildTradeLockerAccountKey({ env, server, accountId, accNum });
        if (!key) continue;
        map.set(key, { env, server, accountId, accNum });
      }
    }
    tlAccountMapRef.current = map;
    if (map.size > 0) {
      const first = map.keys().next();
      const fallback = first && !first.done ? first.value : null;
      if (fallback) {
        if (!tlSnapshotSourceKey || !map.has(tlSnapshotSourceKey)) {
          setTlSnapshotSourceKey(fallback);
        }
        if (!tlNormalizeRefKey || !map.has(tlNormalizeRefKey)) {
          setTlNormalizeRefKey(fallback);
        }
      }
    }
  }, [tlAccounts, tlSavedConfig?.env, tlSavedConfig?.server, tlSnapshotSourceKey, tlNormalizeRefKey]);

  useEffect(() => {
    if (tlStatus === 'connected') {
      try {
        tlRefreshAccounts?.();
      } catch {
        // ignore
      }
    }
  }, [tlRefreshAccounts, tlStatus]);

  useEffect(() => {
    const accountKey = getTradeLockerAccountKey();
    if (!accountKey || !tlQuotesBySymbol) return;
    const list = Object.values(tlQuotesBySymbol);
    for (const quote of list) {
      if (!quote) continue;
      upsertTradeLockerAccountQuote(accountKey, quote as TradeLockerQuote);
    }
  }, [getTradeLockerAccountKey, tlQuotesBySymbol, upsertTradeLockerAccountQuote]);

  const buildTelegramDigest = useCallback(async (windowDays: number, label: string) => {
    const sinceMs = Date.now() - windowDays * 24 * 60 * 60 * 1000;
    const history = Array.isArray(signalHistory) ? signalHistory : [];
    const recent = history.filter((entry) => {
      const ts = entry.resolvedAtMs ?? entry.executedAtMs ?? 0;
      return ts >= sinceMs;
    });
    const wins = recent.filter((entry) => entry.outcome === 'WIN').length;
    const losses = recent.filter((entry) => entry.outcome === 'LOSS').length;
    const resolved = wins + losses;
    const winRate = resolved > 0 ? Math.round((wins / resolved) * 100) : null;

    const symbolStats = new Map<string, { total: number; wins: number }>();
    for (const entry of recent) {
      const symbol = String(entry.symbol || '').trim();
      if (!symbol) continue;
      const stat = symbolStats.get(symbol) || { total: 0, wins: 0 };
      stat.total += 1;
      if (entry.outcome === 'WIN') stat.wins += 1;
      symbolStats.set(symbol, stat);
    }
    const topSymbols = Array.from(symbolStats.entries())
      .sort((a, b) => b[1].total - a[1].total)
      .slice(0, 3)
      .map(([symbol, stat]) => {
        const rate = stat.total > 0 ? Math.round((stat.wins / stat.total) * 100) : null;
        return `${symbol} ${stat.total}${rate != null ? ` (${rate}% win)` : ''}`;
      });

    const fmtMoney = (value: any) => {
      const num = Number(value);
      return Number.isFinite(num) ? num.toFixed(2) : '--';
    };

    const lines: string[] = [];
    lines.push(`${label} Digest`);
    if (tlStatus === 'connected') {
      lines.push(`TradeLocker: Equity ${fmtMoney(tlEquity)} | Balance ${fmtMoney(tlBalance)} | Pos ${tlPositions.length} | Ord ${tlOrders.length}`);
    } else {
      lines.push(`TradeLocker: ${tlStatus || 'offline'}`);
    }

    const mt5AccountRes = await fetchMt5('/account');
    if (mt5AccountRes.ok && mt5AccountRes.data?.account) {
      const account = mt5AccountRes.data.account;
      lines.push(`MT5: Equity ${fmtMoney(account?.equity)} | Balance ${fmtMoney(account?.balance)}`);
    } else {
      lines.push('MT5: offline');
    }

    lines.push(
      `Signals: ${recent.length} | Wins ${wins} | Losses ${losses}${winRate != null ? ` | Win ${winRate}%` : ''}`
    );
    if (topSymbols.length > 0) lines.push(`Top symbols: ${topSymbols.join(', ')}`);

    const statusSymbol = symbolScopeSymbol || activeBrokerSymbol || signalPrimarySymbol;
    if (statusSymbol) {
      const snapshot = await fetchTelegramNewsSnapshot(statusSymbol);
      if (snapshot?.items?.length) {
        const top = snapshot.items[0];
        const toneLabel = formatTelegramNewsTone(snapshot.tone, snapshot.toneScore);
        const impactLabel = snapshot.impactLevel ? snapshot.impactLevel.toUpperCase() : '';
        const trumpFlag = snapshot.trumpNews ? ' Trump News' : '';
        lines.push(`News: ${top.title}${impactLabel ? ` (${impactLabel}${toneLabel ? `/${toneLabel}` : ''})` : ''}${trumpFlag}`);
      }
    }

    return lines.join('\n');
  }, [
    activeBrokerSymbol,
    fetchMt5,
    fetchTelegramNewsSnapshot,
    formatTelegramNewsTone,
    signalHistory,
    signalPrimarySymbol,
    symbolScopeSymbol,
    tlBalance,
    tlEquity,
    tlOrders,
    tlPositions,
    tlStatus
  ]);

  useEffect(() => {
    if (!telegramAlertsActive || !signalTelegramAlertTpSl) return;
    const sentMap = signalTelegramAlertSentRef.current;
    for (const entry of signalEntries) {
      const status = String(entry.status || '').toUpperCase();
      if (status !== 'WIN' && status !== 'LOSS') continue;
      const statusKey = `signal:${status}`;
      const statusSet = sentMap.get(entry.id) || new Set();
      if (statusSet.has(statusKey)) continue;
      statusSet.add(statusKey);
      sentMap.set(entry.id, statusSet);
      const tf = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
      const prob = Number.isFinite(Number(entry.probability)) ? Math.round(Number(entry.probability)) : null;
      const reason = entry.reason ? String(entry.reason).slice(0, 160) : '';
      const lines = [
        `${entry.action} ${entry.symbol} ${tf}`.trim(),
        `Entry ${entry.entryPrice} SL ${entry.stopLoss} TP ${entry.takeProfit}`,
        prob != null ? `Prob ${prob}%` : '',
        reason ? `Reason: ${reason}` : ''
      ].filter(Boolean);
      void sendTelegramAlert(`Signal ${status}`, lines.join('\n'));
    }
  }, [formatTimeframeLabel, sendTelegramAlert, signalEntries, signalTelegramAlertTpSl, telegramAlertsActive]);

  useEffect(() => {
    if (!telegramAlertsActive || !signalTelegramAlertAgentConfidence) return;
    const seen = telegramConfidenceSeenRef.current;
    const lastByAgent = telegramConfidenceRef.current;
    for (const entry of signalEntries) {
      if (!entry?.id || seen.has(entry.id)) continue;
      seen.add(entry.id);
      const probRaw = Number(entry.probability);
      if (!Number.isFinite(probRaw)) continue;
      const agentKey = entry.agentId || entry.agentName;
      if (!agentKey) continue;
      const prob = Math.round(probRaw);
      const prev = lastByAgent.get(agentKey);
      if (prev != null && prev - prob >= signalTelegramAlertConfidenceDrop) {
        const tf = entry.timeframe ? formatTimeframeLabel(entry.timeframe) : '';
        const label = entry.agentName || entry.agentId || 'Agent';
        const msg = `${label}: ${entry.symbol} ${tf} ${prob}% (was ${prev}%)`.trim();
        void sendTelegramAlert('Agent confidence drop', msg);
      }
      lastByAgent.set(agentKey, prob);
    }
  }, [
    formatTimeframeLabel,
    sendTelegramAlert,
    signalEntries,
    signalTelegramAlertAgentConfidence,
    signalTelegramAlertConfidenceDrop,
    telegramAlertsActive
  ]);

  useEffect(() => {
    if (tlStatus !== 'connected') return;
    const snapshot = telegramTlPositionSnapshotRef.current;
    const positions = Array.isArray(tlPositions) ? tlPositions : [];
    const nextById: Record<string, any> = {};
    for (const pos of positions) {
      const id = pos?.id != null ? String(pos.id).trim() : '';
      if (!id) continue;
      const side = String(pos?.type || '').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
      const symbol = String(pos?.symbol || '').trim();
      const size = Number(pos?.size);
      const entry = Number(pos?.entryPrice);
      const pnl = Number(pos?.pnl);
      nextById[id] = { id, side, symbol, size, entry, pnl };
    }

    if (!snapshot.initialized) {
      snapshot.byId = nextById;
      snapshot.initialized = true;
      return;
    }

    const shouldSend = telegramAlertsActive && signalTelegramAlertTrades;
    if (shouldSend) {
      for (const id of Object.keys(nextById)) {
        if (snapshot.byId[id]) continue;
        const pos = nextById[id];
        const sizeLabel = Number.isFinite(pos.size) ? pos.size.toFixed(2) : '--';
        const entryLabel = Number.isFinite(pos.entry) ? pos.entry.toFixed(2) : '--';
        const msg = `${pos.side} ${pos.symbol} ${sizeLabel} @ ${entryLabel}`.trim();
        void sendTelegramAlert('TradeLocker Open', msg);
      }
      for (const id of Object.keys(snapshot.byId)) {
        if (nextById[id]) continue;
        const prev = snapshot.byId[id];
        const sizeLabel = Number.isFinite(prev?.size) ? prev.size.toFixed(2) : '--';
        const pnlLabel = Number.isFinite(prev?.pnl) ? prev.pnl.toFixed(2) : '--';
        const msg = `${prev?.side || ''} ${prev?.symbol || ''} ${sizeLabel} pnl ${pnlLabel}`.trim();
        void sendTelegramAlert('TradeLocker Closed', msg);
      }
    }

    snapshot.byId = nextById;
  }, [sendTelegramAlert, signalTelegramAlertTrades, telegramAlertsActive, tlPositions, tlStatus]);

  useEffect(() => {
    if (!telegramAlertsActive || !signalTelegramAlertTrades) return;
    let mounted = true;
    let stop: (() => void) | null = null;
    let cancelled = false;
    telegramMt5PositionSnapshotRef.current = { initialized: false, byId: {} };

    const resolveMt5PositionId = (pos: any) => {
      const raw =
        pos?.ticket ??
        pos?.position ??
        pos?.id ??
        pos?.order ??
        null;
      if (raw == null) return '';
      return String(raw).trim();
    };

    const poll = async () => {
      if (!mounted) return;
      if (telegramMt5AlertInFlightRef.current) return;
      telegramMt5AlertInFlightRef.current = true;
      try {
        const res = await fetchMt5('/positions');
        if (!mounted) return;
        if (!res?.ok || !Array.isArray(res.data?.positions)) return;
        const positions = res.data.positions;
        const nextById: Record<string, any> = {};
        for (const pos of positions) {
          const id = resolveMt5PositionId(pos);
          if (!id) continue;
          const side = Number(pos?.type) === 0 ? 'BUY' : 'SELL';
          const symbol = String(pos?.symbol || '').trim();
          const size = Number(pos?.volume ?? pos?.volume_current ?? pos?.volume_initial);
          const entry = Number(pos?.price_open ?? pos?.price);
          const pnl = Number(pos?.profit);
          nextById[id] = { id, side, symbol, size, entry, pnl };
        }

        const snapshot = telegramMt5PositionSnapshotRef.current;
        if (!snapshot.initialized) {
          snapshot.byId = nextById;
          snapshot.initialized = true;
          return;
        }

        for (const id of Object.keys(nextById)) {
          if (snapshot.byId[id]) continue;
          const pos = nextById[id];
          const sizeLabel = Number.isFinite(pos.size) ? pos.size.toFixed(2) : '--';
          const entryLabel = Number.isFinite(pos.entry) ? pos.entry.toFixed(2) : '--';
          const msg = `${pos.side} ${pos.symbol} ${sizeLabel} @ ${entryLabel}`.trim();
          void sendTelegramAlert('MT5 Open', msg);
        }
        for (const id of Object.keys(snapshot.byId)) {
          if (nextById[id]) continue;
          const prev = snapshot.byId[id];
          const sizeLabel = Number.isFinite(prev?.size) ? prev.size.toFixed(2) : '--';
          const pnlLabel = Number.isFinite(prev?.pnl) ? prev.pnl.toFixed(2) : '--';
          const msg = `${prev?.side || ''} ${prev?.symbol || ''} ${sizeLabel} pnl ${pnlLabel}`.trim();
          void sendTelegramAlert('MT5 Closed', msg);
        }

        snapshot.byId = nextById;
      } finally {
        telegramMt5AlertInFlightRef.current = false;
      }
    };

    void poll();
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 15_000,
        onTick: () => poll()
      });
    }).catch(() => {});
    return () => {
      mounted = false;
      cancelled = true;
      stop?.();
    };
  }, [fetchMt5, sendTelegramAlert, signalTelegramAlertTrades, telegramAlertsActive]);

  useEffect(() => {
    if (!telegramAlertsActive || !signalTelegramAlertDrawdown) return;
    if (tlStatus !== 'connected') return;
    const env = tlSavedConfig?.env || null;
    const server = tlSavedConfig?.server || null;
    const accountId = tlSavedConfig?.accountId ?? null;
    const accNum = tlSavedConfig?.accNum ?? null;
    if (!env || !server || accountId == null || accNum == null) return;
    const equityNow =
      tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.equity)) ? Number(tlAccountMetrics.equity) : tlEquity;
    if (!Number.isFinite(equityNow) || equityNow <= 0) return;

    const accountKey = `${String(env)}:${String(server)}:${String(accountId)}:${String(accNum)}`;
    const dateKey = getLocalDateKey();
    const tracker = telegramDrawdownAlertRef.current;
    if (tracker.dateKey !== dateKey) {
      tracker.dateKey = dateKey;
      tracker.sent = false;
    }
    if (tracker.sent) return;
    const storageKey = getDailyBaselineStorageKey(accountKey, dateKey);
    const baseline = readLocalJson(storageKey);
    const equityStart = baseline && Number.isFinite(Number(baseline.equityStart)) ? Number(baseline.equityStart) : null;
    if (equityStart == null) {
      writeLocalJson(storageKey, { equityStart: equityNow, createdAtMs: Date.now() });
      return;
    }

    const lossAmount = Math.max(0, equityStart - equityNow);
    if (lossAmount <= 0) return;
    const maxDailyLossRaw = Number(autoPilotConfigRef.current?.maxDailyLoss);
    const hasLimit = Number.isFinite(maxDailyLossRaw) && maxDailyLossRaw > 0;
    const drawdownPct = hasLimit
      ? (lossAmount / maxDailyLossRaw) * 100
      : (lossAmount / equityStart) * 100;
    if (!Number.isFinite(drawdownPct) || drawdownPct < signalTelegramAlertDrawdownPct) return;

    const fmtMoney = (value: number) => value.toFixed(2);
    const limitLabel = hasLimit ? ` of ${fmtMoney(maxDailyLossRaw)}` : '';
    const msg = `Daily drawdown ${fmtMoney(lossAmount)} (${drawdownPct.toFixed(1)}%${limitLabel}).`;
    tracker.sent = true;
    void sendTelegramAlert('Drawdown Alert', msg);
  }, [
    sendTelegramAlert,
    signalTelegramAlertDrawdown,
    signalTelegramAlertDrawdownPct,
    telegramAlertsActive,
    tlAccountMetrics,
    tlEquity,
    tlSavedConfig?.accNum,
    tlSavedConfig?.accountId,
    tlSavedConfig?.env,
    tlSavedConfig?.server,
    tlStatus
  ]);

  useEffect(() => {
    if (!signalTelegramEnabled || !signalTelegramBotToken || !signalTelegramChatId) return;
    if (!signalTelegramDigestDailyEnabled && !signalTelegramDigestWeeklyEnabled) return;
    let mounted = true;
    let stop: (() => void) | null = null;
    let cancelled = false;

    const check = async () => {
      if (!mounted) return;
      const now = new Date();
      const hour = now.getHours();
      const dateKey = getLocalDateKey();
      if (signalTelegramDigestDailyEnabled && hour >= signalTelegramDigestHourLocal) {
        const dailyKey = `${dateKey}:${signalTelegramDigestHourLocal}`;
        if (telegramDigestSentRef.current.dailyKey !== dailyKey) {
          const digest = await buildTelegramDigest(1, 'Daily');
          await sendTelegramText(digest);
          telegramDigestSentRef.current.dailyKey = dailyKey;
        }
      }
      if (
        signalTelegramDigestWeeklyEnabled &&
        now.getDay() === signalTelegramDigestWeeklyDay &&
        hour >= signalTelegramDigestHourLocal
      ) {
        const weeklyKey = `${dateKey}:${signalTelegramDigestWeeklyDay}`;
        if (telegramDigestSentRef.current.weeklyKey !== weeklyKey) {
          const digest = await buildTelegramDigest(7, 'Weekly');
          await sendTelegramText(digest);
          telegramDigestSentRef.current.weeklyKey = weeklyKey;
        }
      }
    };

    void check();
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 60_000,
        onTick: () => check()
      });
    }).catch(() => {});
    return () => {
      mounted = false;
      cancelled = true;
      stop?.();
    };
  }, [
    buildTelegramDigest,
    sendTelegramText,
    signalTelegramChatId,
    signalTelegramDigestDailyEnabled,
    signalTelegramDigestHourLocal,
    signalTelegramDigestWeeklyDay,
    signalTelegramDigestWeeklyEnabled,
    signalTelegramEnabled,
    signalTelegramBotToken
  ]);

  const processTelegramUpdate = useCallback(async (update: any) => {
      const allowed = new Set(parseTelegramChatIds(signalTelegramChatId));
      const callbackRuntime = await loadTelegramCallbackRuntimeModule();
      const callbackRes = await callbackRuntime.runTelegramCallbackRuntime({
        update,
        allowedChatIds: allowed,
        signalTelegramAllowManage,
        signalTelegramCommandMode,
        signalTelegramConfirmationsEnabled,
        telegramPendingActionsRef,
        answerTelegramCallback,
        appendAuditEvent,
        resolveTelegramPendingAction,
        executeTelegramPendingAction,
        sendTelegramText,
        resolveTelegramSignalEntry,
        queueTelegramConfirmation,
        runTelegramSignalAction
      });
      if (callbackRes.handled) return;
      const messageRuntime = await loadTelegramMessageRuntimeModule();
      await messageRuntime.runTelegramMessageRuntime({
        update,
        allowedChatIds: allowed,
        signalTelegramCommandPassphrase,
        signalTelegramAllowManage,
        signalTelegramCommandMode,
        signalTelegramAllowStatus,
        signalTelegramAllowChart,
        signalTelegramConfirmationsEnabled,
        signalStatusSet: SIGNAL_TELEGRAM_STATUS_SET as Set<string>,
        signalEntriesRef,
        tlStatus,
        tlPositionsRef,
        tlOrdersRef,
        tlEquity,
        tlBalance,
        symbolScopeSymbol,
        activeBrokerSymbol,
        signalPrimarySymbol,
        brokerLinkConfigRef,
        setAutoPilotConfigRef,
        autoPilotConfigRef,
        setupWatchersRef,
        telegramWatcherResumeRef,
        sendTelegramText,
        resolveTelegramSignalEntry,
        formatTelegramSignalLine,
        formatTimeframeLabel,
        buildTelegramSignalInlineActions,
        buildTelegramDigest,
        queueTelegramConfirmation,
        runTelegramSignalAction,
        runTelegramManageAction,
        updateSetupWatcher,
        updateSymbolScope,
        parseTelegramSymbol,
        parseTelegramTimeframe,
        parseTelegramBroker,
        parseTelegramAccountHint,
        parseTelegramQtySpec,
        fetchMt5,
        fetchTelegramNewsSnapshot,
        formatTelegramNewsTone,
        captureChartChatSnapshot,
        sendPlainTextToOpenAI,
        sendTelegramPhoto,
        resolveTradeLockerSymbolBestEffort
      });
  }, [
    activeBrokerSymbol,
    answerTelegramCallback,
    addNotification,
    appendAuditEvent,
    brokerLinkConfig,
    brokerWatchSymbols,
    buildTelegramDigest,
    buildTelegramSignalInlineActions,
    cancelSignalOrder,
    captureChartChatSnapshot,
    executeTelegramPendingAction,
    executeSignalTrade,
    executeBrokerActionViaApi,
    fetchTelegramNewsSnapshot,
    formatTelegramNewsTone,
    formatTelegramSignalLine,
    formatTimeframeLabel,
    parseTelegramAccountHint,
    parseTelegramBroker,
    parseTelegramChatIds,
    parseTelegramQtySpec,
    parseTelegramSymbol,
    parseTelegramTimeframe,
    patternSymbols,
    queueTelegramConfirmation,
    rejectSignalEntry,
    resolveTelegramPendingAction,
    resolveTradeLockerSymbolBestEffort,
    resolveTelegramSignalEntry,
    runTelegramManageAction,
    runTelegramSignalAction,
    sendTelegramPhoto,
    sendTelegramText,
    signalPrimarySymbol,
    signalTelegramAllowChart,
    signalTelegramAllowManage,
    signalTelegramAllowStatus,
    signalTelegramBotToken,
    signalTelegramChatId,
    signalTelegramCommandMode,
    signalTelegramCommandPassphrase,
    signalTelegramCommandsEnabled,
    signalTelegramConfirmationsEnabled,
    symbolScopeSymbol,
    tlBalance,
    tlEquity,
    tlStatus,
    updateSymbolScope
  ]);

  const handleTelegramUpdate = useCallback(async (update: any) => {
    const mod = await loadTelegramCommandRuntimeModule();
    await mod.runTelegramUpdateOrchestratorRuntime({
      update,
      signalTelegramCommandsEnabled,
      signalTelegramBotToken,
      signalTelegramChatId,
      telegramUpdateIdRef,
      telegramCommandInFlightRef,
      processUpdate: processTelegramUpdate
    });
  }, [
    processTelegramUpdate,
    signalTelegramBotToken,
    signalTelegramChatId,
    signalTelegramCommandsEnabled
  ]);

  useEffect(() => {
    const api = window.glass?.telegram;
    if (!api?.startPolling || !api?.stopPolling) return;
    const ready = signalTelegramCommandsEnabled && signalTelegramBotToken && signalTelegramChatId;
    if (ready) {
      telegramPollingActiveRef.current = true;
      void api.startPolling({
        botToken: signalTelegramBotToken,
        chatId: parseTelegramChatIds(signalTelegramChatId),
        drain: true
      });
      return;
    }
    if (telegramPollingActiveRef.current) {
      telegramPollingActiveRef.current = false;
      void api.stopPolling();
    }
  }, [parseTelegramChatIds, signalTelegramBotToken, signalTelegramChatId, signalTelegramCommandsEnabled]);

  useEffect(() => {
    const api = window.glass?.telegram;
    if (!api?.onUpdate) return;
    const unsub = api.onUpdate((payload: any) => {
      void handleTelegramUpdate(payload);
    });
    return () => {
      if (unsub) unsub();
    };
  }, [handleTelegramUpdate]);

  const mt5BridgeAvailable = typeof window !== 'undefined' && !!(window as any)?.glass?.mt5?.startBridge;
  const mt5TelemetryEnabled =
    mt5BridgeAvailable &&
    (
      mode === 'mt5' ||
      mode === 'monitor' ||
      !!autoPilotConfig?.enabled ||
      signalExecutionTarget !== 'tradelocker'
    );
  const mt5TelemetryInFlightRef = React.useRef(false);
  const mt5TelemetryBackoffRef = React.useRef(0);
  const {
    startupPhase,
    startupBridgeState,
    startupBridgeError,
    startupBridgeReady,
    openaiKeyStored,
    openaiReadinessState,
    openaiPermissionBlockedReason,
    tradeLockerPermissionBlockedReason,
    tradeLockerReadinessState,
    tradeLockerReady,
    onboardingOpen,
    startupStatus: startupReadinessStatus,
    refreshOpenAiKeyStatus,
    refreshOnboardingStatus
  } = useStartupReadiness({
    tradeLockerSavedConfig: tlSavedConfig,
    refreshTradeLockerSavedConfig: tlRefreshSavedConfig,
    appendLiveError
  });
  startupBridgeGateRef.current.ready = startupBridgeReady;
  startupBridgeGateRef.current.error = startupBridgeError ? String(startupBridgeError) : null;

  useEffect(() => {
    const glass = (window as any)?.glass;
    if (!glass || !glass.tradeLedger || glass.__tradeLedgerHealthInstrumented) return;
    try {
      glass.tradeLedger = instrumentTradeLedger(glass.tradeLedger);
      glass.__tradeLedgerHealthInstrumented = true;
    } catch {
      // ignore instrumentation failures
    }
  }, []);

  useEffect(() => {
    const err = startupReadinessStatus?.probeErrors?.tradeLedger;
    if (err) {
      recordLedgerHealth('app', false, err);
      return;
    }
    if (startupBridgeState === 'ready') {
      recordLedgerHealth('app', true);
    }
  }, [startupBridgeState, startupReadinessStatus?.probeErrors?.tradeLedger]);

  useEffect(() => {
    void refreshOpenAiKeyStatus();
  }, [refreshOpenAiKeyStatus]);

  useEffect(() => {
    setTradeLockerStartupGate((prev) => {
      if (prev.phase === startupPhase && prev.bridgeReady === startupBridgeReady) return prev;
      return {
        phase: startupPhase,
        bridgeReady: startupBridgeReady
      };
    });
  }, [startupBridgeReady, startupPhase]);

  const settingsOpenRef = React.useRef(isSettingsOpen);
  useEffect(() => {
    if (settingsOpenRef.current && !isSettingsOpen) {
      void refreshOpenAiKeyStatus();
    }
    settingsOpenRef.current = isSettingsOpen;
  }, [isSettingsOpen, refreshOpenAiKeyStatus]);

  useEffect(() => {
    if (!mt5TelemetryEnabled) {
      setMt5PositionsCount(null);
      setMt5OrdersCount(null);
      setMt5PositionsUpdatedAtMs(null);
      setMt5OrdersUpdatedAtMs(null);
      setMt5SnapshotError(null);
      return;
    }
    let canceled = false;
    let stop: (() => void) | null = null;

    const poll = async () => {
      if (canceled) return;
      const now = Date.now();
      const nextAllowed = mt5TelemetryBackoffRef.current || 0;
      if (nextAllowed && now < nextAllowed) {
        return Math.max(2000, nextAllowed - now);
      }
      if (mt5TelemetryInFlightRef.current) {
        return 2000;
      }
      mt5TelemetryInFlightRef.current = true;
      try {
        const [positionsRes, ordersRes, spec] = await Promise.all([
          fetchMt5('/positions'),
          fetchMt5('/orders'),
          fetchMt5AccountSpec()
        ]);
        if (canceled) return;
        let hadSuccess = false;
        if (positionsRes?.ok && Array.isArray(positionsRes.data?.positions)) {
          setMt5PositionsCount(positionsRes.data.positions.length);
          setMt5PositionsUpdatedAtMs(Date.now());
          hadSuccess = true;
        }
        if (ordersRes?.ok && Array.isArray(ordersRes.data?.orders)) {
          setMt5OrdersCount(ordersRes.data.orders.length);
          setMt5OrdersUpdatedAtMs(Date.now());
          hadSuccess = true;
        }
        if (spec) {
          setMt5AccountSpec(spec);
          hadSuccess = true;
        }
        if (hadSuccess) {
          setMt5SnapshotError(null);
        } else {
          const err = positionsRes?.error || ordersRes?.error || 'MT5 telemetry unavailable.';
          setMt5SnapshotError(String(err));
          mt5TelemetryBackoffRef.current = Date.now() + 30_000;
        }
      } catch (err: any) {
        if (canceled) return;
        setMt5SnapshotError(err?.message ? String(err.message) : 'MT5 telemetry unavailable.');
        mt5TelemetryBackoffRef.current = Date.now() + 30_000;
      } finally {
        mt5TelemetryInFlightRef.current = false;
      }
      return 15_000;
    };
    void loadMt5TelemetryControllerModule().then((mod) => {
      if (canceled) return;
      const controller = mod.createMt5TelemetryController({
        defaultDelayMs: 15_000,
        schedulerIntervalMs: 1_000,
        tick: poll
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      canceled = true;
      stop?.();
    };
  }, [mt5TelemetryEnabled]);

  const ensureTradeLockerConnected = useCallback(async (reason?: string) => {
    if (tlStatus === 'connected' || tlStatus === 'connecting') {
      return { ok: true, skipped: true, status: tlStatus };
    }
    if (!tlConnect) return { ok: false, error: 'TradeLocker connect unavailable.' };

    const saved = tlSavedConfigRef.current || tlSavedConfig;
    const hasPassword = !!saved?.hasSavedPassword;
    const server = String(saved?.server || '').trim();
    const email = String(saved?.email || '').trim();
    if (!hasPassword || !server || !email) {
      return { ok: false, error: 'TradeLocker credentials missing.' };
    }

    const now = Date.now();
    if (tlConnectInFlightRef.current) {
      return { ok: false, error: 'TradeLocker connect already in progress.' };
    }
    const lastAttempt = tlConnectAttemptAtRef.current || 0;
    if (now - lastAttempt < 12_000) {
      return { ok: false, error: 'TradeLocker connect throttled.' };
    }

    tlConnectAttemptAtRef.current = now;
    tlConnectInFlightRef.current = true;
    try {
      const res = await tlConnect({
        env: saved?.env,
        server,
        email,
        password: '',
        rememberPassword: false,
        rememberDeveloperApiKey: false
      });
      if (res && res.ok === false) {
        return { ok: false, error: res.error || 'TradeLocker connect failed.' };
      }
      return { ok: true, status: 'connected', reason: reason || null };
    } catch (err: any) {
      const msg = err?.message ? String(err.message) : 'TradeLocker connect failed.';
      return { ok: false, error: msg };
    } finally {
      tlConnectInFlightRef.current = false;
    }
  }, [tlConnect, tlSavedConfig, tlStatus]);

  useEffect(() => {
    ensureTradeLockerConnectedRef.current = ensureTradeLockerConnected;
  }, [ensureTradeLockerConnected]);

  useEffect(() => {
    const hydrate = async () => {
      await chartEngine.loadWatches();
      await chartEngine.loadEvents();
      setPatternEvents(chartEngine.listRecentEvents(300));
    };
    hydrate();
    return () => {};
  }, [chartEngine]);

  useEffect(() => {
    const market = marketDataRef.current;
    market.updateStreamHealth({
      streamStatus: tlStreamStatus ?? null,
      streamUpdatedAtMs: tlStreamUpdatedAtMs ?? null,
      quotesUpdatedAtMs: tlQuotesUpdatedAtMs ?? null
    });
  }, [tlQuotesUpdatedAtMs, tlStreamStatus, tlStreamUpdatedAtMs]);

  useEffect(() => {
    const updateActive = () => {
      const meta = nativeChartRef.current?.getMeta?.();
      const symbol = String(meta?.symbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
      const frames = Array.isArray(meta?.frames) ? meta.frames.map((f) => String(f?.resolution || '').trim()).filter(Boolean) : [];
      const resolvedFrames = frames.length > 0 ? frames : (symbolScopeFramesResolved.length > 0 ? symbolScopeFramesResolved : ['4H', '1H', '15m']);
      chartEngine.setActiveSessions(symbol || null, symbol ? resolvedFrames : []);
    };
    let stop: (() => void) | null = null;
    let cancelled = false;
    updateActive();
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 10_000,
        onTick: () => updateActive()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [activeBrokerSymbol, activeTvParams?.symbol, chartEngine, nativeChartMounted, symbolScopeFramesResolved, symbolScopeSymbol]);

  useEffect(() => {
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 15_000,
        onTick: () => {
          requestChartRefresh(1);
        }
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [requestChartRefresh]);

  useEffect(() => {
    const mapTimeframe = (value: string) => {
      const raw = String(value || '').trim().toLowerCase();
      if (raw === '4h') return '4H';
      if (raw === '1h') return '1H';
      return raw === '15m' ? '15m' : value;
    };

    const sessions = Array.isArray(chartSessions.sessions) ? chartSessions.sessions : [];
    const desired = new Map<string, ChartWatchConfig>();

    for (const session of sessions) {
      if (!session || session.watchEnabled === false) continue;
      const symbol = String(session.symbol || '').trim();
      if (!symbol) continue;
      const views = session.views || {};
      for (const [tfKey, tabId] of Object.entries(views)) {
        if (!tabId) continue;
        const timeframe = mapTimeframe(tfKey);
        if (!timeframe) continue;
        const watchId = `chart_session:${session.id}:${timeframe}`;
        desired.set(watchId, {
          watchId,
          symbol,
          timeframe,
          enabled: true,
          detectorsEnabled: undefined,
          source: 'chart_session'
        });
      }
    }

    const existing = chartEngine.listWatches().filter((w) => w.source === 'chart_session');
    const desiredIds = new Set(desired.keys());

    for (const watch of existing) {
      if (!desiredIds.has(watch.watchId)) {
        void chartEngine.removeWatch(watch.watchId);
      }
    }

    for (const watch of desired.values()) {
      void chartEngine.addWatch(watch);
    }
  }, [chartEngine, chartSessions.sessions]);

  const activeBrokerQuote = React.useMemo(() => {
    const sym = String(symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
    if (!sym) return null;
    const key = normalizeSymbolKey(sym);
    const direct = tlQuotesBySymbol?.[key] || null;
    if (direct) return direct;
    const loose = normalizeSymbolLoose(sym);
    if (!loose || !tlQuotesBySymbol) return null;
    const values = Object.values(tlQuotesBySymbol);
    for (const quote of values) {
      if (normalizeSymbolLoose(quote?.symbol || '') === loose) return quote;
    }
    return null;
  }, [activeBrokerSymbol, activeTvParams?.symbol, symbolScopeSymbol, tlQuotesBySymbol]);
  const brokerBadgeSymbol = String(symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol || '').trim();
  const brokerBadgeBid = activeBrokerQuote?.bid ?? null;
  const brokerBadgeAsk = activeBrokerQuote?.ask ?? null;
  const brokerBadgeSpread =
    activeBrokerQuote?.spread ??
    (brokerBadgeBid != null && brokerBadgeAsk != null ? brokerBadgeAsk - brokerBadgeBid : null);
  const brokerBadgeAgeMs = activeBrokerQuote?.fetchedAtMs ?? activeBrokerQuote?.timestampMs ?? null;
  const brokerBadgeAgeLabel = formatAgeShort(brokerBadgeAgeMs);
  const brokerReferencePrice = (() => {
    const mid = Number(activeBrokerQuote?.mid);
    if (Number.isFinite(mid)) return mid;
    if (brokerBadgeBid != null && brokerBadgeAsk != null) return (brokerBadgeBid + brokerBadgeAsk) / 2;
    const last = Number(activeBrokerQuote?.last);
    if (Number.isFinite(last)) return last;
    if (Number.isFinite(Number(brokerBadgeBid))) return Number(brokerBadgeBid);
    if (Number.isFinite(Number(brokerBadgeAsk))) return Number(brokerBadgeAsk);
    return null;
  })();
  const tvPriceAgeMs = activeTvPriceUpdatedAtMs != null ? Math.max(0, Date.now() - activeTvPriceUpdatedAtMs) : null;
  const tvPriceFresh = tvPriceAgeMs != null && tvPriceAgeMs <= 30_000;
  const tvPriceLabel = tvPriceFresh && activeTvPrice != null ? formatBrokerPrice(activeTvPrice) : '';
  const tvPriceAgeLabel = tvPriceFresh ? formatAgeShort(activeTvPriceUpdatedAtMs) : '';
  const tvDelta =
    tvPriceFresh && activeTvPrice != null && brokerReferencePrice != null
      ? brokerReferencePrice - activeTvPrice
      : null;
  const tvDeltaLabel = tvDelta != null ? `${tvDelta >= 0 ? '+' : ''}${formatBrokerPrice(tvDelta)}` : '';
  const tvPriceLine = tvPriceLabel
    ? `TV ${tvPriceLabel}${tvDeltaLabel ? ` | diff ${tvDeltaLabel}` : ''}${tvPriceAgeLabel ? ` | ${tvPriceAgeLabel}` : ''}`
    : '';
  const tvSymbolLine =
    activeTvParams?.symbol && activeBrokerSymbol && activeBrokerSymbol !== activeTvParams.symbol
      ? `TV ${activeTvParams.symbol}`
      : '';

  useEffect(() => {
    tradeLockerExecRef.current = {
      connected: tlStatus === 'connected',
      status: tlStatus,
      lastError: tlLastError,
      tradingEnabled: !!tlSavedConfig?.tradingEnabled,
      autoPilotEnabled: !!tlSavedConfig?.autoPilotEnabled,
      defaultOrderQty: tlSavedConfig?.defaultOrderQty ?? null,
      defaultOrderType: tlSavedConfig?.defaultOrderType || 'market',
      upstreamBlockedUntilMs: tlUpstreamBlockedUntilMs ?? null,
      upstreamLastError: tlUpstreamLastError ?? null,
      upstreamLastStatus: tlUpstreamLastStatus ?? null,
      watchSymbols: brokerWatchSymbols,
      env: tlSavedConfig?.env || null,
      server: tlSavedConfig?.server || null,
      accountId: parseTradeLockerAccountNumber(tlSavedConfig?.accountId),
      accNum: parseTradeLockerAccountNumber(tlSavedConfig?.accNum),
      balance: tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.balance)) ? Number(tlAccountMetrics.balance) : tlBalance,
      equity: tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.equity)) ? Number(tlAccountMetrics.equity) : tlEquity,
      snapshotUpdatedAtMs: tlSnapshotUpdatedAtMs ?? null,
      accountMetrics: tlAccountMetrics ?? null,
      orders: tlOrders ?? null,
      ordersHistory: tlOrdersHistory ?? null,
      refreshSnapshot: tlRefreshSnapshot,
      refreshOrders: tlRefreshOrders,
      refreshOrdersHistory: tlRefreshOrdersHistory,
      refreshAccountMetrics: tlRefreshAccountMetrics,
      refreshQuotes: tlRefreshQuotes,
      closePosition: tlClosePosition,
      modifyPosition: tlModifyPosition,
      modifyOrder: tlModifyOrder,
      cancelOrder: tlCancelOrder
    };
  }, [brokerWatchSymbols, tlAccountMetrics, tlBalance, tlCancelOrder, tlClosePosition, tlEquity, tlLastError, tlModifyOrder, tlModifyPosition, tlRefreshAccountMetrics, tlRefreshOrders, tlRefreshQuotes, tlRefreshSnapshot, tlSavedConfig, tlSnapshotUpdatedAtMs, tlStatus, tlUpstreamBlockedUntilMs, tlUpstreamLastError, tlUpstreamLastStatus]);

  useEffect(() => {
    const prev = tradeLockerExecRef.current || {};
    tradeLockerExecRef.current = {
      ...prev,
      positions: tlPositions,
      orders: tlOrders,
      openPositionsCount: tlPositions.length,
      openOrdersCount: tlOrders.length,
      equity: tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.equity)) ? Number(tlAccountMetrics.equity) : tlEquity,
      balance: tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.balance)) ? Number(tlAccountMetrics.balance) : tlBalance,
      currency: tlAccountMetrics?.currency != null ? String(tlAccountMetrics.currency) : null,
      watchSymbols: brokerWatchSymbols,
      quotesBySymbol: tlQuotesBySymbol ?? {},
      quotesUpdatedAtMs: tlQuotesUpdatedAtMs ?? prev.quotesUpdatedAtMs ?? null,
      quotesError: tlQuotesError ?? null,
      streamStatus: tlStreamStatus ?? prev.streamStatus ?? null,
      streamError: tlStreamError ?? null,
      streamUpdatedAtMs: tlStreamUpdatedAtMs ?? prev.streamUpdatedAtMs ?? null,
      accountMetrics: tlAccountMetrics ?? prev.accountMetrics ?? null,
      accountMetricsUpdatedAtMs: tlAccountMetrics?.updatedAtMs != null ? Number(tlAccountMetrics.updatedAtMs) : (prev.accountMetricsUpdatedAtMs ?? null),
      snapshotUpdatedAtMs: tlSnapshotUpdatedAtMs ?? prev.snapshotUpdatedAtMs ?? null
    };
  }, [brokerWatchSymbols, tlAccountMetrics, tlBalance, tlEquity, tlOrders, tlPositions, tlQuotesBySymbol, tlQuotesError, tlQuotesUpdatedAtMs, tlSnapshotUpdatedAtMs, tlStreamError, tlStreamStatus, tlStreamUpdatedAtMs]);

  useEffect(() => {
    const status = tlStatus ? String(tlStatus) : '';
    if (!status) return;
    if (truthBrokerStatusRef.current === status) return;
    truthBrokerStatusRef.current = status;
    void appendAuditEvent({
      eventType: 'broker_status',
      level: status === 'error' ? 'warn' : 'info',
      symbol: activeBrokerSymbol || null,
      payload: {
        status,
        env: tlSavedConfig?.env || null,
        server: tlSavedConfig?.server || null,
        accountId: tlSavedConfig?.accountId ?? null,
        accNum: tlSavedConfig?.accNum ?? null
      }
    });
  }, [activeBrokerSymbol, appendAuditEvent, tlSavedConfig?.accNum, tlSavedConfig?.accountId, tlSavedConfig?.env, tlSavedConfig?.server, tlStatus]);

  useEffect(() => {
    const ts = Number(tlSnapshotUpdatedAtMs || 0);
    if (!Number.isFinite(ts) || ts <= 0) return;
    if (ts <= truthBrokerSnapshotAtRef.current) return;
    truthBrokerSnapshotAtRef.current = ts;
    void appendAuditEvent({
      eventType: 'broker_snapshot',
      symbol: activeBrokerSymbol || null,
      payload: {
        updatedAtMs: ts,
        positionsCount: Array.isArray(tlPositions) ? tlPositions.length : 0,
        ordersCount: Array.isArray(tlOrders) ? tlOrders.length : 0,
        status: tlStatus || null
      }
    });
  }, [activeBrokerSymbol, appendAuditEvent, tlOrders, tlPositions, tlSnapshotUpdatedAtMs, tlStatus]);

  useEffect(() => {
    const ts = Number(tlQuotesUpdatedAtMs || 0);
    if (!Number.isFinite(ts) || ts <= 0) return;
    if (ts <= truthBrokerQuotesAtRef.current) return;
    if (ts - truthBrokerQuotesAtRef.current < 2000) return;
    truthBrokerQuotesAtRef.current = ts;
    const count = tlQuotesBySymbol ? Object.keys(tlQuotesBySymbol).length : 0;
    void appendAuditEvent({
      eventType: 'broker_quotes',
      symbol: activeBrokerSymbol || null,
      payload: {
        updatedAtMs: ts,
        count
      }
    });
  }, [activeBrokerSymbol, appendAuditEvent, tlQuotesBySymbol, tlQuotesUpdatedAtMs]);

  useEffect(() => {
    const ts = Number(tlStreamUpdatedAtMs || 0);
    const status = tlStreamStatus ? String(tlStreamStatus) : '';
    const prevStatus = truthBrokerStreamStatusRef.current || '';
    const marker = ts > 0 ? ts : 0;
    if (!status && !marker) return;
    if (status === prevStatus && marker && marker <= truthBrokerStreamAtRef.current) return;
    if (marker) truthBrokerStreamAtRef.current = marker;
    truthBrokerStreamStatusRef.current = status || prevStatus || null;
    void appendAuditEvent({
      eventType: 'broker_stream_status',
      symbol: activeBrokerSymbol || null,
      level: status === 'error' ? 'warn' : 'info',
      payload: {
        status: status || null,
        error: tlStreamError || null,
        updatedAtMs: marker || null
      }
    });
  }, [activeBrokerSymbol, appendAuditEvent, tlStreamError, tlStreamStatus, tlStreamUpdatedAtMs]);

  const buildHealthSnapshot = useCallback((): HealthSnapshot => {
    const now = Date.now();
    const watchers = setupWatchersRef.current || [];
    const enabledCount = watchers.filter((w) => w && w.enabled !== false).length;
    const signalsCount = setupSignalsRef.current?.length ?? 0;
    const meta = nativeChartRef.current?.getMeta ? nativeChartRef.current.getMeta() : null;
    const autoState = autoPilotStateRef.current;
    const startup = startupReadinessStatus;
    const workerFallbackStats = getWorkerFallbackStats();
    const refreshSlaSnapshot = refreshSlaMonitor.getSnapshot(now);
    const refreshSlaByChannel = refreshSlaMonitor.getChannelSnapshots(now);
    const brokerCircuitSnapshot = brokerCircuitBreaker.getSnapshot(now);
    const brokerCircuitBySource = brokerCircuitBreaker.getSourceSnapshot(now).map((entry) => ({
      source: entry.source,
      state: entry.state,
      failureCount: entry.failureCount,
      openedAt: entry.openedAtMs ?? null,
      retryAfterMs: entry.retryAfterMs ?? 0,
      lastError: entry.lastError ?? null
    }));
    const brokerCircuitOpenCount = brokerCircuitSnapshot.entries.filter((entry) => entry.open).length;
    const bridgeDomainReadiness = getDomainReadiness();
    const persistenceHealth = getPersistenceHealthSnapshot();
    const executionAuditSnapshot = executionAuditService.getSnapshot();
    const livePolicySnapshot = livePolicyService.getSnapshot();
    const panelConnectivity = normalizePanelConnectivitySnapshot(panelConnectivityEngine.getSnapshot(now), now);
    const crossPanelContextSnapshot = crossPanelContextEngine.getContext();
    const outcomeCursorSnapshot = outcomeConsistencyEngine.getCursor();
    const outcomeConsistencySnapshot = outcomeConsistencyEngine.getConsistencyState(now);
    const panelFreshnessSnapshot = outcomeConsistencyEngine.getPanelFreshness(now);
    const chartFrameCache = chartEngine.getFrameCacheTelemetry();
    const schedulerStats = runtimeScheduler.getStats();
    const signalSchedulerTask = (schedulerStats.tasks || []).find((entry) => entry.id === SIGNAL_AUTO_REFRESH_TASK_ID) || null;
    const shadowSchedulerTask = (schedulerStats.tasks || []).find((entry) => entry.id === SHADOW_CONTROLLER_TASK_ID) || null;
    const scorecardUpdatedAtMs = (agentScorecards || []).reduce((acc, item) => {
      const ts = Number(item?.updatedAtMs || 0);
      if (Number.isFinite(ts) && ts > acc) return ts;
      return acc;
    }, 0);
    const rankFreshness = buildRankFreshnessState({
      updatedAtMs: scorecardUpdatedAtMs || null,
      persistenceOk: persistenceHealth.overallOk,
      rankDomainOk: persistenceHealth.domains?.rank?.ok ?? null,
      driftReports: agentDriftReportsRef.current || [],
      staleAfterMs: 10 * 60_000
    });
    const channelLastSuccess = refreshSlaByChannel
      .map((entry: any) => Number(entry?.lastSuccessAt || 0))
      .filter((value: number) => Number.isFinite(value) && value > 0);
    const lastSuccessfulScanAtMs = Math.max(
      Number(lastSuccessfulSignalScanAtRef.current || 0),
      channelLastSuccess.length > 0 ? Math.max(...channelLastSuccess) : 0
    ) || null;
    const workerFallbackByDomain = workerFallbackStats.reduce((acc, entry) => {
      const domain = String(entry?.domain || 'unknown').trim() || 'unknown';
      acc[domain] = {
        total: Number(entry?.total || 0),
        fallbackUsed: Number(entry?.fallbackUsed || 0),
        byReason: entry?.fallbackReasons || {}
      };
      return acc;
    }, {} as Record<string, { total: number; fallbackUsed: number; byReason: Record<string, number> }>);
    return {
      updatedAtMs: now,
      startupCheckedAtMs: startup?.checkedAtMs ?? null,
      startupPhase: startup?.startupPhase ?? startupPhase ?? null,
      startupOpenaiState: openaiReadinessState || null,
      startupTradeLockerState: tradeLockerReadinessState || null,
      startupOpenaiProbeSource: startup?.openaiProbeSource ?? null,
      startupTradeLockerProbeSource: startup?.tradeLockerProbeSource ?? null,
      startupBridgeState: startup?.bridgeState ?? startupBridgeState ?? null,
      startupBridgeError: startup?.bridgeError ?? startupBridgeError ?? null,
      startupProbeSkippedDueToBridge: startup?.probeSkippedDueToBridge ?? null,
      startupProbeErrors: startup?.probeErrors ?? null,
      startupTradeLockerAutoRestoreAttempted: tlStartupAutoRestore?.attempted ?? null,
      startupTradeLockerAutoRestoreSuccess: tlStartupAutoRestore?.success ?? null,
      startupTradeLockerAutoRestoreError: tlStartupAutoRestore?.error ?? null,
      startupTradeLockerAutoRestoreAtMs: tlStartupAutoRestore?.atMs ?? null,
      startupRequestedScopes: Array.isArray(startup?.requestedScopes) ? startup.requestedScopes.slice() : null,
      startupSkippedScopes: Array.isArray(startup?.skippedScopes) ? startup.skippedScopes.slice() : null,
      startupActiveScopes: Array.isArray(startup?.activeScopes) ? startup.activeScopes.slice() : null,
      startupBlockedScopes: Array.isArray(startup?.blockedScopes) ? startup.blockedScopes.slice() : null,
      startupUnknownScopes: Array.isArray(startup?.unknownScopes) ? startup.unknownScopes.slice() : null,
      startupPermissionError: startup?.permissionError ?? null,
      startupDiagnosticWarning: startup?.diagnosticWarning ?? null,
      brokerStatus: tlStatus || null,
      brokerQuotesUpdatedAtMs: tlQuotesUpdatedAtMs ?? null,
      brokerQuotesError: tlQuotesError ?? null,
      brokerSnapshotUpdatedAtMs: tlSnapshotUpdatedAtMs ?? null,
      brokerStreamStatus: tlStreamStatus ?? null,
      brokerStreamUpdatedAtMs: tlStreamUpdatedAtMs ?? null,
      brokerStreamError: tlStreamError ?? null,
      brokerRateLimitLastAtMs: brokerRateLimitLastAtRef.current ?? null,
      brokerRateLimitLastMessage: brokerRateLimitLastMessageRef.current ?? null,
      brokerRateLimitSuppressUntilMs: brokerRateLimitSuppressUntilMs || null,
      tradelockerRequestQueueDepth: tlStatusMeta?.requestQueueDepth ?? null,
      tradelockerRequestQueueMaxDepth: tlStatusMeta?.requestQueueMaxDepth ?? null,
      tradelockerRequestQueueMaxWaitMs: tlStatusMeta?.requestQueueMaxWaitMs ?? null,
      tradelockerRequestInFlight: tlStatusMeta?.requestInFlight ?? null,
      tradelockerRequestConcurrency: tlStatusMeta?.requestConcurrency ?? null,
      tradelockerMinRequestIntervalMs: tlStatusMeta?.minRequestIntervalMs ?? null,
      tradelockerRateLimitTelemetry: tlStatusMeta?.rateLimitTelemetry ?? null,
      nativeChartSymbol: meta?.symbol || null,
      nativeChartUpdatedAtMs: meta?.updatedAtMs ?? null,
      nativeChartFrames: Array.isArray(meta?.frames) ? meta.frames.length : null,
      setupWatcherEvalAtMs: setupWatcherLastEvalAtRef.current ?? null,
      setupSignalAtMs: setupWatcherLastSignalAtRef.current ?? null,
      setupWatcherCount: watchers.length,
      setupWatcherEnabledCount: enabledCount,
      setupSignalCount: signalsCount,
      backgroundWatcherTickAtMs: backgroundWatcherLastTickAtRef.current ?? null,
      taskTreeUpdatedAtMs: taskTreeUpdatedAtRef.current ?? null,
      autoPilotEnabled: autoPilotConfigRef.current?.enabled ?? null,
      autoPilotMode: autoPilotConfigRef.current?.mode ?? null,
      killSwitch: autoPilotConfigRef.current?.killSwitch ?? null,
      autoPilotState: autoState?.state ?? null,
      autoPilotReason: autoState?.reason ?? null,
      autoPilotReasonMessage: autoState?.message ?? null,
      autoPilotStateUpdatedAtMs: autoState?.updatedAtMs ?? null,
      perf: snapshotPerf(now),
      scheduler: {
        visible: schedulerStats.visible,
        taskCount: schedulerStats.taskCount,
        signalTaskId: SIGNAL_AUTO_REFRESH_TASK_ID,
        signalTask: signalSchedulerTask
          ? {
              id: signalSchedulerTask.id,
              groupId: signalSchedulerTask.groupId,
              runCount: signalSchedulerTask.runCount,
              errorCount: signalSchedulerTask.errorCount,
              lastRunAtMs: signalSchedulerTask.lastRunAtMs,
              lastDurationMs: signalSchedulerTask.lastDurationMs,
              paused: signalSchedulerTask.paused,
              consecutiveFailures: signalSchedulerTask.consecutiveFailures
            }
          : null,
        shadowTaskId: SHADOW_CONTROLLER_TASK_ID,
        shadowTask: shadowSchedulerTask
          ? {
              id: shadowSchedulerTask.id,
              groupId: shadowSchedulerTask.groupId,
              runCount: shadowSchedulerTask.runCount,
              errorCount: shadowSchedulerTask.errorCount,
              lastRunAtMs: shadowSchedulerTask.lastRunAtMs,
              lastDurationMs: shadowSchedulerTask.lastDurationMs,
              paused: shadowSchedulerTask.paused,
              consecutiveFailures: shadowSchedulerTask.consecutiveFailures
            }
          : null
      },
      cacheBudgets: cacheBudgetManager.getTelemetry(),
      chartFrameCache,
      workerFallback: {
        updatedAtMs: now,
        byDomain: workerFallbackByDomain
      },
      signalRefreshSla: {
        updatedAtMs: now,
        tasks: refreshSlaSnapshot
      },
      brokerCircuit: {
        updatedAtMs: brokerCircuitSnapshot.updatedAtMs,
        openCount: brokerCircuitOpenCount,
        entries: brokerCircuitSnapshot.entries
      },
      persistenceHealth,
      refreshSlaByChannel: refreshSlaByChannel as any,
      bridgeDomainReadiness: bridgeDomainReadiness as any,
      brokerCircuitBySource: brokerCircuitBySource as any,
      lastSuccessfulScanAtMs,
      rankFreshness,
      agentDrift: {
        updatedAtMs: now,
        reports: agentDriftReportsRef.current || []
      },
      executionAudit: {
        updatedAtMs: executionAuditSnapshot.updatedAtMs,
        recordsCount: executionAuditSnapshot.records.length,
        mismatches: executionAuditSnapshot.mismatches
      },
      livePolicy: livePolicySnapshot,
      panelConnectivity,
      panelFreshness: panelFreshnessSnapshot,
      outcomeFeed: {
        cursor: outcomeCursorSnapshot,
        consistency: outcomeConsistencySnapshot
      },
      crossPanelContext: crossPanelContextSnapshot
    };
  }, [agentScorecards, brokerRateLimitSuppressUntilMs, chartEngine, openaiReadinessState, snapshotPerf, startupBridgeError, startupBridgeState, startupPhase, startupReadinessStatus, tlQuotesError, tlQuotesUpdatedAtMs, tlSnapshotUpdatedAtMs, tlStartupAutoRestore, tlStatus, tlStreamError, tlStreamStatus, tlStreamUpdatedAtMs, tlStatusMeta, tradeLockerReadinessState]);

  useEffect(() => {
    buildHealthSnapshotRef.current = buildHealthSnapshot;
  }, [buildHealthSnapshot]);

  useEffect(() => {
    const update = () => {
      updateAutoPilotState({ emit: true });
      const snapshot = buildHealthSnapshot();
      healthSnapshotRef.current = snapshot;
      setHealthSnapshot(snapshot);
      const now = Date.now();
      if (now - lastHealthAuditAtRef.current >= 60_000) {
        lastHealthAuditAtRef.current = now;
        void appendAuditEvent({
          eventType: 'health_heartbeat',
          payload: snapshot
        });
      }
    };
    let stop: (() => void) | null = null;
    let cancelled = false;
    update();
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 10_000,
        onTick: () => update()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [appendAuditEvent, buildHealthSnapshot, updateAutoPilotState]);

  const playbookRunningRef = React.useRef(false);
  const playbookLastRunAtRef = React.useRef(0);

  const runExecutionPlaybookTick = useCallback(async () => {
    const mod = await loadExecutionPlaybookRuntimeModule();
    await mod.runExecutionPlaybookTickRuntime({
      tlStatus,
      tlPositions,
      ledger: window.glass?.tradeLedger,
      isShadowEntry,
      normalizeExecutionPlaybook,
      buildPlaybookState,
      getBrokerQuoteForSymbol,
      getBrokerReferencePriceFromQuote,
      validateBrokerStopLevels,
      executeBrokerActionViaApi,
      appendAuditEvent,
      playbookRunningRef,
      playbookLastRunAtRef
    });
  }, [
    appendAuditEvent,
    buildPlaybookState,
    executeBrokerActionViaApi,
    getBrokerQuoteForSymbol,
    getBrokerReferencePriceFromQuote,
    isShadowEntry,
    normalizeExecutionPlaybook,
    tlPositions,
    tlStatus,
    validateBrokerStopLevels
  ]);

  useEffect(() => {
    if (tlStatus !== 'connected') return;
    let stop: (() => void) | null = null;
    let cancelled = false;
    void runExecutionPlaybookTick();
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 5000,
        onTick: () => runExecutionPlaybookTick()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [runExecutionPlaybookTick, tlStatus]);

  const applyDriftControls = useCallback((watcherPerf: Record<string, SetupPerformance>) => {
    const cfg = autoPilotConfigRef.current || {};
    const warnAction = normalizeDriftAction(cfg.driftActionWarn);
    const poorAction = normalizeDriftAction(cfg.driftActionPoor);
    const actionCooldownHours = Number(cfg.driftActionCooldownHours);
    const actionCooldownMs =
      Number.isFinite(actionCooldownHours) && actionCooldownHours > 0 ? actionCooldownHours * 60 * 60_000 : 0;
    const autoRetest = cfg.driftAutoRetest === true;
    const retestCooldownHours = Number(cfg.driftRetestCooldownHours);
    const retestCooldownMs =
      Number.isFinite(retestCooldownHours) && retestCooldownHours > 0 ? retestCooldownHours * 60 * 60_000 : 0;
    const retestRangeDays = Number(cfg.driftRetestRangeDays);
    const rangeDays = Number.isFinite(retestRangeDays) && retestRangeDays > 0 ? Math.floor(retestRangeDays) : 90;
    const retestMaxCombos = Number(cfg.driftRetestMaxCombos);
    const maxCombos =
      Number.isFinite(retestMaxCombos) && retestMaxCombos > 0 ? Math.floor(retestMaxCombos) : 1;
    const now = Date.now();

    const modeRank: Record<string, number> = { suggest: 0, paper: 1, live: 2 };
    const watchers = setupWatchersRef.current || [];

    const scheduleRetest = (watcher: SetupWatcher, status: string) => {
      const last = driftRetestRef.current.get(watcher.id) || 0;
      if (retestCooldownMs > 0 && now - last < retestCooldownMs) return;
      if (driftRetestInFlightRef.current.has(watcher.id)) return;
      driftRetestRef.current.set(watcher.id, now);
      driftRetestInFlightRef.current.add(watcher.id);

      void (async () => {
        try {
          const paramGrid = buildParamGridFromParams(watcher.params);
          if (!paramGrid || Object.keys(paramGrid).length === 0) {
            void appendAuditEvent({
              eventType: 'drift_retest_skipped',
              symbol: watcher.symbol,
              payload: { watcherId: watcher.id, reason: 'empty_param_grid', status }
            });
            return;
          }

          const history = await loadBacktestOptimizationHistory({
            symbol: watcher.symbol,
            strategy: watcher.strategy,
            timeframe: watcher.timeframe,
            rangeDays,
            maxCombos,
            paramGrid
          });

          if (!history.ok) {
            void appendAuditEvent({
              eventType: 'drift_retest_failed',
              symbol: watcher.symbol,
              payload: { watcherId: watcher.id, status, error: history.error || 'history_failed' }
            });
            return;
          }

          let result: any;
          try {
            result = await runBacktestOptimizationWorker(
              {
                request: history.request || {
                  symbol: watcher.symbol,
                  strategy: watcher.strategy,
                  timeframe: watcher.timeframe,
                  rangeDays,
                  maxCombos,
                  paramGrid
                },
                bars: history.bars,
                history: history.history,
                runId: history.runId,
                startedAtMs: history.startedAtMs
              },
              {}
            );
          } catch {
            result = await runBacktestOptimization({
              symbol: watcher.symbol,
              strategy: watcher.strategy,
              timeframe: watcher.timeframe,
              rangeDays,
              maxCombos,
              paramGrid
            });
          }

          if (result?.ok) {
            const saved = await persistSetupLibraryFromOptimization(result, { source: 'drift_retest' });
            if (saved?.ok && saved.entry) {
              const existing = findWatcherForLibraryEntry(saved.entry);
              if (existing) {
                updateSetupWatcher(existing.id, {
                  libraryKey: saved.entry.configKey || saved.entry.key || existing.libraryKey,
                  libraryTier: saved.entry.tier,
                  libraryScore: saved.entry.score,
                  libraryWinRateTier: saved.entry.winRateTier,
                  libraryStats: {
                    total: saved.entry.stats?.total ?? null,
                    winRate: saved.entry.stats?.winRate ?? null,
                    expectancy: saved.entry.stats?.expectancy ?? null,
                    profitFactor: saved.entry.stats?.profitFactor ?? null,
                    netR: saved.entry.performance?.netR ?? null,
                    maxDrawdown: saved.entry.performance?.maxDrawdown ?? null
                  }
                });
              }
              void refreshSetupLibrary();
            }
            void appendAuditEvent({
              eventType: 'drift_retest_complete',
              symbol: watcher.symbol,
              payload: {
                watcherId: watcher.id,
                status,
                runId: result.runId,
                combosTested: result.combosTested,
                bestScore: result?.bestConfig?.performance?.netR ?? null
              }
            });
          } else {
            void appendAuditEvent({
              eventType: 'drift_retest_failed',
              symbol: watcher.symbol,
              payload: { watcherId: watcher.id, status, error: result?.error || 'retest_failed' }
            });
          }
        } finally {
          driftRetestInFlightRef.current.delete(watcher.id);
        }
      })();
    };

    for (const watcher of watchers) {
      const perf = watcherPerf?.[watcher.id];
      const drift = perf?.drift;
      if (!drift || drift.status === 'ok') continue;

      const status = drift.status;
      const action = status === 'poor' ? poorAction : warnAction;
      const mode = watcher.mode || 'suggest';
      let patch: Partial<SetupWatcher> | null = null;

      if (action === 'paper' && (modeRank[mode] ?? 0) > modeRank.paper) {
        patch = { mode: 'paper' };
      } else if (action === 'suggest' && (modeRank[mode] ?? 0) > modeRank.suggest) {
        patch = { mode: 'suggest' };
      } else if (action === 'disable' && watcher.enabled !== false) {
        patch = { enabled: false };
      }

      if (patch) {
        const key = `${watcher.id}:${action}`;
        const last = driftActionRef.current.get(key) || 0;
        if (!actionCooldownMs || now - last >= actionCooldownMs) {
          updateSetupWatcher(watcher.id, patch);
          driftActionRef.current.set(key, now);
          void appendAuditEvent({
            eventType: 'drift_action',
            symbol: watcher.symbol,
            payload: {
              watcherId: watcher.id,
              status,
              action,
              modeBefore: mode,
              enabledBefore: watcher.enabled
            }
          });
        }
      }

      if (autoRetest) {
        scheduleRetest(watcher, status);
      }
    }
  }, [appendAuditEvent, findWatcherForLibraryEntry, persistSetupLibraryFromOptimization, refreshSetupLibrary, updateSetupWatcher]);

  const refreshSetupPerformance = useCallback(async (opts?: { limit?: number; force?: boolean }) => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list) {
      setSetupPerformanceError('Setup performance unavailable (ledger not ready).');
      return { ok: false, error: 'Setup performance unavailable.' };
    }

    const now = Date.now();
    if (!opts?.force && now - setupPerformanceFetchAtRef.current < 5_000) {
      return { ok: true, skipped: true };
    }
    setupPerformanceFetchAtRef.current = now;

    const limit = Number.isFinite(Number(opts?.limit)) ? Math.max(100, Math.min(2000, Math.floor(Number(opts?.limit)))) : 800;

    try {
      const res = await ledger.list({ limit });
      if (!res?.ok || !Array.isArray(res.entries)) {
        const err = res?.error ? String(res.error) : 'Failed to load trade ledger.';
        setSetupPerformanceError(err);
        return { ok: false, error: err };
      }

      const mod = await loadSetupPerformanceRuntimeModule();
      const runtime = mod.computeSetupPerformanceRuntime({
        entries: res.entries,
        account: {
          env: tlSavedConfig?.env ?? null,
          server: tlSavedConfig?.server ?? null,
          accountId: tlSavedConfig?.accountId ?? null,
          accNum: tlSavedConfig?.accNum ?? null
        },
        setupWatchers: setupWatchersRef.current || [],
        setupLibrary: setupLibraryRef.current || [],
        normalizeExecutionPlaybook,
        buildPlaybookState
      });

      if (!runtime.ok) {
        setSetupPerformanceError(runtime.error || 'Failed to compute setup performance.');
        return { ok: false, error: runtime.error || 'Failed to compute setup performance.' };
      }

      setPlaybookStatusByWatcher(runtime.playbookStatus);
      applyDriftControls(runtime.watcherObj);
      setSetupPerformanceByWatcher(runtime.watcherObj);
      setSetupPerformanceByLibrary(runtime.libraryObj);
      setSetupPerformanceByMode(runtime.modeObj);
      setSetupPerformanceBySymbol(runtime.symbolObj);
      setSetupPerformanceSummary(runtime.summary);
      setSetupPerformanceUpdatedAtMs(Date.now());
      setSetupPerformanceError(null);
      return { ok: true };
    } catch (err: any) {
      const message = err?.message ? String(err.message) : 'Failed to compute setup performance.';
      setSetupPerformanceError(message);
      return { ok: false, error: message };
    }
  }, [
    applyDriftControls,
    buildPlaybookState,
    normalizeExecutionPlaybook,
    tlSavedConfig?.accNum,
    tlSavedConfig?.accountId,
    tlSavedConfig?.env,
    tlSavedConfig?.server
  ]);

  useEffect(() => {
    void refreshSetupPerformance({ force: true });
    let stop: (() => void) | null = null;
    let cancelled = false;
    void loadFeatureControllers().then((mod) => {
      if (cancelled) return;
      stop = mod.startIntervalControllerSafe({
        intervalMs: 15_000,
        onTick: () => refreshSetupPerformance()
      });
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [refreshSetupPerformance]);

    useEffect(() => {
      const brokerAvailable =
        !!(window as any)?.glass?.broker?.request || !!(window as any)?.glass?.tradelocker?.getHistorySeries;
      if (!brokerAvailable) return;
      if (tlStatus !== 'connected') {
        const prev = tradeLockerExecRef.current || {};
        if (prev.brokerHistorySummary) {
          tradeLockerExecRef.current = { ...prev, brokerHistorySummary: '', brokerHistoryMeta: null };
        }
        return;
      }

    const activeUrl = activeTab?.url || '';
    const tvParams = getTradingViewParams(activeUrl);
    const tvSymbol = String(tvParams?.symbol || '').trim();
    if (!tvSymbol) {
      const prev = tradeLockerExecRef.current || {};
      if (prev.brokerHistorySummary) {
        tradeLockerExecRef.current = { ...prev, brokerHistorySummary: '', brokerHistoryMeta: null };
      }
      return;
    }

    const primaryResolution = mapTradingViewIntervalToBrokerResolution(tvParams?.interval || '');
    const resolutionSet = new Set<string>();
    if (primaryResolution) resolutionSet.add(primaryResolution);
    resolutionSet.add('1H');
    resolutionSet.add('4H');
    const resolutions = Array.from(resolutionSet).filter((r) => BROKER_RESOLUTION_MS[r]);
    if (resolutions.length === 0) return;

    const now = Date.now();
    const key = `${tvSymbol}::${resolutions.join(',')}`;
    const last = brokerHistoryRef.current;
    if (last && last.key === key && now - last.updatedAtMs < 45_000) return;
    brokerHistoryRef.current = { key, updatedAtMs: now };

    let cancelled = false;
    (async () => {
      const resolvedSymbol = await resolveTradeLockerSymbolBestEffort(tvSymbol);
      const targetSymbol = resolvedSymbol || tvSymbol;
        const tasks = resolutions.map((res) => {
          const resMs = BROKER_RESOLUTION_MS[res];
          const lookbackBars = 300;
          const fromMs = now - resMs * lookbackBars;
          return requestBrokerWithAudit('getHistorySeries', {
            symbol: targetSymbol,
            resolution: res,
            from: fromMs,
            to: now,
            aggregate: true,
            maxAgeMs: 60_000
          }, { symbol: targetSymbol });
        });

      const results = await Promise.all(tasks);
      if (cancelled) return;

      const lines = results
        .map((res, idx) => {
          if (!res?.ok) return '';
          const bars = Array.isArray(res.bars) ? res.bars : [];
          return computeHistorySummaryLine(bars, resolutions[idx], res?.coverage);
        })
        .filter(Boolean);

      if (lines.length === 0) return;

      const summary = lines.join('\n');
      const prev = tradeLockerExecRef.current || {};
      tradeLockerExecRef.current = {
        ...prev,
        brokerHistorySummary: summary,
        brokerHistoryMeta: {
          symbol: targetSymbol,
          resolutions,
          updatedAtMs: Date.now()
        }
      };
    })();

    return () => {
      cancelled = true;
    };
  }, [activeTab?.url, requestBrokerWithAudit, resolveTradeLockerSymbolBestEffort, tlStatus]);

  useEffect(() => {
    if (!autoPilotConfig?.enabled) return;
    const maxDailyLoss = Number(autoPilotConfig?.maxDailyLoss);
    if (!Number.isFinite(maxDailyLoss) || maxDailyLoss <= 0) return;
    if (tlStatus !== 'connected') return;

    const env = tlSavedConfig?.env || null;
    const server = tlSavedConfig?.server || null;
    const accountId = tlSavedConfig?.accountId ?? null;
    const accNum = tlSavedConfig?.accNum ?? null;
    if (!env || !server || !accountId || !accNum) return;

    const equityNow =
      tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.equity)) ? Number(tlAccountMetrics.equity) : tlEquity;
    if (!Number.isFinite(equityNow) || equityNow <= 0) return;

    const accountKey = `${String(env)}:${String(server)}:${String(accountId)}:${String(accNum)}`;
    const dateKey = getLocalDateKey();
    const storageKey = getDailyBaselineStorageKey(accountKey, dateKey);
    const baseline = readLocalJson(storageKey);
    const equityStart = baseline && Number.isFinite(Number(baseline.equityStart)) ? Number(baseline.equityStart) : null;
    if (equityStart == null) {
      writeLocalJson(storageKey, { equityStart: equityNow, createdAtMs: Date.now() });
    }
  }, [autoPilotConfig?.enabled, autoPilotConfig?.maxDailyLoss, tlAccountMetrics, tlEquity, tlSavedConfig, tlStatus]);

  useEffect(() => {
    const env = tlSavedConfig?.env ?? null;
    const server = tlSavedConfig?.server ?? null;
    const accountId = tlSavedConfig?.accountId ?? null;
    const accNum = tlSavedConfig?.accNum ?? null;
    const accountKey =
      env && server && accountId != null && accNum != null
        ? `${String(env)}:${String(server)}:${String(accountId)}:${String(accNum)}`
        : 'sim';
    const stored = readLocalJson(getLossStreakStorageKey(accountKey));
    const streak = stored && Number.isFinite(Number(stored.streak)) ? Number(stored.streak) : 0;
    const updatedAtMs = stored && Number.isFinite(Number(stored.updatedAtMs)) ? Number(stored.updatedAtMs) : null;
    const lastClosedAtMs = stored && Number.isFinite(Number(stored.lastClosedAtMs)) ? Number(stored.lastClosedAtMs) : null;
    setLossStreakState({ streak, updatedAtMs, lastClosedAtMs, accountKey });
  }, [tlSavedConfig?.env, tlSavedConfig?.server, tlSavedConfig?.accountId, tlSavedConfig?.accNum]);

  const tlServerLabel = tlSavedConfig?.server
    ? `${tlSavedConfig.env.toUpperCase()}-${tlSavedConfig.server}`
    : (tlSavedConfig?.env === 'live' ? 'LIVE' : 'DEMO');

  const handleTradeLockerClosePosition = useCallback((id: string, qty?: number) => {
    const pos = tlPositions.find((p) => p.id === id);
    (async () => {
      const res = await executeBrokerActionViaApi({
        type: 'CLOSE_POSITION',
        status: 'PENDING',
        positionId: id,
        qty: qty ?? 0,
        symbol: pos?.symbol ? String(pos.symbol) : undefined,
        source: 'manual',
        reason: 'Manual close'
      });
      if (res?.ok) {
        const qtyLabel = qty && qty > 0 ? ` (qty ${qty})` : '';
        addNotification('Close Requested', `${pos?.symbol || 'Position'} close sent to TradeLocker${qtyLabel}`, 'info');
      } else {
        const err = res?.error ? String(res.error) : 'Failed to close position';
        addNotification('Close Failed', err, 'error');
      }
    })();
  }, [addNotification, executeBrokerActionViaApi, tlPositions]);

  const handleTradeLockerCancelOrder = useCallback((orderId: string) => {
    const ord = tlOrders.find((o) => o.id === orderId);
    (async () => {
      const res = await executeBrokerActionViaApi({
        type: 'CANCEL_ORDER',
        status: 'PENDING',
        orderId,
        symbol: ord?.symbol ? String(ord.symbol) : undefined,
        source: 'manual',
        reason: 'Manual cancel'
      });
      if (res?.ok) {
        addNotification('Cancel Requested', `${ord?.symbol || 'Order'} cancel sent to TradeLocker`, 'info');
      } else {
        const err = res?.error ? String(res.error) : 'Failed to cancel order';
        addNotification('Cancel Failed', err, 'error');
      }
    })();
  }, [addNotification, executeBrokerActionViaApi, tlOrders]);

  // --- TradeLedger reconciliation (best-effort) ---
  const lastLedgerReconcileAtRef = React.useRef(0);
  const lastLedgerBalanceRef = React.useRef<number | null>(null);
  const lastLedgerBalanceAtMsRef = React.useRef<number>(0);
  useEffect(() => {
    const ledger = window.glass?.tradeLedger;
    if (!ledger?.list || !ledger?.update) return;
    if (tlStatus !== 'connected') return;

    const now = Date.now();
    if (now - lastLedgerReconcileAtRef.current < 2_000) return;
    lastLedgerReconcileAtRef.current = now;

    (async () => {
      try {
        const activeEnv = tlSavedConfig?.env ?? null;
        const activeServer = tlSavedConfig?.server ?? null;
        const activeAccountId = tlSavedConfig?.accountId ?? null;
        const activeAccNum = tlSavedConfig?.accNum ?? null;

        // Avoid mis-reconciling when the user switches accounts.
        if (!activeEnv || activeAccountId == null || activeAccNum == null) return;
        const activeAccountKey = `${String(activeEnv)}:${String(activeServer || '')}:${String(activeAccountId)}:${String(activeAccNum)}`;

        const balanceNowCandidate =
          tlAccountMetrics && Number.isFinite(Number(tlAccountMetrics.balance)) ? Number(tlAccountMetrics.balance) : tlBalance;
        const balanceNow = Number.isFinite(Number(balanceNowCandidate)) ? Number(balanceNowCandidate) : null;
        const balancePrev =
          lastLedgerBalanceRef.current != null && Number.isFinite(Number(lastLedgerBalanceRef.current))
            ? Number(lastLedgerBalanceRef.current)
            : null;
        const balancePrevAtMs = Number(lastLedgerBalanceAtMsRef.current || 0);

        if (balanceNow != null) {
          lastLedgerBalanceRef.current = balanceNow;
          lastLedgerBalanceAtMsRef.current = now;
        }

        const listRes = await ledger.list({ limit: 200 });
        if (!listRes?.ok || !Array.isArray(listRes.entries)) return;

        const entries = listRes.entries as any[];
        const recent = entries.filter(e => (Number(e?.createdAtMs) || 0) > now - 24 * 60 * 60 * 1000);
        const missingThresholdMs = 15_000;

        const normalizeStatus = (value: any) => String(value || '').trim().toUpperCase();
        const isCanceledOrderStatus = (value: any) => {
          const s = normalizeStatus(value);
          return s.includes('CANCEL') || s.includes('CANCELED') || s.includes('CANCELLED') || s.includes('EXPIRED');
        };
        const isRejectedOrderStatus = (value: any) => normalizeStatus(value).includes('REJECT');

        const patchById: Record<string, any> = {};
        const closureCandidates: Array<{
          entryId: string;
          symbol: string;
          action: string | null;
          pnlEstimate: number;
          positionId: string;
          clientTag: string | null;
          agentId: any;
          reason: any;
          messageId?: string | null;
          runId?: string | null;
          decisionId?: string | null;
          executionId?: string | null;
          entryPrice?: number | null;
          stopLoss?: number | null;
          takeProfit?: number | null;
          qty?: number | null;
          openedAtMs?: number | null;
        }> = [];

        const mergePatch = (id: string, patch: any) => {
          if (!patch || typeof patch !== 'object') return;
          patchById[id] = {
            ...(patchById[id] || {}),
            ...patch,
            reconciledAtMs: now
          };
        };

        const normStr = (v: any) => String(v ?? '').trim().toUpperCase();

        const matchesActiveAccount = (entry: any) => {
          const acct = entry?.account || entry?.acct || null;
          if (!acct || typeof acct !== 'object') return false;
          if (activeEnv && normStr(acct?.env) !== normStr(activeEnv)) return false;
          if (activeServer && normStr(acct?.server) !== normStr(activeServer)) return false;
          if (Number(acct?.accountId) !== Number(activeAccountId)) return false;
          if (Number(acct?.accNum) !== Number(activeAccNum)) return false;
          return true;
        };

        for (const e of recent) {
          if (e?.broker !== 'tradelocker') continue;
          if (!matchesActiveAccount(e)) continue;
          if (!e?.id) continue;

          const entryId = String(e.id);
          const clientTag = e?.clientTag ? String(e.clientTag) : null;
          const brokerOrderId = e?.brokerOrderId ? String(e.brokerOrderId) : null;

          const orderMatch =
            (brokerOrderId ? tlOrders.find(o => String(o.id) === brokerOrderId) : null) ||
            (clientTag ? tlOrders.find(o => (o as any).strategyId && String((o as any).strategyId) === clientTag) : null) ||
            null;

          const posMatch = clientTag
            ? tlPositions.find(p => (p as any).strategyId && String((p as any).strategyId) === clientTag)
            : null;

          const patch: any = {};
          if (orderMatch) {
            patch.brokerOrderId = String(orderMatch.id);
            patch.brokerOrderStatus = String(orderMatch.status || '');
            patch.brokerOrderSeenAtMs = now;
            if (!e?.brokerAcceptedAtMs) patch.brokerAcceptedAtMs = now;
            if (orderMatch.filledQty != null) patch.orderFilledQty = Number(orderMatch.filledQty);
            if (orderMatch.remainingQty != null) patch.orderRemainingQty = Number(orderMatch.remainingQty);
            if (orderMatch.createdAt instanceof Date) patch.orderCreatedAtMs = orderMatch.createdAt.getTime();
          }
          if (posMatch) {
            const openedNow = !e?.positionOpenedAtMs;
            patch.positionId = String(posMatch.id);
            patch.positionPnl = Number.isFinite(Number(posMatch.pnl)) ? Number(posMatch.pnl) : 0;
            patch.positionSeenAtMs = now;
            patch.positionStatus = 'OPEN';
            patch.positionMissingSinceMs = null;
            patch.status = 'OPEN';
            if (!e?.positionOpenedAtMs) patch.positionOpenedAtMs = now;
            if (Number.isFinite(Number(posMatch.entryPrice)) && Number(posMatch.entryPrice) > 0) patch.brokerEntryPrice = Number(posMatch.entryPrice);
            if (Number.isFinite(Number(posMatch.size)) && Number(posMatch.size) !== 0) patch.brokerQty = Number(posMatch.size);
            if (posMatch.openTime instanceof Date) patch.brokerOpenTimeMs = posMatch.openTime.getTime();
            if (openedNow) {
              void appendAuditEvent({
                eventType: 'trade_opened',
                symbol: e?.symbol ? String(e.symbol) : null,
                runId: e?.runId ?? null,
                decisionId: e?.decisionId ?? null,
                executionId: e?.executionId ?? entryId,
                payload: {
                  entryId,
                  positionId: String(posMatch.id),
                  brokerEntryPrice: Number.isFinite(Number(posMatch.entryPrice)) ? Number(posMatch.entryPrice) : null,
                  qty: Number.isFinite(Number(posMatch.size)) ? Number(posMatch.size) : null
                }
              });
            }
          }

          if (!posMatch && orderMatch) {
            const alreadyTerminal = ['REJECTED', 'CLOSED', 'CANCELLED', 'CANCELED'].includes(normalizeStatus(e?.status));
            if (!alreadyTerminal) {
              if (isCanceledOrderStatus(orderMatch.status)) {
                patch.status = 'CANCELLED';
                patch.brokerCanceledAtMs = now;
              } else if (isRejectedOrderStatus(orderMatch.status)) {
                patch.status = 'REJECTED';
                patch.brokerRejectedAtMs = now;
              } else {
                // Leave as ACCEPTED/PENDING while order is live.
                const prev = normalizeStatus(e?.status);
                if (prev === 'SUBMITTING') patch.status = 'ACCEPTED';
              }
            }
          }

          // Detect closed positions (best-effort): if a previously-seen position disappears for long enough.
          if (!posMatch && e?.positionId) {
            const alreadyClosed =
              String(e?.positionStatus || '').toUpperCase() === 'CLOSED' ||
              Number(e?.positionClosedAtMs || 0) > 0 ||
              Number(e?.outcomeRecordedAtMs || 0) > 0;

            if (!alreadyClosed) {
              const missingSince = Number(e?.positionMissingSinceMs || 0);
              if (!missingSince || missingSince <= 0) {
                patch.positionMissingSinceMs = now;
              } else if (now - missingSince >= missingThresholdMs) {
                  closureCandidates.push({
                  entryId,
                  symbol: e?.symbol ? String(e.symbol) : (clientTag ? String(clientTag) : 'UNKNOWN'),
                  action: e?.action ? String(e.action) : null,
                  pnlEstimate: Number.isFinite(Number(e?.positionPnl)) ? Number(e.positionPnl) : 0,
                  positionId: String(e.positionId),
                  clientTag,
                  agentId: e?.agentId ?? null,
                  reason: e?.reason ?? null,
                  messageId: e?.messageId != null ? String(e.messageId) : null,
                  runId: e?.runId ?? null,
                  decisionId: e?.decisionId ?? null,
                  executionId: e?.executionId ?? null,
                  plannedEntryPrice:
                    Number.isFinite(Number(e?.entryPrice)) && Number(e.entryPrice) > 0 ? Number(e.entryPrice) : null,
                  brokerEntryPrice:
                    Number.isFinite(Number(e?.brokerEntryPrice)) && Number(e.brokerEntryPrice) > 0
                      ? Number(e.brokerEntryPrice)
                      : null,
                  stopLoss: Number.isFinite(Number(e?.stopLoss)) && Number(e.stopLoss) > 0 ? Number(e.stopLoss) : null,
                  takeProfit: Number.isFinite(Number(e?.takeProfit)) && Number(e.takeProfit) > 0 ? Number(e.takeProfit) : null,
                  qty:
                    Number.isFinite(Number(e?.qtyNormalized)) && Number(e.qtyNormalized) > 0
                      ? Number(e.qtyNormalized)
                      : (Number.isFinite(Number(e?.brokerQty)) && Number(e.brokerQty) > 0
                        ? Number(e.brokerQty)
                        : (Number.isFinite(Number(e?.qty)) && Number(e.qty) > 0 ? Number(e.qty) : null)),
                  openedAtMs:
                    Number.isFinite(Number(e?.positionOpenedAtMs)) && Number(e.positionOpenedAtMs) > 0
                      ? Number(e.positionOpenedAtMs)
                      : (Number.isFinite(Number(e?.brokerOpenTimeMs)) && Number(e.brokerOpenTimeMs) > 0 ? Number(e.brokerOpenTimeMs) : null)
                });
              }
            }
          }
          if (Object.keys(patch).length > 0) mergePatch(entryId, patch);
        }

        if (closureCandidates.length > 0) {
          const deltaWindowOk = balancePrev != null && balanceNow != null && now - (balancePrevAtMs || 0) <= 60_000;
          const balanceDelta = deltaWindowOk ? Number(balanceNow) - Number(balancePrev) : null;
          const sumAbsEst = closureCandidates.reduce((acc, c) => acc + Math.abs(Number(c.pnlEstimate) || 0), 0);
          const useBalanceDelta = balanceDelta != null && (Math.abs(balanceDelta) >= 0.01 || sumAbsEst < 0.01);

          // Prefer broker-provided realized P&L if available.
          const brokerInfoByEntryId = new Map<string, any>();
          const tlApi = window.glass?.tradelocker;
          if (tlApi?.getPositionDetails) {
            for (const c of closureCandidates) {
              try {
                const res = await tlApi.getPositionDetails({ positionId: c.positionId });
                if (!res?.ok) {
                  // If we are rate-limited, stop probing and fall back to balance/estimate.
                  if (res?.rateLimited) break;
                  continue;
                }
                const realized = res.realizedPnl != null && Number.isFinite(Number(res.realizedPnl)) ? Number(res.realizedPnl) : null;
                const closeTimeMs = res.closeTime ? Date.parse(String(res.closeTime)) : NaN;
                const openTimeMs = res.openTime ? Date.parse(String(res.openTime)) : NaN;

                brokerInfoByEntryId.set(c.entryId, {
                  realizedPnl: realized,
                  closeTimeMs: Number.isFinite(closeTimeMs) ? closeTimeMs : null,
                  openTimeMs: Number.isFinite(openTimeMs) ? openTimeMs : null,
                  closePrice: res.closePrice != null && Number.isFinite(Number(res.closePrice)) ? Number(res.closePrice) : null,
                  entryPrice: res.entryPrice != null && Number.isFinite(Number(res.entryPrice)) ? Number(res.entryPrice) : null,
                  size: res.size != null && Number.isFinite(Number(res.size)) ? Number(res.size) : null,
                  commission: res.commission != null && Number.isFinite(Number(res.commission)) ? Number(res.commission) : null,
                  swap: res.swap != null && Number.isFinite(Number(res.swap)) ? Number(res.swap) : null,
                  fee: res.fee != null && Number.isFinite(Number(res.fee)) ? Number(res.fee) : null
                });
              } catch {
                // ignore broker detail failures (best-effort)
              }
            }
          }

          const knownBrokerSum = closureCandidates.reduce((acc, c) => {
            const b = brokerInfoByEntryId.get(c.entryId);
            const v = b?.realizedPnl;
            return v != null && Number.isFinite(Number(v)) ? acc + Number(v) : acc;
          }, 0);

          const unknown = closureCandidates.filter((c) => {
            const b = brokerInfoByEntryId.get(c.entryId);
            return !(b?.realizedPnl != null && Number.isFinite(Number(b.realizedPnl)));
          });

          let allocations: Array<{ entryId: string; realizedPnl: number; source: string }> = [];

          const remainingDelta = useBalanceDelta ? Number(balanceDelta || 0) - knownBrokerSum : null;
          const canAllocateRemaining = remainingDelta != null && (Math.abs(remainingDelta) >= 0.01 || sumAbsEst < 0.01);

          if (unknown.length === 0) {
            allocations = [];
          } else if (canAllocateRemaining) {
            if (unknown.length === 1) {
              allocations = [{ entryId: unknown[0].entryId, realizedPnl: Number(remainingDelta || 0), source: 'balance_delta_remaining' }];
            } else {
              const sumEst = unknown.reduce((acc, c) => acc + (Number(c.pnlEstimate) || 0), 0);
              if (Math.abs(sumEst) >= 0.01) {
                allocations = unknown.map((c) => ({
                  entryId: c.entryId,
                  realizedPnl: Number(remainingDelta || 0) * ((Number(c.pnlEstimate) || 0) / sumEst),
                  source: 'balance_delta_remaining_ratio'
                }));
              } else {
                const sumAbs = sumAbsEst > 0 ? sumAbsEst : unknown.length;
                allocations = unknown.map((c) => ({
                  entryId: c.entryId,
                  realizedPnl: Number(remainingDelta || 0) * ((Math.abs(Number(c.pnlEstimate) || 0) || 1) / sumAbs),
                  source: 'balance_delta_remaining_split'
                }));
              }
            }
          } else {
            allocations = unknown.map((c) => ({
              entryId: c.entryId,
              realizedPnl: Number(c.pnlEstimate) || 0,
              source: 'position_pnl_estimate'
            }));
          }

          const allocationById = new Map(allocations.map((a) => [a.entryId, a]));

          for (const c of closureCandidates) {
            const alloc = allocationById.get(c.entryId);
            const broker = brokerInfoByEntryId.get(c.entryId);
            const brokerRealized = broker?.realizedPnl != null && Number.isFinite(Number(broker.realizedPnl)) ? Number(broker.realizedPnl) : null;

            const realizedPnlRaw =
              brokerRealized != null
                ? brokerRealized
                : alloc && Number.isFinite(Number(alloc.realizedPnl))
                  ? Number(alloc.realizedPnl)
                  : Number(c.pnlEstimate) || 0;
            const realizedPnl = Number.isFinite(realizedPnlRaw) ? realizedPnlRaw : 0;

            const memoryId = `mem_close_${c.entryId}`;
            const memoryDedupeKey = `close:${c.entryId}`;

            const closedAtMs = broker?.closeTimeMs != null ? Number(broker.closeTimeMs) : now;
            const detectedAtMs = now;
            const openedAtMs =
              broker?.openTimeMs != null ? Number(broker.openTimeMs)
              : (c.openedAtMs != null ? Number(c.openedAtMs) : null);
            const durationSec =
              openedAtMs != null && Number.isFinite(openedAtMs) && openedAtMs > 0
                ? Math.max(0, Math.round((closedAtMs - openedAtMs) / 1000))
                : null;

            addTradeMemory(c.symbol, realizedPnl, {
              action: c.action,
              agentId: c.agentId,
              broker: 'tradelocker',
              ledgerId: c.entryId,
              messageId: c.messageId ?? null,
              positionId: c.positionId,
              clientTag: c.clientTag,
              reason: c.reason,
              entryPrice: broker?.entryPrice != null ? broker.entryPrice : (c.brokerEntryPrice ?? c.plannedEntryPrice ?? null),
              stopLoss: c.stopLoss ?? null,
              takeProfit: c.takeProfit ?? null,
              qty: broker?.size != null ? broker.size : (c.qty ?? null),
              closePrice: broker?.closePrice ?? null,
              durationSec,
              memoryId,
              dedupeKey: memoryDedupeKey,
              closedAtMs,
              detectedClosedAtMs: detectedAtMs,
              realizedPnlSource: brokerRealized != null ? 'broker_position' : (alloc?.source || 'position_pnl_estimate')
            });
            updateLossStreak(activeAccountKey, String(c.entryId || ''), realizedPnl, closedAtMs);

            // Queue an AI post-trade review so the agents can learn a durable lesson (and propose a rule candidate).
            try {
              let chartSnapshotDataUrl: string | null = null;
              let chartSnapshotPath: string | null = null;
              let chartSnapshotUrl: string | null = null;
              let chartSnapshotTitle: string | null = null;
              let chartSnapshotTimeframe: string | null = null;
              let chartSnapshotCapturedAtMs: number | null = null;

              try {
                if (postTradeReviewEnabledRef.current) {
                  const capture = browserControlsRef.current?.captureTab;
                  if (capture) {
                    const normalizeSymbol = (value: any) => {
                      const raw = String(value || '').trim().toUpperCase();
                      if (!raw) return '';
                      const afterColon = raw.includes(':') ? raw.split(':').pop() || raw : raw;
                      const beforeSpace = afterColon.split(/\s+/)[0] || afterColon;
                      const noSuffix = beforeSpace.split('.')[0] || beforeSpace;
                      return noSuffix.replace(/[^A-Z0-9]/g, '');
                    };

                    const scoreMatch = (candidate: any, target: any) => {
                      const c = normalizeSymbol(candidate);
                      const t = normalizeSymbol(target);
                      if (!c || !t) return 0;
                      if (c === t) return 100;
                      if (c.endsWith(t) || t.endsWith(c)) return 80;
                      if (c.includes(t) || t.includes(c)) return 60;
                      // Weak partial match: share >= 4 leading chars.
                      let common = 0;
                      for (let i = 0; i < Math.min(c.length, t.length); i++) {
                        if (c[i] !== t[i]) break;
                        common += 1;
                      }
                      return common >= 4 ? 40 + common : 0;
                    };

                    const tabsNow = Array.isArray(tabsRef.current) ? tabsRef.current : [];
                    const tabsById = new Map(tabsNow.map((t: any) => [String(t?.id || ''), t]));
                    const activeId = String(activeTabIdRef.current || '');
                    const activeNow: any = activeTabRef.current || null;
                    const candidates: Array<{ tabId: string; url: string; title: string; timeframe: string | null }> = [];
                    const seenTabIds = new Set<string>();
                    const pushCandidate = (cand: { tabId: string; url: string; title: string; timeframe: string | null } | null) => {
                      if (!cand) return;
                      const tabId = String(cand.tabId || '').trim();
                      if (!tabId) return;
                      if (seenTabIds.has(tabId)) return;
                      seenTabIds.add(tabId);
                      candidates.push({ ...cand, tabId });
                    };

                    // Prefer matching Chart Session timeframe tabs when available.
                    const sessionsNow = Array.isArray(chartSessionsRef.current) ? chartSessionsRef.current : [];
                    let bestSession: any = null;
                    let bestSessionScore = 0;
                    for (const s of sessionsNow) {
                      if (!s || typeof s !== 'object') continue;
                      const views = (s as any).views;
                      if (!views || typeof views !== 'object') continue;
                      if (!Object.values(views).some(Boolean)) continue;
                      const score = scoreMatch((s as any).symbol, c.symbol);
                      if (score > bestSessionScore) {
                        bestSessionScore = score;
                        bestSession = s;
                      }
                    }

                    if (bestSession && bestSessionScore > 0) {
                      const views: any = (bestSession as any).views || {};
                      const order = ['15m', '1h', '4h'];
                      for (const tf of order) {
                        const tabId = views[tf] != null ? String(views[tf]) : '';
                        if (!tabId) continue;
                        const tab: any = tabsById.get(tabId);
                        if (!tab || !isTradingViewUrl(tab.url)) continue;
                        pushCandidate({ tabId, url: tab.url, title: tab.title || tab.url, timeframe: tf });
                      }
                    }

                    if (activeNow && activeId && isTradingViewUrl(activeNow.url)) {
                      const { symbol: tvSymbol } = getTradingViewParams(activeNow.url);
                      if (scoreMatch(tvSymbol || activeNow.title || '', c.symbol) > 0) {
                        pushCandidate({ tabId: activeId, url: activeNow.url, title: activeNow.title || activeNow.url, timeframe: null });
                      }
                    }

                    let bestTab: any = null;
                    let bestScore = 0;
                    for (const t of tabsNow) {
                      if (!t || !isTradingViewUrl(t.url)) continue;
                      const { symbol: tvSymbol } = getTradingViewParams(t.url);
                      let score = scoreMatch(tvSymbol || t.title || '', c.symbol);
                      if (score <= 0) continue;
                      if (t.isWatched) score += 5;
                      if (String(t.id) === activeId) score += 3;
                      if (score > bestScore) {
                        bestScore = score;
                        bestTab = t;
                      }
                    }
                    if (bestTab && bestScore > 0) {
                      pushCandidate({ tabId: String(bestTab.id), url: bestTab.url, title: bestTab.title || bestTab.url, timeframe: null });
                    }

                    // Final fallback: capture whatever the active tab is (always mounted).
                    if (activeNow && activeId) {
                      pushCandidate({ tabId: activeId, url: activeNow.url, title: activeNow.title || activeNow.url, timeframe: null });
                    }

                    for (const cand of candidates) {
                      const width = cand.timeframe === '15m' ? 1280 : cand.timeframe ? 1024 : 1280;
                      const frame = await captureTabCached(cand.tabId, { format: 'jpeg', quality: 60, width }, 15_000);
                      if (!frame?.data) continue;

                      chartSnapshotCapturedAtMs = frame.capturedAtMs || Date.now();
                      chartSnapshotDataUrl = `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
                      chartSnapshotUrl = cand.url || null;
                      chartSnapshotTitle = cand.title || null;
                      chartSnapshotTimeframe = cand.timeframe || null;

                      const saver = window.glass?.saveUserFile;
                      if (typeof saver === 'function') {
                        const prefixKey = normalizeSymbol(c.symbol) || 'SYM';
                        const idKey = String(c.entryId || '').slice(0, 24) || 'trade';
                        const saveRes = await saver({
                          data: frame.data,
                          mimeType: frame.mimeType || 'image/jpeg',
                          subdir: 'review-snapshots',
                          prefix: `review_${prefixKey}_${idKey}`
                        });
                        if (saveRes?.ok && saveRes.path) chartSnapshotPath = String(saveRes.path);
                      }

                      break;
                    }
                  }
                }
              } catch {
                // ignore snapshot capture failures
              }

              enqueuePostTradeReview({
                ledgerId: c.entryId,
                broker: 'tradelocker',
                symbol: c.symbol,
                action: c.action,
                messageId: c.messageId ?? null,
                entryPrice: broker?.entryPrice != null ? broker.entryPrice : (c.brokerEntryPrice ?? c.plannedEntryPrice ?? null),
                stopLoss: c.stopLoss ?? null,
                takeProfit: c.takeProfit ?? null,
                qty: broker?.size != null ? broker.size : (c.qty ?? null),
                closePrice: broker?.closePrice ?? null,
                realizedPnl,
                durationSec,
                reason: c.reason,
                closedAtMs,
                chartSnapshotDataUrl: chartSnapshotDataUrl || undefined,
                chartSnapshotPath: chartSnapshotPath || undefined,
                chartSnapshotUrl: chartSnapshotUrl || undefined,
                chartSnapshotTitle: chartSnapshotTitle || undefined,
                chartSnapshotTimeframe: chartSnapshotTimeframe || undefined,
                chartSnapshotCapturedAtMs: chartSnapshotCapturedAtMs || undefined,
                account: {
                  env: activeEnv || null,
                  server: activeServer || null,
                  accountId: activeAccountId ?? null,
                  accNum: activeAccNum ?? null
                }
              });
            } catch { /* ignore */ }

            const expectedEntry =
              Number.isFinite(Number(c.plannedEntryPrice)) && Number(c.plannedEntryPrice) > 0
                ? Number(c.plannedEntryPrice)
                : null;
            const actualEntry =
              broker?.entryPrice != null && Number.isFinite(Number(broker.entryPrice))
                ? Number(broker.entryPrice)
                : (c.brokerEntryPrice != null && Number.isFinite(Number(c.brokerEntryPrice)) ? Number(c.brokerEntryPrice) : null);
            const actionSide = String(c.action || '').toUpperCase();
            const direction = actionSide === 'SELL' ? -1 : 1;
            const slippageAbs =
              expectedEntry != null && actualEntry != null
                ? (actualEntry - expectedEntry) * direction
                : null;
            const slippagePct =
              slippageAbs != null && expectedEntry != null && expectedEntry > 0
                ? (slippageAbs / expectedEntry) * 100
                : null;

            void appendAuditEvent({
              eventType: 'trade_closed',
              symbol: c.symbol,
              runId: c.runId ?? null,
              decisionId: c.decisionId ?? null,
              executionId: c.executionId ?? c.entryId,
              payload: {
                entryId: c.entryId,
                positionId: c.positionId,
                realizedPnl,
                slippageAbs,
                slippagePct,
                brokerClosePrice: broker?.closePrice ?? null,
                brokerCommission: broker?.commission ?? null,
                brokerSwap: broker?.swap ?? null,
                brokerFee: broker?.fee ?? null,
                closedAtMs
              }
            });

            mergePatch(c.entryId, {
              status: 'CLOSED',
              positionStatus: 'CLOSED',
              positionClosedAtMs: closedAtMs,
              positionDetectedClosedAtMs: detectedAtMs,
              positionClosedPnl: realizedPnl,
              positionClosedPnlEstimate: Number.isFinite(Number(c.pnlEstimate)) ? Number(c.pnlEstimate) : 0,
              realizedPnl,
              realizedPnlSource: brokerRealized != null ? 'broker_position' : (alloc?.source || 'position_pnl_estimate'),
              plannedEntryPrice: expectedEntry,
              slippageAbs: slippageAbs != null && Number.isFinite(Number(slippageAbs)) ? Number(slippageAbs) : null,
              slippagePct: slippagePct != null && Number.isFinite(Number(slippagePct)) ? Number(slippagePct) : null,
              balanceAtClose: balanceNow,
              balancePrevAtClose: balancePrev,
              balanceDeltaAtClose: balanceDelta,
              brokerClosePrice: broker?.closePrice ?? null,
              brokerCommission: broker?.commission ?? null,
              brokerSwap: broker?.swap ?? null,
              brokerFee: broker?.fee ?? null,
              brokerEntryPriceAtClose: broker?.entryPrice ?? null,
              brokerQtyAtClose: broker?.size ?? null,
              brokerOpenTimeAtCloseMs: broker?.openTimeMs ?? null,
              positionMissingSinceMs: null,
              outcomeRecordedAtMs: now,
              outcomeMemoryId: memoryId
            });
          }
        }

        const updates = Object.entries(patchById);
        for (const [entryId, patch] of updates) {
          if (!patch || typeof patch !== 'object' || Object.keys(patch).length === 0) continue;
          await ledger.update({ id: entryId, patch });
        }
      } catch {
        // ignore reconciliation errors
      }
    })();
  }, [addTradeMemory, appendAuditEvent, enqueuePostTradeReview, tlAccountMetrics, tlBalance, tlOrders, tlPositions, tlSavedConfig, tlStatus, updateLossStreak]);

  const handleTradeLockerPlaceOrder = useCallback(async (args: any) => {
      const ledger = window.glass?.tradeLedger;
      const hasLedger = !!ledger?.reserve && !!ledger?.update;
      const executionTargets = resolveTradeLockerExecutionTargets();
      if (executionTargets.length === 0) {
        const msg = 'TradeLocker active account not set. Open Locker and select an account.';
        addNotification('TradeLocker Blocked', msg, 'warning');
        return { ok: false, error: msg };
      }

      const snapshotKey = resolveSnapshotSourceKey();
      const primaryKey = snapshotKey && executionTargets.includes(snapshotKey) ? snapshotKey : executionTargets[0];
      const primaryAccount = primaryKey ? parseTradeLockerAccountKey(primaryKey) : null;
      const env = primaryAccount?.env || tlSavedConfig?.env || null;
      const server = primaryAccount?.server || tlSavedConfig?.server || null;
      const accountId = primaryAccount?.accountId ?? null;
      const accNum = primaryAccount?.accNum ?? null;
      const accountKey = primaryKey || (env && accountId != null && accNum != null ? `${String(env)}:${String(server || '')}:${String(accountId)}:${String(accNum)}` : null);

      const orderTypeRaw = String(args?.type || tlSavedConfig?.defaultOrderType || 'market').toLowerCase();
      const orderType = orderTypeRaw === 'limit' ? 'limit' : orderTypeRaw === 'stop' ? 'stop' : 'market';
      const side = String(args?.side || 'BUY').toUpperCase() === 'SELL' ? 'SELL' : 'BUY';
      const symbolRaw = args?.symbol ? String(args.symbol) : 'UNKNOWN';
      const symbol = await resolveTradeLockerSymbolBestEffort(symbolRaw);
      const entryPrice =
        orderType === 'stop'
          ? Number(args?.stopPrice ?? args?.price ?? 0)
          : Number(args?.price || 0);
      const stopLoss = Number(args?.stopLoss || 0);
      const takeProfit = Number(args?.takeProfit || 0);
      const qty = args?.qty != null ? Number(args.qty) : null;

      // Ensure we have a unique tag for matching positions back to this ticket order.
      let strategyId = args?.strategyId ? String(args.strategyId).trim() : '';
      if (!strategyId || strategyId.toLowerCase() === 'manual') {
        try {
          const pseudoProposal: any = {
            symbol,
            action: side,
            entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
            stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
            takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
            reason: 'Manual ticket'
          };
          const dedupeKey = computeTradeDedupeKey({
            proposal: pseudoProposal,
            broker: 'tradelocker',
            accountKey: accountKey || '',
            orderType,
            qty: qty ?? undefined
          });
          strategyId = computeClientStrategyIdFromDedupeKey(dedupeKey);
        } catch {
          strategyId = `gb_ticket_${Date.now().toString(16)}`.slice(0, 31);
        }
      }

      let ledgerId: string | null = null;
      if (hasLedger && accountKey) {
        try {
          const pseudoProposal: any = {
            symbol,
            symbolOriginal: symbolRaw,
            action: side,
            entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
            stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
            takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
            reason: 'Manual ticket'
          };
          const dedupeKey = computeTradeDedupeKey({
            proposal: pseudoProposal,
            broker: 'tradelocker',
            accountKey,
            orderType,
            qty: qty ?? undefined
          });

          const reserveRes = await reserveLedgerEntry({
            ledger,
            dedupeKey,
            windowMs: 2500,
            fallbackMap: tradeDedupeFallbackRef.current,
            fallbackWindowMs: 2500,
            entry: {
              kind: 'trade',
              schemaVersion: 'trade_v1',
              source: 'ticket',
              broker: 'tradelocker',
              status: 'SUBMITTING',
              agentId: null,
              reason: 'Manual ticket',
              symbol,
              symbolOriginal: symbolRaw,
              action: side,
              entryPrice: Number.isFinite(entryPrice) ? entryPrice : 0,
              stopLoss: Number.isFinite(stopLoss) ? stopLoss : 0,
              takeProfit: Number.isFinite(takeProfit) ? takeProfit : 0,
              qty: qty ?? null,
              orderType,
              clientTag: strategyId,
              account: {
                env,
                server,
                accountId,
                accNum
              }
            }
          });

          if (reserveRes?.ok && reserveRes?.reserved === false) {
            addNotification('Duplicate Blocked', 'Duplicate order blocked (clicked too fast).', 'warning');
            return { ok: false, error: 'Duplicate order blocked (clicked too fast).' };
          }
          if (reserveRes?.ok && reserveRes?.entry?.id) {
            ledgerId = String(reserveRes.entry.id);
            try {
              if (ledgerId && ledger?.update) {
                await ledger.update({ id: ledgerId, patch: { executionId: ledgerId } });
              }
            } catch {
              // ignore
            }
          }
        } catch {
          // ledger is best-effort
        }
      }

      const baseArgs: Record<string, any> = { ...(args || {}) };
      baseArgs.symbol = symbol;
      baseArgs.side = side;
      baseArgs.type = orderType;
      if (qty != null) baseArgs.qty = qty;
      if (orderType === 'stop') {
        baseArgs.stopPrice = Number.isFinite(entryPrice) ? entryPrice : baseArgs.stopPrice;
        if (baseArgs.price == null) baseArgs.price = baseArgs.stopPrice;
      }
      baseArgs.strategyId = strategyId;

      const normalizeTicketForAccount = async (targetKey: string) => {
        let normalized = false;
        const nextArgs = { ...baseArgs };
        if (tlNormalizeEnabledRef.current) {
          const refKey = resolveNormalizationReferenceKey();
          if (refKey && refKey !== targetKey) {
            await fetchTradeLockerQuotesForAccount(refKey, [symbol], { skipLock: true, restoreKey: null });
            await fetchTradeLockerQuotesForAccount(targetKey, [symbol], { skipLock: true, restoreKey: null });
            const offset = getNormalizationOffsetForAccount(targetKey, symbol);
            const offsetValue = side === 'BUY' ? offset?.askOffset : offset?.bidOffset;
            if (offset && Number.isFinite(Number(offsetValue))) {
              const adjust = (value: any) => {
                const num = Number(value);
                return Number.isFinite(num) ? num + Number(offsetValue) : value;
              };
              if (nextArgs.price != null) nextArgs.price = adjust(nextArgs.price);
              if (nextArgs.stopPrice != null) nextArgs.stopPrice = adjust(nextArgs.stopPrice);
              if (nextArgs.stopLoss != null) nextArgs.stopLoss = adjust(nextArgs.stopLoss);
              if (nextArgs.takeProfit != null) nextArgs.takeProfit = adjust(nextArgs.takeProfit);
              normalized = true;
            }
          }
        }
        return { args: nextArgs, normalized };
      };

      const useLegacySubmission = readLegacyTradeLockerSubmissionFlag();
      const results = useLegacySubmission
        ? await withTradeLockerAccountLock(async () => {
            const out: Array<{ accountKey: string; res: any; normalized: boolean }> = [];
            for (const targetKey of executionTargets) {
              const switchRes = await ensureTradeLockerAccount(targetKey, 'ticket_execute');
              if (!switchRes.ok) {
                out.push({ accountKey: targetKey, res: { ok: false, error: switchRes.error }, normalized: false });
                continue;
              }
              const payload = await normalizeTicketForAccount(targetKey);
              let res: any = null;
              try {
                res = await requestBrokerWithAudit(
                  'placeOrder',
                  payload.args,
                  {
                    symbol,
                    source: 'ticket_execute',
                    brokerId: 'tradelocker'
                  }
                );
              } catch (e: any) {
                res = { ok: false, error: e?.message ? String(e.message) : 'Failed to place order.' };
              }
              out.push({ accountKey: targetKey, res, normalized: payload.normalized });
            }
            if (snapshotKey && snapshotKey !== getTradeLockerAccountKey()) {
              await ensureTradeLockerAccount(snapshotKey, 'ticket_restore');
            }
            return out;
          })
        : (
            await submitTradeLockerOrderBatch({
              route: 'ticket_execute',
              executionTargets,
              snapshotAccountKey: snapshotKey || null,
              ensureAccount: async (accountKey, reason) => await ensureTradeLockerAccount(accountKey, reason),
              withAccountLock: withTradeLockerAccountLock,
              getActiveAccountKey: getTradeLockerAccountKey,
              switchReason: 'ticket_execute',
              restoreReason: 'ticket_restore',
              submitForAccount: async (accountKey) => {
                const payload = await normalizeTicketForAccount(accountKey);
                let res: any = null;
                try {
                  res = await requestBrokerWithAudit(
                    'placeOrder',
                    payload.args,
                    {
                      symbol,
                      source: 'ticket_execute',
                      brokerId: 'tradelocker'
                    }
                  );
                } catch (e: any) {
                  res = { ok: false, error: e?.message ? String(e.message) : 'Failed to place order.' };
                }
                return { res, normalized: payload.normalized, payload: payload.args };
              }
            })
          ).results.map((row) => ({
            accountKey: row.accountKey,
            res: row.res,
            normalized: !!row.normalized
          }));

      const primaryResult = results.find((r) => r.accountKey === primaryKey) || results[0];
      const res = primaryResult?.res;
      if (!res) {
        addNotification('TradeLocker Error', 'Failed to place order.', 'error');
        return { ok: false, error: 'Failed to place order.' };
      }
      if (res?.ok) {
        const orderId = extractBrokerOrderId(res);
        const orderStatus = res?.orderStatus != null ? String(res.orderStatus) : null;
        const resolvedSymbol = res?.resolvedSymbol != null ? String(res.resolvedSymbol) : null;
        const positionId = res?.positionId != null ? String(res.positionId).trim() : null;
        const filledQty = res?.filledQty != null && Number.isFinite(Number(res.filledQty)) ? Number(res.filledQty) : null;
        const remainingQty = res?.remainingQty != null && Number.isFinite(Number(res.remainingQty)) ? Number(res.remainingQty) : null;
        const statusUpper = orderStatus ? orderStatus.toUpperCase() : '';
        const filledByStatus =
          statusUpper.includes('FILL') || statusUpper.includes('EXECUT') || statusUpper.includes('DONE') || statusUpper.includes('COMPLETE');
        const isFilled = (filledQty != null && filledQty > 0) || filledByStatus;
        const mirrorExecutions = buildMirrorExecutions(results as any, primaryResult?.accountKey || null);

        try {
          const normalizedQty =
           typeof (res as any)?.qty === 'number' && Number.isFinite(Number((res as any).qty))
              ? Number((res as any).qty)
              : qty;
           if (ledgerId && ledger?.update) {
            const patch: any = {
              status: 'ACCEPTED',
              brokerOrderId: orderId,
              brokerAcceptedAtMs: Date.now(),
              qtyNormalized: normalizedQty ?? null,
              clientTag: strategyId,
              brokerOrderStatus: orderStatus,
              orderFilledQty: filledQty,
              orderRemainingQty: remainingQty,
              brokerResolvedSymbol: resolvedSymbol,
              brokerResponse: res?.response ?? null,
              mirrorExecutions
            };
            if (positionId) {
              patch.positionId = positionId;
              if (isFilled) {
                patch.status = 'OPEN';
                patch.positionStatus = 'OPEN';
                patch.positionOpenedAtMs = Date.now();
              }
            }
            await ledger.update({ id: ledgerId, patch });
           }
         } catch { /* ignore */ }

        playSound('success');
        const idHint = orderId ? ` (#${orderId})` : '';
        const statusHint = orderStatus ? `  (${orderStatus})` : '';
        const labelSymbol = resolvedSymbol || symbol || (args?.symbol || 'Order');
        const kindHint = isFilled
          ? 'filled'
          : orderType === 'limit'
            ? 'limit order placed (pending)'
            : orderType === 'stop'
              ? 'stop order placed (pending)'
              : 'accepted (pending)';
        addNotification(isFilled ? 'TradeLocker Filled' : 'TradeLocker Accepted', `${side} ${labelSymbol} ${kindHint}${idHint}${statusHint}`, 'success');
        if (mirrorExecutions.length > 0 && mirrorExecutions.some((m) => m.ok === false)) {
          addNotification('TradeLocker Mirror', 'Some mirror executions failed. Check Audit for details.', 'warning');
        }
        return res;
      } else {
        const err = res?.error ? String(res.error) : 'Unknown error';
        const orderId = extractBrokerOrderId(res);
        const orderStatus = res?.orderStatus != null ? String(res.orderStatus) : null;
        const filledQty = res?.filledQty != null && Number.isFinite(Number(res.filledQty)) ? Number(res.filledQty) : null;
        const remainingQty = res?.remainingQty != null && Number.isFinite(Number(res.remainingQty)) ? Number(res.remainingQty) : null;
        const statusUpper = orderStatus ? orderStatus.toUpperCase() : '';
        const cancelled =
          statusUpper.includes('CANCEL') ||
          statusUpper.includes('CANCELED') ||
          statusUpper.includes('CANCELLED') ||
          statusUpper.includes('EXPIRE') ||
          statusUpper.includes('EXPIRED') ||
          statusUpper.includes('CLOSE') ||
          statusUpper.includes('CLOSED');
        const mirrorExecutions = buildMirrorExecutions(results as any, primaryResult?.accountKey || null);
        try {
          if (ledgerId && ledger?.update) await ledger.update({
            id: ledgerId,
            patch: {
              status: cancelled ? 'CANCELLED' : 'REJECTED',
              brokerOrderId: orderId,
              brokerOrderStatus: orderStatus,
              orderFilledQty: filledQty,
              orderRemainingQty: remainingQty,
              error: err,
              brokerResponse: res?.response ?? null,
              mirrorExecutions
            }
          });
        } catch { /* ignore */ }
        addNotification('TradeLocker Rejected', err, 'error');
        return res;
      }
  }, [
    addNotification,
    ensureTradeLockerAccount,
    fetchTradeLockerQuotesForAccount,
    getNormalizationOffsetForAccount,
    getTradeLockerAccountKey,
    resolveNormalizationReferenceKey,
    resolveSnapshotSourceKey,
    resolveTradeLockerExecutionTargets,
    resolveTradeLockerSymbolBestEffort,
    requestBrokerWithAudit,
    tlSavedConfig,
    withTradeLockerAccountLock
  ]);
  handleTradeLockerPlaceOrderRef.current = handleTradeLockerPlaceOrder;


  // --- System Initialization & Background Monitor ---
  useEffect(() => {
    const timer = deferMs(() => {
      const runtimeVersion = String((window as any)?.glass?.app?.version || '').trim() || 'dev';
      addNotification("System Initialized", buildSystemInitializedMessage(runtimeVersion), "success");
    }, 1000);
    return () => cancelTimer(timer);
  }, [addNotification]);

  const tlStatusRef = React.useRef<string | null>(null);
  const tlErrorRef = React.useRef<string | null>(null);
  const tlErrorNotifiedAtRef = React.useRef<number>(0);
  const tlOrderSnapshotRef = React.useRef<{ initialized: boolean; byId: Record<string, any> }>({ initialized: false, byId: {} });
  const tlPositionSnapshotRef = React.useRef<{ initialized: boolean; byId: Record<string, any> }>({ initialized: false, byId: {} });

  useEffect(() => {
    const prev = tlStatusRef.current;
    tlStatusRef.current = tlStatus;
    if (prev == null || prev === tlStatus) return;

    const envLabel = tlSavedConfig?.env ? tlSavedConfig.env.toUpperCase() : null;
    const serverLabel = tlSavedConfig?.server ? String(tlSavedConfig.server).trim() : null;
    const accountLabel = tlSavedConfig?.accNum != null ? `#${tlSavedConfig.accNum}` : null;
    const parts = [envLabel, serverLabel].filter(Boolean).join('-');
    const target = parts ? `${parts}${accountLabel ? ` ${accountLabel}` : ''}` : accountLabel || 'TradeLocker';

    if (tlStatus === 'connected') {
      addNotification('TradeLocker Connected', `Connected to ${target}.`, 'success');
    } else if (tlStatus === 'disconnected') {
      addNotification('TradeLocker Disconnected', 'Connection closed.', 'warning');
    } else if (tlStatus === 'error') {
      const msg = tlLastError ? String(tlLastError) : 'Unknown connection error.';
      addNotification('TradeLocker Error', msg, 'error');
    }
  }, [addNotification, tlLastError, tlSavedConfig, tlStatus]);

  useEffect(() => {
    const raw =
      (tlLastError && String(tlLastError).trim()) ||
      (tlOrdersError && String(tlOrdersError).trim()) ||
      (tlAccountMetricsError && String(tlAccountMetricsError).trim()) ||
      '';
    if (!raw) return;

    const now = Date.now();
    if (tlErrorRef.current === raw && now - tlErrorNotifiedAtRef.current < 60_000) return;

    tlErrorRef.current = raw;
    tlErrorNotifiedAtRef.current = now;

    const isRateLimited = /rate limit|too many requests|429/i.test(raw);
    if (isRateLimited) {
      brokerRateLimitLastAtRef.current = now;
      brokerRateLimitLastMessageRef.current = raw;
      recordPerf('brokerRateLimits');
      void appendAuditEvent({
        eventType: 'broker_rate_limit',
        level: 'warn',
        payload: {
          message: raw,
          source: 'tradelocker',
          detectedAtMs: now
        }
      });
    }
    addNotification(isRateLimited ? 'TradeLocker Rate Limited' : 'TradeLocker Error', raw, isRateLimited ? 'warning' : 'error');
  }, [addNotification, appendAuditEvent, recordPerf, tlAccountMetricsError, tlLastError, tlOrdersError]);

  useEffect(() => {
    if (tlStatus !== 'connected') {
      tlOrderSnapshotRef.current = { initialized: false, byId: {} };
      tlPositionSnapshotRef.current = { initialized: false, byId: {} };
      return;
    }

    const orders = Array.isArray(tlOrders) ? tlOrders : [];
    const positions = Array.isArray(tlPositions) ? tlPositions : [];

    const fmtQty = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const decimals = num >= 1 ? 2 : 4;
      return num.toFixed(decimals).replace(/\.?0+$/, '');
    };

    const fmtPnl = (value: any) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const sign = num >= 0 ? '+' : '-';
      return `${sign}${Math.abs(num).toFixed(2)}`;
    };

    const normalizeStatus = (value: any) => String(value || '').trim().toUpperCase();
    const isFilledStatus = (value: string) => {
      const s = normalizeStatus(value);
      return s.includes('FILL') || s.includes('EXECUT') || s.includes('DONE') || s.includes('COMPLETE');
    };
    const isCancelledStatus = (value: string) => {
      const s = normalizeStatus(value);
      return s.includes('CANCEL') || s.includes('CANCELED') || s.includes('CANCELLED') || s.includes('EXPIRE') || s.includes('EXPIRED');
    };
    const isRejectedStatus = (value: string) => normalizeStatus(value).includes('REJECT');

    const orderSnap = tlOrderSnapshotRef.current;
    const nextOrdersById: Record<string, any> = {};
    for (const ord of orders) {
      if (!ord?.id) continue;
      const id = String(ord.id);
      nextOrdersById[id] = {
        id,
        symbol: String(ord.symbol || 'UNKNOWN'),
        side: String(ord.side || '').toUpperCase(),
        status: normalizeStatus(ord.status),
        qty: ord.qty,
        filledQty: ord.filledQty ?? null,
        remainingQty: ord.remainingQty ?? null
      };
    }

    if (!orderSnap.initialized) {
      tlOrderSnapshotRef.current = { initialized: true, byId: nextOrdersById };
    } else {
      const prevById = orderSnap.byId || {};
      for (const id of Object.keys(nextOrdersById)) {
        const next = nextOrdersById[id];
        const prev = prevById[id];
        if (!prev) {
          const qtyLabel = fmtQty(next.qty);
          const statusLabel = next.status ? ` (${next.status})` : '';
          addNotification('Order Seen', `${next.side} ${next.symbol}${qtyLabel ? ` ${qtyLabel}` : ''}${statusLabel}`, 'info');
          continue;
        }

        const statusChanged = prev.status !== next.status;
        const fillChanged = Number(prev.filledQty) !== Number(next.filledQty);
        if (statusChanged) {
          if (isFilledStatus(next.status)) {
            addNotification('Order Filled', `${next.side} ${next.symbol}`, 'success');
          } else if (isCancelledStatus(next.status)) {
            addNotification('Order Cancelled', `${next.side} ${next.symbol}`, 'warning');
          } else if (isRejectedStatus(next.status)) {
            addNotification('Order Rejected', `${next.side} ${next.symbol}`, 'error');
          }
          continue;
        }

        if (fillChanged && !isFilledStatus(next.status) && Number(prev.filledQty) === 0 && Number(next.filledQty) > 0) {
          const qtyLabel = fmtQty(next.filledQty);
          addNotification('Order Partially Filled', `${next.side} ${next.symbol}${qtyLabel ? ` ${qtyLabel}` : ''}`, 'info');
        }
      }

      tlOrderSnapshotRef.current = { initialized: true, byId: nextOrdersById };
    }

    const posSnap = tlPositionSnapshotRef.current;
    const nextPositionsById: Record<string, any> = {};
    for (const pos of positions) {
      if (!pos?.id) continue;
      const id = String(pos.id);
      nextPositionsById[id] = {
        id,
        symbol: String(pos.symbol || 'UNKNOWN'),
        side: String(pos.type || '').toUpperCase(),
        size: pos.size,
        pnl: pos.pnl
      };
    }

    if (!posSnap.initialized) {
      tlPositionSnapshotRef.current = { initialized: true, byId: nextPositionsById };
    } else {
      const prevById = posSnap.byId || {};
      for (const id of Object.keys(nextPositionsById)) {
        const next = nextPositionsById[id];
        const prev = prevById[id];
        if (!prev) {
          const qtyLabel = fmtQty(next.size);
          addNotification('Position Opened', `${next.side} ${next.symbol}${qtyLabel ? ` ${qtyLabel}` : ''}`, 'success');
          continue;
        }

        const sizeChanged = Number(prev.size) !== Number(next.size);
        if (sizeChanged) {
          const qtyLabel = fmtQty(next.size);
          addNotification('Position Updated', `${next.side} ${next.symbol}${qtyLabel ? ` ${qtyLabel}` : ''}`, 'info');
        }
      }

      for (const id of Object.keys(prevById)) {
        if (nextPositionsById[id]) continue;
        const prev = prevById[id];
        const pnlLabel = fmtPnl(prev?.pnl);
        addNotification('Position Closed', `${prev.side} ${prev.symbol}${pnlLabel ? ` ${pnlLabel}` : ''}`, 'success');
      }

      tlPositionSnapshotRef.current = { initialized: true, byId: nextPositionsById };
    }
  }, [addNotification, tlOrders, tlPositions, tlStatus]);

  const watchedUrls = React.useMemo(() => {
    return tabs.filter((t) => t.isWatched).map((t) => t.url);
  }, [tabs]);
  const sendBacktestMessage = useCallback((text: string) => {
    const payload = String(text || '').trim();
    if (!payload) return false;
    if (!activeTab) return false;
    sendMessage(
      payload,
      { url: activeTab.url, title: activeTab.title },
      watchedUrls
    );
    return true;
  }, [activeTab, sendMessage, watchedUrls]);
  const watchedCaptureCursorRef = React.useRef<number>(0);
  const chartWatchCaptureCursorRef = React.useRef<number>(0);
  const chartWatchInFlightRef = React.useRef(false);
  const chartWatchLastFrameHashByUrlRef = React.useRef<Record<string, string>>({});
  const chartWatchBackoffUntilMsRef = React.useRef<number>(0);
  const chartWatchRateLimitNotifiedAtMsRef = React.useRef<number>(0);

  // Keep any Chart Session tabs mounted so `captureTab(tabId)` works even when they're not active.
  useEffect(() => {
    if (!keepWatchedTabsMounted) return;
    const required = new Set<string>();
    for (const session of chartSessions.sessions) {
      if (!session.watchEnabled) continue;
      for (const tabId of Object.values(session.views || {})) {
        if (tabId) required.add(tabId);
      }
    }

    if (required.size === 0) return;

    for (const tabId of required) {
      const tab = tabs.find((t) => t.id === tabId);
      if (!tab) continue;
      if (!tab.isWatched || tab.watchSource !== 'auto') {
        updateTab(tabId, { isWatched: true, watchSource: 'auto' });
      }
    }
  }, [chartSessions.sessions, keepWatchedTabsMounted, tabs, updateTab]);

  // --- Unified Capture Scheduler (Live Vision + Chart Watch) ---
  useEffect(() => {
    const liveEnabled = isLive && liveMode !== 'audio' && !isSettingsOpen;
    const chartEnabled = chartWatchEnabled && !isSettingsOpen && isOpen && mode === 'chat';
    if (!liveEnabled && !chartEnabled) return;

    const readInterval = (key: string, fallback: number, min: number, max: number) => {
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? Number(raw) : NaN;
        if (Number.isFinite(parsed)) return Math.min(max, Math.max(min, Math.floor(parsed)));
      } catch { /* ignore */ }
      return fallback;
    };

    const monitoredUrlsNow = () => (tabsRef.current || []).filter((t) => !!t.isWatched).map((t) => t.url);

    const runLiveActive = async () => {
      const capture = browserControlsRef.current?.captureTab;
      if (!capture) return;
      const activeId = activeTabIdRef.current;
      const activeNow = activeTabRef.current;
      if (!activeId || !activeNow) return;

      const frame = await captureTabCached(activeId, { format: 'jpeg', quality: 60, width: 1280 }, 1200);
      if (!frame?.data) return;

      const tvLine = getTradingViewLine(activeNow.url, activeNow.title);
      const label = `ACTIVE TAB SNAPSHOT\nTitle: ${activeNow.title}\nURL: ${activeNow.url}${tvLine ? `\n${tvLine}` : ''}`;
      sendVideoFrame(frame.data, frame.mimeType, label, 'tab:active');
    };

    const runLiveWatched = async () => {
      const capture = browserControlsRef.current?.captureTab;
      if (!capture) return;
      const tabsNow = tabsRef.current || [];
      const activeId = activeTabIdRef.current;
      const watched = tabsNow.filter((t) => t.isWatched && t.id !== activeId);
      if (watched.length === 0) return;

      const index = watchedCaptureCursorRef.current % watched.length;
      watchedCaptureCursorRef.current += 1;
      const tab = watched[index];
      if (!tab) return;

      const frame = await captureTabCached(tab.id, { format: 'jpeg', quality: 55, width: 1024 }, 1500);
      if (!frame?.data) return;

      const tvLine = getTradingViewLine(tab.url, tab.title);
      const label = `WATCHED TAB SNAPSHOT\nTitle: ${tab.title}\nURL: ${tab.url}${tvLine ? `\n${tvLine}` : ''}`;
      sendVideoFrame(frame.data, frame.mimeType, label, `tab:watch:${tab.id}`);
    };

    const runChartWatch = async () => {
      if (chartWatchInFlightRef.current) return;
      if (chartWatchSnoozedUntilMs && Date.now() < chartWatchSnoozedUntilMs) return;

      const capture = browserControlsRef.current?.captureTab;
      if (!capture) return;
      const transform = readChatTabContextTransform();

      const tabsNow = tabsRef.current || [];
      const tabsById = new Map(tabsNow.map((t) => [t.id, t]));
      const sessions = chartSessionsRef.current || [];
      const sessionCandidates = sessions
        .filter((s: any) => !!s && s.watchEnabled !== false)
        .filter((s: any) => Object.values(s.views || {}).some(Boolean));

      const monitoredUrls = monitoredUrlsNow();

      const handleRateLimit = (untilMs: number) => {
        const until = Number(untilMs) || 0;
        if (!until) return;
        chartWatchBackoffUntilMsRef.current = Math.max(chartWatchBackoffUntilMsRef.current, until);

        const now = Date.now();
        const last = Number(chartWatchRateLimitNotifiedAtMsRef.current) || 0;
        if (now - last < 30_000) return;
        chartWatchRateLimitNotifiedAtMsRef.current = now;

        const sec = Math.max(1, Math.round((until - now) / 1000));
        addNotification('Chart Watch Rate Limited', `Backing off for ${sec}s to avoid HTTP 429.`, 'warning');
      };

      if (sessionCandidates.length > 0) {
        const index = chartWatchCaptureCursorRef.current % sessionCandidates.length;
        chartWatchCaptureCursorRef.current += 1;
        const session: any = sessionCandidates[index];
        if (!session) return;

        const key = `chartsession:${session.id}`;
        const timeframeOrder = ['4h', '1h', '15m'] as const;
        const labelForTf = (tf: string) => (tf === '4h' ? 'H4' : tf === '1h' ? 'H1' : '15m');

        const frames: Array<{ label: string; timeframe: string; url: string; title: string; imageDataUrl: string }> = [];
        const hashParts: string[] = [];

        for (const tf of timeframeOrder) {
          const tabId = (session.views as any)?.[tf] as string | null | undefined;
          if (!tabId) continue;
          const tab = tabsById.get(tabId);
          if (!tab) continue;
          if (!isTradingViewUrl(tab.url)) continue;

          const width = tf === '15m' ? 1280 : 1024;
          const frame = await captureTabCached(tab.id, { format: 'jpeg', quality: 60, width }, 2500);
          if (!frame?.data) continue;

          const rawDataUrl = `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
          const dataUrl = await applyVisionTransform(rawDataUrl, transform);
          const base64 = dataUrl.split(',')[1] || '';
          if (!base64) continue;

          const aiLabel = tab.aiLabel ? String(tab.aiLabel).trim() : '';
          const tfLabel = aiLabel || labelForTf(tf);
          frames.push({
            label: tfLabel,
            timeframe: tf,
            url: tab.url,
            title: tab.title,
            imageDataUrl: dataUrl
          });
          hashParts.push(`${tf}:${hashStringSampled(base64)}`);
        }

        if (frames.length === 0) return;

        const prevHash = chartWatchLastFrameHashByUrlRef.current[key];
        const nextHash = hashStringSampled(hashParts.join('|'), 4096);
        if (prevHash && prevHash === nextHash) return;
        chartWatchLastFrameHashByUrlRef.current[key] = nextHash;

        chartWatchInFlightRef.current = true;
        try {
          const res = await runChartWatchUpdate({
            url: key,
            title: `Chart Session: ${session.symbol}`,
            frames: frames,
            monitoredUrls: monitoredUrls,
            mode: chartWatchMode
          });
          if ((res as any)?.rateLimitedUntilMs) {
            handleRateLimit((res as any).rateLimitedUntilMs);
          } else {
            chartWatchBackoffUntilMsRef.current = 0;
          }
        } finally {
          chartWatchInFlightRef.current = false;
        }
        return;
      }

      // Only run Chart Watch on tabs the user explicitly marked as "Watched" (watchSource=manual) to prevent unsolicited spam.
      // Group watched tabs by TradingView symbol so agents can reason across multiple timeframes in a single update.
      const candidates = tabsNow.filter((t) => t.isWatched && t.watchSource === 'manual' && isTradingViewUrl(t.url));
      if (candidates.length === 0) return;

      const groupKeyForTab = (tab: (typeof candidates)[number]) => {
        const { symbol } = getTradingViewParams(tab.url);
        const key = symbol ? symbol : tab.url;
        return key || tab.id;
      };

      const groups = new Map<string, (typeof candidates)[number][]>();
      for (const tab of candidates) {
        const key = groupKeyForTab(tab);
        const existing = groups.get(key);
        if (existing) existing.push(tab);
        else groups.set(key, [tab]);
      }

      const packs = Array.from(groups.entries()).map(([key, tabs]) => ({ key, tabs }));
      if (packs.length === 0) return;

      const packIndex = chartWatchCaptureCursorRef.current % packs.length;
      chartWatchCaptureCursorRef.current += 1;
      const pack = packs[packIndex];
      if (!pack) return;

      const intervalRank = (interval: string) => {
        const raw = String(interval || '').trim();
        if (!raw) return 0;
        if (/^\d+$/.test(raw)) return Number(raw) || 0;
        const match = raw.match(/^(\d+)\s*([a-zA-Z]+)$/);
        if (!match) return 0;
        const n = Number(match[1]);
        const unit = String(match[2] || '').trim().toLowerCase();
        if (!Number.isFinite(n) || n <= 0) return 0;
        if (unit === 'h' || unit === 'hr' || unit === 'hrs' || unit === 'hour' || unit === 'hours') return n * 60;
        if (unit === 'd' || unit === 'day' || unit === 'days') return n * 60 * 24;
        if (unit === 'w' || unit === 'wk' || unit === 'wks' || unit === 'week' || unit === 'weeks') return n * 60 * 24 * 7;
        return 0;
      };

      const sortedTabs = [...pack.tabs].sort((a, b) => {
        const ai = intervalRank(getTradingViewParams(a.url).interval);
        const bi = intervalRank(getTradingViewParams(b.url).interval);
        return bi - ai;
      });

      const MAX_FRAMES = 4;
      const selectedTabs = sortedTabs.slice(0, MAX_FRAMES);

      const packUrl = `tabpack:${pack.key}`;
      const packTitle = `Tab Pack: ${pack.key}`;

      chartWatchInFlightRef.current = true;
      try {
        const frames: Array<{ label: string; timeframe: string; url: string; title: string; imageDataUrl: string }> = [];
        const hashParts: string[] = [];

        for (let i = 0; i < selectedTabs.length; i++) {
          const tab = selectedTabs[i];
          if (!tab) continue;

          const width = i === 0 ? 1280 : 1024;
          const frame = await captureTabCached(tab.id, { format: "jpeg", quality: 60, width }, 2500);
          if (!frame?.data) continue;

          const { interval } = getTradingViewParams(tab.url);
          const aiLabel = tab.aiLabel ? String(tab.aiLabel).trim() : "";
          const tfLabel = aiLabel || (interval ? formatTradingViewIntervalLabel(interval) : "");
          const label = tfLabel || `Chart ${i + 1}`;
          const rawDataUrl = `data:${frame.mimeType || "image/jpeg"};base64,${frame.data}`;
          const dataUrl = await applyVisionTransform(rawDataUrl, transform);
          const base64 = dataUrl.split(',')[1] || "";
          if (!base64) continue;
          frames.push({
            label,
            timeframe: tfLabel,
            url: tab.url,
            title: tab.title,
            imageDataUrl: dataUrl
          });
          hashParts.push(hashStringSampled(base64));
        }

        if (frames.length === 0) return;

        const prevHash = chartWatchLastFrameHashByUrlRef.current[packUrl];
        const nextHash = hashStringSampled(hashParts.join('|'), 4096);
        if (prevHash && prevHash === nextHash) return;
        chartWatchLastFrameHashByUrlRef.current[packUrl] = nextHash;

        const res = await runChartWatchUpdate({
          url: packUrl,
          title: packTitle,
          frames,
          monitoredUrls: monitoredUrls,
          mode: chartWatchMode
        });
        if ((res as any)?.rateLimitedUntilMs) {
          handleRateLimit((res as any).rateLimitedUntilMs);
        } else {
          chartWatchBackoffUntilMsRef.current = 0;
        }
      } finally {
        chartWatchInFlightRef.current = false;
      }
    };

    const liveActiveIntervalMs = readInterval('glass_vision_active_interval_ms', 2000, 500, 60000);
    const liveWatchedIntervalMs = readInterval('glass_vision_watched_interval_ms', 7000, 1000, 600000);
    const chartWatchIntervalMs = readInterval("glass_chart_watch_interval_ms", 60_000, 5_000, 600_000);
    let cancelled = false;
    let stop: (() => void) | null = null;
    void loadLiveCaptureControllerModule().then((mod) => {
      if (cancelled) return;
      const controller = mod.createLiveCaptureController({
        runLiveActive,
        runLiveWatched,
        runChartWatch,
        isLiveEnabled: () => liveEnabled,
        isChartEnabled: () => chartEnabled,
        getChartBackoffUntilMs: () => Number(chartWatchBackoffUntilMsRef.current) || 0,
        liveActiveIntervalMs,
        liveWatchedIntervalMs,
        chartWatchIntervalMs,
        schedulerIntervalMs: 250
      });
      controller.start({ scheduler: runtimeScheduler });
      stop = () => controller.stop();
    }).catch(() => {});
    return () => {
      cancelled = true;
      stop?.();
    };
  }, [addNotification, applyVisionTransform, captureTabCached, chartSessionsRef, chartWatchEnabled, chartWatchMode, chartWatchSnoozedUntilMs, isLive, isOpen, isSettingsOpen, liveMode, mode, readChatTabContextTransform, runChartWatchUpdate, sendVideoFrame]);

  return (
    <ErrorBoundary
      onError={({ error, errorInfo }) => {
        appendLiveError({
          source: 'error_boundary',
          message: error?.message || String(error),
          stack: error?.stack || null,
          detail: errorInfo ? { componentStack: errorInfo.componentStack } : null
        });
      }}
    >
      <div
        className={
          isFullscreen
            ? 'flex items-stretch justify-stretch h-screen w-full p-0 relative'
            : 'flex items-center justify-center min-h-screen w-full p-4 sm:p-8 md:p-12 relative'
        }
      >
        
        {/* Global Notification Layer */}
        <ToastContainer notifications={notifications} onDismiss={dismissNotification} />
        <CommandPalette
          isOpen={commandPaletteOpen}
          query={commandPaletteQuery}
          onQueryChange={setCommandPaletteQuery}
          actions={commandActions}
          onClose={closeCommandPalette}
        />

        <WindowFrame variant={isFullscreen ? 'full' : 'framed'}>
          {/* Header / Chrome */}
          <BrowserChrome 
            currentTab={activeTab}
            tabs={tabs}
            onNavigate={navigate}
            onRefresh={handleRefresh}
            onBack={handleBack}
            onForward={handleForward}
            toggleChat={toggleSidebar}
            isChatOpen={isOpen}
            onToggleWatch={toggleTabWatch}
            onSwitchTab={setActiveTabId}
            onAddTab={addTab}
            onCloseTab={closeTab}
            onTogglePin={toggleTabPin}
            onSetLabel={setTabLabel}
            onOpenSettings={openSettings}
            isFullscreen={isFullscreen}
            onToggleFullscreen={toggleFullscreen}
          />

          {/* Main Content Area */}
          <div className="flex-1 relative flex overflow-hidden">
            
            {/* The Main Browser View */}
            {isTradingViewUrl(activeTab?.url || '') && (
              <div className="absolute top-3 left-3 z-20 pointer-events-none">
                <div className="bg-black/70 backdrop-blur-md border border-white/10 rounded-lg px-3 py-2 text-[10px] font-mono text-gray-200 shadow-lg">
                  <div className="text-gray-400 uppercase tracking-wider">
                    TL Quote{brokerBadgeSymbol ? ` (${brokerBadgeSymbol})` : ''}
                  </div>
                  <div className="mt-1">
                    {brokerBadgeBid != null || brokerBadgeAsk != null ? (
                      <>
                        bid {formatBrokerPrice(brokerBadgeBid)} / ask {formatBrokerPrice(brokerBadgeAsk)}
                      </>
                    ) : (
                      <>bid -- / ask --</>
                    )}
                    {brokerBadgeSpread != null ? ` | sp ${formatBrokerPrice(brokerBadgeSpread)}` : ''}
                    {brokerBadgeAgeLabel ? ` | ${brokerBadgeAgeLabel}` : ''}
                  </div>
                  {tvPriceLine ? (
                    <div className="mt-1 text-gray-500">{tvPriceLine}</div>
                  ) : null}
                  {tvSymbolLine ? (
                    <div className="mt-1 text-gray-500">{tvSymbolLine}</div>
                  ) : null}
                </div>
              </div>
            )}
            <BrowserView 
              tabs={tabs}
              activeTabId={activeTabId}
              onTabUpdate={updateTab}
              onControlsReady={handleControlsReady}
              isOverlayActive={isSettingsOpen || isChartFullscreen}
              keepWatchedTabsMounted={keepWatchedTabsMounted}
            />

            {/* Modular Sidebar Frame */}
            <SidebarFrame 
                isVisible={isOpen} 
                onClose={closeSidebar}
                activeMode={mode}
                onSwitchMode={handleSwitchSidebarMode}
                onPrefetchMode={prefetchSidebarMode}
            >
                <React.Suspense fallback={SIDEBAR_LAZY_FALLBACK}>
                {/* Conditionally render the selected feature */}
                        {mode === 'chat' && (
                    <ChatInterface 
                        channel="chat"
                        messages={messages}
                        onSendMessage={(text, img) => sendMessage(
                          text,
                          {
                            url: activeTab.url,
                            title: activeTab.title,
                            captureScreenshot: async () => {
                              const frame = await captureTabCached(activeTabId, { format: 'jpeg', quality: 60, width: 1280 }, 1200);
                              if (!frame?.data) return null;
                              return `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
                            },
                            captureScreenshots: captureChatTabContextImages
                          },
                          watchedUrls,
                          img
                        )}
                        captureActiveTabScreenshot={async () => {
                          const frame = await captureTabCached(activeTabId, { format: 'jpeg', quality: 80, width: 1280 }, 1200);
                          if (!frame?.data) return null;
                          return `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
                        }}
                        captureContextScreenshots={captureChatTabContextImages}
                         onClearChat={clearChat}
                         isThinking={isThinking}
                         isTeamMode={replyMode === 'team'}
                         onToggleTeamMode={() => setReplyMode(prev => prev === 'team' ? 'single' : 'team')}
                         agents={agents}
                         activeAgentId={activeAgentId}
                         onAddAgent={addAgent}
                         onSwitchAgent={switchAgent}
                         onUpdateAgent={updateAgent}
                         onDeleteAgent={deleteAgent}
                         actionQueueDepth={actionTaskQueueDepth}
                         actionTaskActiveConfig={actionTaskActiveStepRef.current}
                         playbooks={taskPlaybooks}
                         activePlaybookRun={taskPlaybookActiveRunRef.current}
                         recentPlaybookRuns={taskPlaybookRunsRef.current}
                         taskTreeResumeEntries={taskTreeResumeEntries}
                         onResumeTaskTreeRun={(input) => {
                           void resumeTaskTreeRun(input);
                         }}
                         taskTreeRuns={taskTreeRunsState}
                         actionTaskTreeRuns={actionTaskTreeRunsState}
                         onReplayTaskTree={handleReplayTaskTree}
                         recommendedFlows={recommendedActionFlowsState}
                         onRunActionFlow={runRecommendedActionFlow}
                         onRunActionCatalog={runActionCatalog}
                         onResumePlaybookRun={(runId, opts) => {
                           void resumePlaybookRun(runId, opts);
                         }}
                         autoTabVisionEnabled={autoTabVisionEnabled}
                         onToggleAutoTabVision={() => setAutoTabVisionEnabled(prev => !prev)}
                         chartWatchEnabled={chartWatchEnabled}
                         onToggleChartWatch={() => setChartWatchEnabled(prev => !prev)}
                         chartWatchMode={chartWatchMode}
                         onSetChartWatchMode={setChartWatchMode}
                         chartWatchSnoozedUntilMs={chartWatchSnoozedUntilMs}
                         onSnoozeChartWatch={snoozeChartWatch}
                         onClearChartWatchSnooze={clearChartWatchSnooze}
                         chartWatchLeadAgentId={chartWatchLeadAgentId}
                         onSetChartWatchLeadAgentId={setChartWatchLeadAgentId}
                         chartSessions={chartSessions.sessions}
                         activeTabId={activeTabId}
                         getTabTitle={(tabId) => {
                           const tab = tabs.find((t) => t.id === tabId);
                           return tab?.title || tab?.url || tabId;
                         }}
                         onCreateChartSessionFromActiveTab={() => {
                           if (!activeTab) return;
                           const sessionId = chartSessions.createSessionFromTab(activeTab);
                           if (!sessionId) return;
                           chartSessions.assignTabToTimeframe(sessionId, '15m', activeTabId);
                           updateTab(activeTabId, { isWatched: true, watchSource: 'manual' });
                         }}
                         onAssignActiveTabToChartSession={(sessionId, timeframe) => {
                           if (!activeTabId) return;
                           chartSessions.assignTabToTimeframe(sessionId, timeframe, activeTabId);
                           updateTab(activeTabId, { isWatched: true, watchSource: 'manual' });
                         }}
                         onClearChartSessionTimeframe={(sessionId, timeframe) => {
                           chartSessions.clearTimeframe(sessionId, timeframe);
                         }}
                         onToggleChartSessionWatch={(sessionId) => {
                           const session = chartSessions.byId.get(sessionId);
                           if (!session) return;
                           chartSessions.setSessionWatchEnabled(sessionId, !session.watchEnabled);
                         }}
                         onRemoveChartSession={(sessionId) => {
                           chartSessions.removeSession(sessionId);
                         }}
                         // Live Props
                         isLive={isLive}
                         liveMode={liveMode}
                         liveStream={liveStream}
                        startLiveSession={startLiveSession}
                        stopLiveSession={stopLiveSession}
                        sendVideoFrame={sendVideoFrame}
                        // TTS Props
                        speakMessage={speakMessage}
                        speakingMessageId={speakingMessageId}
                        // Session Props
                         sessionBias={sessionBias}
                         onUpdateSessionBias={setSessionBias}
                         // Execution Props
                         onExecuteTrade={(messageId, proposal) => executeTradeProposal(messageId, proposal, 'manual')}
                         onRejectTrade={(messageId) => rejectTradeProposal(messageId, 'Rejected by user')}
                         onExecuteBrokerAction={(messageId, action) => executeBrokerAction(messageId, action)}
                         onRejectBrokerAction={(messageId) => rejectBrokerAction(messageId, 'Rejected by user')}
                         onCancelAgentTool={(messageId) => cancelAgentTool(messageId)}
                         contextPackText={getContextPack()}
                         onCaptureContextPack={captureContextPack}
                         symbolScope={symbolScope}
                         onUpdateSymbolScope={updateSymbolScope}
                         onClearSymbolScope={clearSymbolScope}
                         onSearchSymbols={searchSymbolSuggestions}
                         crossPanelContext={crossPanelContext}
                     />
                 )}
                {mode === 'signal' && (
                    <SignalInterface
                      symbols={signalSymbols}
                      onAddSymbol={handleSignalAddSymbol}
                      onRemoveSymbol={handleSignalRemoveSymbol}
                      onSearchSymbols={searchSymbolSuggestions}
                      timeframes={signalTimeframes}
                      onTimeframesChange={handleSignalTimeframesChange}
                      sessions={signalSessions}
                      onSessionsChange={(next) => updateSignalSettings({ sessions: next })}
                      strategyModes={signalStrategyModes}
                      onStrategyModesChange={(next) => updateSignalSettings({ strategyModes: next })}
                      autoRefreshEnabled={signalAutoRefreshEnabled}
                      onAutoRefreshChange={(next) => updateSignalSettings({ autoRefreshEnabled: next })}
                      refreshIntervalMs={signalRefreshIntervalMs}
                      onRefreshIntervalChange={(next) => updateSignalSettings({ refreshIntervalMs: next })}
                      probabilityThreshold={signalProbabilityThreshold}
                      onProbabilityThresholdChange={(next) => updateSignalSettings({ probabilityThreshold: next })}
                      probabilityMax={signalProbabilityMax}
                      onProbabilityMaxChange={(next) => updateSignalSettings({ probabilityMax: next })}
                      expiryMinutes={signalExpiryMinutes}
                      onExpiryMinutesChange={(next) => updateSignalSettings({ expiryMinutes: next })}
                      autoExecuteEnabled={signalAutoExecuteEnabled}
                      onAutoExecuteChange={(next) => updateSignalSettings({ autoExecuteEnabled: next })}
                      executionTarget={signalExecutionTarget}
                      onExecutionTargetChange={(next) => updateSignalSettings({ executionTarget: next })}
                      memoryMode={signalMemoryMode}
                      onMemoryModeChange={(next) => updateSignalSettings({ memoryMode: next })}
                      memoryLimit={signalMemoryLimit}
                      onMemoryLimitChange={(next) => updateSignalSettings({ memoryLimit: next })}
                      patternContextEnabled={signalIncludePatterns}
                      onPatternContextChange={(next) => updateSignalSettings({ includePatterns: next })}
                      autoPilotEnabled={!!autoPilotConfig?.enabled}
                      autoPilotKill={!!autoPilotConfig?.killSwitch}
                      autoPilotMode={autoPilotConfig?.mode || null}
                      isRunning={signalRunning}
                      lastRunAtMs={signalLastRunAtMs}
                      lastAttemptAtMs={signalLastAttemptAtMs}
                      lastError={signalLastError}
                      lastParseError={signalLastParseError}
                      lastParseAtMs={signalLastParseAtMs}
                      snapshotStatus={signalSnapshotStatus}
                      healthSnapshot={healthSnapshot}
                      signals={signalEntries}
                      simulatedOutcomes={signalSimulatedOutcomes}
                      onRunScan={() => runSignalScan('manual')}
                      onExecuteSignal={(id) => executeSignalTrade(id, 'manual')}
                      onRejectSignal={(id) => rejectSignalEntry(id)}
                      onCancelSignalOrder={(id) => cancelSignalOrder(id)}
                      onOpenAcademyCase={(id) => openAcademyCase(id)}
                      onFocusSignal={handleSignalFocus}
                      onOpenChart={(symbol, timeframe) => openSymbolPanel('nativechart', symbol, timeframe)}
                      onOpenMt5={(symbol, timeframe) => openSymbolPanel('mt5', symbol, timeframe)}
                      onOpenTradeLocker={(symbol, timeframe) => openSymbolPanel('tradelocker', symbol, timeframe)}
                      onPrefillMt5Ticket={(entry) => {
                        void prefillSignalTicket(entry, 'mt5');
                      }}
                      onPrefillTradeLockerTicket={(entry) => {
                        void prefillSignalTicket(entry, 'tradelocker');
                      }}
                      onClearSignals={clearSignalEntries}
                      crossPanelContext={crossPanelContext}
                    />
                )}
                {mode === 'snapshot' && (
                    <SnapshotInterface
                      symbol={snapshotPanelSymbol || symbolScopeSymbol || signalPrimarySymbol || activeBrokerSymbol || activeTvParams?.symbol || ''}
                      candidateSymbols={snapshotPanelCandidates}
                      onSelectSymbol={handleSnapshotPanelSelectSymbol}
                      onSearchSymbols={searchSymbolSuggestions}
                      timeframes={snapshotPanelTimeframes}
                      status={snapshotPanelStatus}
                      onWarmup={() => {
                        void warmupSnapshotPanel();
                      }}
                      onRefresh={() => {
                        void refreshSnapshotPanelStatus();
                      }}
                      applyToSignals={snapshotPanelApplyToSignals}
                      onApplyToSignalsChange={setSnapshotPanelApplyToSignals}
                      brokerConnected={tlStatus === 'connected'}
                      upstreamBlockedUntilMs={tlUpstreamBlockedUntilMs ?? null}
                    />
                )}
                {mode === 'patterns' && (
                    <PatternsInterface
                      symbols={patternSymbols}
                      symbolMode={patternSymbolMode}
                      onSymbolModeChange={(next) => updatePatternSettings({ symbolMode: next })}
                      onAddSymbol={handlePatternAddSymbol}
                      onRemoveSymbol={handlePatternRemoveSymbol}
                      onSearchSymbols={searchSymbolSuggestions}
                      timeframes={patternWatchTimeframes}
                      onTimeframesChange={handlePatternTimeframesChange}
                      detectors={patternDetectorsResolved}
                      onDetectorsChange={handlePatternDetectorsChange}
                      autoRefreshEnabled={patternAutoRefreshEnabled}
                      onAutoRefreshChange={(next) => updatePatternSettings({ autoRefreshEnabled: next })}
                      refreshIntervalMs={patternRefreshIntervalMs}
                      onRefreshIntervalChange={(next) => updatePatternSettings({ refreshIntervalMs: next })}
                      refreshMode={patternRefreshMode}
                      onRefreshModeChange={(next) => updatePatternSettings({ refreshMode: next })}
                      events={patternEvents}
                      effectiveSymbols={patternWatchSymbols}
                      watchCount={patternWatchSummary.watchCount}
                      watchLimit={PATTERN_WATCH_LIMIT}
                      watchTruncated={patternWatchSummary.truncated}
                      onRefreshNow={() => {
                        const fetches = Math.max(1, Math.min(6, patternWatchSummary.watchCount || 1));
                        requestChartRefresh(fetches);
                      }}
                      onFocusChart={(symbol, timeframe) => openSymbolPanel('nativechart', symbol, timeframe)}
                    />
                )}
                {mode === 'shadow' && (
                    <div className="flex h-full w-full flex-col bg-[#0a0a0a]">
                      <div className="flex items-center justify-between px-4 py-2 border-b border-white/10 bg-white/5">
                        <div className="text-[11px] uppercase tracking-wider text-gray-400">Automation Control</div>
                        <div className="flex items-center gap-1 rounded-lg border border-white/10 bg-black/30 p-1">
                          <button
                            type="button"
                            onClick={() => setShadowPanelTabSafe('shadow')}
                            className={`px-3 py-1.5 rounded-md text-xs font-semibold transition-colors ${
                              shadowPanelTab === 'shadow'
                                ? 'bg-slate-600 text-white shadow-sm'
                                : 'text-gray-400 hover:text-white hover:bg-white/5'
                            }`}
                          >
                            Shadow
                          </button>
                          <button
                            type="button"
                            onClick={() => setShadowPanelTabSafe('auto')}
                            className={`px-3 py-1.5 rounded-md text-xs font-semibold transition-colors ${
                              shadowPanelTab === 'auto'
                                ? 'bg-red-600 text-white shadow-sm'
                                : 'text-gray-400 hover:text-white hover:bg-white/5'
                            }`}
                          >
                            Auto
                          </button>
                        </div>
                      </div>
                      <div className="flex-1 overflow-hidden">
                        {shadowPanelTab === 'shadow' ? (
                          <ShadowInterface
                            agents={agents}
                            profiles={shadowProfiles}
                            accounts={shadowAccounts}
                            trades={shadowTradeViews}
                            followEnabled={signalShadowFollowEnabled}
                            onToggleFollow={(next) => updateSignalSettings({ shadowFollowEnabled: next })}
                            onUpdateProfile={updateShadowProfile}
                            onRefresh={() => {
                              void refreshShadowTrades({ force: true, includeCompare: true });
                            }}
                          />
                        ) : (
                          <AutoPilotInterface
                            config={autoPilotConfig}
                            onUpdateConfig={setAutoPilotConfig}
                            equity={equity}
                            memories={memories}
                            agents={agents}
                            activePlaybookRun={taskPlaybookActiveRunRef.current}
                            recentPlaybookRuns={taskPlaybookRunsRef.current}
                            taskTreeResumeEntries={taskTreeResumeEntries}
                            onResumeTaskTreeRun={(input) => {
                              void resumeTaskTreeRun(input);
                            }}
                            taskTreeRuns={taskTreeRunsState}
                            actionTaskTreeRuns={actionTaskTreeRunsState}
                            onReplayTaskTree={handleReplayTaskTree}
                            recommendedFlows={recommendedActionFlowsState}
                            onRunActionFlow={runRecommendedActionFlow}
                            onRunActionCatalog={runActionCatalog}
                            onOpenAcademy={() => openAcademyCase(null)}
                            onResumePlaybookRun={(runId, opts) => {
                              void resumePlaybookRun(runId, opts);
                            }}
                            postTradeReviewEnabled={postTradeReviewEnabled}
                            onTogglePostTradeReview={(enabled) => setPostTradeReviewEnabled(!!enabled)}
                            postTradeReviewAgentId={postTradeReviewAgentId}
                            onSetPostTradeReviewAgentId={(id) => setPostTradeReviewAgentId(String(id || '').trim())}
                            onReviewLastClosedTrade={() => reviewLastClosedTrade()}
                            onAddMemory={({ type, text, meta }) => addManualMemory({ type, text, meta: { source: 'user', ...(meta || {}) } })}
                            onUpdateMemory={updateTradeMemory}
                            onDeleteMemory={deleteTradeMemory}
                            onClearMemories={clearTradeMemories}
                            lossStreak={lossStreakState?.streak ?? null}
                            lossStreakUpdatedAtMs={lossStreakState?.updatedAtMs ?? lossStreakState?.lastClosedAtMs ?? null}
                            shadowTradeStats={shadowTradeStats}
                            shadowCompare={shadowTradeCompare}
                            lastTradeBlock={lastTradeBlock}
                            healthSnapshot={healthSnapshot}
                            brokerRateLimitSuppressUntilMs={brokerRateLimitSuppressUntilMs}
                          />
                        )}
                      </div>
                    </div>
                )}
                {mode === 'calendar' && (
                    <CalendarInterface
                      rules={calendarRules}
                      onRefreshRules={refreshCalendarRules}
                      onUpsertRule={upsertCalendarRule}
                      onToggleRule={toggleCalendarRule}
                      onSearchSymbols={searchSymbolSuggestions}
                      onSyncEvents={() => syncEconomicCalendar({ force: true, reason: 'panel' })}
                      onLoadPnlSnapshot={loadCalendarPnlSnapshot}
                      pnlAccountOptions={(Array.isArray(tlAccounts) ? tlAccounts : [])
                        .map((acct: any) => {
                          const env = tlSavedConfig?.env ? String(tlSavedConfig.env) : '';
                          const server = tlSavedConfig?.server ? String(tlSavedConfig.server) : '';
                          const accountId = parseTradeLockerAccountNumber(acct?.id);
                          const accNum = parseTradeLockerAccountNumber(acct?.accNum);
                          if (accountId == null || accNum == null) return null;
                          const accountKey = buildTradeLockerAccountKey({
                            env: env || null,
                            server: server || null,
                            accountId,
                            accNum
                          });
                          if (!accountKey) return null;
                          const labelRaw = acct?.name ? String(acct.name).trim() : '';
                          const label = labelRaw || `TradeLocker ${accountId}/${accNum}`;
                          return {
                            accountKey,
                            label,
                            broker: 'tradelocker',
                            accountId,
                            accNum,
                            env: env || null,
                            server: server || null
                          };
                        })
                        .filter(Boolean)}
                      pnlActiveAccountKey={getTradeLockerAccountKey()}
                      pnlEnabled
                      onRunActionCatalog={runActionCatalog}
                    />
                )}
                {mode === 'chartchat' && (
                    <div className="flex h-full flex-col">
                      <div className="flex items-center justify-between px-4 py-2 border-b border-white/10 bg-white/5">
                        <div className="text-[11px] font-semibold uppercase tracking-wider text-gray-400">Chart Chat</div>
                        <button
                          type="button"
                          onClick={() => sendChartChatMessageWithSnapshot('Explain latest patterns.', chartChatContext, [], null)}
                          className="px-2 py-1 rounded-md text-[10px] bg-sky-500/20 hover:bg-sky-500/30 text-sky-100"
                        >
                          Explain latest patterns
                        </button>
                      </div>
                      <div className="flex-1 overflow-hidden">
                          <ChatInterface
                            channel="chart"
                            messages={chartChatMessages}
                            onSendMessage={(text, img) => sendChartChatMessageWithSnapshot(text, chartChatContext, [], img)}
                            onClearChat={clearChartChatWithSnapshot}
                            isThinking={chartChatThinking}
                            isTeamMode={chartChatReplyMode === 'team'}
                            chartSnapshotStatus={chartChatSnapshotStatus}
                            onToggleTeamMode={() => setChartChatReplyMode(prev => prev === 'team' ? 'single' : 'team')}
                          agents={chartChatAgents}
                          activeAgentId={chartChatActiveAgentId}
                          onAddAgent={addChartChatAgent}
                          onSwitchAgent={switchChartChatAgent}
                          onUpdateAgent={updateChartChatAgent}
                            onDeleteAgent={deleteChartChatAgent}
                            actionQueueDepth={actionTaskQueueDepth}
                            actionTaskActiveConfig={actionTaskActiveStepRef.current}
                            playbooks={taskPlaybooks}
                            activePlaybookRun={taskPlaybookActiveRunRef.current}
                            recentPlaybookRuns={taskPlaybookRunsRef.current}
                            taskTreeResumeEntries={taskTreeResumeEntries}
                            onResumeTaskTreeRun={(input) => {
                              void resumeTaskTreeRun(input);
                            }}
                            taskTreeRuns={taskTreeRunsState}
                            actionTaskTreeRuns={actionTaskTreeRunsState}
                            onReplayTaskTree={handleReplayTaskTree}
                            recommendedFlows={recommendedActionFlowsState}
                            onRunActionFlow={runRecommendedActionFlow}
                            onRunActionCatalog={runActionCatalog}
                            onResumePlaybookRun={(runId, opts) => {
                              void resumePlaybookRun(runId, opts);
                            }}
                            autoTabVisionEnabled={chartChatAutoTabVisionEnabled}
                          onToggleAutoTabVision={() => setChartChatAutoTabVisionEnabled(prev => !prev)}
                          chartWatchEnabled={chartChatWatchEnabled}
                          onToggleChartWatch={() => setChartChatWatchEnabled(prev => !prev)}
                          chartWatchMode={chartChatWatchMode}
                          onSetChartWatchMode={setChartChatWatchMode}
                          chartWatchSnoozedUntilMs={chartChatSnoozedUntilMs}
                          onSnoozeChartWatch={chartChatSnoozeWatch}
                          onClearChartWatchSnooze={clearChartChatSnooze}
                          chartWatchLeadAgentId={chartChatLeadAgentId}
                          onSetChartWatchLeadAgentId={setChartChatLeadAgentId}
                          chartSessions={chartSessions.sessions}
                          activeTabId={activeTabId}
                          getTabTitle={(tabId) => {
                            const tab = tabs.find((t) => t.id === tabId);
                            return tab?.title || tab?.url || tabId;
                          }}
                          onCreateChartSessionFromActiveTab={() => {
                            if (!activeTab) return;
                            const sessionId = chartSessions.createSessionFromTab(activeTab);
                            if (!sessionId) return;
                            chartSessions.assignTabToTimeframe(sessionId, '15m', activeTabId);
                            updateTab(activeTabId, { isWatched: true, watchSource: 'manual' });
                          }}
                          onAssignActiveTabToChartSession={(sessionId, timeframe) => {
                            if (!activeTabId) return;
                            chartSessions.assignTabToTimeframe(sessionId, timeframe, activeTabId);
                            updateTab(activeTabId, { isWatched: true, watchSource: 'manual' });
                          }}
                          onClearChartSessionTimeframe={(sessionId, timeframe) => {
                            chartSessions.clearTimeframe(sessionId, timeframe);
                          }}
                          onToggleChartSessionWatch={(sessionId) => {
                            const session = chartSessions.byId.get(sessionId);
                            if (!session) return;
                            chartSessions.setSessionWatchEnabled(sessionId, !session.watchEnabled);
                          }}
                          onRemoveChartSession={(sessionId) => {
                            chartSessions.removeSession(sessionId);
                          }}
                          isLive={chartChatIsLive}
                          liveMode={chartChatLiveMode}
                          liveStream={chartChatLiveStream}
                          startLiveSession={startChartChatLive}
                          stopLiveSession={stopChartChatLive}
                          sendVideoFrame={sendChartChatVideoFrame}
                          speakMessage={speakChartChatMessage}
                          speakingMessageId={chartChatSpeakingMessageId}
                          sessionBias={chartChatSessionBias}
                          onUpdateSessionBias={setChartChatSessionBias}
                          onExecuteTrade={(messageId, proposal) => executeChartChatTradeProposal(messageId, proposal, 'manual')}
                          onRejectTrade={(messageId) => rejectChartChatTradeProposal(messageId, 'Rejected by user')}
                          onExecuteBrokerAction={(messageId, action) => executeChartChatBrokerAction(messageId, action)}
                          onRejectBrokerAction={(messageId) => rejectChartChatBrokerAction(messageId, 'Rejected by user')}
                          onCancelAgentTool={(messageId) => cancelChartChatAgentTool(messageId)}
                          contextPackText={getChartContextPack()}
                          onCaptureContextPack={captureChartContextPack}
                          symbolScope={symbolScope}
                          onUpdateSymbolScope={updateSymbolScope}
                          onClearSymbolScope={clearSymbolScope}
                          onSearchSymbols={searchSymbolSuggestions}
                          crossPanelContext={crossPanelContext}
                        />
                      </div>
                    </div>
                )}
                {mode === 'notes' && (
                    <NotesInterface 
                        autoAppend={journalEntry}
                        onClearAppend={() => setJournalEntry(null)}
                        currentTab={activeTab ? { url: activeTab.url, title: activeTab.title } : undefined}
                        sessionBias={sessionBias}
                        captureActiveTabScreenshot={async () => {
                          const frame = await captureTabCached(activeTabId, { format: 'jpeg', quality: 60, width: 1200 }, 1200);
                          if (!frame?.data) return null;
                          return `data:${frame.mimeType || 'image/jpeg'};base64,${frame.data}`;
                        }}
                        activeAccount={tlSavedConfig ? {
                          env: tlSavedConfig.env ?? null,
                          server: tlSavedConfig.server ?? null,
                          accountId: tlSavedConfig.accountId ?? null,
                          accNum: tlSavedConfig.accNum ?? null
                        } : undefined}
                        onReplayTrade={handleReplayTrade}
                        onRunActionCatalog={runActionCatalog}
                        crossPanelContext={crossPanelContext}
                    />
                )}
                {mode === 'leaderboard' && (
                    <LeaderboardInterface 
                        agents={agents}
                        history={leaderboardHistory}
                        scorecards={agentScorecards}
                        rankFreshness={healthSnapshot?.rankFreshness || null}
                        agentDriftReports={healthSnapshot?.agentDrift?.reports || null}
                        filter={leaderboardFilter}
                        onFilterChange={setLeaderboardFilter}
                        onRunActionCatalog={runActionCatalog}
                        onOpenAcademy={() => openAcademyCase(null)}
                        crossPanelContext={crossPanelContext}
                        outcomeFeedCursor={outcomeFeedCursor}
                        outcomeFeedConsistency={outcomeFeedConsistency}
                        panelFreshness={panelFreshness.find((row) => row.panel === 'leaderboard') || null}
                    />
                )}
                {mode === 'academy' && academyMounted && (
                    <AcademyInterface
                      cases={academyCases}
                      lessons={academyLessons}
                      symbolLearnings={academySymbolLearnings}
                      selectedCaseId={academySelectedCaseId}
                      onSelectCase={handleAcademyCaseSelect}
                      autoApplyEnabled={academyAutoApplyEnabled}
                      onToggleAutoApply={(next) => updateAcademySettings({ autoApplyEnabled: next })}
                      autoExportEnabled={academyAutoExportEnabled}
                      onToggleAutoExport={(next) => updateAcademySettings({ autoExportEnabled: next })}
                      lessonLimit={academyLessonLimit}
                      onLessonLimitChange={(next) => updateAcademySettings({ lessonLimit: next })}
                      onRefresh={() => {
                        void refreshAcademyCases();
                        void refreshAcademyLessons();
                        void refreshAcademySymbolLearnings();
                      }}
                      onExport={() => {
                        void persistAcademyExport();
                      }}
                      onOpenChart={(symbol, timeframe) => openSymbolPanel('nativechart', symbol, timeframe)}
                      onOpenMt5={(symbol, timeframe) => openSymbolPanel('mt5', symbol, timeframe)}
                      onOpenTradeLocker={(symbol, timeframe) => openSymbolPanel('tradelocker', symbol, timeframe)}
                      onReplayTrade={handleReplayTrade}
                      crossPanelContext={crossPanelContext}
                      outcomeFeedCursor={outcomeFeedCursor}
                      outcomeFeedConsistency={outcomeFeedConsistency}
                      panelFreshness={panelFreshness.find((row) => row.panel === 'academy') || null}
                    />
                )}
                {mode === 'dashboard' && (
                    <PerformanceDashboard
                      defaultSymbol={symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                      defaultTimeframe={activeTvTimeframeLabel}
                      onApplyToBacktester={applyOrQueueBacktestOptimization}
                      onCreateWatchProfile={createWatchProfileFromOptimization}
                      onSaveWinnerPreset={saveOptimizerWinnerPreset}
                      onRunActionCatalog={runActionCatalog}
                    />
                )}
                {mode === 'monitor' && (
                    <MonitorInterface
                      health={healthSnapshot}
                      onRequestSnapshot={requestSystemSnapshot}
                      onClearSnapshotFrameCache={clearSnapshotFrameCache}
                    />
                )}
                {mode === 'mt5' && (
                    <MT5Interface
                      onRunActionCatalog={runActionCatalog}
                      defaultSymbol={symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                    />
                )}
                  {mode === 'tradelocker' && (
                     <TradeLockerInterface 
                          balance={tlBalance}
                          equity={tlEquity}
                          positions={tlPositions}
                          orders={tlOrders}
                          ordersError={tlOrdersError}
                          brokerQuotes={tlQuotesBySymbol}
                          brokerQuotesUpdatedAtMs={tlQuotesUpdatedAtMs}
                          brokerQuotesError={tlQuotesError}
                          accountMetrics={tlAccountMetrics}
                          accountMetricsError={tlAccountMetricsError}
                          snapshotUpdatedAtMs={tlSnapshotUpdatedAtMs}
                          defaultSymbol={symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                          accounts={tlAccounts}
                          accountsError={tlAccountsError}
                          activeAccount={{
                            env: tlSavedConfig?.env ?? null,
                            server: tlSavedConfig?.server ?? null,
                            accountId: tlSavedConfig?.accountId ?? null,
                            accNum: tlSavedConfig?.accNum ?? null
                          }}
                          snapshotSourceKey={tlSnapshotSourceKey}
                          snapshotAutoSwitch={tlSnapshotAutoSwitch}
                          snapshotFallbackOrder={tlSnapshotFallbackOrder}
                          executionTargets={tlExecutionTargets}
                          normalizationEnabled={tlNormalizeEnabled}
                          normalizationReferenceKey={tlNormalizeRefKey || null}
                          symbolMap={brokerLinkConfig?.symbolMap || []}
                          onRefresh={() => {
                            tlRefreshSnapshot();
                            tlRefreshOrders();
                            tlRefreshAccountMetrics();
                            tlRefreshQuotes();
                          }}
                          onRefreshAccounts={tlRefreshAccounts}
                          onClosePosition={handleTradeLockerClosePosition}
                          onCancelOrder={handleTradeLockerCancelOrder}
                          onPlaceOrder={executeTicketOrderViaApi}
                          onSearchInstruments={tlSearchInstruments}
                          onOpenSettings={() => setIsSettingsOpen(true)}
                          isConnected={tlStatus === 'connected'}
                          tradingEnabled={!!tlSavedConfig?.tradingEnabled}
                          defaultOrderQty={tlSavedConfig?.defaultOrderQty ?? 0}
                          defaultOrderType={tlSavedConfig?.defaultOrderType || 'market'}
                          streamStatus={tlStreamStatus}
                          streamUpdatedAtMs={tlStreamUpdatedAtMs}
                          streamError={tlStreamError}
                          rateLimitTelemetry={tlStatusMeta?.rateLimitTelemetry ?? null}
                          serverLabel={tlServerLabel}
                          connectionLabel={tlConnectionMeta.label}
                          connectionDotClass={tlConnectionMeta.dot}
                          onRunActionCatalog={runActionCatalog}
                          onSnapshotSourceChange={handleSnapshotSourceChange}
                          onSnapshotAutoSwitchChange={setTlSnapshotAutoSwitch}
                          onSnapshotFallbackChange={setTlSnapshotFallbackOrder}
                          onExecutionTargetsChange={setTlExecutionTargets}
                          onNormalizationChange={handleNormalizationChange}
                          onSymbolMapChange={(entries) => {
                            setBrokerLinkConfig((prev) => ({ ...prev, symbolMap: entries || [] }));
                          }}
                        />
                  )}
                {(nativeChartMounted || mode === 'nativechart') && (
                    <div className={mode === 'nativechart' ? 'flex flex-1 flex-col' : 'absolute inset-0 pointer-events-none opacity-0'}>
                        <NativeChartInterface
                            ref={nativeChartRef}
                              activeSymbol={nativeChartSymbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                            isConnected={tlStatus === 'connected'}
                            hasDeveloperApiKey={!!tlSavedConfig?.hasSavedDeveloperApiKey}
                            positions={tlPositions}
                            orders={tlOrders}
                            quotesBySymbol={tlQuotesBySymbol}
                            setupSignals={setupSignals}
                            setupWatchers={setupWatchers}
                            regimeBlocks={setupRegimeBlocks}
                            reviewAnnotations={reviewAnnotations}
                            patternEvents={patternEvents}
                            tvSymbol={activeTvParams?.symbol}
                            tvPrice={activeTvPrice}
                            tvPriceUpdatedAtMs={activeTvPriceUpdatedAtMs}
                            onOpenAcademy={() => openAcademyCase(null)}
                            onOpenSettings={() => setIsSettingsOpen(true)}
                            onSymbolChange={setNativeChartSymbol}
                            resolveSymbol={resolveTradeLockerSymbolBestEffort}
                            onFullscreenChange={setIsChartFullscreen}
                            onBarClose={handleNativeBarClose}
                            onUpdateWatcher={updateSetupWatcher}
                            onRunActionCatalog={runActionCatalog}
                            requestBroker={requestBrokerWithAudit}
                            crossPanelContext={crossPanelContext}
                        />
                    </div>
                )}
                  {(backtesterMounted || mode === 'backtester') && (
                      <div className={mode === 'backtester' ? 'flex flex-1 flex-col' : 'hidden'}>
                          <BacktesterInterface
                              ref={backtesterRef}
                              activeSymbol={backtestSymbol || symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                              isConnected={tlStatus === 'connected'}
                              onOpenSettings={() => setIsSettingsOpen(true)}
                              onSymbolChange={setBacktestSymbol}
                              resolveSymbol={resolveTradeLockerSymbolBestEffort}
                              onSendTrainingMessage={sendBacktestMessage}
                              onSendToWatchlist={sendBacktestSetupToWatchlist}
                              onFocusChart={focusNativeChart}
                              onPersistOptimization={saveSetupLibraryFromOptimization}
                              onCreateWatchProfile={createWatchProfileFromOptimization}
                              onRunActionCatalog={runActionCatalog}
                              activePlaybookRun={taskPlaybookActiveRunRef.current}
                              recentPlaybookRuns={taskPlaybookRunsRef.current}
                              taskTreeResumeEntries={taskTreeResumeEntries}
                              onResumeTaskTreeRun={(input) => {
                                void resumeTaskTreeRun(input);
                              }}
                        taskTreeRuns={taskTreeRunsState}
                        actionTaskTreeRuns={actionTaskTreeRunsState}
                        recommendedFlows={recommendedActionFlowsState}
                        onReplayTaskTree={handleReplayTaskTree}
                        onResumePlaybookRun={(runId, opts) => {
                          void resumePlaybookRun(runId, opts);
                        }}
                              onReady={flushPendingBacktestApply}
                          />
                      </div>
                  )}
                  {(setupsMounted || mode === 'setups') && (
                      <div className={mode === 'setups' ? 'flex flex-1 flex-col min-h-0' : 'hidden'}>
                          <SetupsInterface
                              isConnected={tlStatus === 'connected'}
                              watchers={setupWatchers}
                              signals={setupSignals}
                              regimes={setupRegimes}
                              regimeBlocks={setupRegimeBlocks}
                              libraryEntries={setupLibraryEntries}
                              performanceByWatcher={setupPerformanceByWatcher}
                              performanceByLibrary={setupPerformanceByLibrary}
                              performanceByMode={setupPerformanceByMode}
                              performanceBySymbol={setupPerformanceBySymbol}
                              performanceSummary={setupPerformanceSummary}
                              playbookStatusByWatcher={playbookStatusByWatcher}
                              performanceUpdatedAtMs={setupPerformanceUpdatedAtMs}
                              performanceError={setupPerformanceError}
                              onCreateWatcher={(input) => addSetupWatcher(input)}
                              onUpdateWatcher={updateSetupWatcher}
                              onRemoveWatcher={removeSetupWatcher}
                              onClearSignals={clearSetupSignals}
                              onFocusChart={(symbol, timeframe) => openSymbolPanel('nativechart', symbol, timeframe)}
                              onApplyToBacktester={(payload) => applyOrQueueBacktestOptimization(payload)}
                              onExplainSignal={handleExplainSetupSignal}
                              onRunActionCatalog={runActionCatalog}
                              crossPanelContext={crossPanelContext}
                          />
                      </div>
                  )}
                {(agentCreatorMounted || mode === 'agentcreator') && (
                    <div className={mode === 'agentcreator' ? 'flex flex-1 flex-col min-h-0' : 'hidden'}>
                        <AgentCreatorInterface
                          agents={agents}
                          activeSymbol={symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                          activeTimeframe={activeTvTimeframeLabel}
                          onRunActionCatalog={runActionCatalog}
                          signalScanEnabledByAgentId={agentScanEnabledById}
                          onSetSignalScanEnabled={setAgentSignalScanEnabled}
                          onOpenSignalPanel={() => openSidebarMode('signal')}
                        />
                    </div>
                )}
                {(agentMemoryMounted || mode === 'agentmemory') && (
                    <div className={mode === 'agentmemory' ? 'flex flex-1 flex-col' : 'hidden'}>
                        <AgentMemoryInterface
                            activeSymbol={symbolScopeSymbol || activeBrokerSymbol || activeTvParams?.symbol}
                          activeTimeframe={activeTvTimeframeLabel}
                          agents={agents}
                          onOpenSettings={() => setIsSettingsOpen(true)}
                          onRunActionCatalog={runActionCatalog}
                        />
                    </div>
                )}
                {(agentLabMounted || mode === 'agentlab') && (
                    <div className={mode === 'agentlab' ? 'flex flex-1 flex-col' : 'hidden'}>
                        <AgentLabInterface onRunActionCatalog={runActionCatalog} />
                    </div>
                )}
                {(auditMounted || mode === 'audit') && (
                    <div className={mode === 'audit' ? 'flex flex-1 flex-col' : 'hidden'}>
                        <AuditTrailInterface
                          health={healthSnapshot || undefined}
                          onReplayTaskTree={handleReplayTaskTree}
                          onRunActionCatalog={runActionCatalog}
                          outcomeFeedCursor={outcomeFeedCursor}
                          outcomeFeedConsistency={outcomeFeedConsistency}
                          panelFreshness={panelFreshness.find((row) => row.panel === 'audit') || null}
                        />
                    </div>
                )}
                {(changesMounted || mode === 'changes') && (
                    <div className={mode === 'changes' ? 'flex flex-1 flex-col' : 'hidden'}>
                        <ChangesInterface
                          onRunActionCatalog={runActionCatalog}
                          outcomeFeedCursor={outcomeFeedCursor}
                          outcomeFeedConsistency={outcomeFeedConsistency}
                          panelFreshness={panelFreshness.find((row) => row.panel === 'changes') || null}
                        />
                    </div>
                )}
                </React.Suspense>
            </SidebarFrame>
          </div>
        </WindowFrame>

      </div>

      <OnboardingGate
        open={onboardingOpen}
        startupPhase={startupPhase}
        openaiReady={openaiKeyStored}
        openaiState={openaiReadinessState}
        tradeLockerReady={tradeLockerReady}
        tradeLockerState={tradeLockerReadinessState}
        openaiBlockedReason={openaiPermissionBlockedReason}
        tradeLockerBlockedReason={tradeLockerPermissionBlockedReason}
        mt5Available={mt5BridgeAvailable}
        onOpenSettings={() => setIsSettingsOpen(true)}
        onOpenTradeLocker={() => openSidebarMode('tradelocker')}
        onOpenMt5={() => openSidebarMode('mt5')}
        onRefresh={refreshOnboardingStatus}
      />

      {isSettingsOpen && (
        <React.Suspense fallback={SETTINGS_LAZY_FALLBACK}>
          <SettingsModal 
            isOpen={isSettingsOpen}
            onClose={() => setIsSettingsOpen(false)}
            onSave={handleSettingsSaved}
            onRunActionCatalog={runActionCatalog}
            onExecuteAgentTool={executeAgentToolRequest}
            liveErrors={liveErrors}
            onClearLiveErrors={clearLiveErrors}
            brokerLinkConfig={brokerLinkConfig}
            onBrokerLinkChange={setBrokerLinkConfig}
            signalTelegramConfig={signalTelegramConfig}
            signalTelegramStatusOptions={SIGNAL_TELEGRAM_STATUS_OPTIONS}
            onSignalTelegramChange={updateSignalTelegram}
            signalSnapshotWarmupConfig={{
              barsDefault: signalSnapshotWarmupBarsDefault,
              bars1d: signalSnapshotWarmupBars1d,
              bars1w: signalSnapshotWarmupBars1w,
              timeoutMs: signalSnapshotWarmupTimeoutMs
            }}
            onSignalSnapshotWarmupChange={updateSignalSnapshotWarmup}
            healthSnapshot={healthSnapshot}
            performance={{
              keepWatchedTabsMounted,
              keepWatchedTabsMountedRequested,
              isLive,
              liveMode,
              chatOpen: isOpen,
              sidebarMode: mode,
              chartWatchEnabled,
              watchedTabs: {
                total: tabs.filter((t) => !!t.isWatched).length,
                manual: tabs.filter((t) => !!t.isWatched && t.watchSource === 'manual').length,
                auto: tabs.filter((t) => !!t.isWatched && t.watchSource === 'auto').length
              },
              chartSessions: {
                total: (chartSessions.sessions || []).length,
                watchEnabled: (chartSessions.sessions || []).filter((s) => s && s.watchEnabled !== false).length,
                assignedViews: (chartSessions.sessions || []).reduce((acc, s: any) => {
                  if (!s || !s.views) return acc;
                  return acc + Object.values(s.views).filter(Boolean).length;
                }, 0)
              }
            }}
          />
        </React.Suspense>
      )}
      
      {/* Background Ambience styles */}
      <style>{`
        @keyframes loading-bar {
          0% { width: 0%; margin-left: 0; }
          50% { width: 70%; margin-left: 0; }
          100% { width: 100%; margin-left: 100%; }
        }
        .animate-loading-bar {
          animation: loading-bar 1.5s infinite linear;
        }
        .animate-slideInRight {
          animation: slideInRight 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        .custom-scrollbar::-webkit-scrollbar {
          width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: rgba(255, 255, 255, 0.1);
          border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: rgba(255, 255, 255, 0.2);
        }
      `}</style>
    </ErrorBoundary>
  );
};

export default App;
