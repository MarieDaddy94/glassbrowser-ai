const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const MAIN_PATH = path.join(ROOT, 'electron', 'main.cjs');
const PRELOAD_PATH = path.join(ROOT, 'electron', 'preload.cjs');
const APP_PATH = path.join(ROOT, 'App.tsx');
const GENERATED_SCOPES_MODULE_PATH = path.join(ROOT, 'electron', 'generated', 'ipcScopes.cjs');
const CONTRACT_JSON_PATH = path.join(ROOT, 'contracts', 'ipc.contract.json');
const CONTRACT_TS_PATH = path.join(ROOT, 'contracts', 'ipc.contract.ts');
const GENERATED_SCOPES_PATH = path.join(ROOT, 'electron', 'generated', 'ipcScopes.cjs');

function readFile(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}

function matchAll(regex, text) {
  const out = [];
  let match = null;
  while ((match = regex.exec(text)) != null) {
    out.push(match);
  }
  return out;
}

function toSortedUnique(values) {
  return Array.from(new Set(values.filter(Boolean))).sort((a, b) => String(a).localeCompare(String(b)));
}

function parseMainChannels(mainSource) {
  const matches = matchAll(/ipcMain\.handle\(\s*'([^']+)'/g, mainSource);
  return toSortedUnique(matches.map((m) => m[1]));
}

function parsePreloadChannelScopes(preloadSource) {
  const out = new Map();
  const matches = matchAll(/guardedInvoke(?:WithMeta)?\(\s*'([^']+)'\s*,\s*'([^']+)'/g, preloadSource);
  for (const match of matches) {
    const scope = String(match[1] || '').trim();
    const channel = String(match[2] || '').trim();
    if (!scope || !channel) continue;
    if (!out.has(channel)) out.set(channel, new Set());
    out.get(channel).add(scope);
  }
  return out;
}

function parseAllowlistScopes(preloadSource) {
  try {
    if (fs.existsSync(GENERATED_SCOPES_MODULE_PATH)) {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      const mod = require(GENERATED_SCOPES_MODULE_PATH);
      if (Array.isArray(mod?.ALLOWED_SCOPES) && mod.ALLOWED_SCOPES.length > 0) {
        return toSortedUnique(mod.ALLOWED_SCOPES.map((scope) => String(scope || '').trim()));
      }
    }
  } catch {
    // ignore generated-scope read failures and fall back to source parsing
  }

  const blockMatch = preloadSource.match(/ALLOWED_SCOPES\s*=\s*new Set\(\s*\[([\s\S]*?)\]\s*\)/m);
  let sourceBlock = blockMatch ? blockMatch[1] : '';
  if (!sourceBlock) {
    const fallbackMatch = preloadSource.match(/:\s*\[([\s\S]*?)\]\s*\)\s*;/m);
    sourceBlock = fallbackMatch ? fallbackMatch[1] : '';
  }
  if (!sourceBlock) return [];
  const quoted = matchAll(/'([^']+)'|"([^"]+)"/g, sourceBlock).map((m) => String(m[1] || m[2] || '').trim());
  return toSortedUnique(quoted);
}

function parseAppBootScopes(appSource) {
  const blockMatch = appSource.match(/APP_BOOT_PERMISSION_SCOPES\s*=\s*Object\.freeze\(\s*\[([\s\S]*?)\]\s*\)/m);
  if (!blockMatch) return [];
  const quoted = matchAll(/'([^']+)'|"([^"]+)"/g, blockMatch[1]).map((m) => String(m[1] || m[2] || '').trim());
  return toSortedUnique(quoted);
}

function inferDomain(channel) {
  const raw = String(channel || '').trim();
  if (!raw) return 'unknown';
  const idx = raw.indexOf(':');
  if (idx <= 0) return raw;
  return raw.slice(0, idx);
}

function ensureDir(filePath) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
}

function writeContractFiles(contract) {
  ensureDir(CONTRACT_JSON_PATH);
  ensureDir(CONTRACT_TS_PATH);
  ensureDir(GENERATED_SCOPES_PATH);

  fs.writeFileSync(CONTRACT_JSON_PATH, JSON.stringify(contract, null, 2), 'utf8');

  const ts = [
    '/* eslint-disable */',
    '// Auto-generated by scripts/generateIpcContract.cjs. Do not edit manually.',
    '',
    `export const IPC_CONTRACT = ${JSON.stringify(contract, null, 2)} as const;`,
    '',
    'export type IpcContract = typeof IPC_CONTRACT;',
    'export type IpcChannel = IpcContract["channels"][number]["name"];',
    'export type IpcScope = IpcContract["allowedScopes"][number];',
    ''
  ].join('\n');
  fs.writeFileSync(CONTRACT_TS_PATH, ts, 'utf8');

  const scopesText = [
    "'use strict';",
    '// Auto-generated by scripts/generateIpcContract.cjs. Do not edit manually.',
    '',
    `const ALLOWED_SCOPES = Object.freeze(${JSON.stringify(contract.allowedScopes, null, 2)});`,
    '',
    'module.exports = { ALLOWED_SCOPES };',
    ''
  ].join('\n');
  fs.writeFileSync(GENERATED_SCOPES_PATH, scopesText, 'utf8');
}

function buildContract() {
  const mainSource = readFile(MAIN_PATH);
  const preloadSource = readFile(PRELOAD_PATH);
  const appSource = readFile(APP_PATH);

  const mainChannels = parseMainChannels(mainSource);
  const preloadScopesByChannel = parsePreloadChannelScopes(preloadSource);
  const preloadChannels = toSortedUnique(Array.from(preloadScopesByChannel.keys()));
  const allChannels = toSortedUnique([...mainChannels, ...preloadChannels]);

  const channels = allChannels.map((name) => {
    const scopes = toSortedUnique(Array.from(preloadScopesByChannel.get(name) || []));
    return {
      name,
      domain: inferDomain(name),
      scopes,
      inMain: mainChannels.includes(name),
      inPreload: preloadChannels.includes(name)
    };
  });

  const allowedScopes = parseAllowlistScopes(preloadSource);
  const appBootScopes = parseAppBootScopes(appSource);
  const missingBootScopes = appBootScopes.filter((scope) => !allowedScopes.includes(scope));

  const contract = {
    version: 1,
    generatedBy: 'scripts/generateIpcContract.cjs',
    channels,
    allowedScopes,
    appBootScopes,
    missingBootScopes
  };
  return contract;
}

function main() {
  const contract = buildContract();
  writeContractFiles(contract);
  const channelCount = Array.isArray(contract.channels) ? contract.channels.length : 0;
  const scopeCount = Array.isArray(contract.allowedScopes) ? contract.allowedScopes.length : 0;
  console.log(`[generateIpcContract] wrote contract (${channelCount} channels, ${scopeCount} scopes)`);
  if (Array.isArray(contract.missingBootScopes) && contract.missingBootScopes.length > 0) {
    console.warn(`[generateIpcContract] missing boot scopes in allowlist: ${contract.missingBootScopes.join(', ')}`);
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  buildContract,
  parseMainChannels,
  parsePreloadChannelScopes,
  parseAllowlistScopes,
  parseAppBootScopes
};
